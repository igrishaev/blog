<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Зипперы в Clojure (часть 5). Редактирование</title>
  <meta name="description" content="Оглавление  Зипперы (часть 1). Азы навигации  Зипперы (часть 2). Автонавигация  Зипперы (часть 3). XML-зипперы  Зипперы (часть 4). Поиск в XML  Зипперы (част...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-zippers-5/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Зипперы в Clojure (часть 5). Редактирование</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2020-08-08T00:00:00+00:00">
        Aug 8, 2020
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/zippers/" rel="tag">zippers</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="оглавление">Оглавление</h2>

<ul>
  <li><a href="/clj-zippers-1/">Зипперы (часть 1). Азы навигации</a></li>
  <li><a href="/clj-zippers-2/">Зипперы (часть 2). Автонавигация</a></li>
  <li><a href="/clj-zippers-3/">Зипперы (часть 3). XML-зипперы</a></li>
  <li><a href="/clj-zippers-4/">Зипперы (часть 4). Поиск в XML</a></li>
  <li><a href="/clj-zippers-5/">Зипперы (часть 5). Редактирование</a></li>
  <li><a href="/clj-zippers-6/">Зипперы (часть 6). Виртуальные деревья. Обмен валют</a></li>
  <li><a href="/clj-zippers-7/">Зипперы (часть 7). Обход в ширину. Улучшенный обмен валют</a></li>
  <li><a href="/clj-zippers-8/">Зипперы (часть 8). Заключение</a></li>
</ul>

<p>До сих пор мы игнорировали другую возможность зипперов. Во время обхода можно не
только читать, но и менять локации. В широком плане нам доступны все операции
CRUD (Create, Read, Update, Delete), знакомые из веб-разработки. Ниже мы
разберем, как они работают в зипперах.</p>

<p>Напомним, зиппер принимает третью функцию <code class="language-plaintext highlighter-rouge">make-node</code>, в которую до сих пор мы
передавали <code class="language-plaintext highlighter-rouge">nil</code>. В ней не было нужды, потому что мы только читали
данные. Зиппер вызовет функцию в момент, когда мы просим вернуть данные с учётом
изменений, которые внесли в локации. Функция принимает два параметра: ветку и
потомков. Ее задача — соединить их должным образом.</p>

<!-- more -->

<p>Для простых коллекций вроде вектора функция проста — нужно только обернуть
потомков в <code class="language-plaintext highlighter-rouge">vec</code>, чтобы получить из последовательности вектор. В <code class="language-plaintext highlighter-rouge">vector-zip</code>
функция чуть сложнее, потому что учитывает метаданные. Приведём код этого
зиппера без сокращений:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">vector-zip</span><span class="w">
  </span><span class="p">[</span><span class="nb">root</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nb">vector?</span><span class="w">
          </span><span class="nb">seq</span><span class="w">
          </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="nb">children</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">with-meta</span><span class="w"> </span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="nb">children</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">meta</span><span class="w"> </span><span class="nb">node</span><span class="p">)))</span><span class="w">
          </span><span class="nb">root</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Видим, что новый вектор (форма <code class="language-plaintext highlighter-rouge">(vec children)</code>) копирует метаданные прежнего
вектора (переменная <code class="language-plaintext highlighter-rouge">node</code>). Если вы дополняете оригинал через <code class="language-plaintext highlighter-rouge">assoc</code> или
<code class="language-plaintext highlighter-rouge">conj</code>, метаданные сохраняются. В случае с <code class="language-plaintext highlighter-rouge">vector-zip</code> мы строим новый вектор,
поэтому оборачиваем его в <code class="language-plaintext highlighter-rouge">with-meta</code>. Если убрать <code class="language-plaintext highlighter-rouge">with-meta</code>, на выходе
получим вектор без метаданных, что может повлиять на логику программы.</p>

<p>У XML-зиппера сборка иная: потомков помещают в поле <code class="language-plaintext highlighter-rouge">:content</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="nb">children</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:content</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="nb">children</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">vector</span><span class="w"> </span><span class="nb">children</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Для нашего <code class="language-plaintext highlighter-rouge">map-zip</code>, который работает со словарями, функция сборки выглядела бы
как <code class="language-plaintext highlighter-rouge">assoc</code> или <code class="language-plaintext highlighter-rouge">into</code> с набором пар <code class="language-plaintext highlighter-rouge">MapEntry</code>.</p>

<p>Зиппер неявно вызывает эту функцию, если находит изменённые узлы. Для изменения
служат функции <code class="language-plaintext highlighter-rouge">zip/edit</code>, <code class="language-plaintext highlighter-rouge">zip/replace</code> и другие. Но перед тем, как рассмотреть
их, объясним, как именно протекают изменения в зиппере.</p>

<p>Особенность в том, что изменения сказываются не на исходных данных, а на
локациях. Если изменить текущую локацию, она помечается флагом <code class="language-plaintext highlighter-rouge">:changed?</code>. Это
сигнал к пересборке данных с помощью функции <code class="language-plaintext highlighter-rouge">zip/root</code>, о которой скажем чуть
позже.</p>

<p>Рассмотрим пример с вектором <code class="language-plaintext highlighter-rouge">[1 2 3]</code>. Переместимся на двойку и удвоим её с
помощью функции <code class="language-plaintext highlighter-rouge">zip/edit</code>. Она принимает локацию, функцию и остаточные
аргументы – подход, знакомый вам из атомов (<code class="language-plaintext highlighter-rouge">swap!</code>) и коллекций (<code class="language-plaintext highlighter-rouge">update</code>). По
аналогии с ними, локация получит новое значение, которое вернула функция на базе
прежнего.</p>

<p>Локация до изменений:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/right</span><span class="p">)</span><span class="w">

</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="no">:l</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="no">:pnodes</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]]</span><span class="w"> </span><span class="no">:ppath</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:r</span><span class="w"> </span><span class="p">(</span><span class="nf">3</span><span class="p">)}]</span><span class="w">
</span></code></pre></div></div>

<p>и после. Обратите внимание ключ <code class="language-plaintext highlighter-rouge">:changed?</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="w">
      </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w">

</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="p">{</span><span class="no">:l</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="no">:pnodes</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]]</span><span class="w"> </span><span class="no">:ppath</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:r</span><span class="w"> </span><span class="p">(</span><span class="nf">3</span><span class="p">)</span><span class="w">
    </span><span class="no">:changed?</span><span class="w"> </span><span class="n">true</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>Далее нам бы хотелось получить изменённый вектор <code class="language-plaintext highlighter-rouge">[1 4 3]</code>. Сделаем это вручную:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
    </span><span class="n">zip/up</span><span class="w">
    </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 4 3]</span><span class="w">
</span></code></pre></div></div>

<p>То же самое делает функция <code class="language-plaintext highlighter-rouge">zip/root</code>, которая принимает локацию с
изменениями. Её алгоритм следующий:</p>

<ul>
  <li>подняться до первичной локации, повторно вызывая <code class="language-plaintext highlighter-rouge">zip/up</code>;</li>
  <li>вернуть узел.</li>
</ul>

<p>Чтобы получить результат за один проход, добавим <code class="language-plaintext highlighter-rouge">zip/root</code> на конец стрелочного
оператора:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/right</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/root</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 4 3]</span><span class="w">
</span></code></pre></div></div>

<p>Основная работа происходит в функции <code class="language-plaintext highlighter-rouge">zip/up</code>, которую мы вызвали вручную или
неявно в <code class="language-plaintext highlighter-rouge">zip/root</code>. При подъёме вверх она проверяет, была ли изменена локация,
и если да, перестраивает её с помощью <code class="language-plaintext highlighter-rouge">make-node</code>. Приведём её код в сокращении:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">up</span><span class="w">
  </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="nb">node</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="w"> </span><span class="n">changed?</span><span class="w"> </span><span class="no">:changed?</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">path</span><span class="p">}]</span><span class="w"> </span><span class="n">loc</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">pnodes</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pnode</span><span class="w"> </span><span class="p">(</span><span class="nb">peek</span><span class="w"> </span><span class="n">pnodes</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">with-meta</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">changed?</span><span class="w">
                     </span><span class="p">[(</span><span class="nb">make-node</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">pnode</span><span class="w"> </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">
                      </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">ppath</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">...</span><span class="p">))]</span><span class="w">
                     </span><span class="p">[</span><span class="n">pnode</span><span class="w"> </span><span class="n">ppath</span><span class="p">])</span><span class="w">
                   </span><span class="p">(</span><span class="nb">meta</span><span class="w"> </span><span class="n">loc</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<h2 id="множественное-изменени">Множественное изменени</h2>

<p>При изменении одной локации проблем не возникает. Однако мы редко изменяем одну
локацию – на практике это делают по признаку, то есть пакетно.</p>

<p>Ранее мы раскладывали зиппер в цепочку локаций с помощью <code class="language-plaintext highlighter-rouge">iter-zip</code>, а затем
пропускали через серию <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code> и других функций. Для редактирования этот
метод не подходит. Предположим, мы выбрали второй элемент из результата
<code class="language-plaintext highlighter-rouge">zip-iter</code> и исправили его:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-seq</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="n">iter-zip</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-seq</span><span class="w"> </span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="c1">;; [4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)</span><span class="w">
</span><span class="c1">;;    :changed? true}]</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">zip-iter</code> устроена так, что каждая следующая локация получается из
предыдущей. Вызов <code class="language-plaintext highlighter-rouge">zip/edit</code> на одном из элементов не повлияет на
последующие. Если подняться вверх от последней локации, получим вектор без
изменений.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-seq</span><span class="w"> </span><span class="nb">last</span><span class="w"> </span><span class="n">zip/up</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 2 3]</span><span class="w">
</span></code></pre></div></div>

<p>Как видно из примера, выражение с <code class="language-plaintext highlighter-rouge">zip/edit</code> не повлияло на результат.</p>

<p>При редактировании зипперов применяют следующие паттерны.</p>

<p><strong>Изменяется один элемент.</strong> В этом случае мы итерируем зиппер до тех пор, пока
не встретим нужную локацию в цепочке. Затем меняем её и вызываем <code class="language-plaintext highlighter-rouge">zip/root</code>.</p>

<p><strong>Изменяются многие элементы.</strong> С помощью <code class="language-plaintext highlighter-rouge">loop</code> и <code class="language-plaintext highlighter-rouge">zip/next</code> мы вручную
итерируем зиппер. При этом задана функция, которая либо меняет локацию, любо
оставляет нетронутой. В форму <code class="language-plaintext highlighter-rouge">recur</code> попадает <code class="language-plaintext highlighter-rouge">zip/next</code> от её результата. Если
изменения были, <code class="language-plaintext highlighter-rouge">zip/next</code> оттолкнётся от новой, а не исходной локации.</p>

<p>Для изменения локаций служат функции:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">zip/replace</code> — буквальная замена текущего узла на другой.</li>
  <li><code class="language-plaintext highlighter-rouge">zip/edit</code> — Редактирование узла. По аналогии с <code class="language-plaintext highlighter-rouge">update</code> и <code class="language-plaintext highlighter-rouge">swap!</code> принимает
функцию и добавочные аргументы. Первым аргументом функция получит текущей
узел. Результат заменит содержимое локации.</li>
  <li><code class="language-plaintext highlighter-rouge">zip/remove</code> — Удаляет локацию и перемещает указатель на родителя.</li>
</ul>

<p>Функции для вставки соседей и потомков:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">zip/insert-left</code> — добавить соседа слева от текущей локации;</li>
  <li><code class="language-plaintext highlighter-rouge">zip/insert-right</code> — добавить соседа справа;</li>
  <li><code class="language-plaintext highlighter-rouge">zip/insert-child</code> — добавить текущей локации потомка в начало;</li>
  <li><code class="language-plaintext highlighter-rouge">zip/append-child</code> — добавить потомка в конец.</li>
</ul>

<p>Разница между соседом и потомком в иерархии. Сосед находится на одном уровне с
локацией, а потомок ниже. В центре диаграммы находится локация с вектором <code class="language-plaintext highlighter-rouge">[2
3]</code>.  Её соседи – числа 1 и 4, а потомки – 2 и 3.</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

                ┌─────────────┐
                │ [1 [2 3] 4] │
                └─────────────┘
                       ▲
                       │
    ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
    │   1   │◀───┃   [2 3]   ┃───▶│   4   │
    └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                       │
                 ┌─────┴─────┐
                 ▼           ▼
             ┌───────┐   ┌───────┐
             │   2   │   │   3   │
             └───────┘   └───────┘

</code></pre></div></div>

<p>Рассмотрим функции на простых примерах. Предположим, в глубине вложенных
векторов находится ключ <code class="language-plaintext highlighter-rouge">:error</code>, и нужно исправить его на <code class="language-plaintext highlighter-rouge">:ok</code>. Сперва добавим
предикат для поиска:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-error?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:error</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь ищем локацию, исправляем её и поднимаемся к корню:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="w"> </span><span class="no">:error</span><span class="p">]]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-error</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">data</span><span class="w">
       </span><span class="n">zip/vector-zip</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nf">find-first</span><span class="w"> </span><span class="n">loc-error?</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-error</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/replace</span><span class="w"> </span><span class="no">:ok</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/root</span><span class="p">)</span><span class="w">

</span><span class="c1">;; [1 2 [3 4 [5 :ok]]]</span><span class="w">
</span></code></pre></div></div>

<p>Другой пример — поменять во вложеном векторе все <code class="language-plaintext highlighter-rouge">nil</code> на 0, чтобы обезопасить
математические расчеты. На этот раз локация может быть не одна, поэтому
понадобится обход через <code class="language-plaintext highlighter-rouge">loop</code>. На каждом шаге мы проверяем, подходит ли
локация, и если да, передаём в <code class="language-plaintext highlighter-rouge">recur</code> вызов <code class="language-plaintext highlighter-rouge">zip/next</code> от изменённой версии:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="n">nil</span><span class="p">]]</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/vector-zip</span><span class="w"> </span><span class="n">data</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/end?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="nb">nil?</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/next</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/replace</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/next</span><span class="w"> </span><span class="n">loc</span><span class="p">)))))</span><span class="w">

</span><span class="c1">;; [1 2 [5 0 2 [3 0]] 0 1]</span><span class="w">
</span></code></pre></div></div>

<p>То же самое, но заменить все отрицательные числа по модулю. Для начала объявим
функцию <code class="language-plaintext highlighter-rouge">abs</code> (с версии 1.11 она встроена в Clojure):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">abs</span><span class="w"> </span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">neg?</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w">
    </span><span class="n">num</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Обход похож на предыдущий, но теперь вместо <code class="language-plaintext highlighter-rouge">zip/replace</code> мы вызываем
<code class="language-plaintext highlighter-rouge">zip/edit</code>, который обновляет содержимое локации, отталкиваясь от прежнего
значения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">-1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="w"> </span><span class="mi">-2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">-3</span><span class="w"> </span><span class="mi">2</span><span class="p">]]</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">5</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/vector-zip</span><span class="w"> </span><span class="n">data</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/end?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="n">number?</span><span class="p">)</span><span class="w">
             </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="nb">neg?</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/next</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">abs</span><span class="p">)))</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/next</span><span class="w"> </span><span class="n">loc</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>В обоих случаях цикл выглядит одинаково. Если это конечная локация, вернём её
узел. В противном случае, если локация подходит предикату, меняем ее содержимое
с помощью <code class="language-plaintext highlighter-rouge">zip/edit</code>. От изменённой локации переходим к следующей. Это ключевой
момент: в предпоследней строке вызов <code class="language-plaintext highlighter-rouge">zip/next</code> принимает результат <code class="language-plaintext highlighter-rouge">zip/edit</code>,
а не исходную локацию. Поэтому изменения будут переданы в следующий шаг <code class="language-plaintext highlighter-rouge">loop</code>.</p>

<p>Примеры выше образуют паттерны — повторяющиеся приёмы. Поместим их в отдельные
функции, чтобы не тратить на них внимание в будущем.</p>

<p><strong>Поиск локации по предикату.</strong> Принимает начальную локацию и предикат, начинает
итерацию. Вернёт первую же локацию, которая подошла предикату:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">find-loc</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">loc-pred</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nf">find-first</span><span class="w"> </span><span class="n">loc-pred</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><strong>Обход локаций с изменениями.</strong> Перебирает локации с помощью <code class="language-plaintext highlighter-rouge">zip/next</code> и
<code class="language-plaintext highlighter-rouge">loop/recur</code>. При переходе на следующий шаг оборачивает локацию в
функцию. Ожидается, что функция либо изменит локацию, либо вернёт её без
изменений. Это обобщённая версия цикла, что мы написали выше.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">alter-loc</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">loc-fn</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">loc</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/end?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
      </span><span class="n">loc</span><span class="w">
      </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">loc-fn</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">recur</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Перепишем примеры с новыми функциями. Найдём в векторе локацию, чей узел равен
двойке:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-2?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="p">(</span><span class="nf">find-loc</span><span class="w"> </span><span class="n">loc-2?</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Удвоим её и выйдем на конечный вектор:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-2</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">zip/root</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 4 2]</span><span class="w">
</span></code></pre></div></div>

<p>Изменим отрицательные числа по модулю. Для этого заведём функцию <code class="language-plaintext highlighter-rouge">loc-abs</code>. Если
в узле отрицательное число, вернём исправленную локацию, а иначе — исходную:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-abs</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="n">number?</span><span class="p">)</span><span class="w">
           </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="nb">neg?</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">abs</span><span class="p">)</span><span class="w">
    </span><span class="n">loc</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Осталось передать её в <code class="language-plaintext highlighter-rouge">alter-loc</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">-1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="w"> </span><span class="mi">-2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">-3</span><span class="w"> </span><span class="mi">2</span><span class="p">]]</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="p">(</span><span class="nf">alter-loc</span><span class="w"> </span><span class="n">loc-abs</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/node</span><span class="p">)</span><span class="w">

</span><span class="c1">;; [1 2 [5 2 2 [3 2]] 1 5]</span><span class="w">
</span></code></pre></div></div>

<p>Как только мы вынесли часть кода в функции, преобразования стали короче и
понятней. Как правило, любое действие над зиппером можно обобщить и поместить в
функцию, тем самым упростив логику.</p>

<h2 id="цены-в-xml">Цены в XML</h2>

<p>Перейдём к практическим примерам с XML и товарами. Подготовим следующий файл
<code class="language-plaintext highlighter-rouge">products-price.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"fiber"</span> <span class="na">price=</span><span class="s">"8.99"</span><span class="nt">&gt;</span>VIP Fiber Plus<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"iphone"</span> <span class="na">price=</span><span class="s">"899.99"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 2"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;bundle&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"fiber"</span> <span class="na">price=</span><span class="s">"9.99"</span><span class="nt">&gt;</span>Premium iFiber<span class="nt">&lt;/product&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"iphone"</span> <span class="na">price=</span><span class="s">"999.99"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
      <span class="nt">&lt;/bundle&gt;</span>
    <span class="nt">&lt;/branch&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p>Обратите внимание, что у товаров появились цены – характеристика, которая часто
меняется.</p>

<p>Напомним, что с точки зрения Clojure XML – это вложенные словари с ключами
<code class="language-plaintext highlighter-rouge">:tag</code>, <code class="language-plaintext highlighter-rouge">:attrs</code> и <code class="language-plaintext highlighter-rouge">:content</code>. После изменений мы бы хотели видеть его в
привычном, текстовом виде. Понадобится обратное действие — из структуры данных
получить XML в виде текста. Для этого импортируем модуль <code class="language-plaintext highlighter-rouge">clojure.xml</code>. Его
функция <code class="language-plaintext highlighter-rouge">emit</code> выводит XML на печать.</p>

<p>Часто <code class="language-plaintext highlighter-rouge">emit</code> оборачивают в <code class="language-plaintext highlighter-rouge">with-out-str</code> — макрос для перехвата печати в
строку. В примерах ниже мы просто выводим XML в консоль. <code class="language-plaintext highlighter-rouge">Emit</code> не поддерживает
отступы, поэтому мы добавили их вручную для ясности.</p>

<p><strong>Первая задача</strong> — сделать скидку 10% на все айфоны. У нас готовы почти все
абстракции, так что опишем решение сверху вниз:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.xml</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">xml</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"products-price.xml"</span><span class="w">
    </span><span class="n">-&gt;xml-zipper</span><span class="w">
    </span><span class="p">(</span><span class="nf">alter-loc</span><span class="w"> </span><span class="n">alter-iphone-price</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/node</span><span class="w">
    </span><span class="n">xml/emit</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Этих пяти строк достаточно для нашей задачи. Под вопросом только функция
<code class="language-plaintext highlighter-rouge">alter-iphone-price</code>. Ожидается, что для локации-айфона она вернёт её же, но с
другим атрибутом <code class="language-plaintext highlighter-rouge">price</code>. Локация другого типа останется без изменений. Опишем
функцию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">alter-iphone-price</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">loc-iphone?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">alter-attr-price</span><span class="w"> </span><span class="mf">0.9</span><span class="p">)</span><span class="w">
    </span><span class="n">loc</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Предикат <code class="language-plaintext highlighter-rouge">loc-iphone?</code> проверяет локацию на “айфонность”. Мы уже писали его в
прошлом разделе:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-iphone?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:tag</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:product</span><span class="p">))</span><span class="w">
         </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"iphone"</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Осталась функция <code class="language-plaintext highlighter-rouge">alter-attr-price</code>. Она принимает узел (содержимое локации) и
должна изменить его атрибут <code class="language-plaintext highlighter-rouge">:price</code>. Второй аргумент функции — коэффициент, на
который нужно умножить текущую цену. Небольшая трудность в том, что атрибуты в
XML — строки. Чтобы выполнить умножение, нужно вывести число из строки, умножить
на коэффициент, а результат привести в строку с округлением до двух цифр. Все
вместе даёт нам функцию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">alter-attr-price</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="n">ratio</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="p">[</span><span class="no">:attrs</span><span class="w"> </span><span class="no">:price</span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">price</span><span class="p">]</span><span class="w">
               </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">price</span><span class="w">
                    </span><span class="n">read-string</span><span class="w">
                    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">ratio</span><span class="p">)</span><span class="w">
                    </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%.2f"</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Быстрая проверка этой функции:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">alter-attr-price</span><span class="w"> </span><span class="p">{</span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:price</span><span class="w"> </span><span class="s">"10"</span><span class="p">}}</span><span class="w"> </span><span class="mf">1.1</span><span class="p">)</span><span class="w">
</span><span class="c1">;; {:attrs {:price "11.00"}}</span><span class="w">
</span></code></pre></div></div>

<p>Теперь когда известны все компоненты, запустим первое выражение и получим XML:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"8.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>VIP Fiber Plus<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"809.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 2"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;bundle&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"9.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>Premium iFiber<span class="nt">&lt;/product&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"899.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
      <span class="nt">&lt;/bundle&gt;</span>
    <span class="nt">&lt;/branch&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p>Видим, что цена на айфоны изменилась на 10%, а у остальных товаров осталась
прежней.</p>

<p><strong>Более сложная задача</strong> – во все наборы (бандлы) добавить новый товар —
гарнитуру. Опять же, опишем решение сверху вниз:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"products-price.xml"</span><span class="w">
    </span><span class="n">-&gt;xml-zipper</span><span class="w">
    </span><span class="p">(</span><span class="nf">alter-loc</span><span class="w"> </span><span class="n">add-to-bundle</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/node</span><span class="w">
    </span><span class="n">xml/emit</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Решение отличается только функций <code class="language-plaintext highlighter-rouge">add-to-bundle</code>. Её логика следующая: если
текущая локация — набор, добавить ему потомка, а если нет, просто вернуть
локацию.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add-to-bundle</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">loc-bundle?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/append-child</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">node-headset</span><span class="p">)</span><span class="w">
    </span><span class="n">loc</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Проверка на набор:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-bundle?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="no">:tag</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:bundle</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">zip/append-child</code> добавляет значение в конец потомков локации. В данном
случае это узел <code class="language-plaintext highlighter-rouge">node-headset</code>, который вынесли в константу:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">node-headset</span><span class="w">
  </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:product</span><span class="w">
   </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="s">"headset"</span><span class="w">
           </span><span class="no">:price</span><span class="w"> </span><span class="s">"199.99"</span><span class="p">}</span><span class="w">
   </span><span class="no">:content</span><span class="w"> </span><span class="p">[</span><span class="s">"AirPods Pro"</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Итоговый XML, где в наборах появился новый товар:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"8.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>VIP Fiber Plus<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"899.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 2"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;bundle&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"9.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>Premium iFiber<span class="nt">&lt;/product&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"999.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"199.99"</span> <span class="na">type=</span><span class="s">"headset"</span><span class="nt">&gt;</span>AirPods Pro<span class="nt">&lt;/product&gt;</span>
      <span class="nt">&lt;/bundle&gt;</span>
    <span class="nt">&lt;/branch&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p><strong>Третья задача</strong> — упразднить все наборы. Возможно, руководство решило, что
продавать товары в наборах невыгодно. Что ж, бывает. Для программиста это
значит, что из XML уходят все теги <code class="language-plaintext highlighter-rouge">&lt;bundle&gt;</code>, однако их товары должны перейти в
организацию.</p>

<p>И в третий раз решение отличается лишь целевой функцией:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"products-price.xml"</span><span class="w">
    </span><span class="n">-&gt;xml-zipper</span><span class="w">
    </span><span class="p">(</span><span class="nf">alter-loc</span><span class="w"> </span><span class="n">disband-bundle</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/node</span><span class="w">
    </span><span class="n">xml/emit</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Опишем алгоритм <code class="language-plaintext highlighter-rouge">disband-bundle</code>. Если текущий узел — набор, сохраним его
потомков (товары) в переменную, чтобы не потерять их. Затем удалим
набор. Функция удаления вернёт предка локации, в нашем случае
организацию. Присоединим к ней товары и вернем её.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">disband-bundle</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">loc-bundle?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">products</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/children</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
          </span><span class="n">loc-org</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/remove</span><span class="w"> </span><span class="n">loc</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">append-childs</span><span class="w"> </span><span class="n">loc-org</span><span class="w"> </span><span class="n">products</span><span class="p">))</span><span class="w">
    </span><span class="n">loc</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">append-childs</code> – это обёртка над встроенной
<code class="language-plaintext highlighter-rouge">zip/append-child</code>. Последняя присоединяет только один элемент, что
неудобно. Чтобы присоединить их список, напишем свёртку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">append-childs</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">items</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">item</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nf">zip/append-child</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">item</span><span class="p">))</span><span class="w">
          </span><span class="n">loc</span><span class="w">
          </span><span class="n">items</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Финальный XML без наборов, но с теми же товарами:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"8.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>VIP Fiber Plus<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"899.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 2"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"9.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>Premium iFiber<span class="nt">&lt;/product&gt;</span>
      <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"999.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;/branch&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p>Надеемся, этих примеров достаточно, чтобы читатель понял, как редактировать
зипперы. Обратите внимание, что кода получилось немного: для каждой задачи мы
писали в среднем три функции. Другое преимущество в том, что нет состояния. Все
функции чистые, и их вызов не сказывается на данных. Если на середине выскочит
исключение, дерево XML не будет частично изменённым.</p>

<p>(Продолжение следует)</p>

<h2 id="оглавление-1">Оглавление</h2>

<ul>
  <li><a href="/clj-zippers-1/">Зипперы (часть 1). Азы навигации</a></li>
  <li><a href="/clj-zippers-2/">Зипперы (часть 2). Автонавигация</a></li>
  <li><a href="/clj-zippers-3/">Зипперы (часть 3). XML-зипперы</a></li>
  <li><a href="/clj-zippers-4/">Зипперы (часть 4). Поиск в XML</a></li>
  <li><a href="/clj-zippers-5/">Зипперы (часть 5). Редактирование</a></li>
  <li><a href="/clj-zippers-6/">Зипперы (часть 6). Виртуальные деревья. Обмен валют</a></li>
  <li><a href="/clj-zippers-7/">Зипперы (часть 7). Обход в ширину. Улучшенный обмен валют</a></li>
  <li><a href="/clj-zippers-8/">Зипперы (часть 8). Заключение</a></li>
</ul>


  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-zippers-5/">
    <input required name="captcha" type="hidden" value="9 &#215; 4">

    <div class="block">
        <span class="comment-form-label"><small>9 &#215; 4 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
