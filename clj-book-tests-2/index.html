<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Тесты в Clojure (второй фрагмент)</title>
  <meta name="description" content="Продолжение первой части">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-book-tests-2/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Тесты в Clojure (второй фрагмент)</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2019-11-19T00:00:00+00:00">
        Nov 19, 2019
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/tests/" rel="tag">tests</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>Продолжение <a href="/clj-book-tests-1">первой части</a></em></p>

<h2>

    Содержание

</h2>

<ul id="toc-item-clj-book-tests-2">
  <li><a href="#транзакция-с-откатом" id="toc-item-clj-book-tests-2-транзакция-с-откатом">Транзакция с откатом</a></li>
  <li><a href="#тестирование-веб-приложений" id="toc-item-clj-book-tests-2-тестирование-веб-приложений">Тестирование веб-приложений</a></li>
  <li><a href="#тестирование-систем" id="toc-item-clj-book-tests-2-тестирование-систем">Тестирование систем</a></li>
  <li><a href="#интеграционные-тесты" id="toc-item-clj-book-tests-2-интеграционные-тесты">Интеграционные тесты</a></li>
  <li><a href="#другие-решения" id="toc-item-clj-book-tests-2-другие-решения">Другие решения</a>    <ul>
      <li><a href="#продвинутые-моки" id="toc-item-clj-book-tests-2-продвинутые-моки">Продвинутые моки</a></li>
      <li><a href="#альтернативный-синтаксис" id="toc-item-clj-book-tests-2-альтернативный-синтаксис">Альтернативный синтаксис</a></li>
      <li><a href="#вывод-xunit" id="toc-item-clj-book-tests-2-вывод-xunit">Вывод XUnit</a></li>
      <li><a href="#генерация-данных" id="toc-item-clj-book-tests-2-генерация-данных">Генерация данных</a></li>
    </ul>
  </li>
  <li><a href="#порядок-аргументов" id="toc-item-clj-book-tests-2-порядок-аргументов">Порядок аргументов</a></li>
</ul>

<!-- more -->

<h3 id="транзакция-с-откатом">Транзакция с откатом</h3>

<p>Другой способ избавиться от изменений в базе — обернуть все действия с ней в
особую транзакцию. Такая транзакция завершается оператором не <code class="language-plaintext highlighter-rouge">COMMIT</code>, а
<code class="language-plaintext highlighter-rouge">ROLLBACK</code>, что значит откатить все команды. С точки зрения базы это выглядит
так:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="p">...</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">profiles</span> <span class="p">...</span>
<span class="k">UPDATE</span> <span class="n">users</span> <span class="k">SET</span> <span class="n">name</span><span class="o">=</span><span class="p">...</span>
<span class="k">ROLLBACK</span><span class="p">;</span>
</code></pre></div></div>

<p class="draft-warn">Внимание! Вы читаете черновик к книге <a href="/clojure-in-prod/">“Clojure на производстве”</a>. Для
книги я переписывал его много раз, но в блоге осталась старая версия. Здесь она
для истории, а вам я рекомендую купить книжку.</p>

<p>При выходе из транзакции мы не увидим последствий <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code> и других
команд, выполненных в ее рамках.</p>

<p>В пакет JDBC входит функция <code class="language-plaintext highlighter-rouge">db-set-rollback-only!</code>. Она принимает
транзакционное соединение и выставляет ему флаг rollback. Если флаг установлен,
JDBC завершает блок транзакции оператором ROLLBACK.</p>

<p>Вы уже знакомы с макросом <code class="language-plaintext highlighter-rouge">with-db-transaction</code>: внутри его тела действует
транзакционное соединение, которые получают из JDBC-спеки. Напишем свой макрос
with-db-rollback, который делает то же самое, но дополнительно устанавливает
флаг отката:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-db-rollback</span><span class="w">
  </span><span class="p">[[</span><span class="n">t-conn</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">bindings</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nf">jdbc/with-db-transaction</span><span class="w"> </span><span class="p">[</span><span class="o">~</span><span class="n">t-conn</span><span class="w"> </span><span class="o">~@</span><span class="n">bindings</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">jdbc/db-set-rollback-only!</span><span class="w"> </span><span class="o">~</span><span class="n">t-conn</span><span class="p">)</span><span class="w">
     </span><span class="o">~@</span><span class="n">body</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Пример его работы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-db-rollback</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">*db*</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Inserting the data..."</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">})</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">do-something</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Разработчик следит за тем, чтобы все действия — вставка данных, логика теста —
протекали через <code class="language-plaintext highlighter-rouge">tx</code>, а не <code class="language-plaintext highlighter-rouge">*db*</code>. Иначе изменения в рамках обычного соединения
останутся в базе. Прямо сейчас загрузчик load-data данных ссылается на
глобальную переменную <code class="language-plaintext highlighter-rouge">*db*</code>. Чтобы сообщить ему транзакционное соединение,
придется либо передать параметр, либо связать <code class="language-plaintext highlighter-rouge">*db*</code> с tx формой binding.</p>

<p>Пример с параметром: все действия с базой принимают tx, который мы установили на
вершине теста.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-user-with-rollback</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-db-rollback</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">*db*</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">load-data</span><span class="w"> </span><span class="n">tx</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user-by-name</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="p">(</span><span class="no">:name</span><span class="w"> </span><span class="n">user</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Вариант со связанной переменной. В этом случае мы считаем, что все функции
ссылаются на глобальную <code class="language-plaintext highlighter-rouge">*db*</code>. Внутри макроса она станет транзакционным
соединением с откатом.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-user-with-rollback</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-db-rollback</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">*db*</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*db*</span><span class="w"> </span><span class="n">tx</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">load-data</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user-by-name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="p">(</span><span class="no">:name</span><span class="w"> </span><span class="n">user</span><span class="p">)))))))</span><span class="w">
</span></code></pre></div></div>

<p>Реализация зависит от того, как в проекте устроена работа с базой. Решение с
откатом хорошо подходит для mount и похожей архитектуры, когда база это
глобальная переменная. В случае с системой компонентов могут возникнуть
трудности с передачей tx от теста к логике и наоборот.</p>

<p>В свободное время подумайте, как оформить фикстуру с макросом
with-db-rollback. Будет ли она работать с системой компонентов? Что необходимо в
этом случае?</p>

<h2 id="тестирование-веб-приложений">Тестирование веб-приложений</h2>

<p>До сих пор мы тестировали отдельные функции, в основном связанные с
расчетами. Такие тесты, как говорят математики, необходимы, но недостаточны. Они
защищают проект от спонтанных изменений, но не обещают, что система
устойчива. Поднимемся на уровень выше и рассмотрим, как тестировать приложение
целиком.</p>

<p>В главе про веб-разработку мы пришли к важному выводу. Веб-приложение на каждом
уровне остается функций одного аргумента. Где-то внизу это обработчик конкретной
страницы, условный <code class="language-plaintext highlighter-rouge">(view-profile-page [request])</code>. Комбинация маршрутов и
middleware не меняет это соглашение. Конечный объект app, много раз обернутый в
middleware, по-прежнему принимает словарь запроса и возвращает словарь ответа.</p>

<p>Это определяет, как писать тесты для приложения. Типичный тест составляет запрос
и вызывает приложение как функцию. В ответе ищут HTTP-статус и проверяют на
успех (200, 201) или неудачу (404, 403). Если это JSON-ответ, его тело считывают
в коллекцию и сравнивают с образцом.</p>

<p>Вспомним приложение из первой главы. Отдельные страницы мы соединили в маршруты
с помощью Compojure. Получилось “голое” приложение. Так мы назвали его потому,
что оно многого не умеет. Например, читать параметры запроса, работать с JSON,
куками, сессиями и так далее. Приложение узнает все это из middleware, в которые
мы его оборачиваем.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defroutes</span><span class="w"> </span><span class="n">app-naked</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/"</span><span class="w">      </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-index</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/hello"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-hello</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="n">page-404</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">app-naked</span><span class="w">
      </span><span class="n">wrap-session</span><span class="w">
      </span><span class="n">wrap-keyword-params</span><span class="w">
      </span><span class="n">wrap-params</span><span class="w">
      </span><span class="n">wrap-json-body</span><span class="w">
      </span><span class="n">wrap-json-response</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Напишем несколько тестов для этого приложения. Пусть это будет главная страница
и любая другая, которой нет в дереве маршрутов. Для экономии места проверим
только статус ответа.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-app-index</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get</span><span class="w"> </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/"</span><span class="p">}</span><span class="w">
        </span><span class="n">response</span><span class="w"> </span><span class="p">(</span><span class="nf">app</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">status</span><span class="w"> </span><span class="n">body</span><span class="p">]}</span><span class="w"> </span><span class="n">response</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="n">status</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-app-page-not-found</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get</span><span class="w"> </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/missing"</span><span class="p">}</span><span class="w">
        </span><span class="n">response</span><span class="w"> </span><span class="p">(</span><span class="nf">app</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">status</span><span class="w"> </span><span class="n">body</span><span class="p">]}</span><span class="w"> </span><span class="n">response</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">404</span><span class="w"> </span><span class="n">status</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Как видно из примеров, писать тесты для веб-приложения нетрудно. Однако, мы не
бросим читателя на этом месте. Перечислим несколько приемов, которые облегчат
работу с тестами.</p>

<p><strong>Приложение целиком.</strong> Избегайте ситуации, когда тест вызывает не приложение, а
один из обработчиков. Плохой пример: (page-index request) вместо app. На текущем
уровне вызов конкретной функции ничего не дает. Даже если страница работает по
отдельности, нет гарантии, что запрос пройдет сквозь маршруты и все
middleware. В боевых проектах middleware несут весомую логику. Это права
доступа, разбор токенов и JWT, данные из прошлых запросов в сессии. Убрав все
это из теста, вы тем самым обманываете себя. Объект app, который вы тестируете,
должен быть максимально “заряжен”, т.е. близок к настоящему веб-серверу.</p>

<p><strong>Библиотека запросов.</strong> Выше мы объявили запрос в виде словаря. Это работает
только для простых случаев, когда нет ни параметров строки, ни тела. Если не
позаботиться об инструментах, вы дойдете до уровня</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/users/?page=2&amp;order=name&amp;name_contains=smith&amp;search_type=relevance
</code></pre></div></div>

<p>, что совершенно нечитаемо и тяжело в поддержке. В словаре запроса легко
перепутать ключи :request-method и :method, что автор и сделал при написании
книги.</p>

<p>Чтобы избежать подобных ошибок, воспользуйтесь <code class="language-plaintext highlighter-rouge">ring-mock</code> — библиотекой для
запросов к Ring-приложениям. Ее функции покрывают основные сценарии в
тестах. Так, функция request принимает метод и путь. Если добавить словарь
параметров, то для GET они станут строкой запроса, а для POST — его
телом. URL-кодировку библиотека берет на себя. Другая функция json-body пишет в
запрос тело из коллекции. Рассмотрим несколько примеров.</p>

<p>Простая страница, запрос <code class="language-plaintext highlighter-rouge">GET /help</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">mock/request</span><span class="w"> </span><span class="no">:get</span><span class="w"> </span><span class="s">"/help"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Ввод данных в форму поиска, <code class="language-plaintext highlighter-rouge">GET /movies?search=batman&amp;page=1</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">mock/request</span><span class="w"> </span><span class="no">:get</span><span class="w"> </span><span class="s">"/movies"</span><span class="w"> </span><span class="p">{</span><span class="no">:search</span><span class="w"> </span><span class="s">"batman"</span><span class="w"> </span><span class="no">:page</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Новый пользователь из формы, <code class="language-plaintext highlighter-rouge">POST /users</code>. В этом запросе тело (ключ :body)
станет классом <code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>. Заголовок Content-Type примет значение
<code class="language-plaintext highlighter-rouge">"application/x-www-form-urlencoded"</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">mock/request</span><span class="w"> </span><span class="no">:post</span><span class="w"> </span><span class="s">"/users"</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Случай для JSON-API. Адрес /users ожидает не поля формы, а JSON-тело.Такой
запрос составляют из двух функций:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">mock/request</span><span class="w"> </span><span class="no">:post</span><span class="w"> </span><span class="s">"/users"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">mock/json-body</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Проверка тела.</code> В тестах выше мы проверяли только статус ответа. На практике
одного статуса недостаточно: число 200 еще не говорит, что в ответе именно то,
что нужно. Проверка тела зависит от типа содержимого. Если это текст или HTML,
иногда хватит и регулярного выражения. Например, по фразе “Login” мы определим,
что на этой странице пользователь не авторизован.</p>

<p>Гораздо интересней вариант с JSON-API. В этом случае нужно восстановить данные
из ответа и сравнить с образцом. Для простоты вызовем приложение
sites-handler. Это заглушка, которой мы пользовались для тестировании
карт. Проверка ниже гарантирует, что при изменении ответа мы получим
ошибку. По-другому говорят, что ответ зафиксирован:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">mock/request</span><span class="w"> </span><span class="no">:get</span><span class="w"> </span><span class="s">"/search/v1/"</span><span class="w"> </span><span class="p">{</span><span class="no">:lat</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="no">:lon</span><span class="w"> </span><span class="mi">22</span><span class="p">})</span><span class="w">
      </span><span class="n">response</span><span class="w"> </span><span class="p">(</span><span class="nf">sites-handler</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="n">body</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">cheshire.core/parse-string</span><span class="w"> </span><span class="n">true</span><span class="p">))]</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">}</span><span class="w"> </span><span class="n">body</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Недостаток в том, что мы сравниваем данные как есть. Прием не сработает, если в
ответе даты, уникальные идентификаторы (UUID) или машинные номера. Перед
сравнением их исключают с помощью dissoc и map. Представим, что поиск кафе
вернул результат в таком виде:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:sites</span><span class="w"> </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Site1"</span><span class="w"> </span><span class="no">:date-updated</span><span class="w"> </span><span class="s">"2019-11-12"</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="mi">42</span><span class="p">}</span><span class="w">
         </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Site2"</span><span class="w"> </span><span class="no">:date-updated</span><span class="w"> </span><span class="s">"2019-11-10"</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="mi">99</span><span class="p">}]}</span><span class="w">
</span></code></pre></div></div>

<p>Код ниже вернет только те данные, которые не меняются от запроса к запросу. Их и
сравнивают с образцом.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="no">:sites</span><span class="w">
        </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">sites</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">site</span><span class="p">]</span><span class="w">
                 </span><span class="p">(</span><span class="nb">dissoc</span><span class="w"> </span><span class="n">site</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="no">:date-updated</span><span class="p">))</span><span class="w">
               </span><span class="n">sites</span><span class="p">)))</span><span class="w">
</span><span class="c1">;; {:sites ({:name "Site1"} {:name "Site2"})}</span><span class="w">
</span></code></pre></div></div>

<p>Иногда проверяют не конкретные значения, а структуру ответа. Это удобно на
больших данных, например, когда в каждом элементе двадцать и более полей. В
таком случае ответ проверяют спекой или JSON-схемой.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="c1">;; obtain the response</span><span class="w">
      </span><span class="n">body</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">cheshire.core/parse-string</span><span class="w"> </span><span class="n">true</span><span class="p">))]</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">:api.search/handler</span><span class="w"> </span><span class="n">body</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Затраты на спеку или схему окупаются в будущем. Ими проверяют входные параметры,
генерируют данные для тестов, описывают REST API (Swagger, RAML).</p>

<h2 id="тестирование-систем">Тестирование систем</h2>

<p>Коротко о том, как пишут тесты в проектах с системами, о которых мы говорили в
отдельной главе. Напомним, система это набор компонентов со связями между
ними. Покрыть каждый компонент тестами нетрудно; проблемы возникают на стыке при
взаимодействии. В проекте обязательно должен быть тест, где система работает как
единое целое.</p>

<p>Очевидно, чтобы тест прошел, кто-то должен запустить систему и остановить ее
после. На эту роль подходит фикстура. Будем полагать, что переменная системы и
функции ее запуска и останова находятся в модуле system.clj. Напишем фикстуру
<code class="language-plaintext highlighter-rouge">fix-system</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-system</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">system/start!</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">system/stop!</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>На время ее работы в переменной <code class="language-plaintext highlighter-rouge">system/system</code> будет рабочая система. Другие
фикстуры, например, для работы с базой, могут обратиться к ее компонентам
напрямую. Важно только, чтобы в вызове use-fixtures они шли в правильном порядке
(левее — раньше), иначе вы получите Null-ошибки и другие неприятности.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-db-data</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="p">]}</span><span class="w"> </span><span class="n">system/system</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">prepare-test-data</span><span class="w"> </span><span class="n">db</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">clear-test-data</span><span class="w"> </span><span class="n">db</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:once</span><span class="w"> </span><span class="n">fix-system</span><span class="w"> </span><span class="n">fix-db-data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Читатель заметит, что это противоречит правилу, о котором мы говорили в главе
про системы. Что к системе нельзя обращаться напрямую и копаться в ее
компонентах. Что ж, признаем, для тестов в этом плане действуют
послабления. Обращаться к системе нельзя в промышленном коде. Но тесты это не
промышленный код, поэтому на небольшие нарушения в них порой закрывают
глаза. Главное, чтобы программист понимал, что он намерен выиграть. В нашем
случае выигрыш в том, что мы не пробрасываем компонент базы в фикстуру. Это было
бы честнее, но заняло больше строк кода.</p>

<p>Фикстура <code class="language-plaintext highlighter-rouge">fix-system</code> неслучайно стоит под ключом <code class="language-plaintext highlighter-rouge">:once</code>. Запуск и остановка
системы занимают много времени. В наших интересах прогнать как можно больше
тестов, пока система работает. Если же делать это поштучно, процесс затянется
надолго. Именно с этой проблемой вы столкнетесь при запуске тестов из CIDER. При
попытке выполнить один тест вы будете ждать, пока сработают все фикстуры, в том
числе fix-system.</p>

<p>Кажется, что пять-десять секунд это немного. Но представьте, что работаете над
задачей и запускаете тест раз за разом — подобные паузы раздражают и сбивают с
ритма. Поделимся с читателем техникой, которая решит эту проблему.</p>

<p>Потребуется два шага. Первый — научить систему, чтобы она знала о своем
состоянии. Например, включена ли она сейчас или выключена. Проще всего это
сделать через поле с метаданными. Вынесем имя поля в отдельную
переменную. Перепишем start! так, чтобы в метаданных системы появился флаг со
значением true. Аналогично работает stop!, только флаг принимает ложь. Функция
started? возвращает флаг значение из текущей системы.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">state-field</span><span class="w"> </span><span class="no">::started?</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">start!</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">sys</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">system</span><span class="w">
                </span><span class="n">component/start-system</span><span class="w">
                </span><span class="p">(</span><span class="nb">with-meta</span><span class="w"> </span><span class="p">{</span><span class="n">state-field</span><span class="w"> </span><span class="n">true</span><span class="p">}))]</span><span class="w">
    </span><span class="p">(</span><span class="nf">alter-var-root</span><span class="w"> </span><span class="o">#</span><span class="ss">'system</span><span class="w"> </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="n">sys</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">started?</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="nb">meta</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">state-field</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Второй шаг — перед тем, как включить систему в фикстуре, определить, была ли она
запущена вручную. Если нет, фикстура работает как обычно: запуск, тест,
остановка. Если да, это значит, что системой управляют в ручном режиме. В таком
случае фикстура только выполняет тест, что гораздо быстрее, чем полный цикл.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fixture-system</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">started-manually?</span><span class="w"> </span><span class="p">(</span><span class="nf">system/started?</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="n">started-manually?</span><span class="w">
      </span><span class="p">(</span><span class="nf">start!</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="n">started-manually?</span><span class="w">
      </span><span class="p">(</span><span class="nf">stop!</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Выполните в REPL (system/start!). Теперь можно вызвать тест сколько угодно раз —
не придется ждать, пока запустится система.</p>

<h2 id="интеграционные-тесты">Интеграционные тесты</h2>

<p>Не протяжении главы мы постепенно усложняли тесты. С каждым шагом они все меньше
зависят от технических деталей и делают упор на бизнес-логику. По-другому этот
принцип называют пирамидой тестов. В ее основании лежат юнит-тесты — множество
отдельных проверок. Поднимаясь к вершине, мы абстрагируемся от технического
слоя: в какой-то момент тестируем не отдельные функции, а часть приложения.</p>

<p>Каждый уровень в пирамиде требует специальных знаний. Полагаем, читатель готов к
тому, чтобы подняться на последний этаж — освоить интеграционное
тестирование. Это особая фаза тестов, когда окружение максимально похоже на
промышленное. По-другому их еще называют UI- или Selenium-тестами в честь
одноименного фреймворка. Для большей реалистичности мы не шлем запросы
программно, а имитируем действия человека. Например, управляем браузером: вводим
данные в форму, нажимаем кнопку и проверяем, что появился нужный текст.</p>

<p>Интеграционные тесты выполняются медленно, потому что включают полный цикл
приложения. Это загрузка страницы, выполнение скриптов, ожидание запроса, во
время которого сервер ходит в базу или очередь задач. Если возникнет ошибка, ее
трудно расследовать из-за длины цепи. Представьте, что вы нажали на кнопку, но
текст не появился. Возможны десятки причин, почему этого не произошло.</p>

<p>В этом разделе мы рассмотрим, как писать UI-тесты на Clojure. С подготовительной
частью вы уже знакомы: запускаем систему и наполняем базу тестовыми данными. А
вот тест ведет себя по-новому. Он захватывает контроль над браузером и командует
им. Например, открывает страницу <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8080/</code> и щелкает по
ссылкам. В любой момент мы получим адрес страницы, ее заголовок и HTML-код. В
тест добавляют формы <code class="language-plaintext highlighter-rouge">(is (= ...))</code>, чтобы проверить, на какой странице мы
оказались или видит ли пользователь этот виджет.</p>

<p>Чтобы управлять браузером, понадобится драйвер и библиотека к нему. Под
драйвером понимают утилиту командной строки. Когда драйвер запущен, он принимает
запросы от библиотеки по протоколу HTTP. Одновременно драйвер запускает браузер
в особом режиме, и между ними образуется связь. Фактически, драйвер это
посредник между двумя акторами. Его работа сводится к переводу HTTP-команд в
бинарный протокол браузера и наоборот.</p>

<p>Каждый браузер работает со своим драйвером. Для Chrome он называется
<code class="language-plaintext highlighter-rouge">chromedriver</code>, для FireFox — <code class="language-plaintext highlighter-rouge">geckodriver</code>. Одноименные утилиты ставятся из
пакетных менеджеров <code class="language-plaintext highlighter-rouge">apt</code>, <code class="language-plaintext highlighter-rouge">yum</code> или <code class="language-plaintext highlighter-rouge">brew</code> в зависимости от операционной
системы. Пользователи Windows скачают бинарные файлы с сайта проекта. Драйвер к
Safari называется <code class="language-plaintext highlighter-rouge">safaridriver</code>. С версии 13 он идет в комплекте с Mac OS.</p>

<p>Для работы с драйвером подойдет библиотека Etaoin. Добавьте ее в зависимости
профиля :dev (библиотека нужна только для тестов):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:dev</span><span class="w"> </span><span class="p">{</span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">etaoin</span><span class="w"> </span><span class="s">"0.3.6"</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<p>Убедитесь, что драйвер находится в одной из папок, перечисленных в PATH,
например, <code class="language-plaintext highlighter-rouge">/usr/local/bin</code>. Другими словами, его можно вызвать в терминале,
просто выполнив <code class="language-plaintext highlighter-rouge">chromedriver</code> или <code class="language-plaintext highlighter-rouge">geckodriver</code>. Путь до драйвера можно задать
в опциях библиотеки, но пока что мы сами положим его в нужное место.</p>

<p>Теперь напишем первый тест. Представим, что локальный сервер работает на
порту 8080. Тест открывает форму входа, заполняет поля и нажимает кнопку
“Login”. Страница обновляется, наверху видно приветствие. Пользователь видит
элементы, которые прежде были скрыты (ссылки “My profile”, “Logout”).</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">project.integration-tests</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">etaoin.api</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">e</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-ui-login-ok</span><span class="w">
  </span><span class="p">(</span><span class="nf">e/with-chrome</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">driver</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/go</span><span class="w"> </span><span class="n">driver</span><span class="w"> </span><span class="s">"http://127.0.0.1:8080/login"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/wait-visible</span><span class="w"> </span><span class="n">driver</span><span class="w"> </span><span class="p">{</span><span class="no">:fn/has-text</span><span class="w"> </span><span class="s">"Login"</span><span class="p">})</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/fill</span><span class="w"> </span><span class="n">driver</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:input</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="no">:email</span><span class="p">}</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/fill</span><span class="w"> </span><span class="n">driver</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:input</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="no">:password</span><span class="p">}</span><span class="w"> </span><span class="s">"J3QQ4-H7H2V"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/click</span><span class="w"> </span><span class="n">driver</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:button</span><span class="w"> </span><span class="no">:fn/text</span><span class="w"> </span><span class="s">"Login"</span><span class="p">})</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/wait-visible</span><span class="w"> </span><span class="n">driver</span><span class="w"> </span><span class="p">{</span><span class="no">:fn/has-text</span><span class="w"> </span><span class="s">"Welcome"</span><span class="p">})</span><span class="w">
    </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nf">e/visible?</span><span class="w"> </span><span class="n">driver</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="no">:fn/text</span><span class="w"> </span><span class="s">"My profile"</span><span class="p">}))</span><span class="w">
    </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nf">e/visible?</span><span class="w"> </span><span class="n">driver</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:button</span><span class="w"> </span><span class="no">:fn/text</span><span class="w"> </span><span class="s">"Logout"</span><span class="p">}))))</span><span class="w">
</span></code></pre></div></div>

<p>Разберем отдельные выражения из этого теста. Форма <code class="language-plaintext highlighter-rouge">with-chrome</code> это макрос,
который запускает Хром на время исполнения тела. Макрос необходим, чтобы
гарантированно закрыть драйвер при выходе или в случае ошибки. Без него пришлось
бы писать код с ручным <code class="language-plaintext highlighter-rouge">try/catch</code>, что порождает вложенность и в целом
неудобно:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">driver</span><span class="w"> </span><span class="p">(</span><span class="nf">e/chrome</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/go</span><span class="w"> </span><span class="n">driver</span><span class="w"> </span><span class="s">"http://..."</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/click</span><span class="w"> </span><span class="n">driver</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:button</span><span class="p">})</span><span class="w">
    </span><span class="p">(</span><span class="nf">finally</span><span class="w">
      </span><span class="p">(</span><span class="nf">e/quit</span><span class="w"> </span><span class="n">driver</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">wait-visible</code> ждет до тех пор, пока элемент не появится на экране. К
ней прибегают довольно часто, чтобы дождаться, пока браузер отрисует
верстку. Если не разделить две инструкции ожиданием, между ними будет разница в
несколько миллисекунд. Второе действие либо не успеет выполниться, либо будет
отброшено.</p>

<p>Ожидание в UI-тестах это нормально. Основное время уходит на то, чтобы дождаться
загрузки и выполнить действия с задержкой, как это свойственно
человеку. <code class="language-plaintext highlighter-rouge">Wait-visible</code> это лишь одна из семейства wait-функций. В их число
входит <code class="language-plaintext highlighter-rouge">wait-has-text</code> (дождаться текст на экране), <code class="language-plaintext highlighter-rouge">wait-has-class</code> (ждать,
пока у элемента не появится класс) и многие другие.</p>

<p>Драйвер ищет элементы на странице с помощью селекторов. Это строки с особыми
выражениями; различают CSS- и XPath-селекторы. Сейчас мы не будем разбирать их
синтаксис: это долго и заслуживает отдельной главы. Для простоты рассмотрим
альтернативный прием. На элемент можно сослаться, задав его свойства
словарем. Ключи tag и id означают имя тега и его идентификатор. Другие ключи
становятся атрибутами тега. В примере выше селектор <code class="language-plaintext highlighter-rouge">{:tag :input :name :email}</code>
становится выражением <code class="language-plaintext highlighter-rouge">input[@name='email']</code> на языке XPath.</p>

<p>Подумаем, как улучшить наш тест? Для начала рассмотрим порт 8080. Мы уже знаем,
что подобные значения приходят из конфигурации. Исправьте тест так, чтобы и
сервер, и драйвер работали с одним и тем же портом.</p>

<p>Вспомним, как работает <code class="language-plaintext highlighter-rouge">with-chrome</code>: он создает новый драйвер, выполняет тело и
выключает его. Если каждый тест обернут в <code class="language-plaintext highlighter-rouge">with-chrome</code>, мы теряем время,
многократно повторяя эти шаги. Сделаем так, чтобы драйвер работал на протяжении
всего прогона тестов. Объявим динамическую переменную и фикстуру, которая
связывает драйвер на время тестов. Зарегистрируем ее с ключом <code class="language-plaintext highlighter-rouge">:once</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defonce</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">*driver*</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-chrome</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">e/with-chrome</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">driver</span><span class="w">
    </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*driver*</span><span class="w"> </span><span class="n">driver</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">t</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Мы тестируем приложение в Хроме, самом популярном браузере. Но вот приходит
задача — убедиться, что мы также поддерживаем Firefox. Технически это значит,
что все тесты, которые мы написали для Хрома, должны сработать еще раз в другом
браузере. Скопировать их и заменить with-chrome на with-firefox — сомнительное
решение. Представьте, что через месяц нас попросят добавить Safari. Должен быть
способ, который не влечет за собой разрастание кода.</p>

<p>Поможет мульти-фикстура, с которой мы знакомились в середине главы. Она
пробегает по списку типов браузеров; в примере ниже это <code class="language-plaintext highlighter-rouge">:firefox</code> и
<code class="language-plaintext highlighter-rouge">:chrome</code>. Макрос <code class="language-plaintext highlighter-rouge">with-driver</code> это общий случай <code class="language-plaintext highlighter-rouge">with-chrome</code> и
аналогов. Отличие в том, что <code class="language-plaintext highlighter-rouge">with-driver</code> ожидает первым аргументом тип
браузера. На каждом шаге фикстура связывает драйвер и выполняет тест.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-multi-driver</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">driver-type</span><span class="w"> </span><span class="p">[</span><span class="no">:firefox</span><span class="w"> </span><span class="no">:chrome</span><span class="p">]]</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/with-driver</span><span class="w"> </span><span class="n">driver-type</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">driver</span><span class="w">
      </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*driver*</span><span class="w"> </span><span class="n">driver</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Browser %s"</span><span class="w"> </span><span class="p">(</span><span class="nb">name</span><span class="w"> </span><span class="n">driver-type</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="nf">t</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь тесты по очереди сработают в каждом из браузеров. Для ясности мы
оборачиваем тест в сообщение о том, в рамках какого браузера его
вызывают. Поддержка нового браузера сводится к тому, чтобы добавить в список
ключ <code class="language-plaintext highlighter-rouge">:safari</code>, <code class="language-plaintext highlighter-rouge">:edge</code> и другие.</p>

<p>Еще один способ улучшить тесты — вынести одинаковые действия в фикстуру или
функцию. Например, каждый тест начинается с авторизации и заканчивается выходом
из системы. Чтобы не копировать эти действия каждый раз, напишем фикстуру
<code class="language-plaintext highlighter-rouge">fix-login-logout</code>. В отличии от предыдущих фикстур, ее регистрируют с ключом
<code class="language-plaintext highlighter-rouge">:each</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-login-logout</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doto</span><span class="w"> </span><span class="n">*driver*</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/go</span><span class="w"> </span><span class="s">"http://127.0.0.1:8080/login"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/fill</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:input</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="no">:email</span><span class="p">}</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/click</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:button</span><span class="w"> </span><span class="no">:fn/text</span><span class="w"> </span><span class="s">"Login"</span><span class="p">}))</span><span class="w">
  </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">doto</span><span class="w"> </span><span class="n">*driver*</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/click</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:button</span><span class="w"> </span><span class="no">:fn/text</span><span class="w"> </span><span class="s">"Logout"</span><span class="p">})</span><span class="w">
    </span><span class="p">(</span><span class="nf">e/wait-has-text</span><span class="w"> </span><span class="s">"Login"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Попутно мы внедрили еще одну хорошую практику. Когда несколько функций принимают
одинаковый первый аргумент, их объединяют в макрос doto. Он подставит <code class="language-plaintext highlighter-rouge">*driver*</code>
на второе место в каждый список тела. С <code class="language-plaintext highlighter-rouge">doto</code> код становится немного короче и
чище.</p>

<h2 id="другие-решения">Другие решения</h2>

<p>В последнем разделе мы перечислим другие библиотеки, полезные для тестов. Мы не
будем рассматривать их досконально: ограничимся кратким описанием и примером
кода. Все ответы ищите в документации к проектам.</p>

<h3 id="продвинутые-моки">Продвинутые моки</h3>

<p>На минуту вернемся к мокам — подмене функции через <code class="language-plaintext highlighter-rouge">with-redefs</code>. Этот макрос
слишком многословен, чтобы работать с ним напрямую. Появились библиотеки,
которые описывают мокинг короче и выразительнее. Одна из них называется
<code class="language-plaintext highlighter-rouge">mockery</code>. Библиотека предлагает макрос <code class="language-plaintext highlighter-rouge">with-mock</code> следующего вида:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-mock</span><span class="w"> </span><span class="n">mock</span><span class="w">
  </span><span class="p">{</span><span class="no">:target</span><span class="w"> </span><span class="no">:project.path/get-geo-point</span><span class="w">
   </span><span class="no">:return</span><span class="w"> </span><span class="p">{</span><span class="no">:lat</span><span class="w"> </span><span class="mf">14.23</span><span class="w"> </span><span class="no">:lng</span><span class="w"> </span><span class="mf">52.52</span><span class="p">}}</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-geo-point</span><span class="w"> </span><span class="s">"cafe"</span><span class="w"> </span><span class="s">"200m"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>В примере выше мы “замокали” <code class="language-plaintext highlighter-rouge">get-geo-point</code>, которая, судя по названию,
обращается к стороннему сервису карт. Внутри макроса объект <code class="language-plaintext highlighter-rouge">mock</code> это атом,
внутри которого словарь. Он наполняется данными по мере того, как мы вызываем
цель. Например, сколько раз ее вызвали и с какими аргументами. В выражении ниже
мы добавили проверки на то, что функцию вызвали один раз с аргументами “cafe” и
“200m”.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">called?</span><span class="w"> </span><span class="n">call-count</span><span class="w"> </span><span class="n">call-args</span><span class="p">]}</span><span class="w"> </span><span class="o">@</span><span class="n">mock</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="n">called?</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">call-count</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="s">"cafe"</span><span class="w"> </span><span class="s">"200m"</span><span class="p">)</span><span class="w"> </span><span class="n">call-args</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Библиотека <code class="language-plaintext highlighter-rouge">spy</code> устроена похожим образом. На функцию навешивается “шпион”,
который копит данные о вызове.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">spy-adder</span><span class="w"> </span><span class="p">(</span><span class="nf">spy/spy</span><span class="w"> </span><span class="n">adder</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"calling the function"</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="nf">spy-adder</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"calls to the spy can be accessed via spy/calls"</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nf">spy/calls</span><span class="w"> </span><span class="n">spy-adder</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<h3 id="альтернативный-синтаксис">Альтернативный синтаксис</h3>

<p>Проект <code class="language-plaintext highlighter-rouge">midje</code> предлагает другой способ писать тесты. В этой библиотеке мы имеем
дело с фактами. Факт это набор проверок, сгруппированных по смыслу. В примере
ниже факты о функции <code class="language-plaintext highlighter-rouge">split</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">facts</span><span class="w"> </span><span class="s">"about `split`"</span><span class="w">
 </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="s">"a/b/c"</span><span class="w"> </span><span class="o">#</span><span class="s">"/"</span><span class="p">)</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="s">"a"</span><span class="w"> </span><span class="s">"b"</span><span class="w"> </span><span class="s">"c"</span><span class="p">]</span><span class="w">
 </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="s">""</span><span class="w"> </span><span class="o">#</span><span class="s">"irrelvant"</span><span class="p">)</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="s">""</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Стрелка между выражениями это особый оператор, который называется extended
equality, продвинутое равенство. С ее помощью сравнение величин записывается
короче. Например, форма <code class="language-plaintext highlighter-rouge">1 =&gt; even?</code> приходит к виду <code class="language-plaintext highlighter-rouge">(even? 1)</code>. В <code class="language-plaintext highlighter-rouge">midje</code>
встречаются и другие, более сложные стрелки для проверки коллекций и макросов.</p>

<h3 id="вывод-xunit">Вывод XUnit</h3>

<p>Плагин <code class="language-plaintext highlighter-rouge">test2junit</code> делает так, что отчет о тестах пишется в XML-файл формата
XUnit. Системы непрерывной интеграции, например, CircleCI или TeamCity понимают,
как отобразить его графически. Такой отчет легче просматривать, чем вывод
консоли. Проблемные места выделены красным, стектрейсы спрятаны под выпадающие
элементы. Плагину нужно задать путь к папке, куда писать файл.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:plugins</span><span class="w"> </span><span class="p">[[</span><span class="n">test2junit</span><span class="w"> </span><span class="s">"1.1.2"</span><span class="p">]]</span><span class="w">
</span><span class="no">:test2junit-output-dir</span><span class="w"> </span><span class="s">"target/test2junit"</span><span class="w">
</span></code></pre></div></div>

<h3 id="генерация-данных">Генерация данных</h3>

<p>Возможно, вы столкнетесь с тем, что для тестов нужен большой объем данных,
например, сто или двести тысяч записей. При этом данные должны быть разнообразны
— нас не устроит один и тот же набор, скопированный тысячу раз. Поможет
библиотека <code class="language-plaintext highlighter-rouge">test.check</code>. Ее модуль gen генерирует случайные данные по заданным
правилам. Особенно полезна генерация записей. В примере ниже мы получаем кортеж
строки, числа и булева типа. Затем применяем его к конструктору <code class="language-plaintext highlighter-rouge">-&gt;User</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">[</span><span class="n">user-name</span><span class="w"> </span><span class="n">user-id</span><span class="w"> </span><span class="n">active?</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user-gen</span><span class="w">
  </span><span class="p">(</span><span class="nf">gen/fmap</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">apply</span><span class="w"> </span><span class="n">-&gt;User</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nf">gen/tuple</span><span class="w"> </span><span class="p">(</span><span class="nf">gen/not-empty</span><span class="w"> </span><span class="n">gen/string-alphanumeric</span><span class="p">)</span><span class="w">
                       </span><span class="n">gen/nat</span><span class="w">
                       </span><span class="n">gen/boolean</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="p">(</span><span class="nf">gen/sample</span><span class="w"> </span><span class="n">user-gen</span><span class="p">))</span><span class="w">
</span><span class="c1">;; =&gt; #user.User{:user-name "dfgJKSHF3"</span><span class="w">
</span><span class="c1">;;               :user-id 5</span><span class="w">
</span><span class="c1">;;               :active? false}</span><span class="w">
</span></code></pre></div></div>

<p>Библиотека <code class="language-plaintext highlighter-rouge">clojure.spec</code>, которой мы посвятили главу, идет еще дальше. С
помощью <code class="language-plaintext highlighter-rouge">test.check</code> она генерирует данные по спеке. Так проявляется еще одно
свойство спек: кроме проверки, они подходят для тестовых данных.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:user/id</span><span class="w"> </span><span class="n">int?</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:user/name</span><span class="w"> </span><span class="nb">string?</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:user/active?</span><span class="w"> </span><span class="n">boolean?</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::user</span><span class="w"> </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:user/id</span><span class="w"> </span><span class="no">:user/name</span><span class="w"> </span><span class="no">:user/active?</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">gen/generate</span><span class="w"> </span><span class="p">(</span><span class="nf">s/gen</span><span class="w"> </span><span class="no">::user</span><span class="p">))</span><span class="w">
</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">88546920</span><span class="n">,</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Z4MO7GH80k3mRD"</span><span class="n">,</span><span class="w"> </span><span class="no">:active?</span><span class="w"> </span><span class="n">true</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Возможности <code class="language-plaintext highlighter-rouge">spec.gen</code> обширны. С ее помощью порождают связанные данные,
например, пользователей, которые ссылаются на профили и наоборот. Вместо
случайных величин можно опираться на допустимые значения (списки имен,
городов). Спеки бывают быть любой вложенности, что открывает поле для
экспериментов.</p>

<h2 id="порядок-аргументов">Порядок аргументов</h2>

<p>Необычный вопрос: как писать правильно, <code class="language-plaintext highlighter-rouge">(is (= 200 status))</code> или <code class="language-plaintext highlighter-rouge">(is (= status
200))</code>? На первый взгляд это абсурд. Разве может порядок аргументов влиять на
равенство? Значения либо равны, либо нет. Однако, макрос <code class="language-plaintext highlighter-rouge">is</code> устроен сложнее,
чем мы думаем. Он разбирает выражение <code class="language-plaintext highlighter-rouge">(= 200 status)</code> и выделяет ожидаемую и
фактическую части. По-английски они называются expected и actual.</p>

<p>Ожидаемое это значение, на которое рассчитывает тест. Как правило, это готовое
число или коллекция, которую посчитали заранее. Фактическое значение — то, к
которому мы пришли самостоятельно, например, вызвав функцию. Так, число 68 это
ожидаемое, а <code class="language-plaintext highlighter-rouge">(int (-&gt;fahr 20))</code> — действительное. Статус 200 это ожидаемое, а
<code class="language-plaintext highlighter-rouge">(:status response)</code> — действительное.</p>

<p>Такое разделение необходимо для отчетов. Когда значения не равны, нам бы
хотелось увидеть, где мы ошиблись. Предположим, что в отчете написано: <code class="language-plaintext highlighter-rouge">failed
(= 200 403)</code>. Не совсем ясно, как это трактовать. Мы ожидали успешный ответ, но
не хватило прав доступа? Или это брешь в безопасности — ожидали, что прав на эту
страницу нет, но пользовать все-таки ее увидел? Если же написано expected 200,
got 403, то все ясно — это первый случай (не хватило прав).</p>

<p>Теперь запомните правило: ожидаемое стоит на первом месте, а действительное на
втором. Поэтому пишите <code class="language-plaintext highlighter-rouge">(is (= 200 status))</code> вместо <code class="language-plaintext highlighter-rouge">(is (= status 200))</code>. Автор
согласен, что это непривычно и противоречит здравому смыслу. Как правило,
фактическое это число, а действительное — длинное выражение, поэтому хочется
записать их как слева. Увы, придется побороть себя и писать как справа:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; wrong                     ;; correct</span><span class="w">
</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">20</span><span class="p">))</span><span class="w"> </span><span class="mi">68</span><span class="p">)</span><span class="w">     </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">68</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">20</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Это не ошибка дизайна; правило уходит корнями в прошлое. Первый тестовый
фреймворк <code class="language-plaintext highlighter-rouge">JUnit</code> утвердил именно такой порядок в методах сравнения. Хорошо это
или плохо, судить уже поздно — принцип “expected слева” стал промышленным
стандартом. Аналогичное правило работает в языках Python, Ruby и
других. Отдельные фреймворки предлагают модули, чтобы “перестать говорить как
Йодо”, то есть поменять семантику аргументов. Технически это возможно и в
Clojure, но сейчас мы не будем это рассматривать.</p>

<p>Особенность expected и actual видна при запуске тестов в CIDER. Один и тот же
тест проверяет статус ответа на 200. Пока все идет хорошо, нет разницы, в каком
порядке мы записали аргументы. Но в случе ошибки вариант слева вносит
путаницу. Согласно ему, нормальным считается статус 404, а не 200. Вариант
справа выводит статусы правильно.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; wrong                ;; correct
(is (= status 200))     (is (= 200 status))

Fail in test-...        Fail in test-...
expected: 404           expected: 200
  actual: 200             actual: 404
    diff: - 404             diff: - 200
          + 200                   + 404
</code></pre></div></div>

<p>Тем не менее, не стоит соблюдать это правило слишком рьяно. Иногда равенство с
перепутанными аргументами смотрится лучше, и потому код легче
поддерживать. Следить за порядком или нет остается на усмотрение команды. Автор
признаётся, что на этапе черновика перепутал аргументы везде, где это возможно.</p>

    
<div class="prev-next">

    <div class="prev-next-left">
    
        <p><small><a href="/antisemitism/">&larr; Антисемитизм</a></small></p>
    
    </div>

    <div class="prev-next-mid">
    </div>

    <div class="prev-next-right">
    
        <p><small><a href="/typo-widget/">Виджет опечаток &rarr;</a></small></p>
    
    </div>

</div>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>





<center>
    
    Комментарии
    
    
</center>



<div id="comments">
  
    <div id="comment-4699533030" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            anonymous,
            23rd Nov 2019,
            <a href="#comment-4699533030">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Опечатка: with-db-rollback в сниппете кода назван with-db-transaction.</p>
</div>
    </div>
  
    <div id="comment-4699546330" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            anonymous,
            23rd Nov 2019,
            <a href="#comment-4699546330">link</a>
            
          </em>
        </small>
      </p>
      <div><p>А еще было бы классно написать про stateful генерационные тесты, работающие по принципу конечных автоматов. То есть для API описываются возможные состояния и пути перехода между ними (логин, создание аккаунта, загрузка фотографии, изменение фотографии, удаление, логаут и т.п.), а потом с помощью test.check генерируются деревья - сценарии возможных переходов. И это дело оставляем на ночь шастать по API туда-сюда, а потом оно еще и минимизируется и находит минимальную ломающую последовательность шагов.</p>
</div>
    </div>
  
    <div id="comment-4700965974" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            24th Nov 2019,
            <a href="#comment-4700965974">link</a>
            , <a href="#comment-4699533030">parent</a>
          </em>
        </small>
      </p>
      <div><p>Да, поправил, спасибо.</p>
</div>
    </div>
  
</div>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-book-tests-2/">
    <input required name="captcha" type="hidden" value="9 &#215; 5">

    <div class="block">
        <span class="comment-form-label"><small>9 &#215; 5 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="https://t.me/igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
