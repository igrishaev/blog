<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Почему я против объектов. Часть первая, философская</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/oop-1/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Почему я против объектов. Часть первая, философская</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2018-01-05T00:00:00+00:00">
        Jan 5, 2018
    </time>

    <a href="/tag/oop/" rel="tag">oop</a>, <a href="/tag/programming/" rel="tag">programming</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<p><strong>UPD</strong>: <a href="/oop-2">вторая часть</a>.</p>

<p><strong>LT;DR:</strong> это очень личный взгляд на ООП, который я обдумывал довольно долго,
но окончательно сформировал после прочтения книги Егора <a href="http://www.yegor256.com/elegant-objects.html">“Elegant
Objects”</a>. Если коротко, я высказываюсь против идеи представления кода в
объектной модели. Некоторые аргументы почерпнуты из сторонних публикаций и
адаптированы для краткости. В таких случаях я даю ссылку на оригинал.</p>

<p>Изначально я планировал написать два в одном: и про ментальную, и про
техническую составляющие ООП, но так как текст получается объемный, опубликую
пока что первую часть о том, как ООП ложится на (мой) мозг.</p>

<p>Объекты, как утверждают <a href="https://en.wikipedia.org/wiki/Object-oriented_programming#Objects_and_classes">Википедия</a> и учебники, помогают отобразить
картину физического мира в коде. Думаю, всем это объяснял преподаватель в школе
или университете на примере класса кота или собаки. Потом примеры с
наследованием, переопределением класса “голос” и так далее.</p>

<p>За последние годы мое увлечение ООП плавно сошло на нет. В одном из постов <a href="http://grishaev.me/oop">я
прямо признавался</a>, что не понимаю его принципов. Главное, что меня
смущает: во время работы, если это был не строго объектный язык, а Питон, JS или
PHP, то все задачи я решал простыми функциями. Каждый раз мне говорили, что
просто проект легкий, что однажды наступит БОЛЬШОЙ ПРОЕКТ, где с функциями ты
хлебнешь. Но время шло, БОЛЬШОЙ ПРОЕКТ так и не наступил, и, кажется, в эпоху
микро-сервисов его уже не дождешься. А я все пишу на функциях и неизменяемых
коллекциях. В чем же дело?</p>

<p>И любой объектный код я переписывал на функциях с сокращением числа строк до
двух раз. Как так?</p>

<p>Причина мне видится в том, что ООП очень абстрактно. Одно и то же событие
реального мира можно интерпретировать в объектной модели совершенно
по-разному. Отсюда и трудности изучения, и лишний код.</p>

<p>Представим, что Вася отправляет письмо Пете. На языке объектов это записывается
так (опустим определения классов):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">User</span> <span class="n">vasya</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Vasya"</span><span class="o">);</span>
<span class="nc">User</span> <span class="n">petya</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Petya"</span><span class="o">);</span>
<span class="nc">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">);</span>
<span class="n">vasya</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">petya</span><span class="o">);</span>
</code></pre></div></div>

<p>Тут, возможно, я нарушил один из бесчисленных паттернов ООП: отвечать за
отправку должен не пользователь, а само сообщение (что весьма спорно). Поэтому
следующий после меня разработчик поправит код вот так:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">msg</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="k">from</span><span class="o">=</span><span class="n">vasya</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="n">petya</span><span class="p">)</span>
</code></pre></div></div>

<p>Это уже не синтаксис Джавы, в ней нет именованных аргументов, а скорее
Питона. Написал так, чтоб было понятно: метод <code class="language-plaintext highlighter-rouge">.send()</code> принимает отправителя и
получателя и сам отправляет письмо.</p>

<p>Уже на этом этапе видна вся неоднозначность и зыбкость объектного
мышления. Согласно паттернам, отправку письма логичней вынести в класс
сообщения. С другой стороны, в реальном мире именно пользователь инициирует
отправку. Письмо это неодушевленная сущность, набор байт или листок бумаги. Как
он может что-то отправлять?</p>

<p>Теперь представим, что на каждый чих мы проектируем класс и создаем объект. Как
можно утверждать, что отношения между ними логически верны? Как это доказать?</p>

<p>Зыбкость этого принципа порождает все новые и новые книги и статьи в блогах, где
авторы доказывают, что именно их подход обеспечивает прозрачность и
поддерживаемость программы, написанной в объектном стиле. Но на более
приземленном уровне это выражается, простите, в срачи – бурные обсуждения в
чатах, когда эмоции и мнения намного опережают опыт.</p>

<p>Проблему отношений между объектами я называю “кто на ком стоял”. В самом деле,
ручка пишет по бумаге <code class="language-plaintext highlighter-rouge">pen.writeOn(paper)</code> или бумага с помощью ручки
<code class="language-plaintext highlighter-rouge">paper.write(pen)</code>? Каждый, кто поспешит ответом в духе “ну конечно первый
(второй) вариант”, не учитывает, что это совершенно субъективно.</p>

<p>Предполагаю, что именно поэтому в ООП-среде так популярен рефакторинг. Ключевая
фича каждой промышленной IDE – облегчение рефакторинга: переименование и
перенос методов, автоматическая адаптация кода.</p>

<p>В окружающем нас реальном мире физические объекты играют далеко не решающую
роль. Иными словами, не все можно выразить через объекты. Рассмотрим, например,
акт рукопожатия. Следуя принципам Егора, отразить в коде это можно так:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span>

  <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Handshake</span> <span class="o">{</span>
  <span class="nc">User</span> <span class="n">user1</span><span class="o">;</span>
  <span class="nc">User</span> <span class="n">user2</span><span class="o">;</span>

  <span class="nc">Handshare</span><span class="o">(</span><span class="nc">User</span> <span class="n">user1</span><span class="o">,</span> <span class="nc">User</span> <span class="n">user2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">user1</span> <span class="o">=</span> <span class="n">user1</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">user2</span> <span class="o">=</span> <span class="n">user2</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">void</span> <span class="nf">shake</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// ... лог в консоль или что угодно</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nc">User</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Ivan"</span><span class="o">);</span>
<span class="nc">User</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Petr"</span><span class="o">);</span>
<span class="nc">Handshake</span> <span class="n">hs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Handshake</span><span class="o">(</span><span class="n">user1</span><span class="o">,</span> <span class="n">user2</span><span class="o">);</span>
<span class="n">hs</span><span class="o">.</span><span class="na">shake</span><span class="o">();</span>
</code></pre></div></div>

<p>Но ведь физически рукопожатия не существует. Нет в нашем мире такого объекта,
его нельзя купить, смастерить, поставить на полку. Это событие, акт или,
выражаясь точнее, действие! А что в программировании выражает действие? Функция.</p>

<p>Предположим теперь, что друзья пожали руки несколько раз с интервалом в 10
минут. Будет ли правильным вызывать у того же объекта метод <code class="language-plaintext highlighter-rouge">.shake()</code>? Или на
каждый раз создавать новый объект?</p>

<p>Если первое, не противоречит ли это принципам ООП? Ведь все это разные
рукопожатия, совершенно независящие друг от друга. Что если они жали руки с
перерывом в 10 лет?</p>

<p>Если второе, то чем это отличается от вызова функции? Мы создаем объект,
вызываем единственный метод и тут же забываем его? Зачем тогда класс и объект?
Если один-два метода это все, что нам нужно от класса, не проще ли завести
функцию?</p>

<p>На эту тему уже неписана отличная статья “перестаньте писать классы”, изучите
обязательно. <a href="http://pyvideo.org/pycon-us-2012/stop-writing-classes.html">Видео</a> со слайдами, <a href="https://habrahabr.ru/post/140581/">перевод</a> на
Хабре.</p>

<p>Далее можно рассуждать о более сложных вещах. Рукопожатие все же имеет косвенное
отношение к физическим объектам. Но такие абстрактные понятия как ненависть,
симпатия, эгоизм, честность, религия выразить объектно невозможно. Я имею в
виду, что не составит труда написать класс с нужным именем, который
инкапсулирует другие классы. Но спрашивается, в чем здесь смысл?</p>

<p>Добавьте процессы: горение, магнитные волны, свет. Все, что перечислено выше
имеет значение только в действии. Важен не сам объект, а как он изменяет другие
сущности. Опять же, про <a href="http://www.flyingmachinestudios.com/programming/the-unofficial-guide-to-rich-hickeys-brain/">написана хорошая статья</a>, где рассматривается
река с точки зрения ООП- и ФП-программиста.</p>

<p>В книге “Elegant Objects” Егор справедливо замечает, что сегодняшнее ООП это
просто структура данных с прикрепленными к ней функциями. Однако, не делается
акцент на том, сколь масштабно это явление. С выходом языков Go и Rust на них
перешли тысячи бывших Java и С++ разработчиков, и, похоже, сочли новые языки
вполне себе объектными. А ведь и в Go и в Rust объекты – это банальные сишные
структуры. И если функция принимает первым аргументом такую структуру, то вместо
<code class="language-plaintext highlighter-rouge">some_action(data, 1, "test")</code> можно написать <code class="language-plaintext highlighter-rouge">data.some_action(1, "test")</code>. Вот
и вся разница.</p>

<p>Очевидно, сегодня для большинства вызов функции через точку кажется главным
показателем объектности языка. Я не хочу никого этим обидеть. Человеку
свойственно упрощать рутину: выражать код всей программы с помощью настоящих,
“элегантных” объектов, как советует Егор, мне кажется неподъемным делом. А со
структурам и функциями проще, и даже похоже на ООП.</p>

<p>Я утверждаю, что современный ООП-подход, согласно которому мы выражаем все
сущности как объекты, так же похож на окружающий мир, как шахматы на реальную
войну. То есть в кукольной манере и гротескным упрощением. Тысячи лет назад
войска действительно выстраивались напротив противника, впереди пешие войска, по
бокам боевые слоны, сзади командование. Сегодня это не так.</p>

<p>Кратко резюмируя. В ООП до сих пор нет четкого понимания, как выстраивать
отношения между объектами. Огромное число паттернов сбивает с толку. Объекты в
коде не могут точно описать нематериальные понятия: природные процессы,
отношения между людьми. Гораздо большее значение имеет не объект, а действие над
ним.</p>

<p>В следующий раз поговорим о технической стороне ООП.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментарии</center>

<div id="comments">
  
    <div id="comment-3700957240" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Vyacheslav Ermolaev,
            10th Jan 2018,
            <a href="#comment-3700957240">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Вы  просто смоделировали  неправильно  бизнес-процесс пересылки. При этом нарушили один из принципов SOLID ,  а именно single responsibility. Люди в реальном мире выполняют пересылку почты друг другу. Этим занимает почтовая служба, которой  для  успешного  выполнения  нужно лишь письмо. Для того, чтобы  письмо было доставлено оно должно  содержать не только текст сообщения, но  информацию об  отправителя и  получателе.  <br />Тоже самое с ручкой.  Умение писать  принадлежит  только ручке. Можно, конечно, сказать, что эта бумага была исписана ручкой, но страдательный залог - это  грамматический термин, а не термин ООП. Боюсь,что при реальном опросе  все те, кто реально занимает программированием вариант paper.write(pen) просто не назовут. Методы в ООП это не аналоги сказуемого  в  грамматике и модели строятся на  реальных бизнес-процессах да  к тому же очень часто доменную модель предметной  области создают не программисты, а аналитики, которые в этой  предметной области собаку съели</p>
</div>
    </div>
  
    <div id="comment-4805289901" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Михаил Попов,
            22nd Feb 2020,
            <a href="#comment-4805289901">link</a>
            
          </em>
        </small>
      </p>
      <div><p>“Elegant Objects” уже для понимающих разницу между компьютерным и человеческим мышлениеми. Меня прорубило видео Егора ООП враньё. <br />Как раз я упутался в частном проекте - погружение в задачу занимало каждый раз по часу. <br />Удовольствие от программирования ушло. Поиск привёл к Егору. Профит = программирую, хоть и  по сермяжному, а с удовольствием.<br />Видео про враньё основано на книге Давида Веста - там написано примерно так - думать как компьютер было сначало полезно, при усложнении задачи компьютер Вас "обует", поэтому выгоднее в сложных задачах думать по человечески, а человек решает сложные задачи артелью, коллективом, отрядом ...</p>
<p>А решать с помощью ООП, то что решается процедурно ... как стричь поросёнка - визгу много, шерсти мало... как заставлять льва ловить мышь - бесперспективно и опасно :-).</p>
<p>От себя добавлю - слово "объект" русскоязычным не подходит. Нам подходит "исполнитель". И "класс" не подходит, нам нужна "матка", она делает исполнителей, которые получают сообщение, что-то минимально нужное делают, передают сообщение.<br />И компьютер позволяет нам этих исполнителей использовать снова и снова. <br />Управление толпами исполнителей - погуглите по "ООП разрушить собор построить базар"</p>
<p>Кто не терял кайф программирования, тот не поймёт нашего Егора-"стрельца" :-)</p>
</div>
    </div>
  
    <div id="comment-4805451884" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            22nd Feb 2020,
            <a href="#comment-4805451884">link</a>
            , <a href="#comment-4805289901">parent</a>
          </em>
        </small>
      </p>
      <div><p>Надо просто переболеть Егором и двигаться дальше.</p>
</div>
    </div>
  
    <div id="comment-5568819627" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            dikun,
            12th Oct 2021,
            <a href="#comment-5568819627">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Если юзер и сообщение не могут поделить send, то это намекает на то, что send по справедливости не должен принадлежать кому-то одному (чтоб не ссорились), но должен дружить и с юзером, и сообщением, т.е. <br /><code>send(from=vasya, to=petya, what=msg)</code><br />при этом send - должен иметь доступ к приватным методам и полям юзера и сообщения (друзья должны знать сокровенное о своих друзьях). Что-то похожее есть в С++. Так и называется - друзья. Но на сколько я помню, друзья в C++ должны всё равно какому-то классу принадлежать. А это плохо.</p>
</div>
    </div>
  
    <div id="comment-5568823778" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            dikun,
            12th Oct 2021,
            <a href="#comment-5568823778">link</a>
            , <a href="#comment-5568819627">parent</a>
          </em>
        </small>
      </p>
      <div><p>Если это ДжаваСкрипт, то send-функция у нас ещё и объект, который можно нашпиговать, например, полями:<br /><code>send.amotion = new Amotion('angry')<br />send(from=vasya, to=petya, what=msg)</code></p>
</div>
    </div>
  
</div>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/oop-1/">
    <input required name="captcha" type="hidden" value="1 &#215; 6">

    <div class="block">
        <span class="comment-form-label"><small>1 &#215; 6 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
