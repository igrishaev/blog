<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>REPL, Cider, Emacs (часть 1/4)</title>
  <meta name="description" content="Все части  Первая часть  Вторая часть  Третья часть  Четвертая часть">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-repl-part-1/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">REPL, Cider, Emacs (часть 1/4)</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2022-08-09T00:00:00+00:00">
        Aug 9, 2022
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/repl/" rel="tag">repl</a>, <a href="/tag/emacs/" rel="tag">emacs</a>, <a href="/tag/cider/" rel="tag">cider</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<h2>Все части</h2>

<ul>
  <li><a href="/clj-repl-part-1/">Первая часть</a></li>
  <li><a href="/clj-repl-part-2/">Вторая часть</a></li>
  <li><a href="/clj-repl-part-3/">Третья часть</a></li>
  <li><a href="/clj-repl-part-4/">Четвертая часть</a></li>
</ul>

<h2>

    Оглавление

</h2>

<ul id="toc-item-clojure-repl-toc">
  <li><a href="#исторический-экскурс" id="toc-item-clojure-repl-toc-исторический-экскурс">Исторический экскурс</a></li>
  <li><a href="#пробуем-repl" id="toc-item-clojure-repl-toc-пробуем-repl">Пробуем REPL</a></li>
  <li><a href="#более-сложный-сценарий" id="toc-item-clojure-repl-toc-более-сложный-сценарий">Более сложный сценарий</a></li>
  <li><a href="#свой-repl" id="toc-item-clojure-repl-toc-свой-repl">Свой REPL</a>    <ul>
      <li><a href="#улучшения" id="toc-item-clojure-repl-toc-улучшения">Улучшения</a>        <ul>
          <li><a href="#выход-из-цикла" id="toc-item-clojure-repl-toc-выход-из-цикла">Выход из цикла</a></li>
          <li><a href="#перехват-исключений" id="toc-item-clojure-repl-toc-перехват-исключений">Перехват исключений</a></li>
          <li><a href="#обработчик-исключения" id="toc-item-clojure-repl-toc-обработчик-исключения">Обработчик исключения</a></li>
          <li><a href="#красивая-печать" id="toc-item-clojure-repl-toc-красивая-печать">Красивая печать</a></li>
          <li><a href="#приглашение" id="toc-item-clojure-repl-toc-приглашение">Приглашение</a></li>
          <li><a href="#переменная-результата" id="toc-item-clojure-repl-toc-переменная-результата">Переменная результата</a></li>
          <li><a href="#многострочный-ввод" id="toc-item-clojure-repl-toc-многострочный-ввод">Многострочный ввод</a></li>
        </ul>
      </li>
      <li><a href="#repl-в-repl" id="toc-item-clojure-repl-toc-repl-в-repl">REPL в REPL</a></li>
      <li><a href="#доступ-к-локальным-переменным" id="toc-item-clojure-repl-toc-доступ-к-локальным-переменным">Доступ к локальным переменным</a></li>
    </ul>
  </li>
  <li><a href="#полезные-функции-repl" id="toc-item-clojure-repl-toc-полезные-функции-repl">Полезные функции REPL</a></li>
</ul>

<p><em>Эта глава расскажет о REPL — фундаментальном свойстве Clojure. Так называют интерактивную работу с языком, когда программу наращивают постепенно. Мы рассмотрим, что такое REPL-driven development и почему, однажды познав, от него трудно отказаться.</em></p>

<p>Аббревиатура REPL происходит от четырех слов: Read, Eval, Print и Loop. Дословно они означают прочитать, выполнить, напечатать и повторить. REPL — устойчивый термин, под которым понимают интерактивный режим программы.</p>

<p>Многие современные языки предлагают интерактивный режим. Как правило, он запускается, если вызвать интерпретатор без параметров. Например, команды <code class="language-plaintext highlighter-rouge">python</code> или <code class="language-plaintext highlighter-rouge">node</code> запустят интерактивные сеансы Python и Node.js. В Ruby для этого служит утилита <code class="language-plaintext highlighter-rouge">irb</code> (где i означает interactive). REPL поддерживают не только интерпретаторы, но и языки, которые компилируются в байт-код (Java, Scala) или машинный код (Haskell, SBCL).</p>

<p>Несмотря на это разнообразие, именно в Лисп-системах REPL имеет решающее значение. Если в Python или Node.js его рассматривают как приятное дополнение, то в Лиспе он необходим. Разработка на любом Лиспе зависит от того, насколько хорошо вы взаимодействуете с REPL. На REPL так или иначе опираются все инструменты и практики, документация, видеоуроки и так далее.</p>

<p>В мире Лиспа ходит понятие REPL-driven development. Это стиль разработки, когда код пишут малыми порциями и запускают в REPL. С таким подходом сразу видно поведение программы. Легче проверить неочевидные случаи, например вызвать функцию с <code class="language-plaintext highlighter-rouge">nil</code> или обратиться к ресурсу, которого не существует.</p>

<p>Другой полезный сценарий для REPL — извлечь данные из сети и исследовать их. Эта задача идеально ложиться на интерактивный режим. Как правило, HTTP-запрос предполагает несколько этапов: его подготовку, отправку, чтение тела и поиск нужных полей. Эти шаги проходят интерактивно методом проб и ошибок. Позже мы рассмотрим пример HTTP-запроса в сеансе REPL.</p>

<!-- more -->

<h2 id="исторический-экскурс">Исторический экскурс</h2>

<p>REPL отсчитывает свою историю от <a href="https://en.wikipedia.org/wiki/Lisp_machine">первых Лисп-машин</a>. Это были мейнфреймы с запущенным на них интерпретатором Лиспа. Подобные машины использовали в Xerox для печати, обработки изображений, управления оборудованием, решения задач на оптимизацию и машинного обучения. Разработку Лисп-машин <a href="https://en.wikipedia.org/wiki/Dynamic_Analysis_and_Replanning_Tool">поддерживал отдел DARPA</a>, в том числе потому, что их применяли в военной отрасли.</p>

<p>Золотой век Лисп-машин пришелся на период с 1977 по 1985 год, после чего последовал спад их популярности. Из-за особенностей архитектуры они не могли конкурировать с процессором x86 и компилируемыми языками, — как в плане цены, так и производительности. В итоге Лисп-машины полностью ушли с рынка, но подход REPL, придуманный полвека назад, навсегда остался в индустрии.</p>

<p>Подход и вправду был инновационным. До него программу набирали в редакторе, компилировали и только потом запускали (для краткости опустим перфокарты и прочую рутину). Процесс был долгим и дорогим. Наоборот, Лисп-машина принимала код и выполняла его мгновенно. Для своего времени Лисп был очень высокоуровневым языком. На нем легко выразить сложную логику, не отвлекаясь на низкоуровневые проблемы. Именно в Лиспе появился автоматический контроль за памятью и сборщик мусора. Все это делало Лисп-машину идеальной площадкой для экспериментов.</p>

<p>Интерпретатор Лисп-машины был не просто программой по запуску кода. Фактически он был ее операционной системой, потому что имел доступ к регистрам процессора, оперативной памяти и устройствам ввода-вывода. В REPL можно было просмотреть все переменные и функции, переопределить и удалить их. Это свойство — полный контроль системой — тоже стало неотъемлемой частью REPL.</p>

<p>Язык Clojure, как и другие диалекты Лиспа, активно поддерживает REPL и все связанное с ним. Без знания REPL работа с Clojure будет неэффективна. Классический подход, когда сначала вы пишете программу, а потом запускаете, здесь не работает. Цель этой главы — показать практическую, REPL-ориентированную разработку, принятую в Clojure.</p>

<h2 id="пробуем-repl">Пробуем REPL</h2>

<p>Чтобы познакомиться с REPL, запустим его. Это можно сделать несколькими способами.</p>

<p><strong>Первый</strong> — установить утилиту <a href="https://leiningen.org/">Leiningen</a> для управления проектами на Clojure. Инструкции по установке вы найдете на официальном сайте. Когда утилита установлена, выполните в терминале:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lein repl
</code></pre></div></div>

<p><strong>Второй</strong> способ — установить набор утилит <a href="https://clojure.org/guides/install_clojure">Clojure CLI</a>. На официальном сайте Clojure представлены команды установки для Linux и MacOS. После установки появятся команды <code class="language-plaintext highlighter-rouge">clojure</code> и <code class="language-plaintext highlighter-rouge">clj</code> для запуска проекта. Если вызвать любую из них, запустится REPL:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> clj
<span class="c">#or</span>
<span class="o">&gt;</span> clojure
</code></pre></div></div>

<p><strong>Третий</strong> способ – выполнить архив jar. Старые версии Clojure (до 1.8 включительно) состоят из одного jar-файла, который запускается командой <code class="language-plaintext highlighter-rouge">java -jar</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> java <span class="nt">-jar</span> clojure-1.8.0.jar
</code></pre></div></div>

<p>Другой вариант, когда архив находится в CLASSPATH и явно указан класс <code class="language-plaintext highlighter-rouge">clojure.main</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> java <span class="nt">-cp</span> clojure-1.8.0.jar clojure.main
</code></pre></div></div>

<p>С версии 1.9 Clojure состоит из нескольких jar-файлов. Библиотека Clojure.spec, которую мы рассмотрели в первой книге, поставляется отдельно. Скачайте jar-файлы из <a href="https://mvnrepository.com/">репозитория Maven</a> в разделах <code class="language-plaintext highlighter-rouge">org.clojure/clojure</code> и <code class="language-plaintext highlighter-rouge">org.clojure/spec.alpha</code>. Далее выполните команду:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> java <span class="nt">-cp</span> clojure-1.11.1.jar:spec.alpha-0.3.218.jar clojure.main
</code></pre></div></div>

<p>Когда REPL запущен, вы увидите приглашение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user=&gt;
</code></pre></div></div>

<p>Слово <code class="language-plaintext highlighter-rouge">user</code> означает текущее пространство имен. Если не задано иное, REPL запускается в пространстве <code class="language-plaintext highlighter-rouge">user</code>. Позже мы узнаем, как задать другое пространство или переключить его.</p>

<p>Введите любое выражение на Clojure: число, строку в двойных кавычках или кейворд. Эти значения вычисляются сами в себя:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="mi">1</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="no">:test</span><span class="w">
</span><span class="no">:test</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="s">"Hello REPL!"</span><span class="w">
</span><span class="s">"Hello REPL!"</span><span class="w">
</span></code></pre></div></div>

<p>Задайте глобальную переменную:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/amount</span><span class="w">
</span></code></pre></div></div>

<p>и сошлитесь на нее в выражении:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="mi">7</span><span class="w">
</span></code></pre></div></div>

<p>Более сложный пример. Определите функцию <code class="language-plaintext highlighter-rouge">add</code>, которая складывает два числа. Введите ее в одну строку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/add</span><span class="w">
</span></code></pre></div></div>

<p>и проверьте вызов:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">add</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">5</span><span class="w">
</span></code></pre></div></div>

<p>REPL поддерживает ввод нескольких строк за раз. Предположим, вы бы хотели задать функцию с переносом после параметров, чтобы код выглядел аккуратней:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Если напечатать <code class="language-plaintext highlighter-rouge">(defn add [a b]</code> и нажать ввод, по незакрытой скобке REPL определит, что выражение неполное. Ошибки не произойдет, и следующая строка дополнит исходную. Как только скобки станут сбалансированы, REPL выполнит форму.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="o">#</span><span class="n">_=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/add</span><span class="w">
</span></code></pre></div></div>

<p>Подключите любой из модулей Clojure, например <code class="language-plaintext highlighter-rouge">clojure.string</code> для работы со строками:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">])</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p>С его помощью разбейте строку или выполните автозамену:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="s">"one two three"</span><span class="w"> </span><span class="o">#</span><span class="s">"\s+"</span><span class="p">)</span><span class="w">
</span><span class="p">[</span><span class="s">"one"</span><span class="w"> </span><span class="s">"two"</span><span class="w"> </span><span class="s">"three"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">str/replace</span><span class="w"> </span><span class="s">"Two minutes, Turkish!"</span><span class="n">,</span><span class="w"> </span><span class="o">#</span><span class="s">"Two"</span><span class="w"> </span><span class="s">"Five"</span><span class="p">)</span><span class="w">
</span><span class="s">"Five minutes, Turkish!"</span><span class="w">
</span></code></pre></div></div>

<p>Модуль <code class="language-plaintext highlighter-rouge">clojure.inspector</code> предлагает примитивный графический отладчик. Его функция <code class="language-plaintext highlighter-rouge">inspect-tree</code> принимает данные и выводит окно Swing с деревом папок. Значок папки означает коллекцию; если его раскрыть, появятся дочерние элементы с иконками файлов. Чтобы изучить переменные среды, выполните:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.inspector</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">insp</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">insp/inspect-tree</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Содержимое окна будет примерно таким:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{}
└─ JAVA_MAIN_CLASS_68934=clojure.main
└─ LC_TERMINAL=iTerm2
└─ COLORTERM=truecolor
└─ LOGNAME=ivan
└─ TERM_PROGRAM_VERSION=3.3.12
└─ PWD=/Users/ivan/work/book-sessions
└─ SHELL=/bin/zsh
</code></pre></div></div>

<p>Опробуйте случай с ошибкой: поделите число на ноль или сложите число с <code class="language-plaintext highlighter-rouge">nil</code>. REPL не завершится, но выведет исключение на экран:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="n">Execution</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">(</span><span class="nf">ArithmeticException</span><span class="p">)</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">user/eval554...</span><span class="w">
</span><span class="n">Divide</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">zero</span><span class="w">
</span></code></pre></div></div>

<p>Это правильное поведение: в разработке ошибки случаются часто, и нам бы не хотелось завершать JVM. Однако это справедливо только для сеанса REPL. В боевом запуске программы на Clojure ведут себя как обычно: если исключение не поймано, программа завершается.</p>

<p>По умолчанию REPL выводит краткое сообщение об ошибке. Объект исключения остается в переменной <code class="language-plaintext highlighter-rouge">*e</code>. Исследуем ее:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="n">*e</span><span class="w">

</span><span class="o">#</span><span class="n">error</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="no">:cause</span><span class="w"> </span><span class="s">"Divide by zero"</span><span class="w">
 </span><span class="no">:via</span><span class="w">
 </span><span class="p">[{</span><span class="no">:type</span><span class="w"> </span><span class="n">java.lang.ArithmeticException</span><span class="w">
   </span><span class="no">:message</span><span class="w"> </span><span class="s">"Divide by zero"</span><span class="w">
   </span><span class="no">:at</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.lang.Numbers</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="s">"Numbers.java"</span><span class="w"> </span><span class="mi">188</span><span class="p">]}]</span><span class="w">
 </span><span class="no">:trace</span><span class="w">
 </span><span class="p">[[</span><span class="n">clojure.lang.Numbers</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="s">"Numbers.java"</span><span class="w"> </span><span class="mi">188</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">clojure.lang.Numbers</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="s">"Numbers.java"</span><span class="w"> </span><span class="mi">3901</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">user$eval8888</span><span class="w"> </span><span class="n">invokeStatic</span><span class="w"> </span><span class="s">"form-init3207458389100610076.clj"</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">user$eval8888</span><span class="w"> </span><span class="n">invoke</span><span class="w"> </span><span class="s">"form-init3207458389100610076.clj"</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="p">[</span><span class="n">nrepl.middleware.session$session_exec$main_loop__1048</span><span class="w"> </span><span class="n">invoke</span><span class="w"> </span><span class="s">"session.clj"</span><span class="w"> </span><span class="mi">201</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">clojure.lang.AFn</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="s">"AFn.java"</span><span class="w"> </span><span class="mi">22</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">java.lang.Thread</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="s">"Thread.java"</span><span class="w"> </span><span class="mi">829</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<p>В первой книге мы рассмотрели, что можно сделать с исключением: напечатать в удобном виде, записать в лог, отправить в систему сборки ошибок.</p>

<p>Когда REPL что-то вычислил, результат остается в переменной <code class="language-plaintext highlighter-rouge">*1</code>. С ней легко избежать повторных вычислений. Предположим, мы ввели код, который дает объемный результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="s">"HOME"</span><span class="w"> </span><span class="s">"/Users/ivan"</span><span class="w">
 </span><span class="s">"LC_TERMINAL_VERSION"</span><span class="w"> </span><span class="s">"3.3.12"</span><span class="w">
 </span><span class="s">"USER"</span><span class="w"> </span><span class="s">"ivan"</span><span class="w">
 </span><span class="n">...</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы сослаться на результат, не вычисляя повторно, введите:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">*1</span><span class="w"> </span><span class="s">"USER"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; "ivan"</span><span class="w">
</span></code></pre></div></div>

<p>Переменная <code class="language-plaintext highlighter-rouge">*1</code> полезна для записи в файл. Предположим, мы хотим сохранить переменные среды, чтобы исследовать позже. Для этого введите:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="s">"dump.edn"</span><span class="w"> </span><span class="p">(</span><span class="nb">pr-str</span><span class="w"> </span><span class="n">*1</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>На диске появится файл <code class="language-plaintext highlighter-rouge">dump.edn</code> с данными. Позже мы прочтем его комбинацией <code class="language-plaintext highlighter-rouge">slurp</code> и <code class="language-plaintext highlighter-rouge">read-string</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="s">"dump.edn"</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="s">"HOME"</span><span class="w"> </span><span class="s">"/Users/ivan"</span><span class="w">
 </span><span class="s">"LC_TERMINAL_VERSION"</span><span class="w"> </span><span class="s">"3.3.12"</span><span class="w">
 </span><span class="s">"USER"</span><span class="w"> </span><span class="s">"ivan"</span><span class="w">
 </span><span class="n">...</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Доступны три переменных результата: <code class="language-plaintext highlighter-rouge">*1</code>, <code class="language-plaintext highlighter-rouge">*2</code> и <code class="language-plaintext highlighter-rouge">*3</code>. С каждым вычислением результаты смещаются: последний будет в <code class="language-plaintext highlighter-rouge">*1</code>, предпоследний в <code class="language-plaintext highlighter-rouge">*2</code> так далее. Покажем это на примере:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="mi">1</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="mi">2</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="mi">3</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">*1</span><span class="w"> </span><span class="n">*2</span><span class="w"> </span><span class="n">*3</span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы загрузить в REPL несколько определений, используйте функцию <code class="language-plaintext highlighter-rouge">load-file</code>. Она принимает один аргумент — путь к файлу с кодом на Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">load-file</span><span class="w"> </span><span class="s">"my_functions.clj"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Эффект аналогичен тому, как если бы вы скопировали содержимое файла и вставили в REPL. Функция не влияет на текущее пространство имен, как это делают формы <code class="language-plaintext highlighter-rouge">ns</code> или <code class="language-plaintext highlighter-rouge">require</code>. В боевом коде <code class="language-plaintext highlighter-rouge">load-file</code> не используют, потому что такая загрузка делает код неочевидным: неясно, откуда взялось то или иное определение. Но для экспериментов <code class="language-plaintext highlighter-rouge">load-file</code> подходит идеально.</p>

<p>REPL предлагает макросы для интроинспеции. Выражение <code class="language-plaintext highlighter-rouge">(doc ...)</code> напечатает справку указанной функции, например:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(doc assoc)
-------------------------
clojure.core/assoc
([map key val] [map key val &amp; kvs])
  assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).
</code></pre></div></div>

<p>А форма <code class="language-plaintext highlighter-rouge">(source ...)</code> — ее исходный код (приведем в сокращении):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">source</span><span class="w"> </span><span class="nb">assoc</span><span class="p">)</span><span class="w">
</span><span class="c1">;;</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w">
 </span><span class="o">^</span><span class="p">{</span><span class="no">:arglists</span><span class="w"> </span><span class="o">'</span><span class="p">([</span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="nb">val</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">kvs</span><span class="p">])</span><span class="w">
   </span><span class="no">:doc</span><span class="w"> </span><span class="s">"..."</span><span class="w">
   </span><span class="no">:added</span><span class="w"> </span><span class="s">"1.0"</span><span class="w">
   </span><span class="no">:static</span><span class="w"> </span><span class="n">true</span><span class="p">}</span><span class="w">
 </span><span class="nb">assoc</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="o">^</span><span class="no">:static</span><span class="w"> </span><span class="nb">assoc</span><span class="w">
   </span><span class="p">([</span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="nb">val</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.lang.RT/assoc</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="nb">val</span><span class="p">))</span><span class="w">
   </span><span class="p">([</span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">kvs</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">...</span><span class="p">))))</span><span class="w"> </span><span class="c1">;; truncated</span><span class="w">
</span></code></pre></div></div>

<p>REPL предлагает и другие возможности, о которых мы поговорим позже. Пока что завершите сеанс нажатием <code class="language-plaintext highlighter-rouge">Ctrl+D</code> или выполните <code class="language-plaintext highlighter-rouge">(quit)</code> или <code class="language-plaintext highlighter-rouge">(exit)</code>.</p>

<h2 id="более-сложный-сценарий">Более сложный сценарий</h2>

<p>REPL подходит не только для быстрых экспериментов; опытные разработчики проводят в нем часы и дни. Одна из причин в том, что REPL — лучший способ разведать ситуацию, когда вы не знаете точно, какие данные приходят из внешних источников.</p>

<p>Предположим, мы пишем бота для Telegram, который публикует шутки для программистов. Понадобится сервис, который бы выступил в роли источника шуток. Быстрый поиск дает нам сервис <a href="https://jokeapi.dev/">Joke API</a> с удобным API по протоколу HTTP.</p>

<p>Прежде чем писать бота, убедимся в работе сервиса. Для этого понадобятся HTTP-клиент и парсер JSON. Если вы запускаете REPL при помощи <code class="language-plaintext highlighter-rouge">lein</code>, создайте файл <code class="language-plaintext highlighter-rouge">project.clj</code> с содержимым:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defproject</span><span class="w"> </span><span class="n">repl-chapter</span><span class="w"> </span><span class="s">"0.1.0-SNAPSHOT"</span><span class="w">
  </span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">org.clojure/clojure</span><span class="w"> </span><span class="s">"1.10.0"</span><span class="p">]</span><span class="w">
                 </span><span class="p">[</span><span class="n">clj-http</span><span class="w"> </span><span class="s">"3.9.1"</span><span class="p">]</span><span class="w">
                 </span><span class="p">[</span><span class="n">cheshire</span><span class="w"> </span><span class="s">"5.8.1"</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>

<p>Для утилит Clojure CLI файл <code class="language-plaintext highlighter-rouge">deps.edn</code> выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:deps</span><span class="w">
 </span><span class="p">{</span><span class="n">clj-http/clj-http</span><span class="w"> </span><span class="p">{</span><span class="no">:mvn/version</span><span class="w"> </span><span class="s">"3.9.1"</span><span class="p">}</span><span class="w">
  </span><span class="n">cheshire/cheshire</span><span class="w"> </span><span class="p">{</span><span class="no">:mvn/version</span><span class="w"> </span><span class="s">"5.8.1"</span><span class="p">}}}</span><span class="w">
</span></code></pre></div></div>

<p>Запустите REPL. Обе библиотеки, если еще не были установлены локально, скачаются на ваш компьютер. Подключите их в сеансе:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clj-http.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">client</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="ss">'cheshire.core</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Подготовим словарь запроса:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">request</span><span class="w">
  </span><span class="p">{</span><span class="no">:url</span><span class="w"> </span><span class="s">"https://v2.jokeapi.dev/joke/Programming"</span><span class="w">
   </span><span class="no">:method</span><span class="w"> </span><span class="no">:get</span><span class="w">
   </span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Получим ответ:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">response</span><span class="w">
  </span><span class="p">(</span><span class="nf">client/request</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Каждый результат мы связываем с переменной при помощи <code class="language-plaintext highlighter-rouge">def</code>, чтобы позже сослаться на него. Такой стиль не подходит для промышленного кода, но приемлем в REPL. Поместим тело в отдельную переменную и напечатаем его:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w">
  </span><span class="p">(</span><span class="no">:body</span><span class="w"> </span><span class="n">response</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:category</span><span class="w"> </span><span class="s">"Programming"</span><span class="w">
 </span><span class="no">:delivery</span><span class="w"> </span><span class="s">"They only like chicken NuGet."</span><span class="w">
 </span><span class="no">:type</span><span class="w"> </span><span class="s">"twopart"</span><span class="w">
 </span><span class="no">:setup</span><span class="w"> </span><span class="s">".NET developers are picky when it comes to food."</span><span class="w">
 </span><span class="no">:lang</span><span class="w"> </span><span class="s">"en"</span><span class="w">
 </span><span class="no">:id</span><span class="w"> </span><span class="mi">49</span><span class="w">
 </span><span class="no">:error</span><span class="w"> </span><span class="n">false</span><span class="w">
 </span><span class="no">:safe</span><span class="w"> </span><span class="n">true</span><span class="w">
 </span><span class="no">:flags</span><span class="w">
 </span><span class="p">{</span><span class="no">:nsfw</span><span class="w"> </span><span class="n">false</span><span class="w">
  </span><span class="no">:religious</span><span class="w"> </span><span class="n">false</span><span class="w">
  </span><span class="no">:political</span><span class="w"> </span><span class="n">false</span><span class="w">
  </span><span class="no">:racist</span><span class="w"> </span><span class="n">false</span><span class="w">
  </span><span class="no">:sexist</span><span class="w"> </span><span class="n">false</span><span class="w">
  </span><span class="no">:explicit</span><span class="w"> </span><span class="n">false</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы лучше понять структуру ответа, исследуем его в инспекторе:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.inspector</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">insp</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">insp/inspect-tree</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Из данных видно, что шутка состоит из двух частей: <code class="language-plaintext highlighter-rouge">setup</code> и <code class="language-plaintext highlighter-rouge">delivery</code> (термины можно перевести как “заход” и “разрешение”). Такая структура полезна, когда разрешение показывают не сразу, а после паузы или под тегом спойлера. Так у читателя будет шанс придумать свой вариант. В нашем случае мы просто объединим обе фразы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">joke</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">setup</span><span class="w">
                </span><span class="n">delivery</span><span class="p">]}</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s %s"</span><span class="w"> </span><span class="n">setup</span><span class="w"> </span><span class="n">delivery</span><span class="p">)))</span><span class="w">

</span><span class="s">".NET developers are picky when it comes to food. They only like chicken NuGet."</span><span class="w">
</span></code></pre></div></div>

<p>Если передать необязательный параметр <code class="language-plaintext highlighter-rouge">contains</code>, получим шутку на заданную тему. Например, если это чат о языке Python, будем шутить про JavaScript:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">request</span><span class="w">
  </span><span class="p">{</span><span class="no">:url</span><span class="w"> </span><span class="s">"https://v2.jokeapi.dev/joke/Programming"</span><span class="w">
   </span><span class="no">:method</span><span class="w"> </span><span class="no">:get</span><span class="w">
   </span><span class="no">:query-params</span><span class="w"> </span><span class="p">{</span><span class="no">:contains</span><span class="w"> </span><span class="s">"javascript"</span><span class="p">}</span><span class="w">
   </span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="p">})</span><span class="w">

</span><span class="n">...</span><span class="w">

</span><span class="s">"Why was the JavaScript developer sad?
Because they didn't Node how to Express themself!"</span><span class="w">
</span></code></pre></div></div>

<p>Итак, мы написали фрагменты кода под каждый шаг. Составим функцию, которая принимает язык, про который нужно шутить, и возвращает текст шутки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-joke</span><span class="w"> </span><span class="p">[</span><span class="n">lang</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w">
        </span><span class="p">{</span><span class="no">:url</span><span class="w"> </span><span class="s">"https://v2.jokeapi.dev/joke/Programming"</span><span class="w">
         </span><span class="no">:method</span><span class="w"> </span><span class="no">:get</span><span class="w">
         </span><span class="no">:query-params</span><span class="w"> </span><span class="p">{</span><span class="no">:contains</span><span class="w"> </span><span class="n">lang</span><span class="p">}</span><span class="w">
         </span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="p">}</span><span class="w">

        </span><span class="n">response</span><span class="w">
        </span><span class="p">(</span><span class="nf">client/request</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">

        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">body</span><span class="p">]}</span><span class="w">
        </span><span class="n">response</span><span class="w">

        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">setup</span><span class="w"> </span><span class="n">delivery</span><span class="p">]}</span><span class="w">
        </span><span class="n">body</span><span class="p">]</span><span class="w">

    </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s %s"</span><span class="w"> </span><span class="n">setup</span><span class="w"> </span><span class="n">delivery</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>В действии:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">get-joke</span><span class="w"> </span><span class="s">"python"</span><span class="p">)</span><span class="w">
</span><span class="s">"Why did the Python programmer not respond to the foreign mails he got?
Because his interpreter was busy collecting garbage."</span><span class="w">

</span><span class="p">(</span><span class="nf">get-joke</span><span class="w"> </span><span class="s">"javascript"</span><span class="p">)</span><span class="w">
</span><span class="s">"How did you make your friend rage?
I implemented a greek question mark in his JavaScript code."</span><span class="w">
</span></code></pre></div></div>

<p>На этом этапе еще рано завершать REPL: данные, что мы получили с сервера, пригодятся в тестах. Сохраним их json-файл. Для этого выполним:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="s">"joke-ok.json"</span><span class="w">
      </span><span class="p">(</span><span class="nf">cheshire.core/generate-string</span><span class="w">
       </span><span class="n">data</span><span class="w"> </span><span class="p">{</span><span class="no">:pretty</span><span class="w"> </span><span class="n">true</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; or</span><span class="w">

</span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.java.io</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">io</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">cheshire.core/generate-stream</span><span class="w">
  </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">io/writer</span><span class="w"> </span><span class="s">"joke-ok.json"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="no">:pretty</span><span class="w"> </span><span class="n">true</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание на параметр <code class="language-plaintext highlighter-rouge">:pretty</code>. С ним JSON будет красиво оформлен, то есть записан с отступами и переносами, а не в одну строку.</p>

<p>Важно знать, как ведет себя сторонний сервис в случае ошибки. Если пошутить о Clojure, получим неприятный результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">get-joke</span><span class="w"> </span><span class="s">"clojure"</span><span class="p">)</span><span class="w">
</span><span class="s">"null null"</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы понять, почему так получилось, исследуем ответ сервера:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:url</span><span class="w"> </span><span class="s">"https://v2.jokeapi.dev/joke/Programming"</span><span class="w">
       </span><span class="no">:method</span><span class="w"> </span><span class="no">:get</span><span class="w">
       </span><span class="no">:query-params</span><span class="w"> </span><span class="p">{</span><span class="no">:contains</span><span class="w"> </span><span class="s">"clojure"</span><span class="p">}</span><span class="w">
       </span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="p">}</span><span class="w">
      </span><span class="p">(</span><span class="nf">client/request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="no">:body</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Данные:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:error</span><span class="w"> </span><span class="n">true</span><span class="w">
 </span><span class="no">:internalError</span><span class="w"> </span><span class="n">false</span><span class="w">
 </span><span class="no">:code</span><span class="w"> </span><span class="mi">106</span><span class="w">
 </span><span class="no">:message</span><span class="w"> </span><span class="s">"No matching joke found"</span><span class="w">
 </span><span class="no">:causedBy</span><span class="w"> </span><span class="p">[</span><span class="s">"No jokes were found that match your provided filter(s)."</span><span class="p">]</span><span class="w">
 </span><span class="no">:additionalInfo</span><span class="w">
 </span><span class="s">"Error while finalizing joke filtering: No jokes were found that match your provided filter(s)."</span><span class="w">
 </span><span class="no">:timestamp</span><span class="w"> </span><span class="mi">1651054623055</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Сервер не нашел подходящих шуток и вернул словарь с полем <code class="language-plaintext highlighter-rouge">{:error true}</code>. Перепишите функцию так, чтобы в случае ошибки мы получили <code class="language-plaintext highlighter-rouge">nil</code>, а не строку с <code class="language-plaintext highlighter-rouge">null</code>.</p>

<p>Негативный ответ тоже пригодится в тестах. Запишите его в файл с понятным именем:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">cheshire.core/generate-stream</span><span class="w">
  </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">io/writer</span><span class="w"> </span><span class="s">"joke-err.json"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="no">:pretty</span><span class="w"> </span><span class="n">true</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Итак, разведка выполнена. Мы убедились, что сервис отвечает на запросы. Мы получили данные для тестов. Стало ясно, как ведет себя сервис в случае ошибки. Во время экспериментов появились наброски кода, из которых легко составить конечную версию.</p>

<p>Важно, что эти наброски опираются на реальные данные, а не документацию или систему классов. И то и другое может устареть и не давать реальной картины — что именно передается по сети. В случае с REPL подобной ошибки быть не может.</p>

<p>Только теперь, с багажом опыта и данных, можно садиться за промышленный код. Мы уже проделали основную работу, и остальная часть не потребует усилий. Все это благодаря REPL, который выполнил роль черновика, отладчика и поля экспериментов.</p>

<h2 id="свой-repl">Свой REPL</h2>

<p>Чтобы лучше понять устройство REPL, напишем свою реализацию. Подготовьте минимальный проект с файлом <code class="language-plaintext highlighter-rouge">project.clj</code> или <code class="language-plaintext highlighter-rouge">deps.edn</code>. В файл <code class="language-plaintext highlighter-rouge">src/my_repl.clj</code> поместите следующий код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">my-repl</span><span class="w">
  </span><span class="p">(</span><span class="no">:gen-class</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-main</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">repl</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Форма <code class="language-plaintext highlighter-rouge">(:gen-class)</code> в теле <code class="language-plaintext highlighter-rouge">ns</code> означает, что при компиляции пространства получится одноименный класс. Это же пространство должно быть указано главным в файле <code class="language-plaintext highlighter-rouge">project.clj</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:main</span><span class="w"> </span><span class="n">my-repl</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">-main</code> — точка входа в будущий класс — запускает функцию <code class="language-plaintext highlighter-rouge">repl</code>, которую предстоит написать. Вот ее черновик:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">repl</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">input</span><span class="w"> </span><span class="p">(</span><span class="nb">read-line</span><span class="p">)</span><span class="w">
          </span><span class="n">expr</span><span class="w"> </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w">
          </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="n">expr</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Это бесконечный цикл, где на каждом шаге происходит следующее:</p>

<p><strong>Чтение (Read)</strong></p>

<p>Функция <code class="language-plaintext highlighter-rouge">read-line</code> читает строку из стандартного канала ввода (stdin). Если канал пуст, система ожидает ввода с клавиатуры. Пользователь набирает текст в терминале и жмет Enter. В переменной <code class="language-plaintext highlighter-rouge">input</code> окажется строка.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">read-string</code> читает объект Clojure из строки. Числа, строки и другие примитивы выражаются сами в себя. Например, из строки “1” получим единицу. Символы остаются невычисленными: строка <code class="language-plaintext highlighter-rouge">"(foo bar)"</code> вернет список с символами <code class="language-plaintext highlighter-rouge">foo</code> и <code class="language-plaintext highlighter-rouge">bar</code>. В переменной <code class="language-plaintext highlighter-rouge">expr</code> окажется объект Clojure: символ, строка, число или их коллекция.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="s">"(foo [1 false {:foo BAZ}])"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; (foo [1 false {:foo BAZ}])</span><span class="w">
</span></code></pre></div></div>

<p><strong>Вычисление (Eval)</strong></p>

<p>Функция <code class="language-plaintext highlighter-rouge">eval</code> принимает выражение и вычисляет его. В отличии от других языков, в Clojure <code class="language-plaintext highlighter-rouge">eval</code> ожидает не строку, а форму, то есть примитив (число, символ, кейворд) или коллекцию. Примитивы вычисляются сами в себя:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="mi">1</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="no">:foo</span><span class="p">)</span><span class="w">
</span><span class="no">:foo</span><span class="w">
</span></code></pre></div></div>
<p>Символы вычисляются в переменные текущего пространства. Например, символ <code class="language-plaintext highlighter-rouge">+</code>
связан с функцией <code class="language-plaintext highlighter-rouge">clojure.core/+</code>, и его вычисление вернет объект функции:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="ss">'+</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">function</span><span class="p">[</span><span class="n">clojure.core/+</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>В вычислении можно сослаться на любую переменную, в том числе созданную вами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">some-text</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">some-text</span><span class="w"> </span><span class="s">" World!"</span><span class="p">))</span><span class="w">
</span><span class="s">"Hello World!"</span><span class="w">
</span></code></pre></div></div>

<p>Вариант посложнее со словарем и <code class="language-plaintext highlighter-rouge">update-in</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="p">{</span><span class="no">:b</span><span class="w"> </span><span class="mi">0</span><span class="p">}})</span><span class="w">
</span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="p">]</span><span class="w"> </span><span class="nb">inc</span><span class="p">))</span><span class="w">
</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="p">{</span><span class="no">:b</span><span class="w"> </span><span class="mi">1</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Если переменной, на которую ссылается символ, нет, получим исключение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="ss">'dunno</span><span class="p">)</span><span class="w">
</span><span class="n">Syntax</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">compiling</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="n">Unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nb">resolve</span><span class="w"> </span><span class="nb">symbol</span><span class="err">:</span><span class="w"> </span><span class="n">dunno</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">context</span><span class="w">
</span></code></pre></div></div>

<p><strong>Печать (Print)</strong></p>

<p>Следующий шаг — печать. Результат <code class="language-plaintext highlighter-rouge">eval</code> выводится на экран обычной функцией <code class="language-plaintext highlighter-rouge">println</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>Повтор (Loop)</strong></p>

<p>Оператор <code class="language-plaintext highlighter-rouge">loop</code> переносит нас к первому шагу — чтению с клавиатуры — и все повторяется.</p>

<p>Хоть это и крайне сырая версия REPL, она работает. Скомпилируйте проект командой <code class="language-plaintext highlighter-rouge">lein uberjar</code> и запустите jar-файл:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="w"> </span><span class="n">-jar</span><span class="w"> </span><span class="n">target/uberjar/repl-chapter-0.1.0-SNAPSHOT-standalone.jar</span><span class="w">
</span></code></pre></div></div>

<p>Введите несколько выражений на Clojure, отделяя клавишей Enter. После каждого появится результат вычисления. Приведем фрагмент сеанса:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="p">{</span><span class="no">:one</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="no">:two</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:one</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:two</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'clojure.core/add</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">add</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="mi">9</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">])</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="s">"1 2 3"</span><span class="w"> </span><span class="o">#</span><span class="s">"\s"</span><span class="p">)</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Мы поработали со словарями, определили функцию и вызвали ее, затем подключили модуль. Даже в таком примитивном REPL доступны все возможности языка.</p>

<h3 id="улучшения">Улучшения</h3>

<p>Предлагаем читателю доработать наш самописный REPL — это будет отличная практика.</p>

<h4 id="выход-из-цикла">Выход из цикла</h4>

<p>На текущий момент нельзя завершить REPL без нажатия <code class="language-plaintext highlighter-rouge">Ctrl+C</code>, что неудобно. Сделайте так, чтобы какое-то выражение означало остановку. Например, если пользователь ввел кейворд <code class="language-plaintext highlighter-rouge">:repl/exit</code>, REPL завершается. Проверка может выглядеть так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">input</span><span class="w"> </span><span class="p">(</span><span class="nb">read-line</span><span class="p">)</span><span class="w">
      </span><span class="n">expr</span><span class="w"> </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="n">input</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="no">:repl/exit</span><span class="p">)</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>При вводе <code class="language-plaintext highlighter-rouge">:repl/exit</code> оператор <code class="language-plaintext highlighter-rouge">loop</code> не сработает, и REPL выйдет из цикла.</p>

<h4 id="перехват-исключений">Перехват исключений</h4>

<p>Сейчас, если выражение содержит ошибку, программа завершится аварийно. Исключение — не повод завершать эксперимент: просто напечатаем его и продолжим. Оберните каждый шаг цикла в <code class="language-plaintext highlighter-rouge">try/catch</code> с классом <code class="language-plaintext highlighter-rouge">Throwable</code>, чтобы поймать любое исключение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">repl</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">result</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nf">try</span><span class="w">
            </span><span class="p">[(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">read-line</span><span class="p">)</span><span class="w">
                 </span><span class="p">(</span><span class="nf">read-string</span><span class="p">)</span><span class="w">
                 </span><span class="p">(</span><span class="nb">eval</span><span class="p">))</span><span class="w">
             </span><span class="n">nil</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
              </span><span class="p">[</span><span class="n">nil</span><span class="w"> </span><span class="n">e</span><span class="p">]))]</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*out*</span><span class="w"> </span><span class="n">*err*</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">)))</span><span class="w">
        </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">result</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Скомпилируйте проект заново и запустите. На этот раз программа не “вывалится”, а покажет сообщение и пригласит к дальнейшему вводу:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="mi">1</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="n">Divide</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">zero</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание: форма <code class="language-plaintext highlighter-rouge">recur</code> не может быть внутри <code class="language-plaintext highlighter-rouge">try/catch</code>, поэтому идем на уловку. Выражение <code class="language-plaintext highlighter-rouge">try</code> возвращает пару, где первый элемент — результат, если не было ошибок, а второй — <code class="language-plaintext highlighter-rouge">nil</code> или ошибка, если таковая случилась. Прием с парой мы рассмотрели в первой книге в главе об исключениях.</p>

<p>В зависимости от того, что мы получили — результат или ошибку, — выводим результат в <code class="language-plaintext highlighter-rouge">stdout</code> или <code class="language-plaintext highlighter-rouge">stderr</code> при помощи связывания <code class="language-plaintext highlighter-rouge">binding</code>. В данном примере мы только печатаем текст исключения. Больше деталей можно получить функцией <code class="language-plaintext highlighter-rouge">print-stack-trace</code> из модуля <code class="language-plaintext highlighter-rouge">clojure.stacktrace</code>.</p>

<p>Еще одно замечание касается строки <code class="language-plaintext highlighter-rouge">(if e ...)</code>. Мы проверяем именно исключение, а не результат, потому что результат вполне может быть <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<h4 id="обработчик-исключения">Обработчик исключения</h4>

<p>Чтобы сделать REPL более гибким, поместим обработку исключений в отдельную функцию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">exception-handler</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*out*</span><span class="w"> </span><span class="n">*err*</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>С ней логика <code class="language-plaintext highlighter-rouge">loop/recur</code> станет чище:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">...</span><span class="w">
   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">e</span><span class="w">
     </span><span class="p">(</span><span class="nf">exception-handler</span><span class="w"> </span><span class="n">e</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Пусть функция <code class="language-plaintext highlighter-rouge">repl</code> принимает параметр, чтобы задать свой обработчик исключения. Если он не задан, сработает функция по умолчанию, которую объявили выше. Для ясности переименуем ее в <code class="language-plaintext highlighter-rouge">default-exception-handler</code>. Далее перепишем <code class="language-plaintext highlighter-rouge">repl</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">repl</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">exception-handler</span><span class="p">]}]]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">ex-handler</span><span class="w">
        </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">exception-handler</span><span class="w">
            </span><span class="n">default-exception-handler</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">(</span><span class="nf">...</span><span class="w">
        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">e</span><span class="w">
          </span><span class="p">(</span><span class="nf">ex-handler</span><span class="w"> </span><span class="n">e</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>До того как мы вступим в цикл, переменной <code class="language-plaintext highlighter-rouge">ex-handler</code> назначен обработчик — переданный или заданный по умолчанию. Эта оптимизация нужна , чтобы не вычислять обработчик на каждом шаге.</p>

<p>Запустите <code class="language-plaintext highlighter-rouge">repl</code> с обработчиком, который печатает тип исключения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-main</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">repl</span><span class="w"> </span><span class="p">{</span><span class="no">:exception-handler</span><span class="w">
         </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="n">e</span><span class="p">)))}))</span><span class="w">
</span></code></pre></div></div>

<p>Результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="n">java.lang.ArithmeticException</span><span class="w">
</span></code></pre></div></div>

<h4 id="красивая-печать">Красивая печать</h4>

<p>Функция <code class="language-plaintext highlighter-rouge">println</code> выводит данные в одну строку, что не подходит для вложенных коллекций. Чтобы вывод был удобен, нужны переносы строк и отступы. Воспользуйтесь функцией <code class="language-plaintext highlighter-rouge">pprint</code> из модуля <code class="language-plaintext highlighter-rouge">clojure.pprint</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">my-repl</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.pprint</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">pprint</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">repl</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">pprint/pprint</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Опробуем красивую печать в действии. Понадобится большая коллекция, например словарь переменных среды:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pprint/pprint</span><span class="w">
  </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)))</span><span class="w">

</span><span class="p">{</span><span class="s">"LEIN_VERSION"</span><span class="w"> </span><span class="s">"2.9.5"</span><span class="n">,</span><span class="w">
 </span><span class="s">"HOME"</span><span class="w"> </span><span class="s">"/Users/ivan"</span><span class="n">,</span><span class="w">
 </span><span class="s">"LC_TERMINAL_VERSION"</span><span class="w"> </span><span class="s">"3.3.12"</span><span class="n">,</span><span class="w">
 </span><span class="s">"USER"</span><span class="w"> </span><span class="s">"ivan"</span><span class="w">
 </span><span class="n">...</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Данные будут напечатаны построчно, что гораздо удобней для чтения. Обратите внимание, что красивая печать работает только для типов Clojure, поэтому мы приводим результат <code class="language-plaintext highlighter-rouge">(System/getenv)</code> к словарю функцией <code class="language-plaintext highlighter-rouge">into</code>. Без этого получим экземпляр класса <code class="language-plaintext highlighter-rouge">UnmodifiableMap</code>, на который красивая печать не действует.</p>

<p>В первой книге мы упоминали, что на <code class="language-plaintext highlighter-rouge">pprint</code> влияют глобальные динамические переменные <code class="language-plaintext highlighter-rouge">*print-length*</code> и <code class="language-plaintext highlighter-rouge">*print-level*</code> — максимальные длина и глубина коллекции. Пусть наш REPL позволит изменить эти значения. Если они заданы, цикл запускается в форме <code class="language-plaintext highlighter-rouge">binding</code> с переопределением длины и глубины. Минимальные правки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">repl</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">print-level</span><span class="w">
                       </span><span class="n">print-length</span><span class="p">]}]]</span><span class="w">
  </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*print-level*</span><span class="w">
            </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">print-level</span><span class="w"> </span><span class="n">*print-level*</span><span class="p">)</span><span class="w">
            </span><span class="n">*print-length*</span><span class="w">
            </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">print-length</span><span class="w"> </span><span class="n">*print-length*</span><span class="p">)]</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-main</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">repl</span><span class="w"> </span><span class="p">{</span><span class="no">:print-length</span><span class="w"> </span><span class="mi">3</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Запустив новый REPL, введите коллекцию длиннее трех элементов. При печати вы увидите ее усеченную версию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">...</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<h4 id="приглашение">Приглашение</h4>

<p>Стандартный REPL показывает приглашение вида <code class="language-plaintext highlighter-rouge">user=&gt;</code>. Это удобно по двум причинам. Во-первых, ясно, в каком пространстве мы находимся сейчас — в процессе работы его часто переключают. Во-вторых, стрелка подсказывает, что от нас ожидают ввод.</p>

<p>Добавьте приглашение перед вводом с клавиатуры (вызовом <code class="language-plaintext highlighter-rouge">read-line</code>). Для начала ограничимся статичной строкой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="s">"repl=&gt; "</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">flush</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Вызов <code class="language-plaintext highlighter-rouge">(flush)</code> необходим, чтобы отправить текст в терминал, не дожидаясь наполнения буфера. С приглашением REPL выглядит живее:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">repl=&gt;</span><span class="w"> </span><span class="no">:hello/repl</span><span class="w">
</span><span class="no">:hello/repl</span><span class="w">

</span><span class="n">repl=&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="s">"test"</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="nb">test</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Логично, чтобы за приглашение отвечала функция <code class="language-plaintext highlighter-rouge">get-prompt</code>, которая принимает текущее пространство:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-prompt</span><span class="w"> </span><span class="p">[</span><span class="n">this-ns</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s=&gt; "</span><span class="w"> </span><span class="p">(</span><span class="nb">ns-name</span><span class="w"> </span><span class="n">this-ns</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">repl</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*ns*</span><span class="w"> </span><span class="n">*ns*</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="p">(</span><span class="nf">get-prompt</span><span class="w"> </span><span class="n">*ns*</span><span class="p">))</span><span class="w">
      </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>При смене пространства в REPL меняется и приглашение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clojure.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">in-ns</span><span class="w"> </span><span class="ss">'repl-test</span><span class="p">)</span><span class="w">

</span><span class="n">repl-test=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.core/refer-clojure</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">repl-test=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание на форму <code class="language-plaintext highlighter-rouge">(binding [*ns* *ns*] ...)</code> перед <code class="language-plaintext highlighter-rouge">loop</code>. Без нее не получится сменить пространство: функция <code class="language-plaintext highlighter-rouge">in-ns</code> меняет переменную <code class="language-plaintext highlighter-rouge">*ns*</code> формой <code class="language-plaintext highlighter-rouge">(set! *ns* ...)</code>, что невозможно вне макроса <code class="language-plaintext highlighter-rouge">binding</code>.</p>

<p>Доработайте REPL так, чтобы можно было задать свой обработчик приглашения. Напишите обработчик, который выводит текущее время или длительность сеанса:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">18</span><span class="no">:12=&gt;</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="mi">18</span><span class="no">:14=&gt;</span><span class="w"> </span><span class="n">...</span><span class="w">

</span><span class="mi">00</span><span class="no">:00:05=&gt;</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="mi">00</span><span class="no">:03:34=&gt;</span><span class="w"> </span><span class="n">...</span><span class="w">
</span></code></pre></div></div>

<h4 id="переменная-результата">Переменная результата</h4>

<p>Еще одна полезная доработка — хранить последний результат в переменной, чтобы позже ссылаться на него. Назовем переменную <code class="language-plaintext highlighter-rouge">-r</code> (result).</p>

<p>Исправим REPL: поместим цикл в форму <code class="language-plaintext highlighter-rouge">with-local-vars</code>. Макрос задает локальные переменные, которые напоминают атомы. Чтобы изменить переменную, вызывают <code class="language-plaintext highlighter-rouge">var-set</code>. Значение получают функцией <code class="language-plaintext highlighter-rouge">var-get</code> или оператором <code class="language-plaintext highlighter-rouge">@</code> <code class="language-plaintext highlighter-rouge">(deref)</code>. Новая версия REPL:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">repl</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">with-local-vars</span><span class="w"> </span><span class="p">[</span><span class="n">-r</span><span class="w"> </span><span class="n">nil</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">input</span><span class="w"> </span><span class="p">(</span><span class="nb">read-line</span><span class="p">)</span><span class="w">
            </span><span class="n">expr</span><span class="w"> </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w">
            </span><span class="n">result</span><span class="w">
            </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">expr</span><span class="w">
              </span><span class="n">-r</span><span class="w"> </span><span class="p">(</span><span class="nb">var-get</span><span class="w"> </span><span class="n">-r</span><span class="p">)</span><span class="w">
              </span><span class="p">(</span><span class="nb">eval</span><span class="w">
               </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="o">~</span><span class="ss">'-r</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">var-get</span><span class="w"> </span><span class="n">-r</span><span class="p">)]</span><span class="w">
                  </span><span class="o">~</span><span class="n">expr</span><span class="p">)))]</span><span class="w">
        </span><span class="p">(</span><span class="nb">var-set</span><span class="w"> </span><span class="n">-r</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">recur</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание на то, как вычисляется форма <code class="language-plaintext highlighter-rouge">expr</code>. С помощью оператора <code class="language-plaintext highlighter-rouge">case</code> мы проверяем: если поступил символ <code class="language-plaintext highlighter-rouge">-r</code>, вернем значение переменной <code class="language-plaintext highlighter-rouge">-r</code>. Ввод <code class="language-plaintext highlighter-rouge">-r</code> считается особенным, потому что вычисляется без <code class="language-plaintext highlighter-rouge">eval</code>.</p>

<p>Чтобы сослаться на <code class="language-plaintext highlighter-rouge">-r</code> в выражении, например <code class="language-plaintext highlighter-rouge">(+ -r 3)</code>, идут на трюк. Форма <code class="language-plaintext highlighter-rouge">expr</code> погружается в макрос <code class="language-plaintext highlighter-rouge">let</code>, где символ <code class="language-plaintext highlighter-rouge">-r</code> связан со значением <code class="language-plaintext highlighter-rouge">-r</code>. Причина этих махинаций в том, что <code class="language-plaintext highlighter-rouge">eval</code> не учитывает локальные переменные, и без <code class="language-plaintext highlighter-rouge">let</code> мы получим ошибку, что символ <code class="language-plaintext highlighter-rouge">-r</code> неизвестен. Эту проблему мы подробно изучим в разделе про отладку, а пока что ограничимся минимально рабочим вариантом.</p>

<p>Запустите REPL и проверьте, что в <code class="language-plaintext highlighter-rouge">-r</code> остается результат, при этом на него можно сослаться в выражении:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">6</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">-r</span><span class="w">
</span><span class="mi">6</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">-r</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">18</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">-r</span><span class="w">
</span><span class="mi">18</span><span class="w">
</span></code></pre></div></div>

<p>Доработайте REPL так, чтобы, кроме результата, он хранил последнее исключение в переменной <code class="language-plaintext highlighter-rouge">-e</code>. Например:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="c1">;; ... Stacktrace ...</span><span class="w">

</span><span class="n">-e</span><span class="w">
</span><span class="c1">;; Execution error (ArithmeticException)...</span><span class="w">
</span><span class="c1">;; Divide by zero</span><span class="w">
</span></code></pre></div></div>

<p>Для этого добавьте в макрос <code class="language-plaintext highlighter-rouge">with-local-vars</code> привязку <code class="language-plaintext highlighter-rouge">[... -e nil]</code>. При помощи <code class="language-plaintext highlighter-rouge">try/catch</code> перехватывайте ошибку. Если что-то поймано, запишите исключение в <code class="language-plaintext highlighter-rouge">-e</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">with-local-vars</span><span class="w"> </span><span class="p">[</span><span class="n">-r</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="n">-e</span><span class="w"> </span><span class="n">nil</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="n">...</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">(</span><span class="nb">var-set</span><span class="w"> </span><span class="n">-e</span><span class="w"> </span><span class="n">e</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<h4 id="многострочный-ввод">Многострочный ввод</h4>

<p>До сих пор мы вводили выражения под одной строке. Теперь мы хотим задать функцию с переносом после сигнатуры:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Если нажать ввод после <code class="language-plaintext highlighter-rouge">b]</code>, произойдет следующее. Клавиша Enter завершит прием символов, и в переменной окажется строка <code class="language-plaintext highlighter-rouge">"(defn add [a b]"</code>. Функция <code class="language-plaintext highlighter-rouge">read-string</code> не сможет ее разобрать и бросит исключение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="s">"(defn add [a b]"</span><span class="p">)</span><span class="w">
</span><span class="n">Execution</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="n">EOF</span><span class="w"> </span><span class="n">while</span><span class="w"> </span><span class="n">reading</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы исправить эту неприятность, перед вызовом <code class="language-plaintext highlighter-rouge">read-line</code> следует убедиться, что форма завершена. Для этого проверим строку на баланс скобок: на каждую открывающую приходится закрывающая того же типа (круглая, квадратная, фигурная). Если в строке незакрытые скобки, мы запрашиваем еще одну строку и продолжаем учет скобок. Как только все скобки закрыты, накопленные строки вычисляются как одно выражение.</p>

<p>Чтобы выделить многострочный ввод визуально, каждая следующая строка предваряется отступом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
</span><span class="nb">..</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)]</span><span class="w">
</span><span class="n">....</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Длина отступа (число точек) равна уровню формы — числу вложенных скобок, умноженному на два.</p>

<p>Для учета скобок подойдет <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">стек</a> — структура данных, которая работает по принципу FILO (First In Last Out, первым пришел — последним ушел). В стек добавляют и извлекают из него элементы. Ограничение в том, что извлечь их можно только в обратном порядке. Например, если добавить в стек символы <code class="language-plaintext highlighter-rouge">(</code>, <code class="language-plaintext highlighter-rouge">[</code>, <code class="language-plaintext highlighter-rouge">{</code>, то при извлечении получим <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">[</code>, <code class="language-plaintext highlighter-rouge">(</code>.</p>

<p>При анализе строки мы перебираем ее символы. Открывающие скобки попадают в стек. Как только мы встретили закрывающую скобку, происходит следующее:</p>

<ul>
  <li>убираем с вершины стека последнюю скобку;</li>
  <li>убеждаемся, что она парная к найденной. Если это не так, бросаем исключение.</li>
</ul>

<p>Например, если в стеке содержатся элементы <code class="language-plaintext highlighter-rouge">(</code>, <code class="language-plaintext highlighter-rouge">[</code>, <code class="language-plaintext highlighter-rouge">{</code> и мы встретили закрывающую фигурную скобку, все в порядке: она относится к элементу на вершине <code class="language-plaintext highlighter-rouge">{</code>. Если же попалась квадратная закрывающая, это говорит об ошибке в синтаксисе.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; ok
"(..[..{..}......"
          ^
;; error
"(..[..{..]......"
</code></pre></div></div>

<p>Для начала опишем стек. Это функция, которая порождает функцию, замкнутую на атоме. Внутренняя функция принимает различные команды. Оператор <code class="language-plaintext highlighter-rouge">case</code> определяет их логику. У функции два тела: команды без аргументов и с одним аргументом.</p>

<p>Стек поддерживает команды:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">:count</code>, узнать число элементов;</li>
  <li><code class="language-plaintext highlighter-rouge">:empty?</code>, проверка на пустоту;</li>
  <li><code class="language-plaintext highlighter-rouge">:pop</code>, извлечь элемент с вершины;</li>
  <li><code class="language-plaintext highlighter-rouge">:push</code>, добавить элемент.</li>
</ul>

<p>От других команд <code class="language-plaintext highlighter-rouge">:push</code> отличается тем, что принимает аргумент — значение, которое добавляют. Поэтому <code class="language-plaintext highlighter-rouge">:push</code> описан во втором теле.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-stack</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">-stack</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="n">stack</span><span class="w">
      </span><span class="p">([</span><span class="n">cmd</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">cmd</span><span class="w">
         </span><span class="no">:count</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="o">@</span><span class="n">-stack</span><span class="p">)</span><span class="w">
         </span><span class="no">:empty?</span><span class="w"> </span><span class="p">(</span><span class="nb">zero?</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="o">@</span><span class="n">-stack</span><span class="p">))</span><span class="w">
         </span><span class="no">:pop</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">item</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="o">@</span><span class="n">-stack</span><span class="p">)]</span><span class="w">
                </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">-stack</span><span class="w"> </span><span class="nb">rest</span><span class="p">)</span><span class="w">
                </span><span class="n">item</span><span class="p">)))</span><span class="w">
      </span><span class="p">([</span><span class="n">cmd</span><span class="w"> </span><span class="n">arg</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">cmd</span><span class="w">
         </span><span class="no">:push</span><span class="w">
         </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">-stack</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">arg</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Изначально атом хранит <code class="language-plaintext highlighter-rouge">nil</code>, при добавлении элемента к которому получится список. Функция <code class="language-plaintext highlighter-rouge">conj</code> добавляет элемент в начало списка. Вот почему вершину стека получают функцией <code class="language-plaintext highlighter-rouge">first</code>, а усекают функцией <code class="language-plaintext highlighter-rouge">rest</code>.</p>

<p>Стек в действии:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="nf">make-stack</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">s</span><span class="w"> </span><span class="no">:count</span><span class="p">)</span><span class="w">  </span><span class="c1">;; 0</span><span class="w">
</span><span class="p">(</span><span class="nf">s</span><span class="w"> </span><span class="no">:empty?</span><span class="p">)</span><span class="w"> </span><span class="c1">;; true</span><span class="w">
</span><span class="p">(</span><span class="nf">s</span><span class="w"> </span><span class="no">:push</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">;; (1)</span><span class="w">
</span><span class="p">(</span><span class="nf">s</span><span class="w"> </span><span class="no">:push</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">;; (2 1)</span><span class="w">
</span><span class="p">(</span><span class="nf">s</span><span class="w"> </span><span class="no">:push</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">;; (3 2 1)</span><span class="w">
</span><span class="p">(</span><span class="nf">s</span><span class="w"> </span><span class="no">:count</span><span class="p">)</span><span class="w">  </span><span class="c1">;; 3</span><span class="w">
</span><span class="p">(</span><span class="nf">s</span><span class="w"> </span><span class="no">:pop</span><span class="p">)</span><span class="w">    </span><span class="c1">;; 3</span><span class="w">
</span><span class="p">(</span><span class="nf">s</span><span class="w"> </span><span class="no">:pop</span><span class="p">)</span><span class="w">    </span><span class="c1">;; 2</span><span class="w">
</span><span class="p">(</span><span class="nf">s</span><span class="w"> </span><span class="no">:pop</span><span class="p">)</span><span class="w">    </span><span class="c1">;; 1</span><span class="w">
</span><span class="p">(</span><span class="nf">s</span><span class="w"> </span><span class="no">:empty?</span><span class="p">)</span><span class="w"> </span><span class="c1">;; true</span><span class="w">
</span></code></pre></div></div>

<p>Наш стек является изменяемым объектом. Более “кложурный” способ был бы в том, чтобы сделать его неизменяемым: каждая операция возвращала бы его копию подобно функциям <code class="language-plaintext highlighter-rouge">assoc</code> или <code class="language-plaintext highlighter-rouge">update</code>. Но для разнообразия мы решили поработать с изменяемым стеком. Читатели, близко знакомые с Java, могут взять на вооружение класс <code class="language-plaintext highlighter-rouge">java.util.Stack</code> со схожими возможностями.</p>

<p>Анализ строки сводится к тому, чтобы сперва наполнить стек открывающими скобками, а затем опустошить закрывающими. Если в итоге стек пуст, строка сбалансирована.</p>

<p>Напишем функцию <code class="language-plaintext highlighter-rouge">multi-input</code>, которая читает ввод с клавиатуры до тех пор, пока выражение не сбалансировано. Считанные строки объединяются в одну пробелом. При вводе очередной строки покажем уровень вложенности отступами. Вот алгоритм функции:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">multi-input</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">stack</span><span class="w"> </span><span class="p">(</span><span class="nf">make-stack</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="s">""</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="p">(</span><span class="nf">make-indent</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">flush</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">line</span><span class="w"> </span><span class="p">(</span><span class="nb">read-line</span><span class="p">)</span><span class="w">
            </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="n">line</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">consume-line</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="n">line</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">stack</span><span class="w"> </span><span class="no">:empty?</span><span class="p">)</span><span class="w">
          </span><span class="n">result</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">result</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Код довольно короткий и опирается на две служебные функции. Первая <code class="language-plaintext highlighter-rouge">make-indent</code> строит отступ из точек; его длина равна двойному числу элементов в стеке:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-indent</span><span class="w"> </span><span class="p">[</span><span class="n">stack</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">str/join</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">stack</span><span class="w"> </span><span class="no">:count</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="s">"."</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Вторая функция <code class="language-plaintext highlighter-rouge">consume-line</code> сложнее. Она принимает стек и строку, проходит по символам и корректирует стек. Для корректировки нужен словарь парных скобок. Его ключи и значения — символы типа <code class="language-plaintext highlighter-rouge">Char</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">brace-pairs</span><span class="w">
  </span><span class="p">{</span><span class="sc">\(</span><span class="w"> </span><span class="sc">\)</span><span class="w">
   </span><span class="sc">\[</span><span class="w"> </span><span class="sc">\]</span><span class="w">
   </span><span class="sc">\{</span><span class="w"> </span><span class="sc">\}</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Понадобится зеркальная копия этого словаря, чтобы по закрывающей скобке найти открывающую:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">brace-oppos</span><span class="w">
  </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="n">brace-pairs</span><span class="p">]</span><span class="w">
             </span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="n">k</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>Код насыщения стека:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">consume-line</span><span class="w"> </span><span class="p">[</span><span class="n">stack</span><span class="w"> </span><span class="n">line</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="nb">char</span><span class="w"> </span><span class="n">line</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">cond</span><span class="w">
      </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">brace-pairs</span><span class="w"> </span><span class="nb">char</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">stack</span><span class="w"> </span><span class="no">:push</span><span class="w"> </span><span class="nb">char</span><span class="p">)</span><span class="w">

      </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">brace-oppos</span><span class="w"> </span><span class="nb">char</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">char-oppos</span><span class="w">
            </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">brace-oppos</span><span class="w"> </span><span class="nb">char</span><span class="p">)</span><span class="w">
            </span><span class="n">char-lead</span><span class="w">
            </span><span class="p">(</span><span class="nf">stack</span><span class="w"> </span><span class="no">:pop</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">char-lead</span><span class="w"> </span><span class="n">char-oppos</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">throw</span><span class="w">
           </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w">
                </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Unbalanced expression: %s...%s"</span><span class="w">
                        </span><span class="n">char-lead</span><span class="w"> </span><span class="nb">char</span><span class="p">))))))))</span><span class="w">
</span></code></pre></div></div>

<p>Логика следующая: если символ — открывающая скобка (входит в <code class="language-plaintext highlighter-rouge">brace-pairs</code>), добавить ее в стек. Если закрывающая (входит в <code class="language-plaintext highlighter-rouge">brace-oppos</code>), найти по ней открывающую (переменная <code class="language-plaintext highlighter-rouge">char-oppos</code>). Далее получить элемент с вершины стека методом <code class="language-plaintext highlighter-rouge">:pop</code> (переменная <code class="language-plaintext highlighter-rouge">char-lead</code>). Если переменные не равны, бросить исключение.</p>

<p>Вернитесь в функцию <code class="language-plaintext highlighter-rouge">repl</code> и замените <code class="language-plaintext highlighter-rouge">(read-line)</code> на <code class="language-plaintext highlighter-rouge">(multi-input)</code>. Скомпилируйте проект и опробуйте REPL в действии. Вот что получилось у автора:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">..3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="mi">18</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="nb">..</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'clojure.core/add</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">....</span><span class="no">:bar</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">....</span><span class="no">:baz</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">....</span><span class="p">}</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="nb">..</span><span class="p">[</span><span class="no">:test</span><span class="w"> </span><span class="no">:hello</span><span class="p">]</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">..3</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="nb">..</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:bar</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:baz</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">:foo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:test</span><span class="w"> </span><span class="p">{</span><span class="no">:hello</span><span class="w"> </span><span class="mi">3</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Очевидно, ввести длинное выражение гораздо легче. Проверьте код с неверными скобками. Исключение подскажет, какие именно скобки были причиной:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span><span class="n">java.lang.Exception</span><span class="err">:</span><span class="w"> </span><span class="n">Unbalanced</span><span class="w"> </span><span class="n">expression</span><span class="err">:</span><span class="w"> </span><span class="p">(</span><span class="nf">...</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что попытка извлечь элемент из пустого стека тоже считается ошибкой. Это может случится при работе со строкой <code class="language-plaintext highlighter-rouge">"(+ 1 2 3))"</code>. Предпоследняя скобка очистит стек, но последняя обратится к пустому стеку, что говорит о нарушении. Без доработок мы получим сообщение с <code class="language-plaintext highlighter-rouge">null</code>, что понятно:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Unbalanced</span><span class="w"> </span><span class="n">expression</span><span class="err">:</span><span class="w"> </span><span class="n">null...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Перепишем команду <code class="language-plaintext highlighter-rouge">:pop</code> так, чтобы учесть пустой стек:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:pop</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="o">@</span><span class="n">-stack</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="s">"Stack is empty!"</span><span class="p">))</span><span class="w">
       </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">item</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="o">@</span><span class="n">-stack</span><span class="p">)]</span><span class="w">
         </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">-stack</span><span class="w"> </span><span class="nb">rest</span><span class="p">)</span><span class="w">
         </span><span class="n">item</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Если ввести код с лишними скобками на конце, получим исключение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.lang.Exception: Stack is empty!
</code></pre></div></div>

<p>Подсчет скобок может дать осечку для внутренних строк. Предположим, мы объявили строку со смайликом внутри:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="s">"Hello Clojure :-)"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Наш анализатор не знает, что нужно игнорировать скобки внутри строки. В результате получим ошибку о пустом стеке. Доработайте <code class="language-plaintext highlighter-rouge">(multi-input)</code> так, чтобы при переходе через двойную кавычку включался режим “в строке”, когда скобки не добавляются в стек. При выходе из строки флаг отключается.</p>

<h3 id="repl-в-repl">REPL в REPL</h3>

<p>Еще одна интересная задача: что случится, если вызвать в сеансе функцию <code class="language-plaintext highlighter-rouge">(repl)</code>? Другими словами, запустить REPL в REPL?</p>

<p>Ответ — вы запустите новый сеанс, а прежний повиснет в ожидании. В новом REPL доступны изменения, что вы сделали раньше. При завершении вы вернетесь в прежний REPL и продолжите работу. Покажем это на примере (напомним, что ввод <code class="language-plaintext highlighter-rouge">:repl/exit</code> завершает REPL):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'my-repl/x</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">repl</span><span class="p">)</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="mi">9</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="no">:repl/exit</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"still in the REPL"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; still in the REPL</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p>Видно, что переменная <code class="language-plaintext highlighter-rouge">x</code>, объявленная во внешнем сеансе, доступна во внутреннем. Ввод <code class="language-plaintext highlighter-rouge">:repl/exit</code> возвращает нас в прежний REPL, не завершая программу. Усложним сценарий, поместив <code class="language-plaintext highlighter-rouge">(repl)</code> в середину вычислений:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">repl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="mi">7</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="no">:repl/exit</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre></div></div>

<p>В этом примере форма <code class="language-plaintext highlighter-rouge">let</code> повиснет до тех пор, пока не завершится внутренний REPL. Пребывая в нем, мы ввели выражение <code class="language-plaintext highlighter-rouge">(+ 3 4)</code>. После выхода получим результат всей формы — тройку.</p>

<p>Вложенные сеансы встречаются редко, но они не должны вводить вас в ступор. С точки зрения программы это то же самое, что бесконечный цикл в бесконечном цикле: при завершении внутреннего вы вернетесь во внешний. Вложенность сеансов ограничена только ресурсами компьютера.</p>

<h3 id="доступ-к-локальным-переменным">Доступ к локальным переменным</h3>

<p>Должно быть, вы догадались: вложенный REPL удобен в качестве отладчика. Он прерывает код и поэтому работает как точка останова. С его помощью мы бы остановились на сложном участке кода, чтобы исследовать переменные.</p>

<p>Недостаток нашего REPL в том, у него нет доступа локальным переменным. Предопложим, мы запустили REPL внутри формы <code class="language-plaintext highlighter-rouge">let</code> или функции с аргументами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">repl</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">

</span><span class="c1">;; or</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">repl</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">add</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Логично ожидать, что при вводе <code class="language-plaintext highlighter-rouge">a</code> или <code class="language-plaintext highlighter-rouge">b</code> во вложенном REPL получим единицу и двойку. Однако это не так — сославшись на них, увидим исключение о том, что символ неизвестен:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w">
</span><span class="n">java.lang.RuntimeException</span><span class="err">:</span><span class="w"> </span><span class="n">Unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nb">resolve</span><span class="w"> </span><span class="nb">symbol</span><span class="err">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">context</span><span class="w">
</span></code></pre></div></div>

<p>Как мы упоминали выше, функция <code class="language-plaintext highlighter-rouge">eval</code> учитывает только глобальные переменные, то есть заданные при помощи <code class="language-plaintext highlighter-rouge">def</code>. Предупреждая ваше огорчение, скажем — все-таки можно сделать так, чтобы локальные переменные были доступны. В середине главы мы напишем свой отладчик, где эта проблема решена. Пока что предложим читателю подумать над этим вопросом.</p>

<p>На этом мы закончим работу над собственным REPL и двинемся дальше.</p>

<h2 id="полезные-функции-repl">Полезные функции REPL</h2>

<p>Модуль <code class="language-plaintext highlighter-rouge">clojure.repl</code> содержит функции и макросы для интерактивного сеанса. В основном они служат для информации о переменных и окружении. Подключите модуль командой <code class="language-plaintext highlighter-rouge">use</code>, чтобы пользоваться им без псевдонима:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="ss">'clojure.repl</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">apropos</code> ищет определение по строке или регулярному выражению. Для слова <code class="language-plaintext highlighter-rouge">"update"</code> найдутся следующие кандидаты:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">apropos</span><span class="w"> </span><span class="s">"update"</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">clojure.core/update</span><span class="w">
 </span><span class="n">clojure.core/update-in</span><span class="w">
 </span><span class="n">clojure.core/update-keys</span><span class="w">
 </span><span class="n">clojure.core/update-proxy</span><span class="w">
 </span><span class="n">clojure.core/update-vals</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Если объявить переменную со словом <code class="language-plaintext highlighter-rouge">"update"</code> в названии:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">updated-result</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>и выполнить поиск еще раз, в выборке окажется символ <code class="language-plaintext highlighter-rouge">user/updated-result</code>.</p>

<p>Макрос <code class="language-plaintext highlighter-rouge">dir</code> выводит все публичные переменные пространства:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">dir</span><span class="w"> </span><span class="n">clojure.string</span><span class="p">)</span><span class="w">

</span><span class="n">blank?</span><span class="w">
</span><span class="n">capitalize</span><span class="w">
</span><span class="n">ends-with?</span><span class="w">
</span><span class="n">escape</span><span class="w">
</span><span class="n">...</span><span class="w">
</span></code></pre></div></div>

<p>Знакомый макрос <code class="language-plaintext highlighter-rouge">(doc ...)</code> печатает справку определения. Если это функция или макрос, вы увидите возможные параметры вызова.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w">
  </span><span class="s">"Add two numbers."</span><span class="w">
  </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>=&gt; (doc add)
-------------------------
user/add
([a b])
  Add two numbers.
</code></pre></div></div>

<p>Если возникло исключение, REPL напечатает только его класс и сообщение, чтобы не тратить место на стек-трейс. Функция <code class="language-plaintext highlighter-rouge">pst</code> (сокращение от <strong>p</strong>rint <strong>s</strong>tack <strong>t</strong>race) принудительно выводит полное исключение.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="n">Execution</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">(</span><span class="nf">ArithmeticException</span><span class="p">)</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">user/eval175</span><span class="w"> </span><span class="p">(</span><span class="nf">REPL</span><span class="no">:1</span><span class="p">)</span><span class="nb">.</span><span class="w">
</span><span class="n">Divide</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">zero</span><span class="w">
</span></code></pre></div></div>
<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">pst</span><span class="p">)</span><span class="w">
</span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">Divide</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">zero</span><span class="w">
	</span><span class="n">clojure.lang.Numbers.divide</span><span class="w"> </span><span class="p">(</span><span class="nf">Numbers.java</span><span class="no">:190</span><span class="p">)</span><span class="w">
	</span><span class="n">clojure.lang.Numbers.divide</span><span class="w"> </span><span class="p">(</span><span class="nf">Numbers.java</span><span class="no">:3911</span><span class="p">)</span><span class="w">
	</span><span class="n">user/eval175</span><span class="w"> </span><span class="p">(</span><span class="nf">NO_SOURCE_FILE</span><span class="no">:1</span><span class="p">)</span><span class="w">
    </span><span class="n">...</span><span class="w">
	</span><span class="n">clojure.main/repl/fn--9215</span><span class="w"> </span><span class="p">(</span><span class="nf">main.clj</span><span class="no">:458</span><span class="p">)</span><span class="w">
	</span><span class="n">clojure.main/repl</span><span class="w"> </span><span class="p">(</span><span class="nf">main.clj</span><span class="no">:458</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Эти и другие возможности пригодятся вам в долгих сеансах REPL. Ознакомьтесь с ними <a href="https://clojuredocs.org/clojure.repl">в документации</a> к модулю clojure.repl.</p>

<h2>Все части</h2>

<ul>
  <li><a href="/clj-repl-part-1/">Первая часть</a></li>
  <li><a href="/clj-repl-part-2/">Вторая часть</a></li>
  <li><a href="/clj-repl-part-3/">Третья часть</a></li>
  <li><a href="/clj-repl-part-4/">Четвертая часть</a></li>
</ul>

<!--
Local Variables:
ispell-local-dictionary: "ru"
fill-column: 99999
truncate-lines: nil
End:
-->

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-repl-part-1/">
    <input required name="captcha" type="hidden" value="9 &#215; 2">

    <div class="block">
        <span class="comment-form-label"><small>9 &#215; 2 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
