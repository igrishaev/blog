<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Конфигурация</title>
  <meta name="description" content="    Содержание">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-book-config/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Конфигурация</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2019-07-14T00:00:00+00:00">
        Jul 14, 2019
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/config/" rel="tag">config</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<h2>

    Содержание

</h2>

<ul id="toc-item-clj-book-config">
  <li><a href="#постановка-проблемы" id="toc-item-clj-book-config-постановка-проблемы">Постановка проблемы</a></li>
  <li><a href="#семантика" id="toc-item-clj-book-config-семантика">Семантика</a></li>
  <li><a href="#цикл-конфигурации" id="toc-item-clj-book-config-цикл-конфигурации">Цикл конфигурации</a></li>
  <li><a href="#ошибки-конфигурации" id="toc-item-clj-book-config-ошибки-конфигурации">Ошибки конфигурации</a></li>
  <li><a href="#практика" id="toc-item-clj-book-config-практика">Практика</a>    <ul>
      <li><a href="#анализ-результата" id="toc-item-clj-book-config-анализ-результата">Анализ результата</a></li>
    </ul>
  </li>
  <li><a href="#подробнее-о-переменных-среды" id="toc-item-clj-book-config-подробнее-о-переменных-среды">Подробнее о переменных среды</a>    <ul>
      <li><a href="#локальные-и-глобальные-переменные" id="toc-item-clj-book-config-локальные-и-глобальные-переменные">Локальные и глобальные переменные</a></li>
      <li><a href="#переменные-как-конфигурация" id="toc-item-clj-book-config-переменные-как-конфигурация">Переменные как конфигурация</a></li>
      <li><a href="#env-файлы" id="toc-item-clj-book-config-env-файлы">Env-файлы</a></li>
    </ul>
  </li>
  <li><a href="#переменные-среды-в-clojure" id="toc-item-clj-book-config-переменные-среды-в-clojure">Переменные среды в Clojure</a>    <ul>
      <li><a href="#проблема-лишних-ключей" id="toc-item-clj-book-config-проблема-лишних-ключей">Проблема лишних ключей</a></li>
      <li><a href="#загрузчик-среды" id="toc-item-clj-book-config-загрузчик-среды">Загрузчик среды</a></li>
      <li><a href="#вывод-структуры" id="toc-item-clj-book-config-вывод-структуры">Вывод структуры</a></li>
    </ul>
  </li>
  <li><a href="#простой-менеджер-конфигурации" id="toc-item-clj-book-config-простой-менеджер-конфигурации">Простой менеджер конфигурации</a></li>
  <li><a href="#чтение-среды-из-конфигурации" id="toc-item-clj-book-config-чтение-среды-из-конфигурации">Чтение среды из конфигурации</a></li>
  <li><a href="#короткий-обзор-форматов" id="toc-item-clj-book-config-короткий-обзор-форматов">Короткий обзор форматов</a>    <ul>
      <li><a href="#json" id="toc-item-clj-book-config-json">JSON</a></li>
      <li><a href="#yaml" id="toc-item-clj-book-config-yaml">YAML</a></li>
      <li><a href="#edn" id="toc-item-clj-book-config-edn">EDN</a></li>
    </ul>
  </li>
  <li><a href="#промышленные-решения" id="toc-item-clj-book-config-промышленные-решения">Промышленные решения</a>    <ul>
      <li><a href="#cprop" id="toc-item-clj-book-config-cprop">Cprop</a></li>
      <li><a href="#aero" id="toc-item-clj-book-config-aero">Aero</a></li>
      <li><a href="#yummy" id="toc-item-clj-book-config-yummy">Yummy</a></li>
    </ul>
  </li>
  <li><a href="#заключение" id="toc-item-clj-book-config-заключение">Заключение</a></li>
</ul>

<p>В этой главе мы рассмотрим, как сделать Clojure-проект удобным в плане
настроек. Мы разберем основные приемы конфигурирования: форматы файлов,
переменные среды, несколько библиотек, достоинства и недостатки различных
подходов.</p>

<p class="draft-warn">Внимание! Вы читаете черновик к книге <a href="/clojure-in-prod/">“Clojure на производстве”</a>. Для
книги я переписывал его много раз, но в блоге осталась старая версия. Здесь она
для истории, а вам я рекомендую купить книжку.</p>

<!-- more -->

<h2 id="постановка-проблемы">Постановка проблемы</h2>

<p>Когда мы читаем документацию к библиотекам Clojure, иногда встречаем подобные
выражения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">server</span><span class="w">
  </span><span class="p">(</span><span class="nf">jetty/run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">mysql-db</span><span class="w">
  </span><span class="p">{</span><span class="no">:dbtype</span><span class="w">   </span><span class="s">"mysql"</span><span class="w">
   </span><span class="no">:dbname</span><span class="w">   </span><span class="s">"book"</span><span class="w">
   </span><span class="no">:user</span><span class="w">     </span><span class="s">"ivan"</span><span class="w">
   </span><span class="no">:password</span><span class="w"> </span><span class="s">"****"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Это веб-сервер на 8080 порту и параметры подключения к базе. Примеры полезны
тем, что их можно скопировать в REPL, выполнить и оценить результат. Например,
открыть браузер со страницей веб-приложения или сделать запрос к базе данных.</p>

<p>На практике эти выражения дорабатывают так, чтобы в них не было конкретных цифр
и строк. С точки зрения проекта плохо то, что в выражении веб-сервера явно
записан порт. Такая запись подходит для документации и примеров, но не для
боевого проекта.</p>

<p>Порт 8080, ровно как и другие комбинации нулей и восьмерок, пользуется
популярностью у разработчиков. Велика вероятность, что порт будет занят другим
веб-сервером. Это возможно, когда вы запускаете не отдельный сервис, а их связку
на время разработки или прогона тестов.</p>

<p>Код, написанный разработчиком, обычно проходит несколько стадий. Их набор и
структура отличаются в зависимости от фирмы, но в целом это разработка,
автоматическое и ручное тестирование (юнит-тесты и QA), пре-прод и боевой режим.</p>

<p>На каждой стадии приложение запускают бок о бок с другими
проектами. Предположение о том, что порт 8080 свободен в любой момент на каждой
машине, звучит как утопия. На жаргоне разработчиков это называется “хардкод”
(hardcode), что соответствует идиоме “прибито гвоздями”.</p>

<p>Когда приложение опирается на “прибитые” значения, это вносит проблемы в его
жизненный цикл. Например, вы не сможете одновременно разрабатывать и тестировать
приложение. Или два тестовых сервера подключаются к одной базе данных и вы не
понимаете, почему данные меняются спонтанно.</p>

<p>Ошибка в том, что мы неправильно распределяем ответственность. Приложение не
должно решать, на каком порту запускать веб-сервер. Информация об этом должна
прийти извне. В простейшем случае это текстовый файл. Приложение читает из него
порт и запускает сервер именно так, как это нужно в конкретной машине.</p>

<p>В более сложных сценариях этот файл составляется не человеком, а специальной
программой — менеджером конфигураций. Эти менеджеры хранят информацию о
топологии сети, адреса машин, типы баз данных и параметры подключения к ним. По
запросу они выдают файл с верными параметрами для определенной машины или
сегмента сети.</p>

<p>Процесс, когда мы сообщаем приложению параметры работы, а оно принимает эти
параметры, называется конфигурацией. Это очень интересный и важный
процесс. Когда он построен удачно, проект не испытывает трудностей на разных
стадиях производства.</p>

<h2 id="семантика">Семантика</h2>

<p>Конечная цель конфигурации в том, чтобы управлять программой, не меняя ее
код. Это становится очевидным с ростом кодовой базы и инфраструктуры
фирмы. Когда у вас скрипт на Perl или Python, нет ничего зазорного в том, чтобы
открыть его и поменять константу. На некоторых предприятиях такие скрипты
работают годами.</p>

<p>Но чем совершенней инфраструктура фирмы, тем больше в ней
ограничений. Сегодняшние практики нацелены на то, чтобы свести на нет спонтанные
изменения в проекте. Например, невозможно сделать <code class="language-plaintext highlighter-rouge">git push</code> напрямую в мастер;
нельзя сделать <code class="language-plaintext highlighter-rouge">merge</code>, пока pull request не одобрят минимум два члена команды;
приложение не загрузится на сервер, пока не пройдут тесты.</p>

<p>Это приводит к тому, что даже экстренное изменение в коде потребует около часа,
чтобы попасть на боевой сервер. Изменение в конфигурации несоизмеримо дешевле,
чем выпуск новой версии продукта. Из этого следует правило: если можно вынести
что-то в конфигурацию, лучше сделать это сейчас.</p>

<p>В крупных фирмах практикуют то, что называют <code class="language-plaintext highlighter-rouge">feature flag</code>. Это логическое
поле, которое включает целый пласт логики в приложении. Например, новый
интерфейс, систему обработки заявок, улучшенный чат. Обновления такого масштаба
долго тестируют внутри фирмы, но всегда остается риск, что в боевом режиме
что-то пойдет не так. В этом случае достаточно изменить в конфигурации одно поле
с истины на ложь и перезапустить сервер. Это удобно не только в техническом
плане, но экономит время ваших коллег и сохранит репутацию фирмы.</p>

<h2 id="цикл-конфигурации">Цикл конфигурации</h2>

<p>Во время запуска каждое приложение следует определенному регламенту. Это может
быть подготовка ресурсов, файлов, обмен данными по сети. В момент подготовки
приложение решает, сможет ли оно продолжить работу.</p>

<p>Работа с конфигурацией занимает одну из первых позицией в регламенте. Это
логично, поскольку чем лучше спроектировано приложение, тем больше его частей
опирается на конфигурацию. При этом обработка конфигурации это не монолитная
задача, а набор шагов. Перечислим наиболее важные из них.</p>

<p>На первом этапе программа читает конфигурацию извне. Чаще всего это текстовый
файл или переменные среды. Чтобы хранить данные в тексте, уже придуманы
специальные форматы: JSON, EDN, YAML. Приложение несет на борту модуль, чтобы
получить их этих файлов структуру данных. Мы подробно рассмотрим плюсы и минусы
каждого формата ниже.</p>

<p>Переменные среды это часть операционной системы. Можно представить их как
глобальный словарь в памяти текущего сеанса. Каждое приложение наследует этот
словарь в момент запуска. Языки и фреймворки предлагают функции, чтобы считать
переменные в стандартные строки и словари.</p>

<p>Файлы и переменные среды дополняют друг друга в различных комбинациях. Например,
приложение читает данные из файла, но путь к нему извлекает из переменной
среды. Или в файле конфигурации опущены критические данные: пароли и
API-ключи. Так поступают, чтобы посторонняя программа не смогла считать
их. Приложение читает основные параметры из файла, а секретные ключи из
переменных среды.</p>

<p>Продвинутые системы конфигурации поддерживают систему тегов. Например, в файле
перед значением переменной ставят тег: <code class="language-plaintext highlighter-rouge">:password #env DB_PASSWORD</code>. Это значит,
что в поле <code class="language-plaintext highlighter-rouge">password</code> следует поместить не строку <code class="language-plaintext highlighter-rouge">DB_PASSWORD</code>, а значение
одноименной переменной. Мы подробно рассмотрим систему тегов в следующем
разделе.</p>

<p>Первый этап завершается тем, что вы получили структуру данных. Неважно, был ли
это файл, переменные среды или данные из сети. У вас в памяти структура, чаще
всего словарь, и приложение переходит ко второму этапу — выводу типов.</p>

<p>Не всегда данные, которые вы прочитали извне, соответствуют типам вашего языка
или платформы. Форматы JSON или YAML выделяют базовые типы: строки, числа,
булево, null и коллекции: словарь и список. Легко заметить, что среди них нет
типа даты. В то же время даты часто встречаются в конфигурации, чтобы
регулировать промо-акции или события, связанные с праздниками (черная пятница,
Новый год, и тд).</p>

<p>В структурированных файлах даты задают либо ISO-строкой, либо числом секунд c 1
января 1970 года (эпоха UNIX). Специальный код должен пробежать про структуре
данных и перевести такие поля в тип даты, принятый в языке.</p>

<p>Вывод типов применяют и для коллекций. Словарей и списков может оказаться
недостаточно для комфортной работы. Например, список допустимых состояний
объекта логично представить множеством, поскольку поиск в множестве в среднем
быстрее, чем в линейной структуре. Поэтому список, полученный из JSON-файла,
заменяют на множество.</p>

<p>Читатель, знакомый с Clojure, заметит, что эти проблемы решены в формате EDN. Он
по умолчанию поддерживает даты и множества. Это не совсем верно: в некоторых
проектах пользуются сторонним типом дат, например, <code class="language-plaintext highlighter-rouge">JodaTime</code>. Это значит, нам
потребуется вывод верного типа из строки или стандартного Date.</p>

<p>В других случаях требуется обернуть скалярное значение в класс. Скажем, чтобы
передать ENUM-значение в запрос, нужно обернуть его в класс <code class="language-plaintext highlighter-rouge">PGObject</code>. Чтобы не
создавать новый объект каждый раз, логично вывести тип на этапе
конфигурации. Поэтому даже EDN-данные нуждаются в выводе типов.</p>

<p>Переменные среды не обладают такой гибкостью, как современные форматы
файлов. Если JSON и аналоги выделяют скаляры, структуры и их комбинации, то
переменные среды представлены только строкой. Для переменных вывод типов не
просто желателен, он необходим. Будет физически невозможно передать строку в
функцию, которая ожидает число.</p>

<p>После вывода типов приступают к валидации данных. В главе про Clojure.spec мы
упоминали, что верный тип еще гарантирует корректное значение. Предположим, мы
считали переменную среды <code class="language-plaintext highlighter-rouge">DB_PORT="8080"</code>. До тех пор, пока это строка, мы не
можем проверить значение на числовой диапазон. Проверка нужна, чтобы в
конфигурации нельзя было указать порт 0, -1 или 80.</p>

<p>Из той же главы мы помним, что иногда значения верны по отдельности, но их
комбинация ошибочна. Например, в конфигурации указан срок действия события. Это
массив из двух элементов, где первый это дата начала, а второй дата конца. На
этапе конфигурирования легко поменять даты местами, и тогда проверка текущей
даты на интервал всегда вернет ложь. Валидация должна проверять и даты по
отдельности, и их комбинацию (первая строго меньше второй).</p>

<p>Без валидации вы рискуете передать в Java-код пустые значения. Вы не заметите
ошибки на уровне Clojure, потому что там nil трактуется как пустая коллекция. Но
в случае с Java приложение выложит длинный трейс <code class="language-plaintext highlighter-rouge">NullPointerException</code>,
расследовать который будет тяжело.</p>

<p>Если валидация прошла успешно, переходят к последней стадии. В этот момент
приложение определяет, где хранить конфигурацию. В зависимости от архитектуры
это может быть глобальная переменная модуля или компонент верхнего уровня. Когда
конфигурация прочитана, другие части системы считывают свои параметры и
запускают сами себя.</p>

<h2 id="ошибки-конфигурации">Ошибки конфигурации</h2>

<p>На каждом из перечисленных этапов может возникнуть ошибка. Не найден файл
конфигурации, забыли прочитать ENV-переменные, ошибка синтаксиса в файле,
неверное значение поля. В таком случае от хорошей системы ожидают двух действий:
сообщения об ошибке и немедленного завершения.</p>

<p>Сообщение должно четко отвечать на вопрос, что пошло не так. К сожалению, иногда
разработчики описывают только положительный путь и забывают об ошибках. При
запуске таких программ мы видим стек-трейс и тратим время, чтобы его
осмыслить. Это грубейшая ошибка.</p>

<p>В главе про исключениях мы рассмотрели хорошую практику. Если логика состоит из
отдельных шагов, будет правильно обернуть каждый шаг в <code class="language-plaintext highlighter-rouge">try/catch</code>. Если блок
вышел с ошибкой, мы выводим понятное сообщение о том, что намеревались сделать и
ключевые параметры исключения: его класс и сообщение.</p>

<p>Если ошибка случилась на этапе проверки или вывода типов, разработчик обязан
объяснить, какое именно поле было тому виной. В главе про Clojure.spec мы
рассмотрели, как улучшить стандартный отчет спеки. Это требует дополнительных
усилий, но окупается со временем.</p>

<p>Сегодня IT-индустрия работает так, что одни сотрудники пишут код, а другие
управляют его запуском. Скорее всего коллега из отдела DevOps даже не знает, что
такое Clojure и не сможет понять отчет спеки. Поэтому он придет к вам с просьбой
улучшить вывод сообщений об ошибке в конфигурации. Лучше сделать это заранее
хотя бы из уважения к коллегам.</p>

<p>Если с конфигурацией что-то не так, программа не должна работать дальше в
надежде, что все обойдется. Технически возможна ситуация, когда один из
параметров не задан (nil вместо числа), но программа к нему не обращается. Этого
поведения следует избегать, потому что рано или поздно ошибка всплывет, и ее
будет трудно расследовать.</p>

<p>Когда один из шагов конфигурации не сработал, программа выводит сообщение и
аварийно завершается с кодом, отличным от нуля. Сообщение пишут в канал
<code class="language-plaintext highlighter-rouge">stderr</code>, чтобы подчеркнуть внештатную ситуацию. Современные терминалы
направляют канал ошибок в стандартный вывод, но подсвечивают такие сообщения
красным цветом.</p>

<h2 id="практика">Практика</h2>

<p>Чтобы закрепить все, о чем мы говорили выше, напишем свою подсистему
конфигурации для приложения. Это будет отдельный модуль примерно на 100
строк. Прежде чем садиться за редактор, определимся с основными положениями
будущего кода.</p>

<p>Будем хранить конфигурацию в json-файле. Это не потому, что мы не знаем про
edn. Предположим, что конфигурации других проектов тоже работаю на json-файлах,
и у коллег из DevOps отдела уже написаны скрипты на Python для управления этими
файлами. Проект с новым форматом усложнит коллегам жизнь.</p>

<p>Путь к файлу конфигурации передают в переменной среды <code class="language-plaintext highlighter-rouge">CONFIG_PATH</code>. От
конфигурации мы ожидаем порт веб-сервера, параметры базы данных и диапазон дат
для промо-акции. Текстовые даты должны стать объектами <code class="language-plaintext highlighter-rouge">java.util.Date</code>. Левое
значение интервала строго меньше правого.</p>

<p>Готовый словарь запишем в глобальную переменную <code class="language-plaintext highlighter-rouge">CONFIG</code>. Если на одном из шагов
случилась ошибка, выводим сообщение и завершаем программу.</p>

<p>Начнем со вспомогательной функции <code class="language-plaintext highlighter-rouge">exit</code>. Ее главное тело принимает статус
завершения программы и сообщение, которое увидит пользователь. В альтернативное
тело кроме статуса передают шаблон для функции <code class="language-plaintext highlighter-rouge">format</code> и произвольные параметры
подстановки.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">exit</span><span class="w">

  </span><span class="p">([</span><span class="n">code</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="n">args</span><span class="p">)))</span><span class="w">

  </span><span class="p">([</span><span class="n">code</span><span class="w"> </span><span class="n">message</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">zero?</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="n">*out*</span><span class="w"> </span><span class="n">*err*</span><span class="p">)]</span><span class="w">
     </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*out*</span><span class="w"> </span><span class="n">out</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">message</span><span class="p">)))</span><span class="w">
   </span><span class="p">(</span><span class="nf">System/exit</span><span class="w"> </span><span class="n">code</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>В зависимости от статуса выводим сообщение либо в стандартный поток, либо в
поток ошибок и завершаем программу.</p>

<p>Напишем загрузчик конфигурации. Это последовательность шагов, каждый из которых
принимает результат предыдущего. Логику каждого шага легко понять из имени
функции. Для краткости мы совместили вывод типов и валидацию в одном шаге
<code class="language-plaintext highlighter-rouge">coerce-config</code>. Оба этих действия работают через <code class="language-plaintext highlighter-rouge">clojure.spec</code>, поэтому
технически срабатывают за один вызов <code class="language-plaintext highlighter-rouge">s/conform</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">load-config!</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">get-config-path</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">read-config-file</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">coerce-config</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">set-config!</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Осталось написать логику каждого шага. Функция <code class="language-plaintext highlighter-rouge">get-config-path</code> читает
переменную среды и проверяет, есть ли такой файл на диске. Если все в порядке,
функция вернет путь к файлу. В негативных случаях она вызывает <code class="language-plaintext highlighter-rouge">exit</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="ss">'java.io.File</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-config-path</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">filepath</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"CONFIG_PATH"</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">filepath</span><span class="w"> </span><span class="n">File.</span><span class="w"> </span><span class="n">.exists</span><span class="p">)</span><span class="w">
      </span><span class="n">filepath</span><span class="w">
      </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"Config file does not exist"</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"File path is not set"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Шаг <code class="language-plaintext highlighter-rouge">read-config-file</code> считывает данные из файла по его пути. Для разбора json
воспользуемся библиотекой <code class="language-plaintext highlighter-rouge">cheshire</code>. Поскольку файл конфигурации небольшой, нет
смысла читать из файла поток. Достаточно прочитать содержимое в большую строку и
разобрать ее функций <code class="language-plaintext highlighter-rouge">json/parse-string</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">cheshire.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">json</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">read-config-file</span><span class="w">
  </span><span class="p">[</span><span class="n">filepath</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">filepath</span><span class="w"> </span><span class="nb">slurp</span><span class="w"> </span><span class="p">(</span><span class="nf">json/parse-string</span><span class="w"> </span><span class="n">true</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"Malformed config file: %s"</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Стадия проверки и вывода типов займет больше строк. Это самый важный этап во
всем процессе: нельзя допустить, чтобы приложение начало работу с неверными
параметрами.</p>

<p>Оба действия удобно совместить в спеке. Наша спека для конфигурации одновременно
выводит типы и проверяет значения. В главе про спеку мы рассмотрели продвинутый
способ вывода ошибок на базе собственных словарей. Способ делает сообщения
понятнее для человека, но сложен в поддержке.</p>

<p>Для простоты воспользуемся библиотекой <code class="language-plaintext highlighter-rouge">expound</code>. Ее функция <code class="language-plaintext highlighter-rouge">expound-str</code>
вернет улучшенный вариант стандартного отчета spec. Он не настолько удобен, как
написанные вручную сообщения, но все же лучше, чем <code class="language-plaintext highlighter-rouge">explain</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.spec.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">expound.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">expound</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">coerce-config</span><span class="w">
  </span><span class="p">[</span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::config</span><span class="w"> </span><span class="n">config</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="no">::s/invalid</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">report</span><span class="w"> </span><span class="p">(</span><span class="nf">expound/expound-str</span><span class="w"> </span><span class="no">::config</span><span class="w"> </span><span class="n">config</span><span class="p">)]</span><span class="w">
          </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"Invalid config values: %s %s"</span><span class="w"> </span><span class="sc">\n</span><span class="n">ewline</span><span class="w"> </span><span class="n">report</span><span class="p">))</span><span class="w">
        </span><span class="n">result</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"Wrong config values: %s"</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Логика <code class="language-plaintext highlighter-rouge">coerce-config</code> проста: мы выводим чистые данные из исходных функцией
<code class="language-plaintext highlighter-rouge">s/conform</code>. Ее вызов потенциально несет исключения, поэтому оборачиваем в
<code class="language-plaintext highlighter-rouge">try/catch</code>. Если результат conform был ключом <code class="language-plaintext highlighter-rouge">:invalid</code> из пакета спеки,
формируем отчет об ошибке и выводим пользователю</p>

<p>Не хватает определения спеки. Откроем файл конфигурации и изучим его
структуру. Это json-файл следующего содержания:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"server_port"</span><span class="p">:</span><span class="w"> </span><span class="mi">8080</span><span class="p">,</span><span class="w">
    </span><span class="nl">"db"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"dbtype"</span><span class="p">:</span><span class="w">   </span><span class="s2">"mysql"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"dbname"</span><span class="p">:</span><span class="w">   </span><span class="s2">"book"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"user"</span><span class="p">:</span><span class="w">     </span><span class="s2">"ivan"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"password"</span><span class="p">:</span><span class="w"> </span><span class="s2">"****"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"event"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"2019-07-05T12:00:00"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"2019-07-12T23:59:59"</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Опишем спеку сверху вниз. На верхнем уровне это словарь с ключами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::config</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">::server_port</span><span class="w"> </span><span class="no">::db</span><span class="w"> </span><span class="no">::event</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Порт сервера это комбинация из двух предикатов: число и вхождение в
диапазон. Первичная проверка на число нужна, чтобы во второе выражение не попали
<code class="language-plaintext highlighter-rouge">nil</code> и строка. Это вызовет исключение там, где его не ждали.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::server_port</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w"> </span><span class="n">int?</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="n">x400</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">0</span><span class="n">xffff</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Для подключения к базе данных используем готовую спеку из пакета jdbc:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.java.jdbc.spec</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::db</span><span class="w"> </span><span class="no">::jdbc/db-spec</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Остался диапазон дат. Импортируем функцию для разбора строки в дату. Это пакет
<code class="language-plaintext highlighter-rouge">clojure.instant</code> из стандартной поставки Clojure. Функция <code class="language-plaintext highlighter-rouge">read-instant-date</code>
довольно лояльна к формату строки и читает неполные даты. Обернем ее в
<code class="language-plaintext highlighter-rouge">s/conform</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.instant</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">inst</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">-&gt;date</span><span class="w"> </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">inst/read-instant-date</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запишем проверку диапазона как функцию. Она принимает вектор двух объектов
<code class="language-plaintext highlighter-rouge">java.util.Date</code> и сравнивает их. Даты нельзя сравнивать операторами больше или
меньше. Причина кроется в реализации класса <code class="language-plaintext highlighter-rouge">Date</code> на Java-уровне. Специальная
функция compare принимает два объекта и возвращает -1, 0 и 1, что означает
меньше, равно и больше.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::date-range</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[[</span><span class="n">date1</span><span class="w"> </span><span class="n">date2</span><span class="p">]]</span><span class="w">
    </span><span class="p">(</span><span class="nb">neg?</span><span class="w"> </span><span class="p">(</span><span class="nf">compare</span><span class="w"> </span><span class="n">date1</span><span class="w"> </span><span class="n">date2</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Спека события это комбинация кортежа и проверки диапазона. Спека кортежа
проверяет, что данные это коллекция строго из двух элементов, каждый их которых
преобразуется в дату.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::event</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/tuple</span><span class="w"> </span><span class="n">-&gt;date</span><span class="w"> </span><span class="n">-&gt;date</span><span class="p">)</span><span class="w">
   </span><span class="no">::date-range</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Спека готова, и это значит, что шаг <code class="language-plaintext highlighter-rouge">coerce-config</code> тоже завершен. Уже на этом
этапе можно закомментировать последнюю строку в <code class="language-plaintext highlighter-rouge">load-config!</code> и убедиться, что
на выходе словарь с правильными значениями.</p>

<p>Шаг <code class="language-plaintext highlighter-rouge">set-config!</code> записывает конфигурацию в глобальную переменную. Объявим
будущую конфигурацию под именем <code class="language-plaintext highlighter-rouge">CONFIG</code>. Написание в верхнем регистре,
во-первых, подчеркивает, что это глобальная переменная. Во-вторых, тем самым мы
не затеним ее локальным параметром функции.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">CONFIG</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">set-config!</span><span class="w">
  </span><span class="p">[</span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-var-root</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">CONFIG</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="n">config</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Достаточно вызвать <code class="language-plaintext highlighter-rouge">(load-config!)</code> на старте программы, чтобы в <code class="language-plaintext highlighter-rouge">CONFIG</code>
появилась проверенная конфигурация. Другие подсистемы импортируют <code class="language-plaintext highlighter-rouge">CONFIG</code> в
свои модули и читают нужные им ключи. Вот как выглядит запуск сервера или запрос
к базе данных с учетом конфигурации:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">project.config</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">CONFIG</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">server</span><span class="w">
  </span><span class="p">(</span><span class="nf">jetty/run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:server_port</span><span class="w"> </span><span class="n">CONFIG</span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="p">(</span><span class="no">:db</span><span class="w"> </span><span class="n">CONFIG</span><span class="p">)</span><span class="w"> </span><span class="s">"select * from users"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h3 id="анализ-результата">Анализ результата</h3>

<p>Итак, мы написали загрузчик конфигурации. Он простой и легкий в поддержке. Чтобы
добавить новые поля, достаточно расширить спеку. Хотя это не промышленное
решение, такой загрузчик подойдет для небольших проектов.</p>

<p>Преимущество загрузчика в том, что в любой момент можно считать конфигурацию
заново. Это особенно удобно в сеансе REPL: достаточно изменить json-файл и
вызвать <code class="language-plaintext highlighter-rouge">load-config!</code> повторно.</p>

<p>Один из недостатков нашей реализации в том, что код привязан к функции <code class="language-plaintext highlighter-rouge">exit</code>. В
момент вызова она завершает программу. Это правильный подход на старте
приложения: нет смысла продолжать, если входные параметры неверны. Но при
разработке от этого больше проблем: ошибка в момент загрузки завершит сеанс
REPL. Вам придется запускать проект и подсоединяться к нему заново.</p>

<p>Мы неправильно разделили ответственность. Завершение всей программы это слишком
радикальное действие. Хотелось бы влиять на то, как загрузчик сигнализирует об
ошибке. В идеале загрузка конфигурации и реакция системы на ошибки должны быть
разделены.</p>

<p>Наивный способ исправить ситуацию — вызывать <code class="language-plaintext highlighter-rouge">load-config!</code> внутри макроса,
который переопределяет <code class="language-plaintext highlighter-rouge">exit</code>. Пусть новая функция не вызывает <code class="language-plaintext highlighter-rouge">System/exit</code>, а
просто кидает исключение с тем же сообщением. Вынесем эту логику в отдельную
функцию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">load-config-repl!</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-redefs</span><span class="w">
    </span><span class="p">[</span><span class="n">exit</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="n">msg</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">msg</span><span class="p">)))]</span><span class="w">
    </span><span class="p">(</span><span class="nf">load-config!</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь вызов <code class="language-plaintext highlighter-rouge">load-config-repl!</code> на конфигурации с ошибками просто бросит
исключение, но не завершит сеанс.</p>

<p>Более удачное решение в том, чтобы передать функцию в дополнительные параметры
загрузки. В сторонних библиотеках встречается параметр <code class="language-plaintext highlighter-rouge">:die-fn</code> или
аналогичный. Это функция, которая принимает экземпляр исключения. Тем самым вы
управляете реакцией на ошибку в зависимости от контекста. В боевом запуске die
function завершает программу, в режиме разработки просто пишет сообщение в REPL.</p>

<p>В свободное время доработайте загрузчик так, чтобы он поддерживал параметр
<code class="language-plaintext highlighter-rouge">:die-fn</code>. Продумайте поведение по умолчанию, если он не задан.</p>

<h2 id="подробнее-о-переменных-среды">Подробнее о переменных среды</h2>

<p>Наш загрузчик устроен так, что наиболее значимая информация приходит из
файла. Из переменных среды мы берем только малую часть — путь к этому
файлу. Можно изменить загрузчик так, чтобы он считывал конфигурацию из
переменных и даже не нуждался в файлах.</p>

<p>Прежде чем это сделать, и чтобы лучше понять преимущества этого подхода,
поговорим о переменных среды в отрыве от конкретного языка.</p>

<p>Переменные среды еще называют ENV, “энвы” (от англ. environment, окружающая
среда). Это фундаментальное свойство операционной системы. Представьте
переменные как глобальный словарь, который наполняется во время загрузки. В этом
словаре записаны основные параметры системы. Например, это локаль, список путей,
по которым система ищет исполнительные файлы, домашняя директория текущего
пользователя и многие другие значения.</p>

<p>Чтобы увидеть текущие переменные, выполните в терминале команду env или
printenv. На экране появится список пар вида <code class="language-plaintext highlighter-rouge">ИМЯ=значение</code>. Имена переменных
принято записывать в верхнем регистре, чтобы выделить на фоне других переменных
и подчеркнуть их приоритет. Большинство систем различают регистр, поэтому <code class="language-plaintext highlighter-rouge">foo</code>
и <code class="language-plaintext highlighter-rouge">FOO</code> будут разными переменными. Пробелы и дефисы в имени переменных
недопустимы. Лексемы разделяют подчеркиванием.</p>

<p>Фрагмент вывода <code class="language-plaintext highlighter-rouge">printenv</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">LANG</span><span class="o">=</span>en_US.UTF-8
<span class="nv">PWD</span><span class="o">=</span>/Users/ivan
<span class="nv">SHELL</span><span class="o">=</span>/bin/zsh
<span class="nv">TERM_PROGRAM</span><span class="o">=</span>iTerm.app
<span class="nv">COMMAND_MODE</span><span class="o">=</span>unix2003
</code></pre></div></div>

<p>Каждый новый процесс операционной системы получает копию этого словаря. Процесс
может добавить или удалить переменную, но изменения будут видны только в рамках
этого процесса и его потомков. Если процесс запускает потомка, он наследует
переменные родителя.</p>

<p>Таким образом, первоначальный набор переменных на уровне ОС не изменяется. Все,
что мы можем сделать это установить нужные переменные в одном процессе и
запустить из него дочерние. Чтобы изменить состав переменных на уровне системы,
требуется менять ее конфигурационные файлы.</p>

<h3 id="локальные-и-глобальные-переменные">Локальные и глобальные переменные</h3>

<p>Различают переменные среды и шелла, они же глобальные и локальные переменные. В
них часто путаются начинающие программисты. Откройте терминал и выполните
команду:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">FOO</span><span class="o">=</span>42
</code></pre></div></div>

<p>Тем самым вы задали переменную текущего шелла. Чтобы сослаться на переменную, то
есть получить по имени ее значение, перед ней ставят знак доллара. Выражение
ниже напечатает значение новой переменной:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nv">$FOO</span>
42
</code></pre></div></div>

<p>Если выполнить <code class="language-plaintext highlighter-rouge">printenv</code>, мы не увидим <code class="language-plaintext highlighter-rouge">FOO</code> в списке переменных среды. Это
потому, что выражение <code class="language-plaintext highlighter-rouge">FOO=42</code> устанавливает переменную в текущий шелл, а не
среду. Переменные шелла видны только ему и не наследуются потомками. Проверим
это: из текущего шелла запустим новый и попытаемся напечатать переменную.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sh
<span class="nb">echo</span> <span class="nv">$FOO</span>
</code></pre></div></div>

<p>Результатом будет пустая строка, потому что в процессе-потомке такой переменной
нет. Выполните <code class="language-plaintext highlighter-rouge">exit</code>, чтобы вернуться в родительский шелл.</p>

<p>Выражение <code class="language-plaintext highlighter-rouge">export</code> означает, что переменная становится частью среды
шелла. Установленная таким образом, она видна в списке printenv и доступна
процессам-потомкам:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">FOO</span><span class="o">=</span>42

<span class="nb">printenv</span> | <span class="nb">grep </span>FOO
<span class="nv">FOO</span><span class="o">=</span>42

sh
<span class="nb">echo</span> <span class="nv">$FOO</span>
42
</code></pre></div></div>

<p>Иногда мы хотим запустить процесс с переменной, но так, чтобы она не была видна
другим процессам. В таком случае команда <code class="language-plaintext highlighter-rouge">export</code> не подойдет, потому что об
этой переменной узнают все дочерние процессы. Чтобы сообщить переменную только
одному процессу, его запускают сразу после выражения ИМЯ=значение:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">BAR</span><span class="o">=</span>99 <span class="nb">printenv</span> | <span class="nb">grep </span>BAR
<span class="nv">BAR</span><span class="o">=</span>99
</code></pre></div></div>

<p>Вызов <code class="language-plaintext highlighter-rouge">printenv</code> порождает новый процесс, внутри которого доступна переменная
<code class="language-plaintext highlighter-rouge">BAR</code>. Но если снова напечатать <code class="language-plaintext highlighter-rouge">$BAR</code>, мы получим пустую строку.</p>

<p>Переменные особенно удобны в связке с программами, которые читают из них
настройки. Например, клиент к базе данных PostgreSQL различает около двадцати
переменных: <code class="language-plaintext highlighter-rouge">PGHOST</code>, <code class="language-plaintext highlighter-rouge">PGDATABASE</code>, <code class="language-plaintext highlighter-rouge">PGUSER</code> и многие другие. У переменных среды
приоритет выше, чем у параметров <code class="language-plaintext highlighter-rouge">--host</code>, <code class="language-plaintext highlighter-rouge">--user</code> и аналогов. Это значит, если
в текущем шелле выполнить команды</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PGHOST</span><span class="o">=</span>some.staging.com <span class="nv">PGDATABASE</span><span class="o">=</span>project
</code></pre></div></div>

<p>, то любая утилита из поставки PostgreSQL сработает на заданном сервере, базе и
пользователе. Это удобно, если требуется выполнить серию команд, например дамп
базы, набор запросов и восстановление. Не придется передавать каждой команде
параметры <code class="language-plaintext highlighter-rouge">--host</code> и другие.</p>

<h3 id="переменные-как-конфигурация">Переменные как конфигурация</h3>

<p>Связь между переменными среды и приложением в том, что в общем случае можно
передать конфигурацию переменными. Каждый язык или фреймворк предлагает набор
функций, чтобы считать переменные по отдельности в строки или целиком в
словарь. Разберем преимущества и недостатки этого подхода.</p>

<p>Поскольку окружение хранится в памяти, приложение не обращается к диску во время
чтения переменных. И дело даже не в том, что доступ к памяти быстрее диска
(человек не в силах отличить сотую долю секунды от тысячной). Приложение,
которое не зависит от конкретного файла конфигурации в целом более автономно и
потому удобней в поддержке.</p>

<p>Бывает, во время деплоя на сервер файл конфигурации оказался в другой
директории, и приложение не может его найти. Или, что еще хуже, запускается со
старой версией конфигурации. Такие ситуации замедляют работу команды, оттягивают
на себя полезное время.</p>

<p>В целом считается, что передавать пароли и ключи через переменные безопаснее,
чем в файлах. Причина в том, что файл могут прочитать другие программы, в том
числе шпионское ПО. Или файл конфигурации по ошибке попадет в репозиторий и
останется в его истории. В то же время переменные среды эфемерны. Они живут
только памяти операционной системы. Пользователь физически не может прочитать
переменные процессов, запущенных другим пользователем.</p>

<p>Даже когда конфигурация составлена удачно, не всегда удобно править ее
вручную. Современная индустрия постепенно уходит от файлов в сторону контейнеров
и сервисов. Если раньше мы копировали файлы по FTP или SSH, то сегодня
приложение запускается как множество экземпляров одного образа. Так работают
системы виртуализации Kubernetes и другие.</p>

<p>С точки зрения системы образ это черный ящик. Технически возможно подключиться к
запущенному образу (он называется контейнер). Но во-первых, изменения контейнере
не сохраняются в образ и живут в памяти до завершения работы. Во-вторых,
подключаться к пяти экземплярам приложения и менять что-то вручную утомительно и
непродуктивно. Остается только собрать образ с новым конфигурационным файлом на
борту, загружать его в хранилище и перезапускать сервис, что в целом долго.</p>

<p>Облачные платформы достаточно развиты, чтобы избежать таких сценариев. В панели
администратора для каждого сервиса есть форма с переменными среды, которые
процесс получит при старте. Если приложение читает конфигурацию из среды,
достаточно поменять значение прямо в форме и перезагрузить сервис.</p>

<p>Принцип “конфигурация в среде” встречается в одном из пунктов <a href="https://12factor.net/">The Twelve-Factor
App</a>. Это набор хороших практик при разработке приложений, надежных и
удобных в поддержке. Пункт №3 документа перечисляет достоинства переменных
среды: независимость от файлов, конкретного языка или формата данных, поддержка
на всех платформах.</p>

<p>К недостаткам переменных можно отнести то, что они не типизированы. Переменные
несут только один вид данных — текст. Поэтому разбор и вывод типов остается за
приложением. Важно, чтобы вывод был организован не спонтанно и вручную, а
декларативно.</p>

<p>Так, в проектах на Python часто встречается код:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">db_port</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">[</span><span class="s">"DB_PORT"</span><span class="p">])</span>
</code></pre></div></div>

<p>Это нормально для разового применения, но иногда подобные выражения занимают
несколько экранов. Будет правильно построить словарь, где ключ это имя
переменной, а значение — функция вывода.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">env_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s">"DB_PORT"</span><span class="p">:</span> <span class="nb">int</span><span class="p">}</span>
</code></pre></div></div>

<p>Специальный код обходит эту структуру и наполняет словарь результата. Этот
подход справедлив и для других языков. В случае с Clojure мы пользуемся спекой.</p>

<p>Переменные среды не подразумевают вложенность. Это плоский набор ключей и
значений, что не всегда ложиться на структуру конфигурации. Чем больше
параметров в структуре, тем больше вероятность, что нам захочется сгруппировать
близкие их них по смыслу. Например, вместо того, чтобы перечислять параметры
базы данных с префиксом, логичнее вынести их во вложенный словарь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; so-so</span><span class="w">
</span><span class="p">{</span><span class="no">:db-name</span><span class="w"> </span><span class="s">"book"</span><span class="w">
 </span><span class="no">:db-user</span><span class="w"> </span><span class="s">"ivan"</span><span class="w">
 </span><span class="no">:db-pass</span><span class="w"> </span><span class="s">"****"</span><span class="p">}</span><span class="w">

</span><span class="c1">;; better</span><span class="w">
</span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"book"</span><span class="w">
      </span><span class="no">:user</span><span class="w"> </span><span class="s">"ivan"</span><span class="w">
      </span><span class="no">:pass</span><span class="w"> </span><span class="s">"****"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>В разных системах устоялись свои соглашения, согласно которым обрабатывают
вложенные переменные. В общем порядке это решается специальными
префиксами. Например, одинарное подчеркивание только разделяет лексемы, но не
влияет на структуру. Двойное подчеркивание означает вложенность:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"DB_NAME=book"</span><span class="w">
</span><span class="c1">;; {:db_name "book"}</span><span class="w">

</span><span class="s">"DB__NAME=book"</span><span class="w">
</span><span class="c1">;; {:db {:name "book"}}</span><span class="w">
</span></code></pre></div></div>

<p>Для массивов используют квадратные скобки или запятые. При разборе
строк-массивов остается риск ложного разбиения. Это случается, когда запятая или
скобка относится к слову, а не к синтаксису.</p>

<p>Эти правила и их реализация остаются на совести разработчика. Если форматы json,
yaml и другие задают четкий стандарт о том, как выглядят структуры данных, то
для переменных среды единого стандарта нет. Ситуация ухудшается, когда отдельные
компоненты системы принимают параметры большой вложенности, например список
словарей списков. Переменные среды не способны передать такую структуру.</p>

<p>При разработке становится очевиден другой недостаток переменных среды — на
некоторых системах они доступны только для чтения. Это верно идеологически, но
вынуждает перезагружать сеанс REPL каждый раз, когда требуется новое значение
переменной, что неудобно. В случае с файлом достаточно изменить его и вызвать
функцию загрузки еще раз.</p>

<h3 id="env-файлы">Env-файлы</h3>

<p>Когда переменных среды становится слишком много, их ручной ввод через export
становится утомителен. Поэтому переменные выносят в файл, который по-другому
называют env-конфигурацией.</p>

<p>С технической точки зрения такой файл представляет собой шелл-скрипт. Однако,
чем меньше скриптовых возможностей использует файл, тем лучше. В идеале файл
содержит только пары ИМЯ=значение по одной на каждую строку.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">DB_NAME</span><span class="o">=</span>book
<span class="nv">DB_USER</span><span class="o">=</span>ivan
<span class="nv">DB_PASS</span><span class="o">=</span><span class="k">****</span>
</code></pre></div></div>

<p>Чтобы считать эти данные в шелл, вызывают команду <code class="language-plaintext highlighter-rouge">source &lt;file&gt;</code>. Это одна из
команд <code class="language-plaintext highlighter-rouge">bash</code>, которая выполняет указанный скрипт в текущем сеансе. Cкрипт
добавит переменные в шелл, и вы увидите их после завершения source. Это важное
отличие от команды <code class="language-plaintext highlighter-rouge">bash &lt;file&gt;</code>, которая выполнит скрипт в отдельном шелле.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source </span>ENV
<span class="nb">echo</span> <span class="nv">$DB_NAME</span>
book
</code></pre></div></div>

<p>Но если запустить из текущего шелла приложение, оно не увидит эти
переменные. Вспомним, что выражение <code class="language-plaintext highlighter-rouge">VAR=value</code> задает локальную переменную
шелла, а не среды. Поэтому <code class="language-plaintext highlighter-rouge">DB_NAME</code> и другие не попадут в окружение шелла и не
будут унаследованы приложением. Это легко проверить с помощью <code class="language-plaintext highlighter-rouge">printenv</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source </span>ENV
<span class="nb">printenv</span> | <span class="nb">grep </span>DB
<span class="c"># exit 1</span>
</code></pre></div></div>

<p>Существует два способа решить эту проблему. Первый — открыть файл и расставить
перед каждой парой выражение <code class="language-plaintext highlighter-rouge">export</code>. Тогда source этого файла вынесет
переменные в окружение:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>ENV
<span class="nb">export </span><span class="nv">DB_NAME</span><span class="o">=</span>book
<span class="nb">export </span><span class="nv">DB_USER</span><span class="o">=</span>ivan
<span class="nb">export </span><span class="nv">DB_PASS</span><span class="o">=</span><span class="k">****</span>

<span class="nb">source </span>ENV
<span class="nb">printenv</span> | <span class="nb">grep </span>DB
<span class="nv">DB_NAME</span><span class="o">=</span>book
<span class="nv">DB_USER</span><span class="o">=</span>ivan
<span class="nv">DB_PASS</span><span class="o">=</span><span class="k">****</span>
</code></pre></div></div>

<p>Недостаток этого способа в том, что в env-файле появляется дополнительная
логика. При редактировании файла легко потерять export перед переменной, и
приложение не сможет ее считать.</p>

<p>Другой способ заключается в особом параметре <code class="language-plaintext highlighter-rouge">-a</code> текущего шелла. Когда он
установлен, любая локальная переменная автоматически попадает в окружение. Перед
тем, как читать переменные из файла, этот параметр возводят в истину, а затем
снова в ложь.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span> <span class="nt">-a</span>
<span class="nb">source </span>ENV
<span class="nb">printenv</span> | <span class="nb">grep </span>DB
<span class="c"># prints all the vars</span>
<span class="nb">set</span> +a
</code></pre></div></div>

<p>Выражение <code class="language-plaintext highlighter-rouge">set</code> немного противоречиво: параметр с минусом включает параметр, а с
плюсом — отключает. Это исключение, которое придется запомнить.</p>

<p>Если считать переменную, которая уже была в окружении, она заменит прежнее
значение. За счет этого удобно строить различные конфигурации на базе
файлов-переопределений. Если вам нужны настройки для тестов, не обязательно
дублировать весь файл. Достаточно создать новый файл с отличающимися полями и
выполнить его после исходного.</p>

<p>Пусть тестовые настройки отличаются от стандартных только именем базы. Файл
<code class="language-plaintext highlighter-rouge">ENV</code> несет в себе базовые параметры, а в файл <code class="language-plaintext highlighter-rouge">ENV_TEST</code> поместим новое
значение параметра:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>ENV_TEST
<span class="nv">DB_NAME</span><span class="o">=</span><span class="nb">test

set</span> <span class="nt">-a</span>
<span class="nb">source </span>ENV
<span class="nb">source </span>ENV_TEST
<span class="nb">set</span> +a

<span class="nb">echo</span> <span class="nv">$DB_NAME</span>
<span class="nb">test</span>
</code></pre></div></div>

<p>Читатель заметит, что идея env-файлов противоречива. Сначала мы говорили, что
переменные среды снимают зависимость от файла конфигурации. Но закончили тем,
что создали файл с переменными. Какой в этом смысл, если просто сменился формат
записи?</p>

<p>Разница между json- и env-файлами в том, кто их читает. В первом случае
конфигурацию читает приложение, а во втором — операционная система. Если
json-файл располагается в строго заданной директории, то переменные среды могут
быть прочитаны откуда угодно. Тем самым мы выносим из приложения часть,
ответственную за поиск конфигурации, и оставляем запас для маневра.</p>

<h2 id="переменные-среды-в-clojure">Переменные среды в Clojure</h2>

<p>Переходим к практической части. С учетом всего сказанного рассмотрим, как
работать с env-переменными в Clojure.</p>

<p>Вспомним, что Clojure это гостевая платформа. Это значит, язык не предлагает
возможностей для доступа к системным ресурсам. В библиотеке Clojure нет функции
для чтении переменных среды. Мы получим их из класса <code class="language-plaintext highlighter-rouge">java.lang.System</code>. Это
особый класс Java, который не требуется импортировать. Он доступен в любом
пространстве имен.</p>

<p>Статический метод getenv этого класса возвращает либо значение переменной по ее
имени, либо словарь всех переменных, если вызвать метод без параметров.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; a single variable</span><span class="w">
</span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"HOME"</span><span class="p">)</span><span class="w">
</span><span class="s">"/Users/ivan"</span><span class="w">

</span><span class="c1">;; the whole map</span><span class="w">
</span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="s">"JAVA_ARCH"</span><span class="w"> </span><span class="s">"x86_64"</span><span class="n">,</span><span class="w"> </span><span class="s">"LANG"</span><span class="w"> </span><span class="s">"en_US.UTF-8"</span><span class="p">}</span><span class="w"> </span><span class="c1">;; truncated</span><span class="w">
</span></code></pre></div></div>

<p>Уточним, что метод без параметров возвращает не Clojure-, а Java-коллекцию. Это
неизменяемая версия <code class="language-plaintext highlighter-rouge">java.util.Map</code>. Поэтому переменные невозможно изменить
после запуска виртуальной машины JVM.</p>

<p>Чтобы упростить работу Java-коллекцией, переведем ее в аналогичный тип
Clojure. Заодно преобразуем ключи: сейчас это строки в верхнем регистре и
подчеркиваниями. В мире Clojure пользуются кейвордами для словарей и записью,
известной как <code class="language-plaintext highlighter-rouge">kebab-case</code>: нижний регистр с дефисами.</p>

<p>Напишем функцию для перевода ключа:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-key</span><span class="w">
  </span><span class="p">[</span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="nb">key</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">key</span><span class="w">
      </span><span class="n">str/lower-case</span><span class="w">
      </span><span class="p">(</span><span class="nf">str/replace</span><span class="w"> </span><span class="o">#</span><span class="s">"_"</span><span class="w"> </span><span class="s">"-"</span><span class="p">)</span><span class="w">
      </span><span class="nb">keyword</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>и убедимся в ее работе:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">remap-key</span><span class="w"> </span><span class="s">"DB_PORT"</span><span class="p">)</span><span class="w">
</span><span class="no">:db-port</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">remap-env</code> проходит по Java-коллекции и возвращает ее Clojure-версию с
привычными ключами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-env</span><span class="w">
  </span><span class="p">[</span><span class="n">env</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">acc</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]]</span><span class="w">
     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">key</span><span class="w"> </span><span class="p">(</span><span class="nf">remap-key</span><span class="w"> </span><span class="n">k</span><span class="p">)]</span><span class="w">
       </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="n">v</span><span class="p">)))</span><span class="w">
   </span><span class="p">{}</span><span class="w">
   </span><span class="n">env</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Результат может оказаться довольно большой коллекцией. Современные системы
хранят в памяти несколько десятков переменных. Для экономии места приведем
небольшую часть словаря:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">remap-env</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:home</span><span class="w"> </span><span class="s">"/Users/ivan"</span><span class="w">
 </span><span class="no">:lang</span><span class="w"> </span><span class="s">"en_US.UTF-8"</span><span class="w">
 </span><span class="no">:term</span><span class="w"> </span><span class="s">"xterm-256color"</span><span class="w">
 </span><span class="no">:java-arch</span><span class="w"> </span><span class="s">"x86_64"</span><span class="w">
 </span><span class="no">:term-program</span><span class="w"> </span><span class="s">"iTerm.app"</span><span class="w">
 </span><span class="no">:shell</span><span class="w"> </span><span class="s">"/bin/zsh"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Теперь когда переменные среды это обычный Clojure-словарь, его перемещают по
тому же конвейеру. Это вывод типов и валидация спекой. Поскольку все поля
словаря это строки, придется изменить отдельные части спеки. Например, заменить
числовые поля на вывод чисел из строк. Особо удачной будет спека, которая
работает и с числами для json, и с текстом для переменных среды. Вот как
выглядит умный парсер числа:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="k">cond</span><span class="w">
       </span><span class="p">(</span><span class="nf">int?</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="n">value</span><span class="w">
       </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">try</span><span class="w"> </span><span class="p">(</span><span class="nf">Integer/parseInt</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
              </span><span class="no">::s/invalid</span><span class="p">))</span><span class="w">
       </span><span class="no">:else</span><span class="w"> </span><span class="no">::s/invalid</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>С таким определением мы можем менять источник конфигурации без изменений в
спеке.</p>

<h3 id="проблема-лишних-ключей">Проблема лишних ключей</h3>

<p>Словарь переменных носит существенный недостаток — в нем много посторонних
полей. Приложению не требуется знать домашнюю директорию пользователя и версию
терминала. Эти поля производят шум при выводе конфигурации на печать или в
логи. Если конфигурация не прошла спеку, отчет explain включает эти поля в
отладочную информацию. Их следует убрать.</p>

<p>Лучший способ выбрать подмножество словаря это функция <code class="language-plaintext highlighter-rouge">select-keys</code>. Она
принимает словарь и список ключей. Но как узнать, какие именно ключи нужно
выбрать? Перечислять их вручную долго, и фактически мы дублируем
данные. Центральный объект, который знает о том, какие поля проверять это спека
<code class="language-plaintext highlighter-rouge">::config</code>. С помощью небольшого трюка мы вытащим из нее список ключей.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">s/form</code> принимает ключ спеки и возвращает ее замороженное
определение. Это цепочка cons-ячеек, где каждый элемент это символ, кейворд,
вектор и так далее. Для спеки <code class="language-plaintext highlighter-rouge">::config</code> мы получим список:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">clojure.spec.alpha/keys</span><span class="w">
 </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:book.config/server_port</span><span class="w">
          </span><span class="no">:book.config/db</span><span class="w">
          </span><span class="no">:book.config/event</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>В нашем случае достаточно взять третий элемент формы, это и будет вектор ключей
спеки. Но это наивное решение. У спеки <code class="language-plaintext highlighter-rouge">s/keys</code> может быть до четырех типов
ключей, и мы должны учесть их все.</p>

<p>Отбросим первый элемент формы. В ее остатке нечетные элементы будут типом ключа,
а четные — ключами. Для <code class="language-plaintext highlighter-rouge">-un</code> ключей мы должны отбросить их пространство. Все
вместе дает нам следующую функцию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">spec-&gt;keys</span><span class="w">
  </span><span class="p">[</span><span class="n">spec-keys</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">form</span><span class="w"> </span><span class="p">(</span><span class="nf">s/form</span><span class="w"> </span><span class="n">spec-keys</span><span class="p">)</span><span class="w">
        </span><span class="n">params</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">hash-map</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">form</span><span class="p">))</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">req</span><span class="w"> </span><span class="n">opt</span><span class="w"> </span><span class="n">req-un</span><span class="w"> </span><span class="n">opt-un</span><span class="p">]}</span><span class="w"> </span><span class="n">params</span><span class="w">
        </span><span class="n">-&gt;unqualify</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="nb">keyword</span><span class="w"> </span><span class="nb">name</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">concat</span><span class="w">
     </span><span class="n">req</span><span class="w">
     </span><span class="n">opt</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">-&gt;unqualify</span><span class="w"> </span><span class="n">opt-un</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">-&gt;unqualify</span><span class="w"> </span><span class="n">req-un</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Проверим спеку загрузчика:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">spec-&gt;keys</span><span class="w"> </span><span class="no">::config</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="no">:server_port</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="no">:event</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Перепишем чтение переменных в словарь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">read-env-vars</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">cfg-keys</span><span class="w"> </span><span class="p">(</span><span class="nf">spec-&gt;keys</span><span class="w"> </span><span class="no">::config</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span><span class="w">
        </span><span class="n">remap-env</span><span class="w">
        </span><span class="p">(</span><span class="nb">select-keys</span><span class="w"> </span><span class="n">cfg-keys</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Так вы получите только полезные ключи, то есть те, что описаны в спеке.</p>

<h3 id="загрузчик-среды">Загрузчик среды</h3>

<p>Внесем изменения в загрузчик конфигурации так, чтобы он работал с переменными
среды. Достаточно заменить первые два шага на <code class="language-plaintext highlighter-rouge">read-env-vars</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">load-config!</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">read-env-vars</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">coerce-config</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">set-config!</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>В свободное время доработайте загрузчик так, чтобы источник данных можно было
задать параметром. Например, <code class="language-plaintext highlighter-rouge">:source "/path/to/config.json"</code> означает считать
файл, а <code class="language-plaintext highlighter-rouge">:source :env</code> — переменные среды.</p>

<p>Еще сложнее: как считать оба источника и объединить их? Как сделать объединение
ассиметричным, то есть когда левый словарь замещает существующие поля правого,
но не дополняет новыми?</p>

<h3 id="вывод-структуры">Вывод структуры</h3>

<p>Выше мы упоминали о проблемах со структурой в переменных среды. Редко бывает
так, что конфигурация это плоский словарь. Близкие по семантике параметры
группируют во вложенные словари, например отдельно настройки веб-сервера и базы
данных. Сгруппированные настройки удобней в поддержке.</p>

<p>Улучшим загрузчик: реализуем вложенные словари для переменных
окружения. Договоримся, что двойное подчеркивание означает вложенную
структуру. Поместим в файл <code class="language-plaintext highlighter-rouge">ENV_NEST</code> следующие переменные:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">DB__NAME</span><span class="o">=</span>book
<span class="nv">DB__USER</span><span class="o">=</span>ivan
<span class="nv">DB__PASS</span><span class="o">=</span><span class="k">****</span>
<span class="nv">HTTP__PORT</span><span class="o">=</span>8080
<span class="nv">HTTP__HOST</span><span class="o">=</span>api.random.com
</code></pre></div></div>

<p>Прочитаем его и запустим REPL с новой средой:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span> <span class="nt">-a</span>
<span class="nb">source </span>ENV_NEST
lein repl
</code></pre></div></div>

<p>Достаточно изменить функции преобразования ключа и обхода окружения. Функция
<code class="language-plaintext highlighter-rouge">remap-key-nest</code> принимает строковый ключ и возвращает вектор составных частей:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">-&gt;keywords</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="nb">keyword</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-key-nest</span><span class="w">
  </span><span class="p">[</span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="nb">key</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">key</span><span class="w">
      </span><span class="n">str/lower-case</span><span class="w">
      </span><span class="p">(</span><span class="nf">str/replace</span><span class="w"> </span><span class="o">#</span><span class="s">"_"</span><span class="w"> </span><span class="s">"-"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="o">#</span><span class="s">"--"</span><span class="p">)</span><span class="w">
      </span><span class="n">-&gt;keywords</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">remap-key-nest</span><span class="w"> </span><span class="s">"DB__PORT"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; (:db :port)</span><span class="w">
</span></code></pre></div></div>

<p>Новая функция обхода отличается тем, что делает не <code class="language-plaintext highlighter-rouge">assoc</code>, а <code class="language-plaintext highlighter-rouge">assoc-in</code>, что
порождает вложенные словари:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-env-nest</span><span class="w">
  </span><span class="p">[</span><span class="n">env</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">acc</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]]</span><span class="w">
     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">key-path</span><span class="w"> </span><span class="p">(</span><span class="nf">remap-key-nest</span><span class="w"> </span><span class="n">k</span><span class="p">)]</span><span class="w">
       </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="n">key-path</span><span class="w"> </span><span class="n">v</span><span class="p">)))</span><span class="w">
   </span><span class="p">{}</span><span class="w">
   </span><span class="n">env</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Код ниже вернет сгруппированные параметры, как и было задумано. Для удобства мы
явно выбрали только нужные ключи:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span><span class="w">
    </span><span class="n">remap-env-nest</span><span class="w">
    </span><span class="p">(</span><span class="nb">select-keys</span><span class="w"> </span><span class="p">[</span><span class="no">:db</span><span class="w"> </span><span class="no">:http</span><span class="p">]))</span><span class="w">

</span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="s">"ivan"</span><span class="n">,</span><span class="w"> </span><span class="no">:pass</span><span class="w"> </span><span class="s">"****"</span><span class="n">,</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"book"</span><span class="p">}</span><span class="n">,</span><span class="w">
 </span><span class="no">:http</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="s">"8080"</span><span class="n">,</span><span class="w"> </span><span class="no">:host</span><span class="w"> </span><span class="s">"api.random.com"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Дальше действуем как обычно: пишем спеку, выводим типы из строк и так далее.</p>

<p>Подумайте, как задать переменными окружения массив, например, чтобы перечислить
состояние объекта. Как разобрать массив на элементы? В каких случаях возможно
ложное разбиение?</p>

<h2 id="простой-менеджер-конфигурации">Простой менеджер конфигурации</h2>

<p>К этому моменту читатель может решить, что читать конфигурацию из файла это
плохая практика, и следует переносить параметры в окружение. Это не всегда
так. На практике мы работаем с гибридными моделями, которые сочетают оба
подхода. Приложение читает основные параметры из файла, а пароли и ключи доступа
из переменных среды.</p>

<p>Рассмотрим несколько способов как подружить файлы и окружение. Наивное решение
не потребует писать код: оно работает на утилитах командной строки. Утилита
<code class="language-plaintext highlighter-rouge">envsubst</code> из пакета <code class="language-plaintext highlighter-rouge">GNU gettext</code> реализует простую шаблонную систему. Чтобы
установить <code class="language-plaintext highlighter-rouge">gettext</code>, выполните в терминале команду</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;manager&gt; <span class="nb">install </span>gettext
</code></pre></div></div>

<p>, где <code class="language-plaintext highlighter-rouge">&lt;manager&gt;</code> это менеджер пакетов вашей системы, например <code class="language-plaintext highlighter-rouge">brew</code>, <code class="language-plaintext highlighter-rouge">apt</code>,
<code class="language-plaintext highlighter-rouge">yum</code> и другие.</p>

<p>Текст шаблона приходит из stdin, а роль контекста играют переменные
среды. Утилита заменяет выражения <code class="language-plaintext highlighter-rouge">$VAR_NAME</code> на значения одноименной
переменной. Напишем шаблон будущей конфигурации:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>config.tpl.json
<span class="o">{</span>
    <span class="s2">"server_port"</span>: <span class="nv">$HTTP_PORT</span>,
    <span class="s2">"db"</span>: <span class="o">{</span>
        <span class="s2">"dbtype"</span>:   <span class="s2">"mysql"</span>,
        <span class="s2">"dbname"</span>:   <span class="s2">"</span><span class="nv">$DB_NAME</span><span class="s2">"</span>,
        <span class="s2">"user"</span>:     <span class="s2">"</span><span class="nv">$DB_USER</span><span class="s2">"</span>,
        <span class="s2">"password"</span>: <span class="s2">"</span><span class="nv">$DB_PASS</span><span class="s2">"</span>
    <span class="o">}</span>,
    <span class="s2">"event"</span>: <span class="o">[</span>
        <span class="s2">"</span><span class="nv">$EVENT_START</span><span class="s2">"</span>,
        <span class="s2">"</span><span class="nv">$EVENT_END</span><span class="s2">"</span>
    <span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Поместим переменные среды в отдельный файл:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>ENV_TPL

<span class="nv">DB_NAME</span><span class="o">=</span>book
<span class="nv">DB_USER</span><span class="o">=</span>ivan
<span class="nv">DB_PASS</span><span class="o">=</span><span class="s1">'*(&amp;fd}A53z#$!'</span>
<span class="nv">HTTP_PORT</span><span class="o">=</span>8080
<span class="nv">EVENT_START</span><span class="o">=</span><span class="s1">'2019-07-05T12:00:00'</span>
<span class="nv">EVENT_END</span><span class="o">=</span><span class="s1">'2019-07-12T23:59:59'</span>
</code></pre></div></div>

<p>Считаем переменные в память и “отрендерим” шаблон:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source </span>ENV_TPL
<span class="nb">cat </span>config.tpl.json | envsubst
<span class="o">{</span>
    <span class="s2">"server_port"</span>: 8080,
    <span class="s2">"db"</span>: <span class="o">{</span>
        <span class="s2">"dbtype"</span>:   <span class="s2">"mysql"</span>,
        <span class="s2">"dbname"</span>:   <span class="s2">"book"</span>,
        <span class="s2">"user"</span>:     <span class="s2">"ivan"</span>,
        <span class="s2">"password"</span>: <span class="s2">"*(&amp;fd}A53z#</span><span class="nv">$!</span><span class="s2">"</span>
    <span class="o">}</span>,
    <span class="s2">"event"</span>: <span class="o">[</span>
        <span class="s2">"2019-07-05T12:00:00"</span>,
        <span class="s2">"2019-07-12T23:59:59"</span>
    <span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Чтобы записать результат в файл, добавьте в конец выражения оператор вывода:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>config.tpl.json | envsubst <span class="o">&gt;</span> config.ready.json
</code></pre></div></div>

<p>Способ с <code class="language-plaintext highlighter-rouge">envsubst</code> кажется примитивным на первый взгляд, но неожиданно
оказывается полезным на практике. Принцип шаблона снимает вопрос структуры
данных. Мы храним переменные как плоский словарь и подставляем их в нужное
место. Не приходится думать о правилах вложенности, массивах и так далее.</p>

<p>Часто приложению требуется больше одного файла конфигурации. Например, если
приложение работает на порту 8080, то этот же порт должен встречаться в
конфигурации Nginx, iptables, и, возможно, crontab. На базе одних и тех же
переменных и разных шаблонов мы получим конфигурации для всех
сервисов. Останется разложить их по нужным директориям и перезагрузить службы.</p>

<p>Так <code class="language-plaintext highlighter-rouge">envsubst</code> становится простым менеджером конфигураций. Чтобы
автоматизировать процесс, добавьте простой шелл-скрипт или Make-файл. Решение не
дотягивает до промышленного уровня, но подходит для несложных проектов.</p>

<h2 id="чтение-среды-из-конфигурации">Чтение среды из конфигурации</h2>

<p>Следующие две техники делают так, что приложение читает параметры одновременно
из файла и переменных среды. Разница в том, на каком логическом шаге это
происходит.</p>

<p>Предположим, основные параметры указаны в файле, а пароль базы данных приходит
из среды. Договоримся с членами команды, что поле <code class="language-plaintext highlighter-rouge">:password</code> в файле содержит не
настоящий пароль, а имя переменной, например <code class="language-plaintext highlighter-rouge">"DB_PASS"</code>.</p>

<p>Напишем спеку, которая выводит значение переменной среды по ее имени:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;env</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">varname</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="n">varname</span><span class="p">)</span><span class="w">
         </span><span class="no">::s/invalid</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Если переменная не задана, ее вывод вернет ошибку. Поскольку это пароль, логично
отбросить пустые символы по краям и убедиться, что строка не пустая, прежде чем
мы подключимся к базе.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::db-password</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w"> </span><span class="no">::-&gt;env</span><span class="w">
         </span><span class="nb">string?</span><span class="w">
         </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">str/trim</span><span class="p">)</span><span class="w">
         </span><span class="n">not-empty</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Быстрая проверка:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::db-password</span><span class="w"> </span><span class="s">"DB_PASS"</span><span class="p">)</span><span class="w">
</span><span class="s">"*(&amp;fd}A53z#$!"</span><span class="w">
</span></code></pre></div></div>

<p>Теперь чтобы вынести любое поле из файла в переменную, замените его значение на
имя переменной. Обновите спеку этого поля: добавьте <code class="language-plaintext highlighter-rouge">::-&gt;env</code> в начало цепочки
<code class="language-plaintext highlighter-rouge">s/and</code>.</p>

<p>Другой способ прочитать переменные из файла — расширить его синтаксис
тегами. Теги это короткие символы, которые указывают, что значение за тегом
следует прочитать особым образом. Из известных форматов теги поддерживают yaml и
edn. Библиотеки для работы с ними предлагают уже готовые теги. В основном это
вывод нативных типов платформы из примитивных значений.</p>

<p>Пользователь может задать теги с собственной логикой. Рассмотрим пример с
EDN. Тег начинается со знака решетки и захватывает следующее за ним
значение. Например, <code class="language-plaintext highlighter-rouge">#inst "2019-07-10"</code> означает вывод даты из строки.</p>

<p>Технически тег связан с функцией одного аргумента, которая вычисляет новое
значение на базе исходного. Чтобы задать свой тег, в функцию
<code class="language-plaintext highlighter-rouge">clojure.edn/read-string</code> передают дополнительный словарь тегов. Ключи этого
словаря символы тегов, а значения функции.</p>

<p>Добавим тег <code class="language-plaintext highlighter-rouge">#env</code>, который вернет значение переменной по ее имени. Имя
переменной может быть строкой или символом. Определим функцию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tag-env</span><span class="w">
  </span><span class="p">[</span><span class="n">varname</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="n">varname</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="p">(</span><span class="nb">name</span><span class="w"> </span><span class="n">varname</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">varname</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="n">varname</span><span class="p">)</span><span class="w">
    </span><span class="no">:else</span><span class="w">
    </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="s">"wrong var type"</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Прочитаем edn-строку с новым тегом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.edn</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">edn</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">edn/read-string</span><span class="w">
 </span><span class="p">{</span><span class="no">:readers</span><span class="w"> </span><span class="p">{</span><span class="ss">'env</span><span class="w"> </span><span class="n">tag-env</span><span class="p">}}</span><span class="w">
 </span><span class="s">"{:db-password #env DB_PASS}"</span><span class="p">)</span><span class="w">

</span><span class="c1">;; {:db-password "*(&amp;fd}A53z#$!"}</span><span class="w">
</span></code></pre></div></div>

<p>У вас могут быть и другие теги для вывода специфичных Java-объектов. Чтобы не
передавать словарь тегов каждый раз, объявим partial от
<code class="language-plaintext highlighter-rouge">edn/read-string</code>. Получим функцию, которая принимает только текст:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">read-config</span><span class="w">
  </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">edn/read-string</span><span class="w">
           </span><span class="p">{</span><span class="no">:readers</span><span class="w"> </span><span class="p">{</span><span class="ss">'env</span><span class="w"> </span><span class="n">tag-env</span><span class="p">}}))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы прочитать edn-конфигурацию с особыми тегами, достаточно считать его
содержимое в строку и передать в <code class="language-plaintext highlighter-rouge">read-config</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"/path/to/config.edn"</span><span class="w">
    </span><span class="nb">slurp</span><span class="w">
    </span><span class="n">read-config</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Формат yaml устроен похожим образом: его стандарт предусматривает теги. Тег
начинается с одного или двух восклицательных знаков в зависимости от
семантики. Согласно документации, сторонние теги должны начинаться с <code class="language-plaintext highlighter-rouge">!!</code>, чтобы
их можно было отделить от стандартных, но этому соглашению не всегда следуют.</p>

<p>Библиотека yummy это парсер yaml-файлов, “заряженный” полезными тегами. Среди
прочих он предлагает <code class="language-plaintext highlighter-rouge">!envvar</code>. Тег возвращает значение переменной среды по ее
имени.</p>

<p>Опишем конфигурацию в файле <code class="language-plaintext highlighter-rouge">config.yaml</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">server_port</span><span class="pi">:</span> <span class="m">8080</span>
<span class="na">db</span><span class="pi">:</span>
  <span class="na">dbtype</span><span class="pi">:</span>   <span class="s">mysql</span>
  <span class="na">dbname</span><span class="pi">:</span>   <span class="s">book</span>
  <span class="na">user</span><span class="pi">:</span>     <span class="kt">!envvar</span> <span class="s">DB_USER</span>
  <span class="na">password</span><span class="pi">:</span> <span class="kt">!envvar</span> <span class="s">DB_PASS</span>
</code></pre></div></div>

<p>Импортируем библиотеку и прочитаем конфигурацию. На месте тегов получим значения
переменных:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">yummy.config</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">yummy</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">yummy/load-config</span><span class="w"> </span><span class="p">{</span><span class="no">:path</span><span class="w"> </span><span class="s">"config.yaml"</span><span class="p">})</span><span class="w">

</span><span class="p">{</span><span class="no">:server_port</span><span class="w"> </span><span class="mi">8080</span><span class="w">
 </span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"mysql"</span><span class="w">
      </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"book"</span><span class="w">
      </span><span class="no">:user</span><span class="w"> </span><span class="s">"ivan"</span><span class="w">
      </span><span class="no">:password</span><span class="w"> </span><span class="s">"*(&amp;fd}A53z#$!"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>У библиотеки yummy есть и другие преимущества, о которых мы поговорим в
следующем разделе.</p>

<p>Концепция тегов в конфигурации имеет преимущества и недостатки. С одной стороны,
они делают конфигурацию плотнее. На строку с тегом приходится больше смысла. Мы
выносим логику разбора тегов в стороннюю библиотеку и тем самым уменьшаем код
проекта.</p>

<p>С другой стороны, теги привязывают конфигурацию к одной платформе и
библиотеке. Например, если в вашем .yaml-файле встречается тег <code class="language-plaintext highlighter-rouge">!envvar</code>, то
библиотека на Python не сможет его прочитать, потому что в ней нет этого тега. С
технической стороны это можно исправить: игнорировать незнакомые теги или
установить заглушку. Но такой подход и не гарантирует одинаковый результат на
разных платформах.</p>

<p>Другой недостаток тегов в том, что с ними конфигурация обрастает побочными
эффектами. В терминах функционального программирования она теряет
чистоту. Появляется соблазн вынести в теги слишком много логики. Например,
импортировать дочерние файлы, форматировать строки, восстанавливать сложные
объекты из скаляров. Теги стирают грань между чтением конфигурации и ее
пост-обработкой, и когда их слишком много, конфигурацию трудно поддерживать.</p>

<p>Оба приема — разбор спекой или тегами — оппонируют друг другу. На выбор
конкретного метода влияют внутреннее устройство фирмы, рабочие процессы и
соглашения внутри команды.</p>

<h2 id="короткий-обзор-форматов">Короткий обзор форматов</h2>

<p>К этому моменту мы упомянули три формата для хранения конфигурации. Это JSON,
EDN и YAML. Перечислим особенности каждого из них. Мы ставим цель не выявить
идеальный формат, а подготовить читателя к неочевидным моментам, которые
возникнут в работе с этими файлами.</p>

<h3 id="json">JSON</h3>

<p>Формат JSON наверняка известен каждому разработчику. Это способ записать данные
в том виде, как это принято в JavaScript. Стандарт определяет числа, строки,
логический тип, null и два вида коллекций: массив и словарь. Коллекции могут
быть произвольно вложены друг в друга.</p>

<p>Ключевое преимущество JSON в его популярности. Он стал де-факто стандартом для
обмена данными между клиентом и сервером. По сравнению с XML его легче читать и
поддерживать. JSON поддерживают все современные редакторы, языки и
платформы. Это нативный способ хранить данные в мире JavaScript.</p>

<p>К сожалению, формат не предусматривает комментарии. На первый взгляд это кажется
мелочью. На практике комментарии важны, особенно если в фирме принято разделение
труда. Если разработчик добавил новый параметр, хорошим тоном будет написать
комментарий о том, что он делает и какие значения принимает. Ради интереса
посмотрите файлы конфигурации Redis, PostgreSQL или Nginx — на 90 процентов они
состоят из комментариев.</p>

<p>Разработчики придумали десятки уловок, чтобы обойти это ограничение. Например,
добавлять над каждым полем одноименное с комментарием:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"server_port"</span><span class="p">:</span><span class="w"> </span><span class="s2">"A port which the web-server is bound to."</span><span class="p">,</span><span class="w">
    </span><span class="nl">"server_port"</span><span class="p">:</span><span class="w"> </span><span class="mi">8080</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Расчет сделан на то, что библиотеки не проверяют ключ на вхождение в словарь, и
второй <code class="language-plaintext highlighter-rouge">server_port</code> заменит первый. Заметим, что стандарт JSON не регулирует
такой сценарий; он остается на откуп разработчиков. Логика может быть иной,
например бросить исключение или не заменять ключ, который уже в словаре.</p>

<p>Другие способы включают пустую строку в качестве ключа комментария или
специальные ключи, обрамленные подчеркиваниями. Эти методы хрупки и не всегда
проходят проверку линтерами. Отдельные программисты добавляют поддержку
комментариев на уровне продукта. Так, популярный редактор Sublime Text хранит
настройки в .json-файлах с поддержкой JavaScript-комментариев. Но в общем случае
решения этой проблемы нет.</p>

<p>На момент появления JSON выгодно отличался от многословного XML. JSON-данные
выглядят чище и удобнее для человека, чем дерево XML-тегов. Но современные
форматы выражают данные еще чище. Например, в YAML любую структуру можно
записать без единой скобки, пользуясь только отступами.</p>

<p>Синтаксис JSON “шумит”: он требует кавычек, двоеточий и запятых в случаях, где
другие форматы лояльны. Например, запятая на конце последнего элемента массива
или объекта считается ошибкой. Ключи не могут быть числами или
токенами.</p>

<p>Сравните одну и ту же структуру данных в YAML и JSON:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                              {
server_port: 8080                  "server_port": 8080,
db:                                "db": {
  dbtype:   mysql                      "dbtype":   "mysql",
  dbname:   book                       "dbname":   "book",
  user:     user                       "user":     "ivan",
  password: '****'                     "password": "****"
event:                             },
  - 2019-07-05T12:00:00            "event": [
  - 2019-07-12T23:59:59                "2019-07-05T12:00:00",
                                       "2019-07-12T23:59:59"
                                   ]
                               }
</code></pre></div></div>

<p>Стандарт JSON не поддерживает теги, о которых мы говорили выше.</p>

<h3 id="yaml">YAML</h3>

<p>Язык разметки YAML, как и JSON, различает базовые типы: скаляры, null и
коллекции. YAML делает упор на краткости записи. Это выражается в том, что
вложенность структур определяют отступы, а не скобки. Запятые не обязательны
там, где они выводятся логически. Например, массив чисел в одну строку выглядит
как в JSON:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">numbers</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">1</span><span class="pi">,</span> <span class="nv">2</span><span class="pi">,</span> <span class="nv">3</span><span class="pi">]</span>
</code></pre></div></div>

<p>Но в случае с многострочной записью нужда в скобках и запятых отпадает:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">numbers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="m">1</span>
  <span class="pi">-</span> <span class="m">2</span>
  <span class="pi">-</span> <span class="m">3</span>
</code></pre></div></div>

<p>YAML поддерживает комментарии в стиле Python. Благодаря этому формат популярен у
DevOps-инженеров. Программы docker-compose и Kubernetes работают на yaml-файлах.</p>

<p>В отличии от JSON, YAML предлагает синтаксис для многострочного текста. Такой
текст проще читать и копировать, чем одну строку с вкраплениями <code class="language-plaintext highlighter-rouge">\n</code>.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">description</span><span class="pi">:</span> <span class="pi">|</span>
  <span class="s">To resolve the error, please do the following:</span>

  <span class="s">- Press Control + Alt + Delete;</span>
  <span class="s">- Turn off your computer;</span>
  <span class="s">- Walk for a while.</span>

  <span class="s">Then try again.</span>
</code></pre></div></div>

<p>Язык официально поддерживает теги.</p>

<p>Недостатки YAML вытекают из его преимуществ. Вложенность отступами кажется
удачным решением до тех пор, пока файл не станет большим. Рано или поздно ваш
глаз будет прыгать на большие расстояния, чтобы сверять уровни
структур. Возрастает риск неприятного события, когда ключ “уезжает” в другую
часть словаря из-за лишнего отступа. С точки зрения синтаксиса ошибки нет,
поэтому ее трудно найти.</p>

<p>Иногда отказ от кавычек приводит к неверным типам или структуре. Предположим, в
поле phrases перечислены фразы, которые увидит пользователь:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">phrases</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Welcome aboard!</span>
  <span class="pi">-</span> <span class="s">See you soon!</span>
  <span class="pi">-</span> <span class="na">Warning</span><span class="pi">:</span> <span class="s">wrong email address.</span>
</code></pre></div></div>

<p>Из-за двоеточия в последней фразе парсер решит, что это вложенный словарь. При
попытке считать такой файл получится неверная структура:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:phrases</span><span class="w">
 </span><span class="p">[</span><span class="s">"Welcome aboard!"</span><span class="w">
  </span><span class="s">"See you soon!"</span><span class="w">
  </span><span class="p">{</span><span class="no">:Warning</span><span class="w"> </span><span class="s">"wrong email address."</span><span class="p">}]}</span><span class="w">
</span></code></pre></div></div>

<p>Другие примеры: версия продукта <code class="language-plaintext highlighter-rouge">3.3</code> это число, но <code class="language-plaintext highlighter-rouge">3.3.1</code> — строка. Телефон
<code class="language-plaintext highlighter-rouge">+79625241745</code> это число, потому что знак плюса считается унарным оператором по
аналогии с минусом. Лидирующие нули означают восьмеричную запись: если не
добавить кавычки к идентификатору <code class="language-plaintext highlighter-rouge">000042</code>, вы получите число <code class="language-plaintext highlighter-rouge">34</code>.</p>

<p>Это не значит, что YAML неудачный формат. Все перечисленные случаи описаны в
стандарте и имеют логическое объяснение. Но читатель должен помнить, что отказ
от кавычек потенциально ведет к ошибке конфигурации.</p>

<h3 id="edn">EDN</h3>

<p>Формат EDN занимает особое место в этом обзоре. Он предназначен для хранения
данных Clojure и поэтому играет такую же роль в экосистеме языка, как JSON в
мире JavaScript. Это естественный, родной способ связать данные с файлом в
Clojure.</p>

<p>Синтаксис EDN почти полностью соответствует компилятору Clojure. Поэтому формат
охватывает больше типов, чем JSON и YAML. Например, из скалярных типов доступны
символы и кейворды (типы <code class="language-plaintext highlighter-rouge">clojure.lang.Symbol</code> и <code class="language-plaintext highlighter-rouge">Keyword</code>). Кроме вектора и
словаря формат поддерживает списки и множества.</p>

<p>Теги начинаются с символа решетки. По умолчанию стандарт предлагает два тега:
<code class="language-plaintext highlighter-rouge">#inst</code> и <code class="language-plaintext highlighter-rouge">#uuid</code>. Первый читает строку в дату, а второй в экземпляр
<code class="language-plaintext highlighter-rouge">UUID</code>. Такие идентификаторы используют в распределенных системах, например БД
Cassandra. Выше мы показывали, как зарегистрировать свой тег. Достаточно связать
его с функцией одного аргумента при чтении EDN-строки.</p>

<p>Собирательный пример с разными коллекциями и тегами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:task-state</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:pending</span><span class="w"> </span><span class="no">:in-progress</span><span class="w"> </span><span class="no">:done</span><span class="p">}</span><span class="w">
 </span><span class="no">:account-ids</span><span class="w"> </span><span class="p">[</span><span class="mi">1001</span><span class="w"> </span><span class="mi">1002</span><span class="w"> </span><span class="mi">1003</span><span class="p">]</span><span class="w">
 </span><span class="no">:server</span><span class="w"> </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w"> </span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="p">}</span><span class="w">
 </span><span class="no">:date-range</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019-07-01"</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019-07-31"</span><span class="p">]</span><span class="w">
 </span><span class="no">:cassandra-id</span><span class="w"> </span><span class="o">#</span><span class="n">uuid</span><span class="w"> </span><span class="s">"26577362-902e-49e3-83fb-9106be7f60e1"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>EDN-данные не отличаются от записи в .clj-файлах. Если скопировать содержимое
файла в REPL или модуль Clojure, компилятор просто выполнит их. Правило работает
и наоборот: вывод REPL можно скопировать в файл для дальнейшей работы.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">pr-str</code> возвращает текстовую версию данных. Поэтому сброс в EDN
сводится к простым шагам: “напечатать” данные в строку и записать ее в
файл. Пример ниже записывает в файл <code class="language-plaintext highlighter-rouge">dataset.edn</code> результат функции
<code class="language-plaintext highlighter-rouge">get-huge-dataset</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">get-huge-dataset</span><span class="p">)</span><span class="w">
    </span><span class="nb">pr-str</span><span class="w">
    </span><span class="p">(</span><span class="nf">as-&gt;</span><span class="w"> </span><span class="n">dump</span><span class="w">
        </span><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="s">"dataset.edn"</span><span class="w"> </span><span class="n">dump</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>EDN поддерживает не только обычные комментарии. Комбинация <code class="language-plaintext highlighter-rouge">#_</code> игнорирует
следующий за ним элемент. Под элементом понимается что угодно: скаляр,
коллекция. Например, если нужно проигнорировать словарь, который занимает
несколько строк, достаточно поставить перед ним <code class="language-plaintext highlighter-rouge">#_</code>, и парсер пропустит
его.</p>

<p>Это позволяет “отключить” целые части конфигурации. В следующем примере мы
игнорируем пользователя Ioann. Если поставить обычный комментарий, он заденет
закрывающие скобки, и выражение не будет окончено.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:users</span><span class="w"> </span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}</span><span class="w">
         </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Juan"</span><span class="p">}</span><span class="w">
         </span><span class="o">#</span><span class="n">_</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ioann"</span><span class="p">}]}</span><span class="w">
</span></code></pre></div></div>

<p>EDN становится особо удачным выбором, когда и бекенд, и фронтенд приложения
построены на одном стеке Clojure + ClojureScript.</p>

<p>Отметим, что EDN привязан к экосистеме Clojure и потому не известен
разработчикам на других языках. Современные редакторы, как правило, не
подсвечивают его синтаксис без сторонних плагинов. Это может доставить проблем
вашим DevOps-коллегами, которые работали только с JSON и YAML.</p>

<p>Если конфигурацию обрабатывают сторонние Python- или Ruby-скрипты, придется
ставить библиотеку для работы с этим форматом. Поэтому выбор в пользу EDN делают
фирмы, где Clojure преобладает над другими технологиями.</p>

<h2 id="промышленные-решения">Промышленные решения</h2>

<p>Хотя Clojure-разработчику важно понимать, как работает конфигурация, мы не
ожидаем, что в каждом проекте ее пишут с нуля. Логично предположить, что идеи,
изложенные в этой главе, уже выражены в сторонних решениях. В заключительном
разделе мы рассмотрим, какие библиотеки предлагает Clojure-сообщество для
конфигурации проектов.</p>

<p>Мы остановили внимание на проектах cprop, aero и yummy. Библиотеки отличаются в
идеологии и архитектуре. Мы специально подобрали их так, чтобы увидеть проблему
с разных сторон.</p>

<h3 id="cprop">Cprop</h3>

<p>Библиотека cprop устроена по принципу “данные отовсюду”. В отличии от нашего
загрузчика у cprop больше источников данных. Библиотека читает не только файл и
переменные среды, но и ресурсы, property-файлы и пользовательские словари.</p>

<p>Cprop приводит данные из разных источников к одному виду. Можно сказать, что это
обертка над различными “бекендами” данных. При помощи cprop можно задать
конфигурацию разным способом, но получить одинаковый результат.</p>

<p>В библиотеке задан порядок обхода источников и их приоритет. Параметры из одного
источника могут заменять другие. Например, переменная среды имеет более высокий
приоритет, чем одноименная из файла. Для частных случаев в cprop легко задать
свой порядок загрузки.</p>

<p>На верхнем уровне доступна функция <code class="language-plaintext highlighter-rouge">load-config</code>. Вызванная без параметров,
функция запускает стандартный загрузчик. По умолчанию cprop ищет два источника
данных: Java-ресурс и property-файл.</p>

<p>Под ресурсом понимают особый файл, который становится частью Java-проекта. На
этапе разработки файлы ресурсов хранят в директории resources. Cprop ожидает
ресурс с именем <code class="language-plaintext highlighter-rouge">config.edn</code>. Это первичный источник данных.</p>

<p>Если системное свойство conf не пустое, библиотека полагает, что это путь к
property-файлу и загружает из него словарь. Системные свойства это особая группа
переменных в рамках Java-машины. Можно сказать, что свойства это аналог среды
окружения для JVM.</p>

<p>При загрузке JVM получает набор свойств по умолчанию, например, тип и версию
операционной системы, параметры файловой системы, опции JVM и
другие. Дополнительные свойства передают параметром <code class="language-plaintext highlighter-rouge">-D</code> при запуске
java-программы. Пример ниже запускает скомпилированный jar-файл со свойством
<code class="language-plaintext highlighter-rouge">conf</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-Dconf</span><span class="o">=</span><span class="s2">"/path/to/config.properties"</span> <span class="nt">-jar</span> project.jar
</code></pre></div></div>

<p>Файлы <code class="language-plaintext highlighter-rouge">.properties</code> это пары поле=значение по одной на строку. Поля носят
доменную структуру: это лексемы, разделенные точкой. Лексемы убывают по
старшинству:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>db.type=mysql
db.host=127.0.0.1
db.pool.connections=8
</code></pre></div></div>

<p>Библиотека расценивает точки как вложенные словари. Загрузка такого файла вернет
структуру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="s">"mysql"</span><span class="w">
      </span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
      </span><span class="no">:pool</span><span class="w"> </span><span class="p">{</span><span class="no">:connections</span><span class="w"> </span><span class="mi">8</span><span class="p">}}}</span><span class="w">
</span></code></pre></div></div>

<p>Получив конфигурацию из ресурса или property-файла, cprop ищет переопределения в
переменных среды. Для них работают те же правила, что и в нашем
загрузчике. Например, если задана переменная <code class="language-plaintext highlighter-rouge">DB__POOL__CONNECTIONS=16</code>, она
заменит значение 8 в примере выше. При этом cprop игнорирует переменные, которые
не входят в ключи конфигурации, и тем самым не загрязняет ее.</p>

<p>Стандартные пути поиска можно задать ключами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w">
 </span><span class="no">:resource</span><span class="w"> </span><span class="s">"private/config.edn"</span><span class="w">
 </span><span class="no">:file</span><span class="w"> </span><span class="s">"/path/custom/config.edn"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Для работы с ресурсами cprop предлагает функции из модуля
<code class="language-plaintext highlighter-rouge">cprop.source</code>. Например, from-env Вернет словарь всех переменных среды,
<code class="language-plaintext highlighter-rouge">from-props-file</code> загрузит properties-файл и так далее. Разработчик вправе
построить их них такую комбинацию, которая нужна проекту.</p>

<p>Ключ <code class="language-plaintext highlighter-rouge">:merge</code> объединяет конфигурацию с произвольными источниками. Убер-пример
из документации:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w">
 </span><span class="no">:resource</span><span class="w"> </span><span class="s">"path/within/classpath/to.edn"</span><span class="w">
 </span><span class="no">:file</span><span class="w"> </span><span class="s">"/path/to/some.edn"</span><span class="w">
 </span><span class="no">:merge</span><span class="w"> </span><span class="p">[{</span><span class="no">:datomic</span><span class="w"> </span><span class="p">{</span><span class="no">:url</span><span class="w"> </span><span class="s">"foo.bar"</span><span class="p">}}</span><span class="w">
         </span><span class="p">(</span><span class="nf">from-file</span><span class="w"> </span><span class="s">"/path/to/another.edn"</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">from-resource</span><span class="w"> </span><span class="s">"path/within/classpath/to-another.edn"</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">from-props-file</span><span class="w"> </span><span class="s">"/path/to/some.properties"</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">from-system-props</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">from-env</span><span class="p">)])</span><span class="w">
</span></code></pre></div></div>

<p>В вектор <code class="language-plaintext highlighter-rouge">:merge</code> можно добавить любое выражение, которое вернет словарь. Но в
общем случае <code class="language-plaintext highlighter-rouge">(load-config)</code> без параметров будет достаточным решением.</p>

<p>Чтобы отследить загрузку такой сложной конфигурации, установите переменную среды
DEBUG:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">DEBUG</span><span class="o">=</span>y
</code></pre></div></div>

<p>С ней cprop выводит в лог служебную информацию. Это список источников, порядок
их загрузки, переопределение переменных и так далее.</p>

<p>Cprop только загружает данные из разных источников, но не проверяет их. В
библиотеке не реализована валидация спекой, как это сделано в нашем
загрузчике. Этот шаг остается на усмотрение разработчика.</p>

<p>В cprop работает своя система вывода типов. Если строка состоит только из цифр,
ее приводят к числу. Значения с запятыми становятся списками. В целом этих
возможностей недостаточно для полного контроля за типами. Вам по-прежнему
понадобится <code class="language-plaintext highlighter-rouge">spec</code> и <code class="language-plaintext highlighter-rouge">conform</code> для вывода типов и сообщений об ошибке.</p>

<h3 id="aero">Aero</h3>

<p>Проект aero предлагает другой подход. В отличии от cprop, библиотека работает
только с одним источником данных: файлами <code class="language-plaintext highlighter-rouge">*.edn</code>. Aero несет на борту теги, с
которыми EDN становится похож на мини-язык программирования. В нем появляются
базовые операторы ветвления, импорта, форматирования. По-другому это можно
назвать “EDN на стероидах”.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">read-config</code> читает файл или ресурс EDN:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">aero.core</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">(</span><span class="nf">read-config</span><span class="p">)])</span><span class="w">

</span><span class="p">(</span><span class="nf">read-config</span><span class="w"> </span><span class="s">"config.edn"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">read-config</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.java.io/resource</span><span class="w"> </span><span class="s">"config.edn"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Центральная точка библиотеки это теги, которые срабатывают при чтении. Разберем
основные из них. Тег <code class="language-plaintext highlighter-rouge">#env</code> заменяет имя переменной среды на ее значение. Нам
уже приходилось писать его:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:passwod</span><span class="w"> </span><span class="o">#</span><span class="n">env</span><span class="w"> </span><span class="n">DB_PASS</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Тег <code class="language-plaintext highlighter-rouge">#envf</code> форматирует строку переменными среды. Например, параметры базы
данных заданы отдельными полями, но вы предпочитаете JDBC URI – длинную строку,
похожую на веб-адрес. Чтобы не дублировать данные, адрес вычисляют на базе
исходных полей:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db-uri</span><span class="w"> </span><span class="o">#</span><span class="n">envf</span><span class="w"> </span><span class="p">[</span><span class="s">"jdbc:postgresql://%s/%s?user=%s"</span><span class="w">
                </span><span class="n">DB_HOST</span><span class="w"> </span><span class="n">DB_NAME</span><span class="w"> </span><span class="n">DB_USER</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Тег <code class="language-plaintext highlighter-rouge">#or</code> похож на одноименный оператор Clojure и в основном нужен для значений
по умолчанию. Так, в нашем env-файле не задан порт базы данных. Чтобы избежать
неочевидности, укажем стандартный порт:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="o">#</span><span class="nb">or</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="n">env</span><span class="w"> </span><span class="n">DB_PORT</span><span class="w"> </span><span class="mi">5432</span><span class="p">]}}</span><span class="w">
</span></code></pre></div></div>

<p>Оператор <code class="language-plaintext highlighter-rouge">#profile</code> предлагает интересный способ взять значение в зависимости от
профиля. Значение за тегом обязательно словарь. Ключи словаря это профили, а
значения – то, что получим в результате его разрешения. Профиль задают в
параметрах <code class="language-plaintext highlighter-rouge">read-config</code>.</p>

<p>Пример ниже показывает, как определить имя базы данных по профилю. Без профиля
мы получим <code class="language-plaintext highlighter-rouge">"book"</code>, но для <code class="language-plaintext highlighter-rouge">:test</code> имя станет <code class="language-plaintext highlighter-rouge">"book_TEST"</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="o">#</span><span class="n">profile</span><span class="w"> </span><span class="p">{</span><span class="no">:default</span><span class="w"> </span><span class="s">"book"</span><span class="w">
                      </span><span class="no">:dev</span><span class="w">     </span><span class="s">"book_DEV"</span><span class="w">
                      </span><span class="no">:test</span><span class="w">    </span><span class="s">"book_TEST"</span><span class="p">}}}</span><span class="w">

</span><span class="p">(</span><span class="nf">read-config</span><span class="w"> </span><span class="s">"aero.test.edn"</span><span class="w"> </span><span class="p">{</span><span class="no">:profile</span><span class="w"> </span><span class="no">:test</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"book_TEST"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Тег <code class="language-plaintext highlighter-rouge">#include</code> внедряет в конфигурацию содержимое другого edn-файла. При этом
дочерний файл тоже содержит aero-теги, и библиотека выполняет их рекурсивно. К
импорту прибегают, когда конфигурация отдельных компонентов становится большой.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:queue</span><span class="w"> </span><span class="o">#</span><span class="n">include</span><span class="w"> </span><span class="s">"message-queue.edn"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Тег <code class="language-plaintext highlighter-rouge">#ref</code> описывает ссылку на любое место конфигурации. Это вектор ключей,
который обычно передают в <code class="language-plaintext highlighter-rouge">get-in</code>. Ссылка позволяет избежать дублирования
данных. Например, сторонний компонент нуждается в пользователе, под которым мы
подключаемся к базе данных:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; config.edn</span><span class="w">
</span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="o">#</span><span class="n">env</span><span class="w"> </span><span class="n">DB_USER</span><span class="p">}</span><span class="w">
 </span><span class="no">:worker</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="o">#</span><span class="nb">ref</span><span class="w"> </span><span class="p">[</span><span class="no">:db</span><span class="w"> </span><span class="no">:user</span><span class="p">]}}</span><span class="w">

</span><span class="c1">;; result</span><span class="w">
</span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="s">"ivan"</span><span class="p">}</span><span class="n">,</span><span class="w"> </span><span class="no">:worker</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="s">"ivan"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Эти и другие теги можно комбинировать различными способами и добавлять
собственные.</p>

<p>Фактически aero предлагает несложный язык описания конфигураций. Проект выглядит
многообещающе. Aero подкупает интересными идеями и красотой реализации. Но в
момент, когда вам захочется переехать с негибкого JSON на aero, подумайте об
обратной стороне медали.</p>

<p>Конфигурацию не случайно отделяют от кода. Если бы не потребность индустрии, мы
бы хранили параметры в исходных файлах. Но все же мы не делаем так, – наоборот,
хорошие практики в один голос советуют отделять параметры от кода. В том числе
потому, что в отличие от кода конфигурация декларативна.</p>

<p>Негибкие JSON- и properties-файлы обладают важным свойством: они
декларативны. Когда вы открыли файл в редакторе или “катнули” его в консоль, то
сразу видите данные. Отдельные их части могут дублироваться, синтаксис не
настолько удобен для чтения. Но данные выражаются сами в себя, и ошибки быть не
может. Вы просто видите их.</p>

<p>Наоборот, файл с нестандартными тегами труден в поддержке. Это не конфигурация,
а код. Файл становится трудно читать, его нужно выполнить. При чтении файла у
вас в голове запускается мини-интерпретатор, который не гарантирует точный
результат.</p>

<p>Получается своего рода круг. Мы вынесли параметры в статическую конфигурацию,
добавили теги и вернулись к коду. Такой подход тоже имеет право на жизнь, но к
нему следует прийти осознанно.</p>

<h3 id="yummy">Yummy</h3>

<p>Библиотека yummy замыкает наш обзор. Yummy отличается от аналогов двумя
свойствами. Во-первых, она работает с файлами YAML для чтения конфигурации
(отсюда и название). Во-вторых, процесс ее загрузки максимально похож на тот,
что мы рассмотрели в начале главы.</p>

<p>Вспомним, что полноценный загрузчик не только читает параметры. Цикл
конфигурации включает проверку данных и вывод ошибки. Сообщение об ошибке внятно
объясняет, в чем причина. С помощью необязательных параметров мы должны иметь
возможность “зацепиться” за основные события. Yummy предлагает почти все из
перечисленного.</p>

<p>Библиотека читает YAML-разметку из файла. Путь к файлу либо передан в
параметрах, либо библиотека ищет его по определенному имени в переменных среды
или свойствах JVM.</p>

<p>Вариант, когда путь задан явно:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">yummy.config</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">load-config</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">load-config</span><span class="w"> </span><span class="p">{</span><span class="no">:path</span><span class="w"> </span><span class="s">"config.yaml"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Во втором примере вместо пути задали имя программы. Yummy ищет путь к файлу в
переменной среды <code class="language-plaintext highlighter-rouge">&lt;name&gt;_CONFIGURATION</code> или свойстве <code class="language-plaintext highlighter-rouge">&lt;name&gt;.configuration</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">BOOK_CONFIGURATION</span><span class="o">=</span>config.yaml
</code></pre></div></div>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w"> </span><span class="p">{</span><span class="no">:program-name</span><span class="w"> </span><span class="no">:book</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Библиотека расширяет YAML несколькими тегами. Это знакомый вам <code class="language-plaintext highlighter-rouge">!envvar</code> для
переменных среды:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">db</span><span class="pi">:</span>
  <span class="na">password</span><span class="pi">:</span> <span class="kt">!envvar</span> <span class="s">DB_PASS</span>
</code></pre></div></div>

<p>Тег <code class="language-plaintext highlighter-rouge">!keyword</code> полезен в случаях, когда вместо строки ожидают кейворд:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">states</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="kt">!keyword</span> <span class="s">task/pending</span>
  <span class="pi">-</span> <span class="kt">!keyword</span> <span class="s">task/in-progress</span>
  <span class="pi">-</span> <span class="kt">!keyword</span> <span class="s">task/done</span>
</code></pre></div></div>

<p>Результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:states</span><span class="w"> </span><span class="p">[</span><span class="no">:task/pending</span><span class="w"> </span><span class="no">:task/in-progress</span><span class="w"> </span><span class="no">:task/done</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Тег <code class="language-plaintext highlighter-rouge">!uuid</code> аналогичен <code class="language-plaintext highlighter-rouge">#uuid</code> для EDN. Он возвращает объект <code class="language-plaintext highlighter-rouge">java.util.UUID</code> из
строки:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">system-user</span><span class="pi">:</span> <span class="kt">!uuid</span> <span class="s">cb7aa305-997c-4d53-a61a-38e0d8628dbb</span>
</code></pre></div></div>

<p>Тег <code class="language-plaintext highlighter-rouge">!slurp</code> читает текст из стороннего файла. Это полезно для сертификатов
шифрования. Их содержимое это длинная строка, которая плохо укладываются в общую
конфигурацию:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">tls</span><span class="pi">:</span>
  <span class="na">auth</span><span class="pi">:</span> <span class="kt">!slurp</span> <span class="s2">"</span><span class="s">certs/ca.pem"</span>
  <span class="na">cert</span><span class="pi">:</span> <span class="kt">!slurp</span> <span class="s2">"</span><span class="s">certs/cert.pem"</span>
  <span class="na">pkey</span><span class="pi">:</span> <span class="kt">!slurp</span> <span class="s2">"</span><span class="s">certs/key.pk8"</span>
</code></pre></div></div>

<p>Если в директории certs оказались все нужные сертификаты, в ключах <code class="language-plaintext highlighter-rouge">:auth</code>,
<code class="language-plaintext highlighter-rouge">:cert</code> и <code class="language-plaintext highlighter-rouge">:pkey</code> будет содержимое этих файлов.</p>

<p>Чтобы проверить данные, в параметры <code class="language-plaintext highlighter-rouge">load-config</code> передают ключ спеки. Когда
ключ указан, yummy выполняет s/assert для параметров из yaml-файла. Если данные
не прошли проверку, всплывает исключение. Yummy использует библиотеку expound,
чтобы улучшить отчет спеки об ошибке.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w"> </span><span class="p">{</span><span class="no">:program-name</span><span class="w"> </span><span class="no">:book</span><span class="w">
              </span><span class="no">:spec</span><span class="w"> </span><span class="no">::config</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Словарь опцией yummy принимает параметр <code class="language-plaintext highlighter-rouge">:die-fn</code>. Это функция, которая будет
вызвана, если любая из стадий завершится с ошибкой. Функция принимает два
аргумента: объект исключения и текстовую метку, которая подсказывает, на какой
стадии произошла ошибка.</p>

<p>Если <code class="language-plaintext highlighter-rouge">:die-fn</code> не задан, yummy вызывает обработчик по умолчанию. Обработчик
выводит текст в stderr и завершает программу со кодом 1. Вспомним, что это
неудобно на этапе разработки: мы не хотим обрывать REPL из-за ошибки в
конфигурации. В интерактивном сеансе die-fn подавляет исключение и только
выводит текст:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w">
 </span><span class="p">{</span><span class="no">:program-name</span><span class="w"> </span><span class="no">:book</span><span class="w">
  </span><span class="no">:spec</span><span class="w"> </span><span class="no">::config</span><span class="w">
  </span><span class="no">:die-fn</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="n">msg</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*out*</span><span class="w"> </span><span class="n">*err*</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
              </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))))})</span><span class="w">
</span></code></pre></div></div>

<p>Но в боевом режиме мы запишем исключение в лог и завершим программу.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w">
 </span><span class="p">{</span><span class="no">:program-name</span><span class="w"> </span><span class="no">:book</span><span class="w">
  </span><span class="no">:spec</span><span class="w"> </span><span class="no">::config</span><span class="w">
  </span><span class="no">:die-fn</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="n">msg</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nf">log/errorf</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"Config error"</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nf">System/exit</span><span class="w"> </span><span class="mi">1</span><span class="p">))})</span><span class="w">
</span></code></pre></div></div>

<p>Из недостатков yummy отметим, что для работы со спекой используется
<code class="language-plaintext highlighter-rouge">s/assert</code>. Функция не выводит новые значения, как это делает <code class="language-plaintext highlighter-rouge">s/conform</code>, а
только выбрасывает исключение, если проверка не прошла. Поэтому эффект
conform-спек не окажет действия на данные, которые вы получите.</p>

<p>С другой стороны, это сделано нарочно. Библиотеку писали так, что вывод типов
срабатывает на этапе тегов, а спека только проверяет данные. С таким подходом
все преобразования видны на уровне yaml-файла.</p>

<h2 id="заключение">Заключение</h2>

<p>Перечислим основные тезисы из разделов этой главы.</p>

<p>Конфигурация нужна для того, чтобы помочь приложению пройти стадии
производства. На каждой стадии приложение запускают с особыми настройками, чтобы
выполнить должные проверки. Без поддержки конфигурации это просто невозможно.</p>

<p>Загрузка конфигурации включает в себя чтение данных, вывод типов и проверку
значений. В случае ошибки программа выводит понятное сообщение и завершается с
аварийным кодом. Нет смысла продолжать работу с неверными параметрами.</p>

<p>Источником конфигурации может быть файл, Java-ресурс, переменные
окружения. Допустимы гибридные схемы, когда основные данные приходят из файла, а
секретные поля из окружения.</p>

<p>Переменные среды живут в памяти операционной системы. Если переменных много, их
помещают в ENV-файл. Но приложение не читает этот файл; его загружает в память
система, которая отвечает за работу приложения на сервере. С точки зрения
приложения неизвестно, откуда пришли переменные.</p>

<p>Окружение это плоский словарь. Переменные хранят только текст, ключи никак не
структурированы. В разных системах прибегают к особым соглашениям о том, как имя
переменной ложится на логическую структуру. Это могут быть точки, двойные
подчеркивания или что-то другие.</p>

<p>Форматы файлов различаются синтаксисом и типами данных. Форматы общего
назначения покрывают базовые типы: строки, числа, словари и списки. Они не
настолько гибки, но гарантируют поддержку в разных языках. Наоборот, форматы,
созданные для конкретной платформы, обеспечивают тесную интеграцию с ней, но не
популярны в других языках.</p>

<p>Стандарты некоторых форматов официально поддерживают систему тегов. Теги опасны
тем, что при их большом количестве конфигурация превращается в код. Но эта
возможность полезна в качестве запасного варианта.</p>

<p>Экосистема Clojure предлагает несколько интересных библиотек для конфигурации
приложения. Они различаются замыслом и архитектурой, и наверняка каждый
разработчик найдет то, что ему по душе.</p>

<p>Нет однозначного ответа на вопрос о том, какой формат, библиотека или рабочий
процесс лучше. В каждой фирме действуют свои соглашения и порядки. Разработчик
должен быть готов к тому, в новой команде конфигурацию готовят по-другому.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-book-config/">
    <input required name="captcha" type="hidden" value="7 &#215; 4">

    <div class="block">
        <span class="comment-form-label"><small>7 &#215; 4 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
