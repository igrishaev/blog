<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Изменяемость в Clojure</title>
  <meta name="description" content="    Содержание">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-book-mutability/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Изменяемость в Clojure</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2019-06-16T00:00:00+00:00">
        Jun 16, 2019
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/programming/" rel="tag">programming</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<h2>

    Содержание

</h2>

<ul id="toc-item-clj-book-mutability">
  <li><a href="#общие-проблемы-изменяемых-данных" id="toc-item-clj-book-mutability-общие-проблемы-изменяемых-данных">Общие проблемы изменяемых данных</a>    <ul>
      <li><a href="#в-защиту-состояния" id="toc-item-clj-book-mutability-в-защиту-состояния">В защиту состояния</a></li>
    </ul>
  </li>
  <li><a href="#атомы" id="toc-item-clj-book-mutability-атомы">Атомы</a>    <ul>
      <li><a href="#приращение-атома" id="toc-item-clj-book-mutability-приращение-атома">Приращение атома</a></li>
      <li><a href="#совместный-доступ" id="toc-item-clj-book-mutability-совместный-доступ">Совместный доступ</a></li>
      <li><a href="#валидаторы-и-вотчеры" id="toc-item-clj-book-mutability-валидаторы-и-вотчеры">Валидаторы и вотчеры</a></li>
      <li><a href="#другие-примеры" id="toc-item-clj-book-mutability-другие-примеры">Другие примеры</a></li>
    </ul>
  </li>
  <li><a href="#volatile" id="toc-item-clj-book-mutability-volatile">Volatile</a>    <ul>
      <li><a href="#применение" id="toc-item-clj-book-mutability-применение">Применение</a></li>
    </ul>
  </li>
  <li><a href="#переходные-коллекции" id="toc-item-clj-book-mutability-переходные-коллекции">Переходные коллекции</a>    <ul>
      <li><a href="#технические-детали" id="toc-item-clj-book-mutability-технические-детали">Технические детали</a></li>
      <li><a href="#итерация-с-изменением" id="toc-item-clj-book-mutability-итерация-с-изменением">Итерация с изменением</a></li>
      <li><a href="#семантика-и-ограничения" id="toc-item-clj-book-mutability-семантика-и-ограничения">Семантика и ограничения</a></li>
    </ul>
  </li>
  <li><a href="#подмена-переменных-alter-var-root" id="toc-item-clj-book-mutability-подмена-переменных-alter-var-root">Подмена переменных. Alter-var-root</a>    <ul>
      <li><a href="#понятие-переменной" id="toc-item-clj-book-mutability-понятие-переменной">Понятие переменной</a></li>
      <li><a href="#запуск-по-требованию" id="toc-item-clj-book-mutability-запуск-по-требованию">Запуск по требованию</a></li>
      <li><a href="#коротко-о-системах" id="toc-item-clj-book-mutability-коротко-о-системах">Коротко о системах</a></li>
      <li><a href="#патчинг" id="toc-item-clj-book-mutability-патчинг">Патчинг</a></li>
      <li><a href="#в-боевом-режиме" id="toc-item-clj-book-mutability-в-боевом-режиме">В боевом режиме</a></li>
    </ul>
  </li>
  <li><a href="#немного-о-set" id="toc-item-clj-book-mutability-немного-о-set">Немного о set!</a></li>
  <li><a href="#изменения-в-контексте-binding" id="toc-item-clj-book-mutability-изменения-в-контексте-binding">Изменения в контексте. Binding</a>    <ul>
      <li><a href="#динамические-переменные" id="toc-item-clj-book-mutability-динамические-переменные">Динамические переменные</a></li>
      <li><a href="#отказ-от-set" id="toc-item-clj-book-mutability-отказ-от-set">Отказ от set!</a></li>
      <li><a href="#пример-с-переводом-строк" id="toc-item-clj-book-mutability-пример-с-переводом-строк">Пример с переводом строк</a></li>
    </ul>
  </li>
  <li><a href="#локальные-переменные-в-контексте" id="toc-item-clj-book-mutability-локальные-переменные-в-контексте">Локальные переменные в контексте</a>    <ul>
      <li><a href="#императивный-подход" id="toc-item-clj-book-mutability-императивный-подход">Императивный подход</a></li>
    </ul>
  </li>
  <li><a href="#глобальные-изменения-в-контексте" id="toc-item-clj-book-mutability-глобальные-изменения-в-контексте">Глобальные изменения в контексте</a>    <ul>
      <li><a href="#приложение-с-координатами" id="toc-item-clj-book-mutability-приложение-с-координатами">Приложение с координатами</a></li>
      <li><a href="#тесты" id="toc-item-clj-book-mutability-тесты">Тесты</a></li>
    </ul>
  </li>
  <li><a href="#все-вместе" id="toc-item-clj-book-mutability-все-вместе">Все вместе</a></li>
</ul>

<p>В этой главе мы поговорим про изменяемость данных. Тем, кто программирует на
классических языках, покажется странным, что теме уделено так много
внимания. Причина кроется в дизайне языка. Неизменяемые коллекции – одна из
центральных идей Clojure.</p>

<p class="draft-warn">Внимание! Вы читаете черновик к книге <a href="/clojure-in-prod/">“Clojure на производстве”</a>. Для
книги я переписывал его много раз, но в блоге осталась старая версия. Здесь она
для истории, а вам я рекомендую купить книжку.</p>

<p>В классических языках данные по умолчанию изменяются, а стандартная библиотека
предлагает ограничения: локи, атомарные изменения, постоянные коллекции. Clojure
устроена наоборот: по умолчанию данные не изменяются, а стандартная библиотека
включает несколько техник, чтобы изменять данные. Этим техникам и посвящена
глава.</p>

<p>Руководства по Clojure учат работать с неизменяемыми данными. Это приводит к
тому, что начинающие программисты на Clojure испытывают трудности, когда
возникает потребность менять данные. На время этой главы мы займем
противоположную позицию: рассмотрим, какими способом хранить и управлять
состоянием в программах.</p>

<!-- more -->

<h2 id="общие-проблемы-изменяемых-данных">Общие проблемы изменяемых данных</h2>

<p>Clojure устроена так, что на ней трудно писать императивный код. В императивном
подходе делают акцент на изменение данных. Например, чтобы получить список
удвоенных чисел, проделывают шаги:</p>

<ul>
  <li>создать новый пустой список;</li>
  <li>пройти по всем элементам исходного списка;</li>
  <li>на каждом шаге вычислить новый элемент;</li>
  <li>добавить его к новому списку.</li>
</ul>

<p>Базовые типы Clojure неизменяемы, поэтому к ним нельзя применить алгоритм
выше. Программистам на императивных языках кажется невозможным писать код без
изменения коллекций. Привычка менять данные настолько укрепилась в них, что
иммутабельность кажется почти физическим ограничением.</p>

<p>Это сделано нарочно. Создатель языка полагает, что изменяемость данных —
наиболее острая проблема в разработке ПО. Когда мы пишем код, то видим его
первичное состояние. В этом состоянии он будет только первый такт машинного
времени. Затем императивный код инициирует классы, изменит их внутренние
поля. Каждый объект читает и изменяет другие объекты и так далее.</p>

<p>Код на экране это снимок системы в момент времени. Мы видим ее двумерный
срез. Правильно рассматривать систему как изменение состояния во времени.</p>

<p>Именно поэтому так трудно расследовать инциденты. Мы не знаем, в каком состоянии
была система на момент сбоя. Чтобы исправить ошибку, ее сперва повторяют в
локальном окружении. Но вопрос как прийти в конкретное состояние становится
проблемой. Не всегда система спроектирована так, что ее можно запустить с
произвольным состоянием.</p>

<p>Неизменяемые данные отсекают целый пласт ошибок, которым подвержены императивные
языки. Рассмотрим примеры на Python.</p>

<p>Пусть на уровне модуля объявлен словарь. Это стандартные параметры запроса к
стороннему API. Функция принимает дополнительные параметры, объединяет со
стандартными и передает в HTTP-клиент:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DEFAULT_PARAMS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"allow_redirects"</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
    <span class="s">"timeout"</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="s">"headers"</span><span class="p">:</span> <span class="p">{</span><span class="s">"Content-Type"</span><span class="p">:</span> <span class="s">"application/json"</span><span class="p">},</span>
    <span class="s">"auth"</span><span class="p">:</span> <span class="p">(</span><span class="s">"username"</span><span class="p">,</span> <span class="s">"password"</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">api_call</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="n">params</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">DEFAULT_PARAMS</span><span class="p">)</span> <span class="c1"># !
</span>    <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">"https://api.host.com"</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resp</span><span class="p">.</span><span class="n">json</span><span class="p">()</span>
</code></pre></div></div>

<p>Первая строка в функции критична, хотя на первый взгляд это незаметно. Метод
<code class="language-plaintext highlighter-rouge">update</code> словаря дополняет его другим словарем. В данном случае изменяют словарь
<code class="language-plaintext highlighter-rouge">params</code>. Он живет внутри функции и скрыт от внешнего мира.</p>

<p>Вариант ниже несет грубую ошибку. Переменная <code class="language-plaintext highlighter-rouge">api_params</code> получает не копию
глобальных параметров, а только ссылку. Изменяя <code class="language-plaintext highlighter-rouge">api_params</code>, мы на самом деле
меняем <code class="language-plaintext highlighter-rouge">DEFAULT_PARAMS</code>. От вызова к вызову словарь будет меняться, что ведет к
странному поведению программы.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">api_call</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="n">api_params</span> <span class="o">=</span> <span class="n">DEFAULT_PARAMS</span>
    <span class="n">api_params</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">"https://api.host.com"</span><span class="p">,</span> <span class="o">**</span><span class="n">api_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resp</span><span class="p">.</span><span class="n">json</span><span class="p">()</span>
</code></pre></div></div>

<p>На собеседованиях часто задают такой вопрос. Есть сигнатура функции:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="o">=</span><span class="p">[]):</span>
</code></pre></div></div>

<p>Объясните, чем плоха эта функция и приведите пример ошибочного поведения?</p>

<p>Ответ в том, что параметры функции по умолчанию создаются однажды. В данном
случае <code class="language-plaintext highlighter-rouge">bar</code> равен пустому списку. В Python список изменяется. Если в <code class="language-plaintext highlighter-rouge">bar</code> не
был передан другой параметр, мы получим ссылку на исходный список. Достаточно
изменить его методом <code class="language-plaintext highlighter-rouge">append</code>, и тогда каждый вызов <code class="language-plaintext highlighter-rouge">foo</code> будет иметь дело с
разным значением <code class="language-plaintext highlighter-rouge">bar</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="o">=</span><span class="p">[]):</span>
    <span class="n">bar</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bar</span>
</code></pre></div></div>

<p>Последовательный вызов <code class="language-plaintext highlighter-rouge">foo</code> вернет списки <code class="language-plaintext highlighter-rouge">[1]</code>, <code class="language-plaintext highlighter-rouge">[1, 1]</code>, <code class="language-plaintext highlighter-rouge">[1, 1, 1]</code> и так
далее. Это очень неприятная ошибка. Ее легко исправить, но трудно отловить.</p>

<p>Современные IDE анализируют код и показывают потенциально опасные места. Пример
выше обнаружить довольно легко, и с ним справляются все анализаторы и
линтеры. Но мы не можем полностью положиться на утилиты. Когда данные в коде
меняются постоянно, невозможно отследить где ошибка, а где умышленное действие.</p>

<p>Clojure делает упор на обработке коллекций. Из стандартной библиотеки доступны
несколько сотен функций. Это сортировка, фильтрация, добавление элементов,
взаимная конвертация и многое другое. Функции не требуют промежуточный список
или словарь для накопления результата.</p>

<p>Начинающих кложуристов выдает следующий код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">[])</span><span class="w">
      </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">item</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">new-item</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">item</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">new-item</span><span class="p">)))</span><span class="w">
  </span><span class="o">@</span><span class="n">result</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Проблема в том, что программист следует привычке из императивного прошлого. В
примере выше не нужен атом-аккумулятор, достаточно <code class="language-plaintext highlighter-rouge">map</code> или <code class="language-plaintext highlighter-rouge">for</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Оба примера короче и понятней. Нам не нужно создавать новую коллекцию и
присоединять элементы вручную. Это делают встроенные функции.</p>

<p>Мы поговорим о коллекциях в отдельной главе, а пока что запомните правило. Вам
не нужно состояние для обработки коллекций. Если код опирается на атом или
Java-коллекцию, скорее всего это слабое решение.</p>

<p>Авторы Clojure сделали все, чтобы выделить состояние на фоне общего кода. К
состоянию прибегают только в крайних случаях. Если вы написали код на атомах без
уважительной причины, в лучшем случае вам сделают замечание. В худшем — не
примут код в проект.</p>

<p>В оставшейся части главы мы поиграем в адвоката дьявола — изучим особые
возможности Clojure. Язык предлагает несколько техник, чтобы изменять данные и
даже писать в императивном стиле. Мы рассмотрим, когда эти возможности
действительно нужны и как ими пользоваться.</p>

<h3 id="в-защиту-состояния">В защиту состояния</h3>

<p>Выше мы говорили, что состояние несет потенциальные ошибки. Это слишком линейное
заявление. Без состояния работают только небольшие, чаще учебные
программы. Например, скрипты, которые запускают раз в неделю. Но писать
промышленный код без состояния невозможно.</p>

<p>Неизменяемые данные избавляют нас от нужды переписывать поля классов и
словарей. Это значимый выигрыш, но кроме внутренних данных приложение завязано
на сторонних ресурсах, например, базе данных и файлах. В их отношении действует
правило: гораздо дешевле работать с открытым ресурсом, чем каждый раз открывать
и закрывать его. В общих словах, состояние повышает скорость.</p>

<p>Много лет назад веб-серверы работали по протоколу CGI, Common Gateway
Interface. Получив запрос, сервер запускал в отдельном процессе скрипт или
бинарный файл. Входные параметры передавались через переменные среды. Программа
считывала их, выполняла логику и писала ответ в стандартный поток. Сервер
перехватывал поток и выводил пользователю.</p>

<p>Схема была простой и удобной. Приложение могло быть скриптом на Perl,
shell-сценарием или бинарным файлом. У сервера не было состояния. Разработчик в
любой момент менял файл на новый, и изменения вступали в силу немедленно.</p>

<p>За преимущества платили скоростью. Каждый запрос к серверу порождал новый
процесс. Даже если программа написана на C, запуск нового процесса это дорогая
операция. Через протокол FastCGI и аналоги индустрия пришла к тому, что
приложение должно жить в памяти постоянно, а не по запросу.</p>

<p>Типичное FastCGI-приложение работало как самостоятельный сервер. Его
производительность была на два порядка выше, чем у CGI. Но теперь появилось
состояние — открытый порт и цикл ввода-вывода. Этот цикл читал запрос,
делегировал его отдельному треду и передавал ответ пользователю. Это усложнило
разработку, потребовало новых фреймворков и подходов.</p>

<p>По той же модели работают соединения с базами данных. Представим, что на каждый
запрос мы открываем соединение с базой, работаем с ней и закрываем. В рамках
машинного времени открыть новое соединение это долгая операция. Так появились
пулы соединений.</p>

<p>Пул это особый объект, который держит несколько открытых соединений. Пул знает,
какое из них в данный момент занято или свободно. Чтобы работать с базой, мы
занимаем одно из свободных соединений, передаем по нему данные, а затем
возвращаем обратно. С точки зрения наблюдателя пул — это примитивный объект,
который выдает и забирает соединения.</p>

<p>Внутренняя логика пула может быть очень сложной. Если соединений не хватает, он
увеличивает свою емкость, а при избытке сокращает. Для каждого соединения пул
считает время работы и сколько раз им пользовались. Он же решает, когда следует
закрыть соединение и заменить его новым. Логика пула работает в отдельном треде,
чтобы не блокировать основную программу.</p>

<p>Столь сложное устройство пула оправдано скоростью доступа. Теперь каждый запрос
к базе протекает по заранее открытому соединению, что намного быстрее, чем
открывать его каждый раз.</p>

<p>Наконец, сама архитектура современных систем поощряет изменять данные. В
начальной школе нам объясняют устройство памяти как массив ячеек. Запись нового
значения в ячейку по адресу считается дешевой операцией. И в C++, и в Python
одинаково легко обновить элемент массива:</p>

<p>items[4] = 5;</p>

<p>Неизменяемые структуры ложатся на современную модель памяти хуже. Этим
объясняется их сложность. Типичный неизменяемый список это дерево узлов с
внутренним указателем. Его устройство гораздо сложнее линейного массива
ячеек. Неизменяемые коллекции достаточно умны, чтобы при изменении копировать
данные не полностью, а лишь частично. Но при больших объемах данных выгоднее
работать с изменяемыми структурами.</p>

<p>Сказанное выше не отменяет достоинства постоянных коллекций. Автор не призывает
пользоваться состоянием повсеместно. Это обратная сторона медали, цена, которую
мы платим за удобство. Разработчик должен знать, на что идет, когда добавляет в
проект состояние или избавляется от него.</p>

<h2 id="атомы">Атомы</h2>

<p>Clojure предлагает несколько способов изменять данные. Самый простой из них —
атом. Это объект, который прячет внутри себя другой объект. Чтобы создать атом,
достаточно вызвать одноименную функцию с начальным значением:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">42</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Если напечатать атом, увидим примерно следующее:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#&lt;Atom@10ed2e87: 42&gt;
</code></pre></div></div>

<p>Чтобы извлечь значение <code class="language-plaintext highlighter-rouge">42</code>, применяют оператор <code class="language-plaintext highlighter-rouge">@</code>. Запись <code class="language-plaintext highlighter-rouge">@store</code> это
укороченный вариант <code class="language-plaintext highlighter-rouge">(deref store)</code>. Функция <code class="language-plaintext highlighter-rouge">deref</code> принимает атом и возвращает
его внутренний объект. Семантически это то же самое, что получить значение по
указателю. В русской литературе эту операцию называют “разыменование”. В
разговорном языке оператор <code class="language-plaintext highlighter-rouge">@</code> называют “дереф”, “дерефнуть”.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">store</span><span class="w"> </span><span class="c1">;; 42</span><span class="w">
</span></code></pre></div></div>

<p>В отличии от коллекций, атом меняет содержимое. При этом он остается тем самым
атомом. Это важное отличие. Если добавить к словарю ключ, получим новый словарь,
при этом старый не изменится. Если изменить содержимое атома, это будет все тот
же атом с номером 10ed2e87.</p>

<p>Наивный способ изменить атом заключается в функции <code class="language-plaintext highlighter-rouge">reset!</code>. Она принимает атом
и другое значение. Оно может быть любого типа, в том числе nil, коллекцией или
Java-объектом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="p">{</span><span class="no">:items</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]})</span><span class="w">
</span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"error"</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">42</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Если выполнить <code class="language-plaintext highlighter-rouge">@store</code> после каждого выражения, получим то же значение, что
передали в <code class="language-plaintext highlighter-rouge">reset!</code>. Это <code class="language-plaintext highlighter-rouge">nil</code>, словарь, исключение.</p>

<h3 id="приращение-атома">Приращение атома</h3>

<p>Мы назвали <code class="language-plaintext highlighter-rouge">reset!</code> наивным, потому что функция не учитывает текущее значение
атома. На практике атом изменяют, отталкиваясь от его содержимого. Например,
если это счетчик, то нам неважно, какое значение в нем сейчас. Мы посылаем атому
команду “прибавь к содержимому единицу”. Если это вектор, то сообщение выглядит
как “добавь к содержимому новый элемент”.</p>

<p>Значение атома уходит на второй план. Нас интересует действие, функция. Чтобы
обновить атом с учетом текущего состояния, мы посылаем атому функцию. Она
принимает текущее значение атома и возвращает новое. Это новое значение заменит
содержимое атома.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">swap!</code> принимает атом и другую функцию, которая рассчитывает новое
значение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w"> </span><span class="c1">;; 1</span><span class="w">
</span></code></pre></div></div>

<p>Если повторять вызов <code class="language-plaintext highlighter-rouge">swap!</code>, значение <code class="language-plaintext highlighter-rouge">counter</code> каждый раз увеличится на
единицу.</p>

<p><code class="language-plaintext highlighter-rouge">Swap!</code> принимает дополнительные параметры для расчета. Например, мы хотим
увеличить счетчик сразу на три позиции или отмотать его назад. Очевидно, функция
<code class="language-plaintext highlighter-rouge">inc</code> здесь не поможет.</p>

<p>Возникает вопрос о приращении и как его передать. Воспользуемся сложением и
вычитанием. Первым аргументом станет текущее значение атома, а второй аргумент
мы передаем в <code class="language-plaintext highlighter-rouge">swap!</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">;; increase by 3</span><span class="w">
</span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">;; decrease by 2</span><span class="w">
</span></code></pre></div></div>

<p>Новое содержимое атома рассчитано по принципу:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">&lt;current&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">&lt;current&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>, где <code class="language-plaintext highlighter-rouge">&lt;current&gt;</code> это текущее значение атома.</p>

<p>Пример выше это частный случай <code class="language-plaintext highlighter-rouge">swap!</code> с одним аргументом. В общем случае
функция принимает их неограниченное количество:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="n">arg3</span><span class="w"> </span><span class="n">arg4</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Тогда новое значение вычисляется формой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">func</span><span class="w"> </span><span class="n">&lt;current&gt;</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="n">arg3</span><span class="w"> </span><span class="n">arg4</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>До сих пор мы хранили в атомах счетчики, то есть обычные числа. Но на практике
редко считают только одну сущность. Гораздо чаще встречаются счетчики в разрезе
чего-то. Например, просмотры страниц по адресам, количество сообщений у
пользователя и так далее.</p>

<p>Чтобы не создавать по атому на каждую сущность, используют один со словарем
внутри. Рассмотрим подсчет системных ресурсов. Это атом, внутри которого
словарь. Ключи означают тип ресурса, значения — степень потребления в байтах или
процентах.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">usage</span><span class="w">
  </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{</span><span class="no">:cpu</span><span class="w"> </span><span class="mi">35</span><span class="w">
         </span><span class="no">:store</span><span class="w"> </span><span class="mi">63466734</span><span class="w">
         </span><span class="no">:memory</span><span class="w"> </span><span class="mi">10442856</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Отдельная функция вычисляет потребление диска. Чтобы записать новое значение в
атом по ключу <code class="language-plaintext highlighter-rouge">:store</code>, вызовем <code class="language-plaintext highlighter-rouge">swap!</code> со следующими параметрами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-used-store</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">rand-int</span><span class="w"> </span><span class="mi">99999999</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">store</span><span class="w"> </span><span class="p">(</span><span class="nf">get-used-store</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="nb">assoc</span><span class="w"> </span><span class="no">:store</span><span class="w"> </span><span class="n">store</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Эта форма перепишет значение в <code class="language-plaintext highlighter-rouge">:store</code> на новое. Возможен и другой подход,
когда мы не вычисляем все занятое место на диске, а фиксируем разницу на каждое
изменение файловой системы. Например, если пользователь создал или удалил файл,
мы перехватываем это событие и обновляем <code class="language-plaintext highlighter-rouge">:store</code> с приращением.</p>

<p>Пусть функция <code class="language-plaintext highlighter-rouge">get-file-event</code> каким-то образом получает последнее событие,
связанное с файловой системой. Это словарь с ключами <code class="language-plaintext highlighter-rouge">:action</code> и <code class="language-plaintext highlighter-rouge">:size</code>. В
зависимости от <code class="language-plaintext highlighter-rouge">:action</code> мы наращиваем или уменьшаем потребление диска.</p>

<p>Наша версия <code class="language-plaintext highlighter-rouge">get-file-event</code> будет заглушкой, которая случайно возвращает одно
из двух событий:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-file-event</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">rand-nth</span><span class="w">
   </span><span class="p">[{</span><span class="no">:action</span><span class="w"> </span><span class="no">:delete</span><span class="w">
     </span><span class="no">:path</span><span class="w"> </span><span class="s">"/path/to/deleted/file.txt"</span><span class="w">
     </span><span class="no">:size</span><span class="w"> </span><span class="mi">563467</span><span class="p">}</span><span class="w">
    </span><span class="p">{</span><span class="no">:action</span><span class="w"> </span><span class="no">:create</span><span class="w">
     </span><span class="no">:path</span><span class="w"> </span><span class="s">"/path/to/new/photo.jpg"</span><span class="w">
     </span><span class="no">:size</span><span class="w"> </span><span class="mi">7345626</span><span class="p">}]))</span><span class="w">
</span></code></pre></div></div>

<p>Тогда логика пересчета выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">action</span><span class="w"> </span><span class="n">size</span><span class="p">]}</span><span class="w"> </span><span class="p">(</span><span class="nf">get-file-event</span><span class="p">)]</span><span class="w">

  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="no">:delete</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="no">:store</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w">

    </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="no">:create</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="no">:store</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="n">size</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>По такому принципу считают ресурсы в облачных платформах. Обращение к диску это
дорогая операция. Мы не можем в любой момент пробежаться по дереву папок и
посчитать суммарное потребление. Иногда файлы одного пользователя хранятся на
разных дисках и серверах. Поэтому ресурсы считают итеративно, мелкими
изменениями и раз в определенный интервал сверяют данные.</p>

<p>Усложним пример с ресурсами. Теперь мы считаем их в разрезе пользователей. Ключи
верхнего уровня означают номер пользователя, а значения — словари ресурсов. Для
каждого пользователя фиксируем список запущенных процессов. Это множество их
идентификаторов, <code class="language-plaintext highlighter-rouge">PID</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">usage-all</span><span class="w">
  </span><span class="p">(</span><span class="nf">atom</span><span class="w">
   </span><span class="p">{</span><span class="mi">1005</span><span class="w"> </span><span class="p">{</span><span class="no">:cpu</span><span class="w"> </span><span class="mi">35</span><span class="w">
          </span><span class="no">:store</span><span class="w"> </span><span class="mi">63466734</span><span class="w">
          </span><span class="no">:memory</span><span class="w"> </span><span class="mi">10442856</span><span class="w">
          </span><span class="no">:pids</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">6266</span><span class="n">,</span><span class="w"> </span><span class="mi">5426</span><span class="n">,</span><span class="w"> </span><span class="mi">6542</span><span class="p">}}}))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы добавить новый процесс пользователю 1005, выполним следующий <code class="language-plaintext highlighter-rouge">swap!</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">usage-all</span><span class="w"> </span><span class="n">update-in</span><span class="w"> </span><span class="p">[</span><span class="mi">1005</span><span class="w"> </span><span class="no">:pids</span><span class="p">]</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="mi">9999</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Это двойное комбо: мы передали в <code class="language-plaintext highlighter-rouge">swap!</code> функцию, которая принимает функцию. В
данном случае это <code class="language-plaintext highlighter-rouge">update-in</code> и <code class="language-plaintext highlighter-rouge">conj</code>. Выразим эту емкую запись по шагам:</p>

<ul>
  <li>
    <p>получим множество процессов <code class="language-plaintext highlighter-rouge">&lt;pids&gt;</code>: <code class="language-plaintext highlighter-rouge">(get-in &lt;current&gt; [1005 :pids])</code>;</p>
  </li>
  <li>
    <p>добавим к нему новый процесс: <code class="language-plaintext highlighter-rouge">(conj &lt;pids&gt; 9999)</code>. Обозначим новое множество
через <code class="language-plaintext highlighter-rouge">&lt;pids*&gt;</code>;</p>
  </li>
  <li>
    <p>обновим <code class="language-plaintext highlighter-rouge">&lt;current&gt;</code> новым множеством: <code class="language-plaintext highlighter-rouge">(assoc-in &lt;current&gt; [1005 :pids]
&lt;pids*&gt;)</code>.</p>
  </li>
</ul>

<p>Чтобы удалить процесс, достаточно заменить <code class="language-plaintext highlighter-rouge">conj</code> на <code class="language-plaintext highlighter-rouge">disj</code>. Это противоположная
функция: она удаляет элемент из множества.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">usage-all</span><span class="w"> </span><span class="n">update-in</span><span class="w"> </span><span class="p">[</span><span class="mi">1005</span><span class="w"> </span><span class="no">:pids</span><span class="p">]</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="mi">9999</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Очевидно, что <code class="language-plaintext highlighter-rouge">swap!</code> мощнее <code class="language-plaintext highlighter-rouge">reset!</code>. Последний используют редко, в основном
чтобы сбросить атом в исходное значение. В остальных случаях важно знать текущее
значение атома. Относительно него мы рассчитываем новое значение.</p>

<h3 id="совместный-доступ">Совместный доступ</h3>

<p>Функция, которую передают в <code class="language-plaintext highlighter-rouge">swap!</code>, должна быть без сторонних эффектов. В
терминах функционального программирования ее бы назвали чистой функцией. Она не
должна обращаться к базе данных, файлам, потоку вывода на экран. Технически это
возможно, но тогда вы столкнетесь со странным поведением программы. Иногда
функция, переданная в <code class="language-plaintext highlighter-rouge">swap!</code>, выполяется несколько раз. Причина кроется в
способе, которым атом обновляет содержимое.</p>

<p>Предположим, сразу несколько потоков работают с атомом. Пусть это будет
распределенный подсчет ресурсов. Один поток слушает события файловой системы и
обновляет потребление диска. Другой мониторит запущенные процессы, подсчитывает
свободную память и так далее.</p>

<p>Возникает проблема совместного доступа к ресурсу. Возможна ситуация, когда оба
потока начали обновлять одни и те же данные. Первый поток справился быстрее и
записал в атом свою версию данных. Но второй поток рассчитывает собственную
версию относительно исходных данных. Когда второй поток изменит атом, действие
первого аннулируется.</p>

<p>Это классическая задача про терминал и семейную пару. Муж и жена одновременно
вносят наличные на общий счет. На начальном этапе счет пуст. Жена вносит 100
рублей, терминал прибавляет эту сумму к нулю и записывает в базу. Муж вносит 50
рублей, терминал делает то же самое. Итого на счете 50 рублей, а 100 пропали.</p>

<p>Атом достаточно умен, чтобы не допустить такого поведения. Он запоминает свое
внутреннее значение на момент вычисления нового. Назовем это значение
начальным. Перед тем как обновить содержимое, атом проверяет, что текущее
значение совпадает с начальным. Если они не равны, это значит, что атом обновили
из другого потока.</p>

<p>В таком случае атом повторяет цикл. Текущее становится начальным, от него
рассчитывается новое значение. Атом снова сравнивает текущее и начальное
значения. Цикл повторяется до тех пор, пока они не равны. Это значит, что за
время вычислений атом никто не обновил. Атом меняет текущее значение на новое,
цикл закончен.</p>

<p>Покажем сказанное на примере. Имеем атом со словарем:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{</span><span class="no">:number</span><span class="w"> </span><span class="mi">0</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Объявим функцию медленного сложения. Она принимает число, приращение и время
простоя. Чтобы было ясно, в какой момент она работает, добавим вывод в консоль.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">+slow</span><span class="w">
  </span><span class="p">[</span><span class="n">num</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="n">timeout</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Current: %s, timeout: %s"</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="n">timeout</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="n">timeout</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="n">delta</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Обновим атом одновременно из двух тредов. В первом треде функция спит две
секунды, во втором пять:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">do</span><span class="w">
  </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="no">:number</span><span class="w"> </span><span class="n">+slow</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2000</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="no">:number</span><span class="w"> </span><span class="n">+slow</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5000</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Спустя некоторое время проверим атом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">sample</span><span class="w"> </span><span class="c1">;; {:number 3}</span><span class="w">
</span></code></pre></div></div>

<p>Это правильное значение. Вывод консоли:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Current: 0, timeout: 2000
Current: 0, timeout: 5000
Current: 1, timeout: 5000
</code></pre></div></div>

<p>Видим, что вторая функция выполнена два раза. Это в точности следует алгоритму
выше. Второй <code class="language-plaintext highlighter-rouge">swap!</code> начал расчеты с начальным значением <code class="language-plaintext highlighter-rouge">{:number 0}</code>, а к их
завершению значение атома стало <code class="language-plaintext highlighter-rouge">{:number 1}</code>. Такое значение уже записал первый
<code class="language-plaintext highlighter-rouge">swap!</code>. Чтобы избежать ошибки, атом запустил второй <code class="language-plaintext highlighter-rouge">swap!</code> повторно
относительно <code class="language-plaintext highlighter-rouge">{:number 1}</code>.</p>

<p>Когда атом меняют из нескольких потоков, перезапуск функции случается больше
двух раз. Это недопустимое поведение для базы данных или сетевых сервисов. Вот
почему функция не должна обращаться к сторонним ресурсам.</p>

<h3 id="валидаторы-и-вотчеры">Валидаторы и вотчеры</h3>

<p>Поведение атомов расширяют валидаторы и вотчеры (анг. watcher,
наблюдатель). Валидаторы это функции-предикаты. Они принимают новое значение
атома <em>до того</em>, как оно записано в текущее. Если валидатор вернул ложь, вызов
<code class="language-plaintext highlighter-rouge">swap!</code> завершается ошибкой.</p>

<p>Чтобы добавить валидатор к атому, используют функцию <code class="language-plaintext highlighter-rouge">set-validator!</code>. В случае
с счетчиком предположим, что он не может быть отрицательным. Попытка понизить
его в нулевом состоянии вызовет исключение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">set-validator!</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="p">(</span><span class="nb">complement</span><span class="w"> </span><span class="nb">neg?</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="nb">dec</span><span class="p">)</span><span class="w"> </span><span class="c1">;; repeat 3 times...</span><span class="w">
</span><span class="c1">;; Execution error (IllegalStateException) at ...</span><span class="w">
</span><span class="c1">;; Invalid reference state</span><span class="w">
</span></code></pre></div></div>

<p>Вотчеры это побочные эффекты атома. Они срабатывают <em>после того</em>, как атом
перешел в новое состояние. Вотчер связан с уникальным ключом и функцией. Эта
функция принимает четыре аргумента: ключ, атом, старое и новое значения. Одному
атому можно назначить несколько вотчеров.</p>

<p>Разберемся, когда полезны вотчеры. Вспомним пример с подсчетом ресурсов. Система
получает события извне и обновляет атом. В отличии от валидации счетчика, мы не
можем бросить исключение, если потребление памяти или диска превысило лимит. В
этом нет смысла, потому что события поступают из внешней системы. Выброс
исключения на нашей стороне не остановит новые события.</p>

<p>Логично вынести проверку потребления в вотчер. Если один из ресурсов превысил
порог, вотчер совершит нужные действия. Например, уведомит пользователя письмом,
что ресурс исчерпан. Или направит запрос в другую подсистему, чтобы
приостановить загрузку файлов для этого пользователя.</p>

<p>В упрощенном примере мы пишем ошибку в лог, если потребление превысло
лимит. Объявим функцию вотчера:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.tools.logging</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">log</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">STORE_LIMIT</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="mi">25</span><span class="p">))</span><span class="w"> </span><span class="c1">;; 25 Gb</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">store-watcher</span><span class="w">
  </span><span class="p">[</span><span class="n">_key</span><span class="w"> </span><span class="n">_atom</span><span class="w"> </span><span class="n">_old</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w">

  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">store</span><span class="p">]}</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="n">STORE_LIMIT</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">log/errorf</span><span class="w"> </span><span class="s">"Disk usage %s has reached the limit %s"</span><span class="w">
                  </span><span class="n">store</span><span class="w"> </span><span class="n">STORE_LIMIT</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что из четырех параметров мы используем только последний,
новое значение атома. Было бы правильно назначить первым трем символы
подчеркивания. Это предотвращает связывание лишних переменных и потому работает
быстрее. Но мы оставили имена для семантики.</p>

<p>Назначим вотчер атому с ключом <code class="language-plaintext highlighter-rouge">:store</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">usage</span><span class="w">
  </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{</span><span class="no">:cpu</span><span class="w"> </span><span class="mi">35</span><span class="w">
         </span><span class="no">:store</span><span class="w"> </span><span class="mi">63466734</span><span class="w">
         </span><span class="no">:memory</span><span class="w"> </span><span class="mi">10442856</span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="nf">add-watch</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="no">:store</span><span class="w"> </span><span class="n">store-watcher</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Если потребление диска превысит лимит, увидим запись в лог:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="no">:store</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="n">STORE_LIMIT</span><span class="p">)</span><span class="w">
</span><span class="c1">;; Disk usage 26907012334 has reached the limit 26843545600</span><span class="w">
</span></code></pre></div></div>

<p>Валидацию и вотчеры рассматривают как пре- и пост-эффекты. Разница в том, что
первые могут прервать дальнейшее исполнение, а вторые нет. У них разная
семантика. Предварительные эффекты проверяют то, что может случиться, а
постэффекты — то, что уже случилось. Поэтому на них реагируют по-разному.</p>

<h3 id="другие-примеры">Другие примеры</h3>

<p>Мы уже уточнили, что атомы не нужны для обработки коллекций. Clojure предлагает
десятки функций для обхода и преобразования одних коллекций в другие. Атом рядом
с коллекцией говорит о слабом решении.</p>

<p>Читатель возразит, что выше мы использовали атом, чтобы обновить словарь
ресурсов. Это не совсем верно. Если бы требовалось получить новую коллекцию, мы
бы использовали <code class="language-plaintext highlighter-rouge">update</code> или <code class="language-plaintext highlighter-rouge">assoc</code>. Настоящая цель в том, чтобы обеспечить
доступ к одной и той же коллекции из разных частей кода. В этом и есть
предназначение атома: контроллировать доступ к неизменяемым объектам.</p>

<p>На атомы опираются некоторые из стандартных функций Clojure, например,
<code class="language-plaintext highlighter-rouge">memoize</code>. Это декоратор, который возвращает улучшенную версию функции. Такая
функция запоминает свой результат относительно аргументов и записывает во
внутреннюю таблицу. Если вызвать функцию с теми же аргументами, функция вернет
результат из таблицы без вычислений.</p>

<p>Роль таблицы играет атом. Функция-результат <code class="language-plaintext highlighter-rouge">memoize</code> замкнута относительно
атома, который виден только ей. Вот как выглядит декоратор:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">memoize</span><span class="w">
  </span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">mem</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{})]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nb">find</span><span class="w"> </span><span class="o">@</span><span class="n">mem</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">val</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
          </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="nb">assoc</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="n">ret</span><span class="p">)</span><span class="w">
          </span><span class="n">ret</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Может показаться странным, что для поиска в словаре авторы пользуются <code class="language-plaintext highlighter-rouge">find</code>
вместо <code class="language-plaintext highlighter-rouge">get</code>. Разница в том, как функции трактуют пустое значение. Если по ключу
записан <code class="language-plaintext highlighter-rouge">nil</code>, то get тоже вернет <code class="language-plaintext highlighter-rouge">nil</code>, и форма <code class="language-plaintext highlighter-rouge">if-let</code> выполнит вторую
ветку. Но <code class="language-plaintext highlighter-rouge">find</code> вернет особую сущность <code class="language-plaintext highlighter-rouge">MapEntry</code>, значение из которой
извлекают функцией <code class="language-plaintext highlighter-rouge">val</code>.</p>

<p>Убедимся, что декоратор работает на функции <code class="language-plaintext highlighter-rouge">+slow</code>, которую мы объявили
выше. Объявим аналог этой функции с кешем и замерим вызовы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">+mem</span><span class="w"> </span><span class="p">(</span><span class="nf">memoize</span><span class="w"> </span><span class="n">+slow</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">time</span><span class="w"> </span><span class="p">(</span><span class="nf">+mem</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2000</span><span class="p">))</span><span class="w">
</span><span class="s">"Elapsed time: 2004.699832 msecs"</span><span class="w">

</span><span class="p">(</span><span class="nb">time</span><span class="w"> </span><span class="p">(</span><span class="nf">+mem</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2000</span><span class="p">))</span><span class="w">
</span><span class="s">"Elapsed time: 0.078052 msecs"</span><span class="w">
</span></code></pre></div></div>

<p>Первый вызов долгий, а второй и последующие с теми же аргументами — быстрые.</p>

<p>Атомы используют в веб-разработке. Это дешевый способ хранить состояние между
запросами. На атомах легко сделать счетчики просмотров, сессии, кеши. Вот так,
например, выглядит счетчик просмотренных страниц. Это комбинация из атома и
middleware:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">page-counter</span><span class="w">
  </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{</span><span class="s">"/"</span><span class="w"> </span><span class="mi">0</span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-page-counter</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">request-method</span><span class="w"> </span><span class="n">uri</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">request-method</span><span class="w"> </span><span class="no">:get</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">page-counter</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">uri</span><span class="w"> </span><span class="p">(</span><span class="nf">fnil</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">request</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>На каждый GET-запрос мы увеличиваем счетчик для текущего адреса. Обратите
внимание на форму <code class="language-plaintext highlighter-rouge">fnil</code>, которую мы передаем в update. Она возвращает особую
версию <code class="language-plaintext highlighter-rouge">inc</code>, которая не вызовет исключение, если первый аргумент был
<code class="language-plaintext highlighter-rouge">nil</code>. Такое возможно, когда в словаре еще нет нужного ключа. Тогда вместо <code class="language-plaintext highlighter-rouge">nil</code>
будет передан ноль.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">page-seen</code> возвращает число просмотров по адресу страницы. Как ей
пользоваться зависит от способа, которым сервер генерирует HTML-разметку. Если
это hiccup-подобная структура, то компонент подвала выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-seen</span><span class="w">
  </span><span class="p">[</span><span class="n">uri</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="o">@</span><span class="n">page-counter</span><span class="w"> </span><span class="n">uri</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">footer</span><span class="w">
  </span><span class="p">[</span><span class="n">uri</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"footer"</span><span class="p">}</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">seen</span><span class="w"> </span><span class="p">(</span><span class="nf">page-seen</span><span class="w"> </span><span class="n">uri</span><span class="p">)]</span><span class="w">
     </span><span class="p">[</span><span class="no">:p</span><span class="w"> </span><span class="s">"This page has been seen "</span><span class="w"> </span><span class="n">seen</span><span class="w"> </span><span class="s">" times."</span><span class="p">])])</span><span class="w">
</span></code></pre></div></div>

<p>Решения на атомах подвержены следующим недостаткам. Они локальны, то есть не
связаны с другими экземплярами программы. Если веб-приложение состоит из
нескольких нод, то каждая хранит собственный счетчик. Поэтому на каждый запрос
пользователь видит разные данные. Чтобы избежать странного поведения, данные
хранят в сетевых централизованных сервисах, например, Redis.</p>

<p>Атомы не постоянны. Если завершить программу, они теряют состояние. Допустим
вариант, когда атом читает начальные данные из ресурса и время от времени
сохраняет состояние в ресурс.</p>

<h2 id="volatile">Volatile</h2>

<p>На первый взгляд атом работает просто. С точки зрения разработчика это несколько
удобных функций. Но внутри атом довольно сложен. Он регулирует параллельный
доступ к значению, вызывает валидацию и отслеживает изменения. Иногда эти
возможности излишни. Когда требуется только менять значение, пользуются
упрощенной версией атома — <code class="language-plaintext highlighter-rouge">volatile</code>.</p>

<p>Объект <code class="language-plaintext highlighter-rouge">volatile</code> тоже хранит и изменяет внутреннее значение. Одноименная
функция создает объект с начальным состоянием. Функции <code class="language-plaintext highlighter-rouge">vreset!</code> и <code class="language-plaintext highlighter-rouge">vswap!</code>
аналогичным тем, что мы рассматривали для атома. Префикс <code class="language-plaintext highlighter-rouge">v</code> означает, что они
работают для <code class="language-plaintext highlighter-rouge">volatile</code>.</p>

<p>Пример с ресурсами. Вместо атома используем другой тип хранилища:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">vusage</span><span class="w">
  </span><span class="p">(</span><span class="nf">volatile!</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">vreset!</span><span class="w"> </span><span class="n">vusage</span><span class="w">
         </span><span class="p">{</span><span class="no">:cpu</span><span class="w"> </span><span class="mi">35</span><span class="w">
          </span><span class="no">:store</span><span class="w"> </span><span class="mi">63466734</span><span class="w">
          </span><span class="no">:memory</span><span class="w"> </span><span class="mi">10442856</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">vswap!</span><span class="w"> </span><span class="n">vusage</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="no">:store</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Disk usage is"</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="o">@</span><span class="n">vusage</span><span class="w"> </span><span class="no">:store</span><span class="p">))</span><span class="w">
</span><span class="c1">;; Disk usage is 68709614</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Volatile</code> отличается от атома тем, что не контролирует запись из нескольких
тредов. Перепишем пример с двумя потоками:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">vsample</span><span class="w"> </span><span class="p">(</span><span class="nf">volatile!</span><span class="w"> </span><span class="p">{</span><span class="no">:number</span><span class="w"> </span><span class="mi">0</span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="nf">do</span><span class="w">
  </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">vswap!</span><span class="w"> </span><span class="n">vsample</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="no">:number</span><span class="w"> </span><span class="n">+slow</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2000</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">vswap!</span><span class="w"> </span><span class="n">vsample</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="no">:number</span><span class="w"> </span><span class="n">+slow</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5000</span><span class="p">)))</span><span class="w">

</span><span class="c1">;; Current: 0, timeout: 2000</span><span class="w">
</span><span class="c1">;; Current: 0, timeout: 5000</span><span class="w">

</span><span class="o">@</span><span class="n">vsample</span><span class="w"> </span><span class="c1">;; {:number 2}</span><span class="w">
</span></code></pre></div></div>

<p>Вывод консоли говорит, что, во-первых, вторая операция сработала один
раз. Во-вторых, результат первого треда утерян. Если для атома итоговое число
было 3, то в случае с <code class="language-plaintext highlighter-rouge">volatile</code> это 2. Операцию <code class="language-plaintext highlighter-rouge">+1</code> мы просто потеряли. Из
этого следует, что <code class="language-plaintext highlighter-rouge">volatile</code> не подходит для многопоточного кода.</p>

<p>Валидаторы и вотчеры не работают для volatile. Это освобождает его от слежки за
содержим. Запись без проверок и пост-эффектов работает быстрее.</p>

<h3 id="применение">Применение</h3>

<p>У <code class="language-plaintext highlighter-rouge">volatile</code> две области применения — трансдьюсеры и императивный
код. Трансдьюсеры это особый способ обработки коллекций. Они оборачивают
стандартные функции <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">reduce</code> и другие таким образом, что их комбинация не
порождает промежуточных коллекций. Технически это это возможно за счет
внутреннего состояния.</p>

<p>Трансдьюсер на раскрывает состояние внешнему миру. Он заинтересован не в
валидации и побочных эффектах, а в скорости записи. Поэтому <code class="language-plaintext highlighter-rouge">volatile</code> подходит
на роль состояния лучше, чем атом. В этой главе мы не будем касаться
трансдьюсеров. Это отдельная тема, которую мы рассмотрим в главе про коллекции.</p>

<p><code class="language-plaintext highlighter-rouge">Volatile</code> полезен, когда мы пишем императивный код. Это случается, и к этому
следует относиться спокойно. Иногда бизнес-требования слишком сложны и
противоречивы. Накладывать их на функциональный стиль становится слишком дорого.</p>

<p>Например, дана задача получить плоскую структуру из дерева. Оно устроено по
сложным правилам: если в первой ветке одно значение, то рассматривать вторую, а
иначе третью. И дальше: если для первой и третьей веток справедливо условие <code class="language-plaintext highlighter-rouge">X</code>,
положить в список произведение их значений.</p>

<p>Эти требования насквозь императивны, и нам выгодно описать их таким же
образом. Так мы сделаем код ближе к бизнес-логике и облегчим поддержку.</p>

<p>Пример с малым подмножеством такого дерева:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w">
  </span><span class="p">{</span><span class="no">:items</span><span class="w"> </span><span class="p">[{</span><span class="no">:result</span><span class="w"> </span><span class="p">{</span><span class="no">:value</span><span class="w"> </span><span class="mi">74</span><span class="p">}}</span><span class="w">
           </span><span class="p">{</span><span class="no">:result</span><span class="w"> </span><span class="p">{</span><span class="no">:value</span><span class="w"> </span><span class="mi">74</span><span class="p">}}]</span><span class="w">
   </span><span class="no">:records</span><span class="w"> </span><span class="p">[{</span><span class="no">:usage</span><span class="w"> </span><span class="mi">99</span><span class="w"> </span><span class="no">:date</span><span class="w"> </span><span class="s">"2018-09-09"</span><span class="p">}</span><span class="w">
             </span><span class="p">{</span><span class="no">:usage</span><span class="w"> </span><span class="mi">52</span><span class="w"> </span><span class="no">:date</span><span class="w"> </span><span class="s">"2018-11-05"</span><span class="p">}]})</span><span class="w">
</span></code></pre></div></div>

<p>Код обработки похож на набор блоков, где каждый блок это каскад when-let. На
нижнем уровне каскада мы изменяем коллекцию. Это императивный стиль, но в данном
случае он удобен. Если одно из правил вдруг потеряет актуальность, достаточно
удалить блок. Удобно, когда над блоком пишут комментарий с ссылкой на
документацию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">volatile!</span><span class="w"> </span><span class="p">[])]</span><span class="w">

  </span><span class="c1">;; see section 5.4 from the doc: http://...</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="no">:items</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="no">:result</span><span class="w"> </span><span class="no">:value</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="no">:records</span><span class="w"> </span><span class="nb">last</span><span class="w"> </span><span class="no">:usage</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">vswap!</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)))))</span><span class="w">

  </span><span class="c1">;; more and more expressions</span><span class="w">
  </span><span class="o">@</span><span class="n">result</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h2 id="переходные-коллекции">Переходные коллекции</h2>

<p>С помощью атома мы создали подобие изменяемых коллекций. Получилась устойчивая
модель: постоянная коллекция и особый объект, чтобы менять содержимое. С новой
техникой данные можно менять и без атомов. Clojure предлагает настоящие
изменяемые коллекции. По-другому они называются <code class="language-plaintext highlighter-rouge">transient</code> (анг. временный,
переходный).</p>

<p>Изменяемые коллекции получают из их постоянных аналогов. Такая коллекция
поддерживает очень малый набор функций, буквально добавить и удалить
элемент. Стадартные <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code> и сотня других функций не работают с
transient-коллекциями. Происходит своего рода размен. Мы теряем мощь стандартной
библиотеки, но обретаем скорость и императивный подход.</p>

<p>Транзиентные коллекции в несколько раз быстрее постоянных. Исторически
компьютеры устроены так, что изменить ячейку памяти проще, чем выделить
новую. Неизменяемые структуры похожи на дерево коммитов с изменениями. Вставка в
дерево работает за несколько шагов. Их число либо постоянно, либо зависит от
размера дерева. В целом это медленней, чем переписать i-тый элемент массива.</p>

<p>Транзиентная коллекция это изменяемый слепок ее постоянной копии. В этом режиме
коллекцию меняют императивно. Когда алгоритм закончил работу, ее замораживают. В
результае получают неизменяемую коллекцию.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">transient</code> порождает переходную коллекцию из исходной. Для работы с ней
используют особые версии <code class="language-plaintext highlighter-rouge">conj!</code>, <code class="language-plaintext highlighter-rouge">assoc!</code>, <code class="language-plaintext highlighter-rouge">dissoc!</code> и другие. Функции изменяют
содержимое коллекции, а не возвращают их новую копию, как это делают обычные
<code class="language-plaintext highlighter-rouge">conj</code> и <code class="language-plaintext highlighter-rouge">assoc</code>.</p>

<h3 id="технические-детали">Технические детали</h3>

<p>Функция <code class="language-plaintext highlighter-rouge">persistent!</code> завершает жизненный цикл переходной коллекции. Она
возвращает ее постоянную копию. Одновременно функция запечатывает изменяемую
коллекцию, и ее становится невозможно обновить.</p>

<p>Рассмотрим пример с переходным вектором. На него действуют всего две функции:
<code class="language-plaintext highlighter-rouge">conj!</code> и <code class="language-plaintext highlighter-rouge">pop!</code>, добавить и убрать элемент из хвоста:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">items*</span><span class="w"> </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])]</span><span class="w">
  </span><span class="p">(</span><span class="nf">conj!</span><span class="w"> </span><span class="n">items*</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">conj!</span><span class="w"> </span><span class="n">items*</span><span class="w"> </span><span class="no">:b</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">pop!</span><span class="w"> </span><span class="n">items*</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">persistent!</span><span class="w"> </span><span class="n">items*</span><span class="p">))</span><span class="w">
</span><span class="c1">;; [1 2 3 :a]</span><span class="w">
</span></code></pre></div></div>

<p>Вариант со словарем и <code class="language-plaintext highlighter-rouge">assoc!</code> и <code class="language-plaintext highlighter-rouge">dissoc!</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">params*</span><span class="w"> </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="p">})]</span><span class="w">
  </span><span class="p">(</span><span class="nf">assoc!</span><span class="w"> </span><span class="n">params*</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">assoc!</span><span class="w"> </span><span class="n">params*</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">dissoc!</span><span class="w"> </span><span class="n">params*</span><span class="w"> </span><span class="no">:b</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">persistent!</span><span class="w"> </span><span class="n">params*</span><span class="p">))</span><span class="w">
</span><span class="c1">;; {:a 1, :c 3}</span><span class="w">
</span></code></pre></div></div>

<p>Читатель заметит, что имя изменяемой переменной заканчивается звездочкой. Это не
нарушает синтаксис Clojure. В отличии от других языков, в имени переменной могут
быть дефис, апостроф и другие символы. Считается хорошим тоном выделять особые
переменные штрихом или звездочкой. Поскольку к изменяемым переменным прибегают
редко, их считают особыми.</p>

<p>После того как коллекция заморожена, изменить ее невозможно. Следующий пример
бросает исключение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">params*</span><span class="w"> </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="p">})]</span><span class="w">
  </span><span class="p">(</span><span class="nf">assoc!</span><span class="w"> </span><span class="n">params*</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">persistent!</span><span class="w"> </span><span class="n">params*</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">assoc!</span><span class="w"> </span><span class="n">params*</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
    </span><span class="n">result</span><span class="p">))</span><span class="w">
</span><span class="c1">;; IllegalAccessError: Transient used after persistent! call</span><span class="w">
</span></code></pre></div></div>

<p>Поэтому форма <code class="language-plaintext highlighter-rouge">(persistent! &lt;mutable&gt;)</code>, как правило, замыкает блок с изменяемой
переменной.</p>

<p>Переходные коллекции помогают там, где нужен императивный подход. Выше мы
рассматривали случай с обходом сложного дерева. Тогда мы использовали <code class="language-plaintext highlighter-rouge">volatile</code>
в качестве аккумулятора данных. То же самое с транзиентным вектором:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result*</span><span class="w"> </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="p">[])</span><span class="w">
      </span><span class="n">push!</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="nf">conj!</span><span class="w"> </span><span class="n">result*</span><span class="w"> </span><span class="n">item</span><span class="p">))]</span><span class="w">

  </span><span class="c1">;; see section 5.4 from the doc: http://...</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="no">:items</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="no">:result</span><span class="w"> </span><span class="no">:value</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="no">:records</span><span class="w"> </span><span class="nb">last</span><span class="w"> </span><span class="no">:usage</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">push!</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)))))</span><span class="w">

  </span><span class="c1">;; more and more expressions</span><span class="w">
  </span><span class="p">(</span><span class="nf">persistent!</span><span class="w"> </span><span class="n">result*</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Пример демонстрирует еще одну технику. Чтобы не писать каждый раз <code class="language-plaintext highlighter-rouge">(conj!
result* item)</code>, мы вводим локальную функцию <code class="language-plaintext highlighter-rouge">push!</code>. Она замкнута на результате
и принимает только значение. Чтобы добавить элемент, достаточно вызвать <code class="language-plaintext highlighter-rouge">(push!
x)</code>. Это экономит код и скрывает детали реализации.</p>

<h3 id="итерация-с-изменением">Итерация с изменением</h3>

<p>Мы упоминали, что переходные коллекции быстрее постоянных. Это заметно на долгих
итерациях через <code class="language-plaintext highlighter-rouge">loop/recur</code>. Как правило, одна из переменных это
коллекция-результат. В каждом <code class="language-plaintext highlighter-rouge">recur</code> мы передаем ее копию, дополненную с
помощью <code class="language-plaintext highlighter-rouge">conj</code> или <code class="language-plaintext highlighter-rouge">assoc</code>.</p>

<p>Когда число итераций велико, прибегают к уловке. Вместо постоянной коллекции
передают ее транзиентный вариант. Тем самым итерацию ускоряют в 2-4 раза. С
точки зрения кода изменения минимальны. Достаточно учесть следующие пункты:</p>

<ul>
  <li>изменить тип результата на <code class="language-plaintext highlighter-rouge">(transient &lt;coll&gt;)</code>;</li>
  <li>вместо <code class="language-plaintext highlighter-rouge">conj</code> или <code class="language-plaintext highlighter-rouge">assoc</code> вызывать их аналоги: <code class="language-plaintext highlighter-rouge">conj!</code>, <code class="language-plaintext highlighter-rouge">assoc!</code>;</li>
  <li>вернуть персистентную коллекцию с помощью <code class="language-plaintext highlighter-rouge">persistent!</code>.</li>
</ul>

<p>Для дальнейших экспериментов объявим переменную nums, последовательность из
миллиона чисел:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">999999</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Пример наивной итерации с помощью <code class="language-plaintext highlighter-rouge">loop</code>. Результат — такой же вектор чисел:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="p">[]</span><span class="w">
       </span><span class="n">nums</span><span class="w"> </span><span class="n">nums</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">nums</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">nums</span><span class="p">))</span><span class="w">
    </span><span class="n">result</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Эти же вычисления с изменяемым вектором:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">result*</span><span class="w"> </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="p">[])</span><span class="w">
       </span><span class="n">nums</span><span class="w"> </span><span class="n">nums</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">nums</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">conj!</span><span class="w"> </span><span class="n">result*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">nums</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">persistent!</span><span class="w"> </span><span class="n">result*</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Число строк осталось прежним, изменилось имя переменной и некоторые
функции. Важно, что правки в <code class="language-plaintext highlighter-rouge">loop</code> не распространяются выше по коду. Говорят,
что рефакторинг изолирован внутри <code class="language-plaintext highlighter-rouge">loop</code>.</p>

<p>Это дает свободу действий. На ранних стадиях мы пишем код без изменяемых
коллекций. На стадии улучшения итерацию исправляют так, что внутренние данные
меняются. Если рефакторинг не затрагивают участки выше, оставляют ускоренный
вариант.</p>

<p>Макрос <code class="language-plaintext highlighter-rouge">time</code> выполняет тело и печатает затраченное время. Если обернуть в
<code class="language-plaintext highlighter-rouge">time</code> оба примера, получим следующие результаты:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; 166.688721 msecs</span><span class="w">
</span><span class="c1">;;  69.415038 msecs</span><span class="w">
</span></code></pre></div></div>

<p>Конкретные цифры зависят от оборудования, операционной системы и версии языка,
но разница в несколько раз сохраняется. Транзиентные коллекции действительно
быстрее постоянных аналогов.</p>

<p>Мутабельные коллекции работают для <code class="language-plaintext highlighter-rouge">reduce</code>. В других языках эта функция
называется <code class="language-plaintext highlighter-rouge">fold</code> или свертка. Центральной точкой в <code class="language-plaintext highlighter-rouge">reduce</code> становится
коллекция-аккумулятор. Строго говоря, аккумулятором может быть любой тип,
например, число для сложения. Но чаще всего это списки и словари.</p>

<p>Различают два способа начать свертку. Первый — когда роль аккумулятора играет
первый элемент коллекции. Для списка <code class="language-plaintext highlighter-rouge">1, 2, 3</code> и функции сложения им станет
единица. Второй — когда аккумулятор задают отдельным параметром. Например,
пустой вектор для списка удвоенных чисел.</p>

<p>Идея в том, чтобы передать в качестве аккумулятора изменяемую коллекцию. На
каждом шаге reduce изменять ее функциями <code class="language-plaintext highlighter-rouge">conj!</code> и аналогами. Сравним обычный
<code class="language-plaintext highlighter-rouge">reduce</code> с постоянной коллекцией:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">reduce</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w">
 </span><span class="p">[]</span><span class="w">
 </span><span class="n">nums</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>И его мутабельную версию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">persistent!</span><span class="w">
 </span><span class="p">(</span><span class="nb">reduce</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result*</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">conj!</span><span class="w"> </span><span class="n">result*</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="p">[])</span><span class="w">
  </span><span class="n">nums</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, форму reduce пришлось обернуть в <code class="language-plaintext highlighter-rouge">persistent!</code>. В случае с
<code class="language-plaintext highlighter-rouge">loop</code> мы смогли втянуть <code class="language-plaintext highlighter-rouge">persistent!</code> внутрь и тем самым изолировать
изменения. Но reduce не такой гибкий в этом плане. Мы не можем определить внутри
анонимной функции, достигли ли мы конца итерации или нет. Без вынужденного
<code class="language-plaintext highlighter-rouge">persistent!</code> код уровнем выше получит транзиентную коллекцию, что недоспустимо.</p>

<h3 id="семантика-и-ограничения">Семантика и ограничения</h3>

<p>Изменяемые данные относятся к продвинутым техникам. Они предъявляют новые
требования к программисту, причем не только на уровне кода. Как мы выяснили, в
техническом плане достаточно нескольких функций, чтобы код стал
императивным. Транзиентные коллекции меняют дизайн, архитектуру приложения.</p>

<p>Выигрыш в скорости еще не значит, что транзиентные коллекции применяют на каждом
шагу. Худшее, что может сделать Clojure-разработчик — написать код, где функции
обмениваются такими коллекциями. На этом месте стоит задуматься, почему авторы
языка уделили так много времени неизменяемости. Будет грубейшей ошибкой
игнорировать их идеи.</p>

<p>Феномен, когда на этапе разработки пытаются выжать максимум скорости, называется
преждевременной оптимизацией. Ее вред либо известен программисту, либо еще
предстоит познать. Занимаясь оптимизацией, задавайте вопросы. Действительно ли
важно ускорить этот цикл? Поможет ли это продукту? Или вы действуете из
любопытства?</p>

<p>Транзиентные коллекции должны быть изолированы в небольших функциях. При таком
подходе переход от постоянных типов к изменяемым не влияет на ее вызов и
результат. Рефакторинг должен затрагивать только внутренности функции, но не
сторонних потребителей.</p>

<p>Изменяемая коллекция не имеет право быть глобальной переменной. Воздержитесь от
определений вроде <code class="language-plaintext highlighter-rouge">(def users* (transient []))</code> на уровне модуля. Вы придете к
тому, что <code class="language-plaintext highlighter-rouge">users*</code> станет буфером обмена между функциями. Вызывая функцию, вы не
знаете наверняка ее результат, потому что он зависит от глобальной
переменной. Так писали тридцать лет назад на Си и Паскале за неимением других
средств.</p>

<p>В отличии от атома, транзиентные типы не регулируют обращение к ним из разных
потоков. Придерживайтесь правила, что только один тред изменяет коллекцию. Не
передавайте их в футуры.</p>

<h2 id="подмена-переменных-alter-var-root">Подмена переменных. Alter-var-root</h2>

<p>И атомы, и транзиентные коллекции обладают особенностью. Они изменяют содержимое
объекта, а не сам объект. Это не всегда то поведение, которые мы ожидаем.</p>

<p>Например, переменная size это атом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы изменить его, вызовем <code class="language-plaintext highlighter-rouge">reset!</code> или <code class="language-plaintext highlighter-rouge">swap!</code> как в примерах выше. Но
переменная <code class="language-plaintext highlighter-rouge">size</code> всегда будет атомом. Каждый раз, чтобы прочитать ее значение,
понадобится оператор <code class="language-plaintext highlighter-rouge">@</code>. Это не всегда удобно.</p>

<p>Аналогично ведут себя транзиентные коллекции. К ним легко добавить и удалить
элемент, но это будет та же самая коллекция. Невозможно присвоить ей <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>В некоторых случаях нам хочется менять глобальную переменную. Например, чтобы
сперва она была <code class="language-plaintext highlighter-rouge">nil</code>, затем словарем, затем снова <code class="language-plaintext highlighter-rouge">nil</code>. Авторы Clojure
намеренно усложнили этот сценарий. Менять переменные технически возможно, но
нежелательно с точки зрения дизайна языка.</p>

<p>Нежелательно писать на Clojure так, как вы привыкли в Python или Java. Когда
программист изменяет глобальную переменную, он должен понимать, зачем она
понадобилась и возможно ли от нее избавиться. Глобальные переменные без
уважительной причины — признак плохого кода.</p>

<p>Встречаются два сценария, когда глобальные переменные оправданы. Это состояние
системы и monkey-patch.</p>

<p>Условный проект на Clojure состоит из отдельных компонентов или доменов. Это
веб-сервер, база данных, очередь сообщений. Каждый домен помещают в свой модуль:
<code class="language-plaintext highlighter-rouge">http.clj</code>, <code class="language-plaintext highlighter-rouge">db.clj</code> и так далее.</p>

<p>На практике редко бывает так, что приложение работает с двумя базами или
очередями. Поэтому в модуле объявляют глобальную переменную, которая хранит
состояние этого компонента. Например, <code class="language-plaintext highlighter-rouge">project.http/server</code> или
<code class="language-plaintext highlighter-rouge">project.db/conn</code>.</p>

<p>Возникает проблема, как объявить такую переменную. Начинающие допускают ошибку,
когда инициируют состояние на уровне модуля:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">server</span><span class="w"> </span><span class="p">(</span><span class="nf">jetty/run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">run-jetty</code> запустит сервер при загрузке модуля. Это плохая практика,
потому что загрузка модуля не должна нести побочных эффектов. Возможно, что на
локальной машине уже запущен сервер с таким портом. С таким кодом невозможно
работать в сеансе REPL. Он делает то, о чем его не просили.</p>

<p>Сервер, базы данных, очереди и другие компоненты должны включаться только по
требованию. Поэтому переменная <code class="language-plaintext highlighter-rouge">server</code> вначале равна <code class="language-plaintext highlighter-rouge">nil</code>. Затем функция
<code class="language-plaintext highlighter-rouge">start!</code> запускает сервер и записывает его объект в <code class="language-plaintext highlighter-rouge">server</code>. Функция <code class="language-plaintext highlighter-rouge">stop!</code>
останавливает его и меняет значение на <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<h3 id="понятие-переменной">Понятие переменной</h3>

<p>Чтобы переписать переменную, прибегают к <code class="language-plaintext highlighter-rouge">alter-var-root</code>. Это функция, которая
изменяет объекты, объявленные через <code class="language-plaintext highlighter-rouge">def</code> и <code class="language-plaintext highlighter-rouge">defn</code>. Ее вызов похож на <code class="language-plaintext highlighter-rouge">swap!</code>
для атома. Функция принимает объект <code class="language-plaintext highlighter-rouge">Var</code> и другую функцию, которая вычисляет
новое значение на базе текущего.</p>

<p>Рассмотрим, что такое Var. Это экземпляр класса <code class="language-plaintext highlighter-rouge">clojure.lang.Var</code> из библиотеки
Clojure. <code class="language-plaintext highlighter-rouge">Var</code> описывает переменную в пространстве имен. Чтобы получить объект
переменной, ее символ передают в макрос <code class="language-plaintext highlighter-rouge">var</code>, например <code class="language-plaintext highlighter-rouge">(var server)</code>. Эта
запись аналогична <code class="language-plaintext highlighter-rouge">#'server</code>, что немного короче.</p>

<p>Символ переменной и ее объект это разные сущности. Сам по себе символ ничего не
значит. Он равен только самому себе. Можно представить символ как слово
языка. Слово это определенная комбинация букв, и в языке не может быть двух
одинаковых слов. Но у слова может быть несколько значений в зависимости от
контекста. Объект, на который ссылается слово в данном контексте, и есть
переменная.</p>

<p>Символ это посредник между пространством имен и переменными. Когда мы пишем
<code class="language-plaintext highlighter-rouge">(def num 42)</code>, это не значит, что переменная <code class="language-plaintext highlighter-rouge">num</code> равна числу 42. На самом
деле мы создали объект <code class="language-plaintext highlighter-rouge">Var</code> со значением 42. Затем поместили этот объект в
текущее пространство под символом <code class="language-plaintext highlighter-rouge">num</code>.</p>

<p>Технически пространство имен устроено как словарь. Его ключи это символы, а
значения переменные. Формы <code class="language-plaintext highlighter-rouge">def</code> и <code class="language-plaintext highlighter-rouge">defn</code> наполняют этот словарь. Можно сказать,
что <code class="language-plaintext highlighter-rouge">def</code> задает слову смысл, и в момент компиляции Clojure понимает это слово.</p>

<p>Над символом работает операция вычисления. Если в сеансе REPL ввести <code class="language-plaintext highlighter-rouge">num</code>,
интерпретатор выполнит поиск с таким ключом в пространстве имен. Если ключ
найден, REPL вернет значение переменной, в нашем случае 42.</p>

<p>Clojure намеренно скрывает от нас стадию переменной, и это правильно. Если бы
выражение <code class="language-plaintext highlighter-rouge">num</code> вернуло переменную, в этом не было бы никакого смысла. Объект
<code class="language-plaintext highlighter-rouge">Var</code> это не цифра, а сложный объект. Значение 42 это лишь одно из множества его
полей.</p>

<p>Мы подробно поговорим о пространствах и переменных в другой главе. Пока что
отметим, что переменные, как правило, скрыты от пользователя. Обычно разработчик
видит либо их символ (<code class="language-plaintext highlighter-rouge">num</code>), либо значение (<code class="language-plaintext highlighter-rouge">42</code>). Функция <code class="language-plaintext highlighter-rouge">alter-var-root</code> —
тот случай, когда переменные заявляют о себе.</p>

<h3 id="запуск-по-требованию">Запуск по требованию</h3>

<p>Вернемся к примеру с сервером. Объявим переменную, которая в будущем станет
объектом <code class="language-plaintext highlighter-rouge">jetty.server.Server</code>. По умолчанию это <code class="language-plaintext highlighter-rouge">nil</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">server</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">start!</code> заменяет <code class="language-plaintext highlighter-rouge">server</code> результатом анонимной функции. Эта функция
принимает текущее значение. Чтобы не запускать сервер дважды, мы проверяем, был
ли он уже запущен. Если нет, создаем новый сервер и возвращаем его объект. Если
да, просто вернем текущий.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">start!</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-var-root</span><span class="w">
   </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">server</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">server</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">if-not</span><span class="w"> </span><span class="n">server</span><span class="w">
       </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">})</span><span class="w">
       </span><span class="n">server</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Аналогично работает <code class="language-plaintext highlighter-rouge">stop!</code>: выключаем сервер если он уже был
запущен. Устанавливаем переменную в nil.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">stop!</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-var-root</span><span class="w">
   </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">server</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">server</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">server</span><span class="w">
       </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">))</span><span class="w">
     </span><span class="n">nil</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Вызов <code class="language-plaintext highlighter-rouge">(start!)</code> в REPL запустит сервер в фоновом режиме. Браузер начнет
отвечать на запросы по адресу http://127.0.0.1:8080/ (путь зависит от маршрутов
приложения). Выражение <code class="language-plaintext highlighter-rouge">server</code> в REPL напечатает Java-объект сервера.</p>

<p>По такому же принципу устроена работа с базой. Чтобы не создавать подключение на
каждый запрос, применяют пулы соединений. В модуле для работы с БД объявляют
переменную <code class="language-plaintext highlighter-rouge">conn</code> со значением <code class="language-plaintext highlighter-rouge">nil</code>. Функция <code class="language-plaintext highlighter-rouge">start!</code> создает новый пул и
обновляет переменную.</p>

<p>После старта к базе посылают запросы. Это функции <code class="language-plaintext highlighter-rouge">query</code>, <code class="language-plaintext highlighter-rouge">update!</code>, <code class="language-plaintext highlighter-rouge">insert!</code>
и другие из пакета <code class="language-plaintext highlighter-rouge">clojure.java.jdbc</code>. Первым параметром они принимают
подключение к базе или пул:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"select 1 as result"</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-user-by-id</span><span class="w">
  </span><span class="p">[</span><span class="n">user-id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/get-by-id</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="n">user-id</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">stop!</code> выключает пул, закрывает соединения с базой и восстанавливает
<code class="language-plaintext highlighter-rouge">conn</code> в nil. Мы опустим код этих функций, потому что они отличаются только
именем глобальной переменной (<code class="language-plaintext highlighter-rouge">conn</code> вместо <code class="language-plaintext highlighter-rouge">server</code>) и строкой, где создается
сервер или пул.</p>

<h3 id="коротко-о-системах">Коротко о системах</h3>

<p>Техника <code class="language-plaintext highlighter-rouge">alter-var-root</code> вводит модуль в одно из двух состояний: включен и
выключен. Это особенно удобно для разработки, когда нас интересует конкретная
подсистема. Например, для отладки базы не требуется включать веб-сервер, а
подсистема кеширования не зависит от рассылки писем.</p>

<p>В широком смысле описанное выше называют системой. Это набор компонентов, из
которых состоит приложение. С помощью <code class="language-plaintext highlighter-rouge">alter-var-root</code> строят системы для
<em>несложных</em> проектов. Как правило, это веб-приложения с сервером и базой
данных. По-другому их называют системами для бедных.</p>

<p>Преимущество таких систем в том, что они не зависят от сторонних
библиотек. Каждый модуль выставляет универсальные “ручки управления”: функции
<code class="language-plaintext highlighter-rouge">start!</code> и <code class="language-plaintext highlighter-rouge">stop!</code>, которые обращаются к <code class="language-plaintext highlighter-rouge">alter-var-root</code>. Это простая и
понятная схема.</p>

<p>С другой стороны, “бедные” системы не знают, как один компонент зависит от
другого. Ручные зависимости становятся проблемой с ростом проекта. Поэтому
большие системы строят с помощью специальных библиотек. Некоторые из них тоже
опираются на <code class="language-plaintext highlighter-rouge">alter-var-root</code>. Мы подробно рассмотрим системы в другой главе.</p>

<h3 id="патчинг">Патчинг</h3>

<p>Выше мы изменяли переменные в текущем пространстве. Фактически это улучшенный
вариант с атомом. Разница в том, что переменная не требует оператора <code class="language-plaintext highlighter-rouge">@</code>, когда
ссылаются на ее значение. Это делает код чище и короче.</p>

<p>Истинная мощь <code class="language-plaintext highlighter-rouge">alter-var-root</code> в том, что функция работает с переменными из
любого пространства. Под любым мы понимаем:</p>

<ul>
  <li>текущий модуль;</li>
  <li>соседние модули проекта;</li>
  <li>сторонние библиотеки;</li>
  <li>стандартные модули Сlojure, например, <code class="language-plaintext highlighter-rouge">clojure.core</code>.</li>
</ul>

<p>С помощью <code class="language-plaintext highlighter-rouge">alter-var-root</code> можно повлиять на любую точку всего проекта. В том
числе вторгнуться в чужие модули и даже те, что идут в поставке с Clojure!</p>

<p>Это мощная техника, но ей пользуются редко. Менять код в момент исполнения
считается сомнительной практикой. По-другому это называется monkey patch. Термин
означает изменение классов и функций не на уровне кода, а когда программа уже
запущена.</p>

<p>Если программист злоупотребляет патчингом, программа ведет себя неочевидным
образом. Коллегам будет трудно понять, почему в коде написано одно, а
выполняется другое. Это затрудняет поддержку проекта, привносит раздражение в
повседневную работу.</p>

<p>К патчингу прибегают, если одновременно сошлись несколько условий:</p>

<ul>
  <li>без этого изменения мы не сможем двигаться дальше;</li>
  <li>проблема не в нашем коде, а в сторонней библиотеке или самой платформе;</li>
  <li>чтобы устранить проблему в коде, понадобиться существенное время.</li>
</ul>

<p>Типичный случай, когда патчинг оправдан — ошибка в чужой библиотеке. Наверняка
многие сталкивались с тем, что автор не принимает изменения, которые вы
прислали. Причины могут быть разными. Автор считает, что проблема не в коде, а
неверных данных. Автор забросил проект или опасается, что часть прав будет
принадлежать вам, — словом, исправить код не удается.</p>

<p>Технически не сложно клонировать репозиторий и внести правки. По-другому это
называют форкнуть, сделать форк (анг. fork — вилка, ответвление). Но встают
организационные проблемы. Где хранить новый репозиторий? Как сделать так, чтобы
изменения в оригинальной библиотеке отражались на ее клоне? Как настроить
окружение, чтобы система сборки качала нашу версию, а не оригинал? Разрешает ли
автор использовать измененную версию его кода?</p>

<p>Эти проблемы сложны тем, что вовлекают других людей: админов, юристов,
руководство фирмы. Вряд ли мы найдем время, чтобы на середине проекта все
отложить и заняться ими. В данном случае monkey patch будет разумным решением.</p>

<p>Патчинг полезен во время разработки. Мы часто печатаем данные на экран, чтобы
исследовать их. Недостаток функции <code class="language-plaintext highlighter-rouge">println</code> в том, что ее вывод не
структурирован. Отдельные части коллекций “слипаются”, и их трудно прочитать.</p>

<p>Пакет <code class="language-plaintext highlighter-rouge">clojure.pprint</code> (сокращение от pretty printing) решает эту
проблему. Функция <code class="language-plaintext highlighter-rouge">pprint</code> из этого модуля выводит данные с отступами и
переносами строк. Это особенно удобно для вложенных словарей.</p>

<p>Другое достоинство <code class="language-plaintext highlighter-rouge">pprint</code> — ограничение на глубину и длину коллекций. На
больших данных печать в лоб чревата задержкой. Функция <code class="language-plaintext highlighter-rouge">pprint</code> опирается на
глобальные настройки Clojure. Они определяют, сколько брать элементов из
коллекции и на какую глубину погружаться.</p>

<p>Не всегда удобно писать <code class="language-plaintext highlighter-rouge">(clojure.pprint/pprint data)</code> вместо <code class="language-plaintext highlighter-rouge">(println
data)</code>. Как и любой модуль, <code class="language-plaintext highlighter-rouge">clojure.pprint</code> сперва импортируют. Чтобы не
отвлекаться на импорт, сделаем так, что на время разработки вызов <code class="language-plaintext highlighter-rouge">println</code>
аналогичен <code class="language-plaintext highlighter-rouge">pprint</code>. Пропатчим функцию следующим образом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="ss">'clojure.pprint</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">alter-var-root</span><span class="w">
 </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="nb">println</span><span class="p">)</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="n">clojure.pprint/pprint</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Достаточно выполнить этот код один раз в любом месте проекта. Теперь вызов
<code class="language-plaintext highlighter-rouge">(println data)</code> напечатает данные так, как это делает <code class="language-plaintext highlighter-rouge">pprint</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">&lt;vector-of-dicts-of-vectors...&gt;</span><span class="p">)</span><span class="w">

</span><span class="c1">;; [{:foo 42, :bar [1 2 3 4 5 {:foo 42, :bar [1 2 {#, #}]}]}</span><span class="w">
</span><span class="c1">;;  {:foo 42, :bar [1 2 {:foo 42, :bar [1 2 {#, #}]}]}]</span><span class="w">
</span></code></pre></div></div>

<p>Функция заменяет вложенные участки на символ #, чтобы не обрушить на вас лавину
данных. На глубину и длину печати влияют особые глобальные переменные. Позже мы
рассмотрим, как задать им другие значения.</p>

<p>Подмена <code class="language-plaintext highlighter-rouge">println</code> на <code class="language-plaintext highlighter-rouge">pprint</code> полезна только во время разработки. Чтобы не
повлиять на боевой режим, код с <code class="language-plaintext highlighter-rouge">alter-var-root</code> выносят в отдельный
модуль. Такие модули называют модулями среды, потому что они загружаются не
всегда, а по условию. Код с заменой печати логично поместить в файле
<code class="language-plaintext highlighter-rouge">env/dev/print.clj</code>. Проект настраивают так, что в режиме разработки он
просматривает дополнительные пути для загрузки кода.</p>

<p>Например, если это lein-проект, то в файле <code class="language-plaintext highlighter-rouge">project.clj</code> пишут следующее:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:profiles</span><span class="w">
 </span><span class="no">:dev</span><span class="w">  </span><span class="p">{</span><span class="no">:source-paths</span><span class="w"> </span><span class="p">[</span><span class="s">"env/dev"</span><span class="p">]}</span><span class="w">
 </span><span class="no">:test</span><span class="w"> </span><span class="p">{</span><span class="no">:source-paths</span><span class="w"> </span><span class="p">[</span><span class="s">"env/test"</span><span class="p">]}}</span><span class="w">
</span></code></pre></div></div>

<p>Запись означает, что в режиме разработки мы получим доступ ко всем модулям из
папки <code class="language-plaintext highlighter-rouge">env/dev</code>, а во время прогона тестов – из <code class="language-plaintext highlighter-rouge">env/test</code>. Мы рассмотрим как
настроить проект в отдельной главе.</p>

<p>По аналогии с переходными коллекциями, патчинг должен быть изолирован от
остального кода. Его эффект замыкают в отдельной функции или даже модуле. Рядом
должен быть комментарий с описанием того, что произойдет при вызове и какую мы
преследуем цель.</p>

<h3 id="в-боевом-режиме">В боевом режиме</h3>

<p>Рассмотрим случай, когда <code class="language-plaintext highlighter-rouge">alter-var-root</code> полезен в промышленном запуске. В
предыдущей <a href="/clj-book-exceptions/">главе об исключениях</a> мы отметили
проблему. Макросы <code class="language-plaintext highlighter-rouge">log/info</code>, <code class="language-plaintext highlighter-rouge">log/error</code> и другие принимают первым аргументом
исключение. При записи в файл мы не знаем, как система логирование запишет его в
текст. Длина трейса и цепочка исключений выглядят по-разному в зависимости от
бекенда (log4j, Logback и другие).</p>

<p>Мы написали функцию ex-print. Она принимает исключение и печатает его именно
так, как нужно нам. виде. Функция не вываливает стек-трейс на весь экран, а
обходит цепочку исключений и для каждого звена печатает класс, сообщение и
контекст:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">ex-print</span><span class="w">
  </span><span class="p">[</span><span class="o">^</span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">indent</span><span class="w"> </span><span class="s">"  "</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-chain</span><span class="w"> </span><span class="n">e</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="nb">class</span><span class="w"> </span><span class="n">.getCanonicalName</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="n">indent</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-data</span><span class="w"> </span><span class="n">e</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="n">indent</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="n">data</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Недостаток решения в том, что вместо <code class="language-plaintext highlighter-rouge">(log/error e)</code> приходится писать:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">log/error</span><span class="w"> </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-print</span><span class="w"> </span><span class="n">e</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Это значительно длинее и вынуждает импортировать <code class="language-plaintext highlighter-rouge">ex-print</code> в каждый модуль, где
логируют исключения. Было бы удобней, если б мы по-прежнему писали <code class="language-plaintext highlighter-rouge">(log/error
e)</code>, а <code class="language-plaintext highlighter-rouge">ex-print</code> срабатывал самостоятельно за кадром. Это возможно с помощью
<code class="language-plaintext highlighter-rouge">alter-var-root</code>.</p>

<p>Отметим, что <code class="language-plaintext highlighter-rouge">log/error</code>, <code class="language-plaintext highlighter-rouge">log/info</code> и аналоги это не функции, а макросы. Макрос
это эфемерная сущность, на которую нельзя сослаться через var. Макрос живет
только во время компиляции программы. После компиляции на его месте остается
список функций и базовых форм. В этом и состоит трюк. Нельзя изменить макрос, но
можно подменить функции, на которые он опирается.</p>

<p>Модуль <code class="language-plaintext highlighter-rouge">clojure.tools.logging</code> он устроен так, что макрос <code class="language-plaintext highlighter-rouge">log/error</code> и другие
сводится к вызову функции <code class="language-plaintext highlighter-rouge">log/log*</code>. Это бутылочное горлышко, через которое
проходят все логи. Вот как выглядит ее сигнатура:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">log*</span><span class="w">
  </span><span class="p">[</span><span class="n">logger</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="n">throwable</span><span class="w"> </span><span class="n">message</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Параметр <code class="language-plaintext highlighter-rouge">throwable</code> это объект исключения или <code class="language-plaintext highlighter-rouge">nil</code>. Подменим <code class="language-plaintext highlighter-rouge">log*</code> на
анонимную функцию со следующей логикой:</p>

<ul>
  <li>если <code class="language-plaintext highlighter-rouge">throwable</code> не nil, перевести исключение в текст;</li>
  <li>присоединить его к исходному сообщению через перенос строки;</li>
  <li>передать параметры в оригинальный <code class="language-plaintext highlighter-rouge">log*</code> с новым сообщением. При этом
<code class="language-plaintext highlighter-rouge">throwable</code> будет nil. В нем отпала потребность, поскольку мы сделали его
частью сообщения;</li>
  <li>если <code class="language-plaintext highlighter-rouge">throwable</code> был nil, вызвать <code class="language-plaintext highlighter-rouge">log*</code> не меняя входных параметров.</li>
</ul>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">install-better-logging</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-var-root</span><span class="w">
   </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">clojure.tools.logging/log*</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">log*</span><span class="p">]</span><span class="w"> </span><span class="c1">;; 5</span><span class="w">
     </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">logger</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="n">throwable</span><span class="w"> </span><span class="n">message</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">throwable</span><span class="w">
         </span><span class="p">(</span><span class="nf">log*</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="n">nil</span><span class="w">
               </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="sc">\n</span><span class="n">ewline</span><span class="w">
                    </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w">
                      </span><span class="p">(</span><span class="nf">ex-print</span><span class="w"> </span><span class="n">throwable</span><span class="p">))))</span><span class="w">
         </span><span class="p">(</span><span class="nf">log*</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="n">throwable</span><span class="w"> </span><span class="n">message</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Хитрость кроется в строке 5. Анонимная функция, переданная в <code class="language-plaintext highlighter-rouge">alter-var-root</code>,
принимает прежнее значение переменной. Это оригинальная функция
<code class="language-plaintext highlighter-rouge">clojure.tools.logging/log*</code>, и параметр <code class="language-plaintext highlighter-rouge">log*</code> ссылается на нее. Новая функция
замкнута относительно переменной log* и может ее вызывать.</p>

<p>Получился своего рода декоратор. Новая версия <code class="language-plaintext highlighter-rouge">log*</code> только меняет входные
параметры и вызывает старую функцию. После вызова <code class="language-plaintext highlighter-rouge">(install-better-logging)</code>
логирование исключений изменится. Теперь достаточно написать <code class="language-plaintext highlighter-rouge">(log/error e)</code>,
чтобы ошибка была записана в файл именно так, как нужно нам.</p>

<p>Преимущество этого подхода в том, что поведение задано на уровне
Clojure-кода. Если потребуется улучшить логи, мы доработаем функцию <code class="language-plaintext highlighter-rouge">ex-print</code> в
любой момент. Это удобнее, чем наследовать Java-класс от условного
<code class="language-plaintext highlighter-rouge">com.logging.ThrowableRenderer</code> и переопределять его методы.</p>

<p>Мощь <code class="language-plaintext highlighter-rouge">alter-var-root</code> компенсируется вредом ее необдуманного применения. Функция
нужна, чтобы точечно менять переменные в особых случаях. Прибегайте к
<code class="language-plaintext highlighter-rouge">alter-var-root</code> только если альтернативный путь существенно увеличивает код и
временные затраты.</p>

<h2 id="немного-о-set">Немного о set!</h2>

<p>Мы уже упоминали об особенности <code class="language-plaintext highlighter-rouge">pprint</code> для красивой печати. Функция
замечательна тем, что проверяет вложенность и длину коллекций. Эти ограничения
помогут избежать ситуации, когда данные заливают несколько экранов, а редактор
тормозит на подсветке синтаксиса. Проверка на длину особенно важна, потому что
некоторые коллекции не просто велики, а бесконечны.</p>

<p>Длину и вложенность вывода определяют глобальные переменные <code class="language-plaintext highlighter-rouge">*print-length*</code> и
<code class="language-plaintext highlighter-rouge">*print-level*</code>. По умолчанию <code class="language-plaintext highlighter-rouge">*print-length*</code> равен 100. Это довольно много,
особенно если учесть, что элементами коллекции могут быть другие
коллекции. Например, результат запроса к БД это список словарей. Печать ста
словарей это дорогая операция, поэтому логично уменьшить <code class="language-plaintext highlighter-rouge">*print-length*</code> на
старте приложения. Для этого используют форму <code class="language-plaintext highlighter-rouge">set!</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*print-length*</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Теперь печать бесконечной коллекции отобразит только первые 8 элементов:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="c1">;; (1 1 1 1 1 1 1 1 ...)</span><span class="w">
</span></code></pre></div></div>

<p>Многоточие означает, что в коллекции есть и другие элементы, но их отбросили.</p>

<p>Вложенность или уровень коллекции это воображаемый индекс. Когда одна коллекция
становится элементом другой, ее индекс увеличивается на единицу.</p>

<p>Объявим вложенную структуру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="p">{</span><span class="no">:bar</span><span class="w"> </span><span class="p">{</span><span class="no">:baz</span><span class="w"> </span><span class="p">[</span><span class="mi">42</span><span class="p">]}}})</span><span class="w">
</span></code></pre></div></div>

<p>Так выглядит вывод при разных значениях <code class="language-plaintext highlighter-rouge">*print-level*</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*print-level*</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w">
</span><span class="c1">;; {:foo {:bar #}}</span><span class="w">

</span><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*print-level*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w">
</span><span class="c1">;; {:foo #}</span><span class="w">
</span></code></pre></div></div>

<p>При нулевом уровне увидим только символ <code class="language-plaintext highlighter-rouge">#</code>.</p>

<p>Всего в Clojure около десяти переменных с “ушками”. Две из них мы уже
рассмотрели, это <code class="language-plaintext highlighter-rouge">*print-length*</code> и <code class="language-plaintext highlighter-rouge">*print-level*</code> для настроек
печати. Перечислим несколько других:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">*warn-on-reflection*</code>: если истина, компилятор покажет предупреждение в тех
местах, где не удалось вывести Java-тип. Это продвинутая техника, и мы
рассмотрим ее в другой главе.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">*assert*</code>: если ложь, отключает <code class="language-plaintext highlighter-rouge">assert</code>-макрос. Это особая форма, которая
проверет выражение на истинность. Если выражение ложно, форма выбрасывает
исключение. По умолчанию assert-ы включены, ими пользуются на этапах
разработки и тестирования. В боевом режиме их выключают, чтобы повысить
произвоительность.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">*in*</code>, <code class="language-plaintext highlighter-rouge">*out*</code>: каналы стандартного ввода и вывода. Это объекты <code class="language-plaintext highlighter-rouge">Reader</code> и
<code class="language-plaintext highlighter-rouge">Writer</code>, откуда платформа читает и пишет данные.</p>
  </li>
</ul>

<p>Эти и другие переменные изменяют формой <code class="language-plaintext highlighter-rouge">set!</code>. Значение зависит от семантики
переменной. Рассмотрим несколько примеров.</p>

<p>Показывать предупреждения, если компилятор не смог вывести тип:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*warn-on-reflection*</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Отключить <code class="language-plaintext highlighter-rouge">assert</code>-формы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*assert*</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="mi">42</span><span class="p">}</span><span class="w"> </span><span class="no">:bar</span><span class="p">))</span><span class="w">
</span><span class="c1">;; won't throw an exception</span><span class="w">
</span></code></pre></div></div>

<p>Направить вывод в файл: все, что напечатано функциями семейства <code class="language-plaintext highlighter-rouge">print</code>,
появится не в консоли, а в файле. Полезно, когда объем данных слишком велик. При
выводе в файл редактор не тратит ресурсы на подсветку синтаксиса.</p>

<p>Ниже мы создаем объект <code class="language-plaintext highlighter-rouge">Writer</code> с файлом <code class="language-plaintext highlighter-rouge">out.log</code> в качестве точки сбора
данных. Затем назначаем переменной <code class="language-plaintext highlighter-rouge">*out*</code> этот объект.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.java.io</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">io</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nf">io/writer</span><span class="w"> </span><span class="s">"out.log"</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*out*</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Теперь <code class="language-plaintext highlighter-rouge">print</code> молча возвращает nil. Результат печати вы найдете в файле
<code class="language-plaintext highlighter-rouge">out.log</code> в той директории, откуда запустили REPL.</p>

<p>Выражения <code class="language-plaintext highlighter-rouge">(set! *&lt;something&gt;* &lt;value&gt;)</code> размещают в коде по такому же принципу,
что и <code class="language-plaintext highlighter-rouge">alter-var-root</code>. Если значение требуется только для определенного режима,
форму <code class="language-plaintext highlighter-rouge">set!</code> записывают в модуле среды, например <code class="language-plaintext highlighter-rouge">env/dev/settings.clj</code>.</p>

<p>Утилиты проектов принимают словарь глобальных переменных. При старте они
автоматически назначают переменным значения. Например, конфигурация lein
учитывает ключ <code class="language-plaintext highlighter-rouge">:global-vars</code>. Еще большей гибкости можно добиться, если
указывать переменные в профилях. Ниже мы задаем разные значения глобальным
переменным в зависимости от режима разработки (dev) или сборки (uberjar).</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:profiles</span><span class="w">
 </span><span class="no">:dev</span><span class="w"> </span><span class="p">{</span><span class="no">:global-vars</span><span class="w"> </span><span class="p">{</span><span class="n">*warn-on-reflection*</span><span class="w"> </span><span class="n">true</span><span class="w">
                     </span><span class="n">*assert*</span><span class="w"> </span><span class="n">true</span><span class="p">}}</span><span class="w">
 </span><span class="no">:uberjar</span><span class="w"> </span><span class="p">{</span><span class="no">:global-vars</span><span class="w"> </span><span class="p">{</span><span class="n">*warn-on-reflection*</span><span class="w"> </span><span class="n">false</span><span class="w">
                         </span><span class="n">*assert*</span><span class="w"> </span><span class="n">false</span><span class="p">}}}</span><span class="w">
</span></code></pre></div></div>

<p>С помощью <code class="language-plaintext highlighter-rouge">set!</code> нельзя изменить пользовательские переменные, даже если они с
“ушками” и помечены как динамические. Пример ниже бросит исключение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:dynaimc</span><span class="w"> </span><span class="n">*data*</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*data*</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span><span class="c1">;; Unhandled java.lang.IllegalStateException</span><span class="w">
</span><span class="c1">;; Can't change/establish root binding of: *data* with set</span><span class="w">
</span></code></pre></div></div>

<p>Воспользуйтесь функцией <code class="language-plaintext highlighter-rouge">alter-var-root</code>, которую мы рассмотрели выше.</p>

<h2 id="изменения-в-контексте-binding">Изменения в контексте. Binding</h2>

<p>Техники, которые мы рассмотрели к этому моменту, обладают одинаковым
свойством. Их эффект длится до конца работы программы. Изменения в атомах,
транзиентных коллекциях и глобальных переменных называют персистентными
(анг. persistent – постоянный).</p>

<p>Может показаться странным, но это не всегда то поведение, на которое мы
рассчитываем. Иногда требуется изменить данные временно. Например, глобальная
переменная равна X, но этот участок кода ожидает Y.</p>

<p>Технически возможно построить временные изменения на базе постоянных. Например,
вызывать <code class="language-plaintext highlighter-rouge">alter-var-root</code> с новым и старым значениями на границах блока кода. Но
такой подход влечет две проблемы: изоляцию изменений и их откат.</p>

<p>Проблема изоляции состоит в том, что, как правило, временные изменения
происходят в рамках одного потока. Это значит, что если мы временно изменили
глобальную переменную с X на Y, то в другом треде она по-прежнему будет X. Это
важно, поскольку мы физически не можем знать, какой участок кода сейчас
выполняет другой тред. Значит, мы не можем позволить себе менять глобальные
переменные для всех тредов в произвольный момент.</p>

<p>Проблема отката означает, что изменения в данных необходимо отменить. После
выполнения блока кода данные должны быть в точности такими же, как и до
него. Практика, когда код оборачивают в <code class="language-plaintext highlighter-rouge">alter-var-root</code> или <code class="language-plaintext highlighter-rouge">set!</code>, плоха тем,
что одна из форм, чаще заключительная, может потеряться во время
рефакторинга. Это чревато странным поведением программы и трудной отладкой.</p>

<p>С этого момента и до конца главы мы будем рассматривать временные изменения
данных. Clojure предлагает несколько форм, чтобы выполнить произвольный код в
контексте переменных с другими значениями. Первая из них это <code class="language-plaintext highlighter-rouge">binding</code>
(анг. “связывание”).</p>

<p>Синтаксис <code class="language-plaintext highlighter-rouge">binding</code> аналогичен форме <code class="language-plaintext highlighter-rouge">let</code>: это форма связывания и произвольный
код. Форма связывания это вектор, где перечисляют символы переменных и их
значения. Символы должны ссылаться на уже объявленные переменные. Произвольный
код, или тело макроса, будет исполнен в рамках этих переменных с новыми
значениями. Результат <code class="language-plaintext highlighter-rouge">binding</code> это последнее выражение его тела. Изменения,
которые оказывает <code class="language-plaintext highlighter-rouge">binding</code>, протекают в рамках текущего треда и не влияют на
соседние.</p>

<h3 id="динамические-переменные">Динамические переменные</h3>

<p><code class="language-plaintext highlighter-rouge">Binding</code> работает только с динамическими переменными. Компилятор считает
переменную динамической, если ей назначен тег <code class="language-plaintext highlighter-rouge">^:dynamic</code>. Это сокращенная форма
<code class="language-plaintext highlighter-rouge">^{:dynamic true}</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">*server*</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">;; or</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="p">{</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">true</span><span class="p">}</span><span class="w"> </span><span class="n">*server*</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Словарь с крышкой в <code class="language-plaintext highlighter-rouge">def</code>-определении называют метаданными. Это дополнительные
параметры будущей переменной. В данном случае мы сообщаем компилятору, что
переменная динамическая, то есть будет изменена в будущем.</p>

<p>Глобальные переменные принято выделять “ушками”, то есть звездочками по краям. В
английском языке такую запись называют earmuffs syntax. Правило было принято еще
в старых Lisp-системах, и Clojure следует традиции.</p>

<p>Ушки и динамичность связаны между собой. Если переменная с ушками, но не
динамическая, компилятор предупредит о возможной ошибке:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">*server*</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">;; Warning: *server* not declared dynamic and thus [...]</span><span class="w">
</span><span class="c1">;; Please either indicate ^:dynamic *server* or change the name.</span><span class="w">
</span></code></pre></div></div>

<p>Сами по себе ушки не делают переменную динамической, это просто соглашение. Если
переменная не динамическая, <code class="language-plaintext highlighter-rouge">binding</code> бросит исключение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*server*</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">*server*</span><span class="p">))</span><span class="w">
</span><span class="c1">;; Execution error (IllegalStateException)</span><span class="w">
</span><span class="c1">;; Can't dynamically bind non-dynamic var: *server*</span><span class="w">
</span></code></pre></div></div>

<h3 id="отказ-от-set">Отказ от set!</h3>

<p>Вспомним пример с ограничениями на длину и глубину печати. Чтобы ограничить
вывод, мы писали что-то вроде:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*print-level*</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>На самом деле это плохой пример. Он нарушает принципы изоляции и отката, которые
мы только что рассмотрели. Изменение переменной <code class="language-plaintext highlighter-rouge">*print-level*</code> не изолировано и
повлияет на всю систему глобально. Если в этот момент другой тред что-то
напечатает, мы увидим результат с максимальной вложенностью 4, что отличается от
величины, которую задали на старте приложения. Сразу после оператора <code class="language-plaintext highlighter-rouge">(println
data)</code> следует восстановить прежнее значение <code class="language-plaintext highlighter-rouge">*print-level*</code>. Однако, об этом
легко забыть.</p>

<p>Вот как выглядит правильный вариант для печати с особыми настройками:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*print-level*</span><span class="w"> </span><span class="mi">8</span><span class="w">
          </span><span class="n">*print-length*</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="p">{</span><span class="no">:bar</span><span class="w"> </span><span class="p">{</span><span class="no">:baz</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="mi">1</span><span class="p">)}}}))</span><span class="w">
</span><span class="c1">;; {:foo {:bar {:baz (1 1 1 1 ...)}}}</span><span class="w">
</span></code></pre></div></div>

<p>Этот код избавлен от упомянутых недостатков. Вне формы <code class="language-plaintext highlighter-rouge">binding</code> переменные
останутся с прежними значениями, а соседние треды не заметят изменений.</p>

<p>Вспомним, как мы перенаправили печать данных в файл. Мы назначили переменной
<em>out</em> специальный объект FileWriter:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*out*</span><span class="w"> </span><span class="p">(</span><span class="nf">io/writer</span><span class="w"> </span><span class="s">"data.txt"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Этот метод не лишен недостатков. Во-первых, не ясно, кто и в какой момент
закроет файл. Программа может завершиться аварийно, и мы потеряем часть
данных. Должен быть какой-то фоновый обработчик, который закроет файл даже в
случае сбоя.</p>

<p>Во-вторых, не всегда данные пишут в один и тот же файл. Возможно, мы ожидаем
увидеть часть данных на эеране, а другую часть в файле. Как мы выяснили,
переключать <code class="language-plaintext highlighter-rouge">*out*</code> глобально это опасная практика: повышается риск
непредсказуемого вывода.</p>

<p>Правильный подход в том, чтобы открыть файл и временно связать с ним переменную
вывода:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">with-open</span><span class="w"> </span><span class="p">[</span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="nf">io/writer</span><span class="w"> </span><span class="s">"dump.edn"</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*out*</span><span class="w"> </span><span class="n">out</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="p">{</span><span class="no">:test</span><span class="w"> </span><span class="mi">42</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Объединим оба примера в функцию для сброса данных в файл. Такая функция полезна
для отладки больших данных. Она принимает путь к файлу и произвольное
значение. Внутри функция связывает стандартный вывод с временно открытым файлом
и печатает данные. Чтобы сделать вывод более детальным, назначаем переменным
печати большие значения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">dump-data</span><span class="w">
  </span><span class="p">[</span><span class="nb">path</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">with-open</span><span class="w"> </span><span class="p">[</span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="nf">io/writer</span><span class="w"> </span><span class="nb">path</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*out*</span><span class="w"> </span><span class="n">out</span><span class="w">
              </span><span class="n">*print-level*</span><span class="w"> </span><span class="mi">32</span><span class="w">
              </span><span class="n">*print-length*</span><span class="w"> </span><span class="mi">256</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="n">data</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Вот как работает сброс данных в произвольный файл:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">dump-data</span><span class="w"> </span><span class="s">"sample.edn"</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]}]})</span><span class="w">
</span></code></pre></div></div>

<p>и их восстановление:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"sample.edn"</span><span class="w"> </span><span class="nb">slurp</span><span class="w"> </span><span class="n">read-string</span><span class="p">)</span><span class="w">
</span><span class="c1">;; {:foo [1 2 3 {:foo [1 2 3]}]}</span><span class="w">
</span></code></pre></div></div>

<p>Доработайте функцию <code class="language-plaintext highlighter-rouge">dump-data</code> так, чтобы можно было передать значения
<code class="language-plaintext highlighter-rouge">*print-level*</code> и <code class="language-plaintext highlighter-rouge">*print-length*</code>. В идеале это третий необязательный параметр
opt, словарь, в котором функция ищет дополнительные настройки.</p>

<h3 id="пример-с-переводом-строк">Пример с переводом строк</h3>

<p>Приведем пример из реального проекта, когда <code class="language-plaintext highlighter-rouge">binding</code> чрезвычайно полезен. Речь
пойдет об интернационализации веб-приложения. Под термином понимают вывод текста
на разных языках в зависимости от настроек пользователя.</p>

<p>В приложениях с переводами текст хранят в виде огромных словарей. Они состоят из
двух уровней: локали и тегов. Локаль это международный код языка, например ru,
en. Локаль может состоять из доменов, разделенных подчеркиванием или дефисом,
например <code class="language-plaintext highlighter-rouge">en_US</code> или <code class="language-plaintext highlighter-rouge">en_GB</code>. В данном случае US и GB означают американский и
британский диалекты английского. В восточных языках встречается даже тройная
вложенность доменов, чтобы обозначить локальный диалект в провинции.</p>

<p>Под тегом понимают короткую машинную строку. Она описывает семантику фразы,
которая позже заменит ее в момент перевода. Например, по тегу <code class="language-plaintext highlighter-rouge">ui/add-to-cart</code>
становится ясно, что это надпись на кнопке “добавить в корзину”.</p>

<p>В зависимости от фреймворка или библиотеки словари находятся в коде, в файлах
или базе данных. Но принцип интернационализации остается прежним: по локали и
тегу библиотека совершает т.н. lookup, то есть поиск перевода в
дереве. Изобразим наивную реализацию такого подхода на Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">tr-map</span><span class="w">
  </span><span class="p">{</span><span class="no">:en</span><span class="w"> </span><span class="p">{</span><span class="no">:ui/add-to-cart</span><span class="w"> </span><span class="s">"Add to Cart"</span><span class="p">}</span><span class="w">
   </span><span class="no">:ru</span><span class="w"> </span><span class="p">{</span><span class="no">:ui/add-to-cart</span><span class="w"> </span><span class="s">"Добавить в корзину"</span><span class="p">}})</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tr</span><span class="w">
  </span><span class="p">[</span><span class="n">locale</span><span class="w"> </span><span class="n">tag</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">tr-map</span><span class="w"> </span><span class="p">[</span><span class="n">locale</span><span class="w"> </span><span class="n">tag</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"&lt;%s%s&gt;"</span><span class="w"> </span><span class="n">locale</span><span class="w"> </span><span class="n">tag</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Функция tr возвращает перевод то локали и тегу. Если перевод не найден,
результатом будет машинное выражение, например <code class="language-plaintext highlighter-rouge">&lt;:en:ui/sign-in&gt;</code>.</p>

<p>Недостаток функции в том, что каждый раз ей нужно передавать локаль. Это
утомительно, особенно с учетом того, что локаль вычисляется один раз на старте
запроса и не меняется в процессе. Иногда на один запрос требуется перевести
полсотни фраз. Это 50 вызовов tr, и каждый дополнительный параметр зашумляет
код.</p>

<p>Еще один недостаток локали в том, что место ее определения слишком далеко от
мест перевода. Между этими участками кода лежит дистанция как в физическом, так
и ментальном плане. Под физическим мы понимаем стек вызовов. Обычно мы
определяем локаль в особом middleware. Это может быть параметр адресной строки
(/?lang=ru) или поддомен (en.wikipedia.org). Но middleware считаются логикой
высокого уровня, а переводы расположены где-то внизу внутри обработчика. Даже
если сообщить запросу поле <code class="language-plaintext highlighter-rouge">:locale</code>, будет физически трудно спустить его до
уровня перевода и передать <code class="language-plaintext highlighter-rouge">(:locale request)</code> в каждый вызов <code class="language-plaintext highlighter-rouge">tr</code>.</p>

<p>Под ментальной дистанцией имеют в виду следующее. На уровне переводов нам не
хочется знать, откуда приходит локаль. Наоборот, эти сведения избыточны, потому
что они завязывают нас на конкретную реализацию. Это особенно очевидно, когда мы
работаем с шаблонной системой, устроенной по принципу Django.</p>

<p>Аналог такой системы в Clojure называется Selmer. Шаблонизатор Django
подразумевает, что у вас обычные HTML-файлы со вставками в фигурных
скобках. Выражения в скобках вычисляются в конечные значения. В шаблонной
системе выделяют фильтры. Это символьное обозначение функции, которую нужно
применить к переменной. Например, запись:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">&lt;p&gt;</span><span class="p">{{</span><span class="w"> </span><span class="n">user.name</span><span class="err">|</span><span class="n">lower</span><span class="w"> </span><span class="p">}}</span><span class="n">&lt;/p&gt;</span><span class="w">
</span></code></pre></div></div>

<p>означает, что между тегами параграфа следует разместить поле <code class="language-plaintext highlighter-rouge">:name</code> словаря
<code class="language-plaintext highlighter-rouge">user</code>. При этом привести имя к нижнему регистру. В Clojure эта запись выглядела
бы так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">str/lower-case</span><span class="w"> </span><span class="p">(</span><span class="no">:name</span><span class="w"> </span><span class="n">user</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Фильтром может быть любая функция, в том числе наша <code class="language-plaintext highlighter-rouge">tr</code>. Достаточно внести ее в
регистр фильтров. Нам бы хотелось, чтобы код шаблона выглядел так:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"widget"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/login"</span><span class="nt">&gt;</span>{{ "ui/log-in"|tr }}<span class="nt">&lt;/a&gt;</span>
  <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/register"</span><span class="nt">&gt;</span>{{ "ui/register"|tr }}<span class="nt">&lt;/a&gt;</span>
  <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/help"</span><span class="nt">&gt;</span>{{ "ui/help"|tr }}<span class="nt">&lt;/a&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>Тогда фильтр “tr” должен быть функцией одной переменной. Она принимает машинную
строку и возвращает ее перевод.</p>

<p>Очевидно, локаль должна быть как-то предопределена. Мы должны сделать так, чтобы
в рамках конкретного запроса фильтр опирался на рассчитанную в middleware
локаль. При этом ни в коем случае не влиять на перевод в параллельных запросах.</p>

<p>Поможет локальное связывание через <code class="language-plaintext highlighter-rouge">binding</code>. Определим глобальную переменную
<code class="language-plaintext highlighter-rouge">*locale*</code>. В терминах Clojure такая переменная называется несвязанной, потому
что ей не сообщили значение. Можно рассматривать ее как ячейку, в которой еще
нет данных.</p>

<p>Изменим функцию <code class="language-plaintext highlighter-rouge">tr</code>: теперь она принимает только тег, а в качестве локали
ссылается на глобальную <code class="language-plaintext highlighter-rouge">*locale*</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">*locale*</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tr</span><span class="w">
  </span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">tr-map</span><span class="w"> </span><span class="p">[</span><span class="n">*locale*</span><span class="w"> </span><span class="n">tag</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы изолировать <code class="language-plaintext highlighter-rouge">*locale*</code> от внешних потребителей, предоставим специальный
макрос <code class="language-plaintext highlighter-rouge">with-locale</code>. Он выполняет блок кода в момент, когда переменная временно
связана с переданной локалью. Теперь любой перевод, вызванный внутри макроса,
сработает для этой локали:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-locale</span><span class="w">
  </span><span class="p">[</span><span class="n">locale</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*locale*</span><span class="w"> </span><span class="o">~</span><span class="n">locale</span><span class="p">]</span><span class="w">
     </span><span class="o">~@</span><span class="n">body</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">with-locale</span><span class="w"> </span><span class="no">:en</span><span class="w">
  </span><span class="p">(</span><span class="nf">tr</span><span class="w"> </span><span class="no">:ui/add-to-cart</span><span class="p">))</span><span class="w">
</span><span class="c1">;; "Add to Cart"</span><span class="w">

</span><span class="p">(</span><span class="nf">with-locale</span><span class="w"> </span><span class="no">:ru</span><span class="w">
  </span><span class="p">(</span><span class="nf">tr</span><span class="w"> </span><span class="no">:ui/add-to-cart</span><span class="p">))</span><span class="w">
</span><span class="c1">;; "Добавить в корзину"</span><span class="w">
</span></code></pre></div></div>

<p>Напишем middleware, который определяет локаль по запросу. Для простоты решим,
что это параметр lang из адресной строки. Если не удалось найти параметр, берем
локаль по умолчанию. Весь нижележащий middleware-стек будет выполнен под
макросом <code class="language-plaintext highlighter-rouge">with-locale</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-locale</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">locale</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">[</span><span class="no">:params</span><span class="w"> </span><span class="s">"lang"</span><span class="p">]</span><span class="w"> </span><span class="no">:en</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">with-locale</span><span class="w"> </span><span class="n">locale</span><span class="w">
        </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">request</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Наконец, напишем фильтр tr для шаблонной системы. Это обертка над одноименной
функцией. Внутри шаблона мы не можем указывать ключевые слова, только
строки. Это значит, вместо <code class="language-plaintext highlighter-rouge">{{ :ui/sign-in }}</code> пишут <code class="language-plaintext highlighter-rouge">{{ "ui/sign-in"
}}</code>. Фильтр <code class="language-plaintext highlighter-rouge">tr</code> переводит это строку в ключ, а затем ищет по нему
перевод. Функция <code class="language-plaintext highlighter-rouge">add-filter!</code> заносит функцию в регистр фильтров под именем
“tr”.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">selmer.filters</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">add-filter!</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">add-filter!</span><span class="w"> </span><span class="no">:tr</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">line</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="nb">keyword</span><span class="w"> </span><span class="n">tr</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь мы не заботимся об источнике локали уровне перевода. С нашей точки зрения
ее предоставил кто-то другой, а кто и как именно в данном случае не важно. В
любой момент мы изменим код <code class="language-plaintext highlighter-rouge">with-locale</code> и <code class="language-plaintext highlighter-rouge">wrap-locale</code>, но это не отразится
на шаблонах. Запись <code class="language-plaintext highlighter-rouge">{{ "ui/log-in"|tr }}</code> останется прежней, даже если механизм
переводов изменится.</p>

<h2 id="локальные-переменные-в-контексте">Локальные переменные в контексте</h2>

<p>Форма <code class="language-plaintext highlighter-rouge">binding</code> связывает переменные с новыми значениями один раз. В блоке кода
невозможно задать одной из переменных новое значение. Это возможно только в
рамках вложенного <code class="language-plaintext highlighter-rouge">binding</code>, что не всегда удобно, особенно когда мы пишем
императивный код.</p>

<p>Макрос <code class="language-plaintext highlighter-rouge">with-local-vars</code> объявляет набор локальных переменных. Их особенность в
том, что внутри макроса им можно назначать произвольные значения. Каждая
переменная это маленький объект, для которого работают операции <code class="language-plaintext highlighter-rouge">get</code> и <code class="language-plaintext highlighter-rouge">set</code>,
то есть получить и установить значение.</p>

<p>Локальные переменные полезны, когда описывают запутанную бизнес-логику. Макрос
<code class="language-plaintext highlighter-rouge">with-local-vars</code> не сдвигает код вправо, как это делают <code class="language-plaintext highlighter-rouge">let</code> или
<code class="language-plaintext highlighter-rouge">binding</code>. Блок с локальными переменными выглядит линейно, его проще читать.</p>

<p>Форма <code class="language-plaintext highlighter-rouge">with-local-vars</code> похожа на <code class="language-plaintext highlighter-rouge">let</code>: это вектор связывания и произвольный
блок кода. Разница в том, что внутри макроса работают функции <code class="language-plaintext highlighter-rouge">var-get</code> и
<code class="language-plaintext highlighter-rouge">var-set</code>. С их помощью из переменных читают и записывают значения. Например,
если макрос задал переменную <code class="language-plaintext highlighter-rouge">a</code>, то форма <code class="language-plaintext highlighter-rouge">(var-set a 9)</code> установит ее
содержимое в 9.</p>

<p>Важно, что символ переменной вернет ее объект, а не значение. Убедимся в этом на
примере ниже:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">with-local-vars</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w">
  </span><span class="n">a</span><span class="p">)</span><span class="w">
</span><span class="c1">;; #&lt;Var: --unnamed--&gt;</span><span class="w">
</span></code></pre></div></div>

<p>Выражение вернуло не ноль, а объект типа Var. Поэтому запись <code class="language-plaintext highlighter-rouge">(+ a 1)</code> приведет
к ошибке приведения типов.</p>

<p>Чтобы извлечь значение из переменной, ее следует разыменовать или
“дерефнуть”. Для этого служит функция <code class="language-plaintext highlighter-rouge">var-get</code>; для краткой записи прибегают к
оператору <code class="language-plaintext highlighter-rouge">@</code>: <code class="language-plaintext highlighter-rouge">(+ @a 1)</code>.</p>

<h3 id="императивный-подход">Императивный подход</h3>

<p>Выше мы приводили пример с обработкой дерева. Из массивной структуры данных
нужно извлечь несколько величин и вернуть их композицию: сумму, произведение или
другое выражение. В прошлый раз мы использовали атом. Теперь решим задачу на
локальных переменных.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">calc-billing</code> рассчитывает сумму к оплате для клиента. Параметр data
это сводный отчет с метриками потребленных ресурсов. На уровне Clojure это
комбинация списков и словарей. Согласно бизнес-правилам, итоговую сумму находят
из трех составляющих. Каждую составляющую рассчитывают из данных рангом ниже и
так далее. Поскольку логика включает много условий, удобно выразить ее на
изменяемых переменных.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">calc-billing</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">with-local-vars</span><span class="w">
    </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w">

    </span><span class="c1">;; find a</span><span class="w">
    </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">usage</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;some</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="no">:usage</span><span class="w"> </span><span class="nb">last</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">days</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;some</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="no">:days</span><span class="w"> </span><span class="nb">first</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">var-set</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="n">days</span><span class="p">))))</span><span class="w">

    </span><span class="c1">;; find b</span><span class="w">
    </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">limits</span><span class="w"> </span><span class="n">...</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">vms</span><span class="w"> </span><span class="n">...</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">var-set</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">limits</span><span class="w"> </span><span class="n">vms</span><span class="p">))))</span><span class="w">

    </span><span class="c1">;; find c</span><span class="w">
    </span><span class="c1">;; ...</span><span class="w">

    </span><span class="c1">;; result</span><span class="w">
    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="o">@</span><span class="n">a</span><span class="w"> </span><span class="o">@</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">@</span><span class="n">c</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Локальные переменные не настолько продвинуты как атомы. Для переменных нет
аналога <code class="language-plaintext highlighter-rouge">swap!</code>, когда значение меняют функцией. Поэтому <code class="language-plaintext highlighter-rouge">with-local-vars</code> не
подходит для наращивания коллекций. Если user это локальный словарь, добавить к
нему новое поле будет затруднительно. Функция <code class="language-plaintext highlighter-rouge">var-set</code> может задать только
новый словарь, а комбинация <code class="language-plaintext highlighter-rouge">var-set</code> и <code class="language-plaintext highlighter-rouge">var-get</code> выглядит неуклюже:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">with-local-vars</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}]</span><span class="w">
  </span><span class="c1">;; (var-set user assoc :age 33) ;; won't work</span><span class="w">
  </span><span class="p">(</span><span class="nb">var-set</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="p">(</span><span class="nb">var-get</span><span class="w"> </span><span class="n">user</span><span class="p">)</span><span class="w"> </span><span class="no">:age</span><span class="w"> </span><span class="mi">33</span><span class="p">))</span><span class="w">
  </span><span class="o">@</span><span class="n">user</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Макросом <code class="language-plaintext highlighter-rouge">with-local-vars</code> пользуются, когда сложная логика завязана на простых
типах (числах, строках). На локальных переменных удобно писать конечные автоматы
и алгоритмы с состоянием. Эта техника редко встречается в проектах на Clojure,
но в нужный момент сэкономит время и код.</p>

<h2 id="глобальные-изменения-в-контексте">Глобальные изменения в контексте</h2>

<p>Преимущество <code class="language-plaintext highlighter-rouge">binding</code> в том, что изменения происходят только в текущем
треде. Вспомним пример с переменной <code class="language-plaintext highlighter-rouge">*out*</code>. Если беспорядочно менять ее в
процессе работы, получим непредсказуемый вывод. Говорят, что эффект binding
изолоированный или потокобезопасный, что расценивается как благо. И все же
бывают ситуации, когда изменения должны охватить систему глобально. Для этого
служит форма <code class="language-plaintext highlighter-rouge">with-redefs</code>.</p>

<p>Ее синтаксис похож <code class="language-plaintext highlighter-rouge">binding</code>: вектор связывания и произвольный блок кода. В
отличии от <code class="language-plaintext highlighter-rouge">binding</code>, эффект <code class="language-plaintext highlighter-rouge">with-redefs</code> распространяется на всю среду
исполнения. Это значит, изменения вступят в силу для каждого потока. Например,
веб-сервер обрабатывает сотни запросов в секунду в нескольких потоках. Если одна
из страниц выполняет часть логики в <code class="language-plaintext highlighter-rouge">with-redefs</code>, это повлияет на параллельные
запросы. Аналогично <code class="language-plaintext highlighter-rouge">binding</code> и <code class="language-plaintext highlighter-rouge">let</code>, изменения откатываются в момент выхода из
макроса.</p>

<p>Наивный пример ниже объясняет принципы <code class="language-plaintext highlighter-rouge">with-redefs</code>. Мы подменяем функцию
<code class="language-plaintext highlighter-rouge">println</code> на суррогат, который печатает фиксированный текст.</p>

<p>В теле макроса мы запускаем футуру с телом <code class="language-plaintext highlighter-rouge">(println 42)</code>. Футура (анг. future,
будущее) или фьючер это особый объект из области многопоточности. Футура
принимает блок кода и исполняет его в пуле тредов. В таком пуле каждый его тред
никогда не завершается, а только помечается как занятый или свободный. Если тред
свободен, он принимает задачу от футуры, исполняет ее и возвращает
результат. Футура это посредник между клиентом и внутренним механизмом
многопоточности.</p>

<p>Если коротко, тело <code class="language-plaintext highlighter-rouge">(println 42)</code> будет выполнено в другом потоке. Оператор <code class="language-plaintext highlighter-rouge">@</code>
перед футурой предписывает ждать до тех пор, пока не будет получен результат из
пула. Код ниже напечатает “fake print”:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-redefs</span><span class="w">
  </span><span class="p">[</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="s">"fake print"</span><span class="p">))]</span><span class="w">
  </span><span class="o">@</span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="mi">42</span><span class="p">)))</span><span class="w">
</span><span class="c1">;; fake print</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что если убрать оператор <code class="language-plaintext highlighter-rouge">@</code>, футура напечатает 42. Причина в том, что
на запуск футуры, передачу задания в пул, исполнение и остальные шаги требуется
время. С машинной точки зрения это сложный цикл, каждый этап которого занимает
такты проццессора. Без оператора <code class="language-plaintext highlighter-rouge">@</code> мы только запускаем футуру и сразу выходим
из <code class="language-plaintext highlighter-rouge">with-redefs</code>. Пул тредов доберется до задания <code class="language-plaintext highlighter-rouge">(println 42)</code> уже в тот
момент, когда эффект макроса закончился.</p>

<p>Изменения в нескольких потоках это особая веха в разработке ПО. На эту тему
пишут книги, этому учатся годами. Мы коснемся многопоточности в будущих главах
книги, а пока что рассмотрим пример с <code class="language-plaintext highlighter-rouge">with-redefs</code> из реального проекта.</p>

<p>Документация <code class="language-plaintext highlighter-rouge">with-redefs</code> подчеркивает, что макрос особенно полезен для
тестирования. Это связано с тем, что иногда приложение опирается на сторонние
сервисы. Например, географичесий поиск или граф связей социальных
сетей. Некоторые сервисы отвечают долго, поэтому к ним обращаются в фоне.</p>

<p>При тестировании возникает проблема доступа к этим сервисам. Нельзя допустить,
чтобы на каждый прогон тестов приложение обращалось к настоящему ресурсу. Это
усложняет экосистему, влечет утечку ключей, исчерпывает квоту на доступ к
сервису.</p>

<p>Идея в том, чтобы с помощью <code class="language-plaintext highlighter-rouge">with-redefs</code> заменить ключевые функции, которые
обращаются в сеть. Тогда кроме нормального поведения мы сможем имитировать
ошибки. Это возможно, если в качестве замены передать функцию, которая бросает
нужное исключение.</p>

<h3 id="приложение-с-координатами">Приложение с координатами</h3>

<p>Предположим, мобильное приложение отправляет на сервер текущее положение
пользователя. Это пара чисел: долгота и широта. Позже пользователь просматривает
историю путешествий. Очевидно, в списке локаций он ожидает не машинные цифры, а
названия мест и стран с фотографией. Поэтому для каждой пары координат мы должны
найти данные об этом месте.</p>

<p>Технически это устроено следующим образом. Страница <code class="language-plaintext highlighter-rouge">POST /location</code> принимает
коорданаты в JSON-теле запроса. Чтобы узнать данные о месте, мы посылаем запрос
в гео-сервис Гугла. Извлекаем из ответа основные поля и записываем их в базу
вместе с координатами. Затем возвращаем ответ 200 OK. Для мобильного приложения
это знак, что новая локация записана в базу.</p>

<p>Начальная версия кода. В данном случае функция <code class="language-plaintext highlighter-rouge">geo/place-info</code> обращается к
серверам Гугла. Она возвращает словарь с ключами <code class="language-plaintext highlighter-rouge">:title</code>, <code class="language-plaintext highlighter-rouge">:country</code>,
<code class="language-plaintext highlighter-rouge">:image_url</code> и другими. Мы объединяем эти данные с координатами и записываем в
базу.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">location-handler</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">params</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="n">point</span><span class="w"> </span><span class="p">(</span><span class="nb">select-keys</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="p">[</span><span class="no">:lat</span><span class="w"> </span><span class="no">:lon</span><span class="p">])</span><span class="w">
        </span><span class="n">place</span><span class="w"> </span><span class="p">(</span><span class="nf">geo/place-info</span><span class="w"> </span><span class="n">point</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">db/create-location</span><span class="w"> </span><span class="p">(</span><span class="nb">merge</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">place</span><span class="w"> </span><span class="n">point</span><span class="p">))</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="s">"OK"</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>В код закрался неочевидный недостаток. Пока мы извлекаем данные из Гугла,
мобильное приложение ждет ответа. С машинной точки зрения это долго, ведь сеть
не гарантирует мгновенную доставку данных. Чем больше мобильных клиентов
отправляют координаты на сервер, тем больше сетевых запросов мы посылаем в
Гугл. На сервере все больше висящих сетевых соединений, число запросов в секунду
снижается. Это дегенеративное поведение системы.</p>

<p>Заметим, что <code class="language-plaintext highlighter-rouge">geo/place-info</code> не гарантирует, что все данные получится извлечь
за один запрос. API Гугла со временем меняются. Например, поля с фотографиями
вполне могут переехать из условного geosearch в photosearch, что порождает
второй запрос.</p>

<p>Быстрое решение проблемы в том, чтобы записать координаты в базу и сразу же
ответить мобильному клиенту. А сбор данных о месте вынести в футуру. Тем самым
мы сократим время ожидания клиента. Теперь мобильное приложение ждет только
запись в базу и запуск футуры, что намного меньше, чем несколько запросов в
сеть.</p>

<p>В новой версии функция <code class="language-plaintext highlighter-rouge">db/create-point</code> записывает коорданаты и возвращает id
новой записи. Этот id нужен, чтобы позже обновить локацию данными о месте. Поиск
данных и запись в базу протекают в футуре.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">location-handler</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">params</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="n">point</span><span class="w"> </span><span class="p">(</span><span class="nb">select-keys</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="p">[</span><span class="no">:lat</span><span class="w"> </span><span class="no">:lon</span><span class="p">])</span><span class="w">
        </span><span class="n">row-id</span><span class="w"> </span><span class="p">(</span><span class="nf">db/create-point</span><span class="w"> </span><span class="n">point</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">future</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">place</span><span class="w"> </span><span class="p">(</span><span class="nf">geo/place-info</span><span class="w"> </span><span class="n">point</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">db/update-place</span><span class="w"> </span><span class="n">row-id</span><span class="w"> </span><span class="n">place</span><span class="p">)))</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="s">"OK"</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что быстрое решение не значит лучшее. В нашем случае возможны несколько
вариантов, например, с фоновым обработчиком или очередью задач. Но они дольше в
реализации, а вариант с футурой затрагивает лишь три строки. Это дешевое
временное решение, которое даст время на поиск оптимального.</p>

<h3 id="тесты">Тесты</h3>

<p>Напишем тест для этого обработчика. Чтобы не обращаться к реальным серверам
Гугла, временно заменим функцию <code class="language-plaintext highlighter-rouge">geo/place-info</code>. Для полноты картины проверим,
как поведет себя обработчик, если <code class="language-plaintext highlighter-rouge">geo/place-info</code> бросит сетевое исключение. В
таких случаях целевую функцию заменяют на анонимную, которая кидает нужное
исключение.</p>

<p>Каждый тест будет начинаться с выражения <code class="language-plaintext highlighter-rouge">with-redefs</code> для замены
<code class="language-plaintext highlighter-rouge">geo/place-info</code>. Чтобы уменьшить код, напишем макрос <code class="language-plaintext highlighter-rouge">with-place-info</code>. Он
принимает будущий результат функции и тело теста:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-place-info</span><span class="w">
  </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nf">with-redefs</span><span class="w"> </span><span class="p">[</span><span class="n">geo/place-info</span><span class="w">
                 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">~</span><span class="ss">'point</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="n">result</span><span class="p">)]</span><span class="w">
     </span><span class="o">~@</span><span class="n">body</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Вот как выглядит тест для положительного сценария. Внутри макроса
<code class="language-plaintext highlighter-rouge">with-place-info</code> вызов <code class="language-plaintext highlighter-rouge">geo/place-info</code> вернет переданный словарь. Мы вызываем
обработчик с координатами и проверяем, что получили код 200. Затем мы должны
убедиться, что футура извлекла данные и записала их базу. Добавляем небольшую
задержку и читаем из базы последнюю локацию. В ее полях должны быть данные из
тестового словаря.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-place-ok</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-place-info</span><span class="w">
    </span><span class="p">{</span><span class="no">:title</span><span class="w"> </span><span class="s">"test_title"</span><span class="w">
     </span><span class="no">:country</span><span class="w"> </span><span class="s">"test_country"</span><span class="p">}</span><span class="w">

    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">{</span><span class="no">:lat</span><span class="w"> </span><span class="mf">11.111</span><span class="w"> </span><span class="no">:lon</span><span class="w"> </span><span class="mf">22.222</span><span class="p">}}</span><span class="w">
          </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">status</span><span class="w"> </span><span class="n">body</span><span class="p">]}</span><span class="w"> </span><span class="p">(</span><span class="nf">location-handler</span><span class="w"> </span><span class="n">request</span><span class="p">)]</span><span class="w">

      </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="n">status</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"OK"</span><span class="w"> </span><span class="n">body</span><span class="p">))</span><span class="w">

      </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w">

      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">location</span><span class="w"> </span><span class="p">(</span><span class="nf">db/get-last-location</span><span class="p">)</span><span class="w">
            </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">title</span><span class="w"> </span><span class="n">country</span><span class="p">]}</span><span class="w"> </span><span class="n">location</span><span class="p">]</span><span class="w">

        </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">title</span><span class="w"> </span><span class="s">"test_title"</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">country</span><span class="w"> </span><span class="s">"test_country"</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы проверить, как поведет себя приложение во время ошибки, смоделируем
негативный сценарий. Пусть при обращении к <code class="language-plaintext highlighter-rouge">geo/place-info</code> будет выброшено
исключение с кодом 429. Такое возможно на практике, когда превышен лимит на
число запросов к службам Гугла. Объявим такое исключение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">ex-quota</span><span class="w">
  </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"429 Quota reached"</span><span class="w">
           </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">429</span><span class="w">
            </span><span class="no">:headers</span><span class="w"> </span><span class="p">{}</span><span class="w">
            </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:error_code</span><span class="w"> </span><span class="no">:QUOTA_REACHED</span><span class="w">
                   </span><span class="no">:error_message</span><span class="w"> </span><span class="s">"..."</span><span class="p">}}))</span><span class="w">
</span></code></pre></div></div>

<p>и напишем тест:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-place-quota-reached</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-place-info</span><span class="w">
    </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="n">ex-quota</span><span class="p">)</span><span class="w">

    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">{</span><span class="no">:lat</span><span class="w"> </span><span class="mf">11.111</span><span class="w"> </span><span class="no">:lon</span><span class="w"> </span><span class="mf">22.222</span><span class="p">}}</span><span class="w">
          </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">status</span><span class="w"> </span><span class="n">body</span><span class="p">]}</span><span class="w"> </span><span class="p">(</span><span class="nf">location-handler</span><span class="w"> </span><span class="n">request</span><span class="p">)]</span><span class="w">
      </span><span class="c1">;; ...</span><span class="w">
      </span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Текущая версия <code class="language-plaintext highlighter-rouge">location-handler</code> не перехватывает потенциальные ошибки, поэтому
тест выше пройдет неудачно. Подумайте, как улучшить обработчик страницы и тест к
нему для случая с негативным HTTP-ответом.</p>

<p>Возможен сценарий, когда мы получили от сервиса даже негативный ответ. Например,
из-за сбоя в сети на нашей стороне. Это значит, что вызов <code class="language-plaintext highlighter-rouge">geo/place-info</code>
бросает особое сетевое исключение. Напишем отдельный тест для недоступной сети:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-place-conn-err</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-place-info</span><span class="w">
    </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.net.ConnectException</span><span class="w"> </span><span class="s">"test_timeout"</span><span class="p">))</span><span class="w">
    </span><span class="c1">;; ...</span><span class="w">
    </span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Прием с подменой функций и классов называется мок или мокинг (анг. mock –
поделка). Мы подробно рассмотрим тесты в следующих главах и познакомимся с
другими техниками. Пока что заметим, что макрос with-redefs это простой способ
что-то “замокать”, то есть подменить окружение на время тестов.</p>

<p>Макрос <code class="language-plaintext highlighter-rouge">with-redefs</code> это улучшенный вариант формы <code class="language-plaintext highlighter-rouge">with-redefs-fn</code>. Их отличия в
синтаксисе. Макрос <code class="language-plaintext highlighter-rouge">with-redefs</code> напоминает привычные <code class="language-plaintext highlighter-rouge">let</code> и <code class="language-plaintext highlighter-rouge">binding</code>. Это
вектор связывания и блок кода. Макрос <code class="language-plaintext highlighter-rouge">with-redefs-fn</code> принимает словарь и
функцию без аргументов. Ключи словаря это переменные, то есть объекты
<code class="language-plaintext highlighter-rouge">Var</code>. Функция будет вызвана в момент, когда каждое значение словаря заменит
парную ему переменную.</p>

<p>Пример с заменой <code class="language-plaintext highlighter-rouge">geo/place-info</code> другим способом выглядит так. Напомним, что
синтаксис <code class="language-plaintext highlighter-rouge">#'&lt;something&gt;</code> аналогичен <code class="language-plaintext highlighter-rouge">(var &lt;something&gt;)</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-redefs-fn</span><span class="w">
  </span><span class="p">{</span><span class="o">#</span><span class="ss">'geo/place-info</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">point</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="no">:title</span><span class="w"> </span><span class="s">"test"</span><span class="p">})}</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">(</span><span class="nf">geo/place-info</span><span class="w"> </span><span class="p">{</span><span class="no">:lat</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:lon</span><span class="w"> </span><span class="mi">2</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Если тело макроса это одна большая форма, например, <code class="language-plaintext highlighter-rouge">let</code>, то не обязательно
оборачивать его в <code class="language-plaintext highlighter-rouge">(fn [])</code>. Достаточно подставить спереди знак <code class="language-plaintext highlighter-rouge">#</code>, чтобы
превратить форму в анонимную функцию.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-redefs-fn</span><span class="w">
  </span><span class="p">{</span><span class="o">#</span><span class="ss">'geo/place-info</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">point</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="no">:title</span><span class="w"> </span><span class="s">"test"</span><span class="p">})}</span><span class="w">
  </span><span class="o">#</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">point</span><span class="w"> </span><span class="p">{</span><span class="no">:lat</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:lon</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
         </span><span class="n">place</span><span class="w"> </span><span class="p">(</span><span class="nf">geo/place-info</span><span class="w"> </span><span class="n">point</span><span class="p">)]</span><span class="w">
     </span><span class="c1">;; ... do something else</span><span class="w">
     </span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Недостаток формы <code class="language-plaintext highlighter-rouge">with-redefs-fn</code> в том, что ее синтаксис более шумный. Легко
забыть, что тело должно быть не произвольным блоком кода, а функцией. Это делает
форму непохожей на другие макросы Clojure. <code class="language-plaintext highlighter-rouge">With-redefs</code> скрывает эти отличия, и
по возможности следует пользоваться им.</p>

<h2 id="все-вместе">Все вместе</h2>

<p>Clojure предлагает разнообразные приемы для изменения данных. Но в отличии от
императивных языков с их знаком равенства, в Clojure пользуются специальными
формами. Язык спроектирован так, что к изменениям прибегают выборочно. Это
считается продвинутым уровнем, к которому переходят после азов неизменяемости.</p>

<p>К этому моменту читатель может запутаться, в чем разница между отдельными
техниками и когда ими пользоваться. Перечислим объекты и функции, рассмотренные
выше и типовые сценарии, когда они полезны.</p>

<p><strong>Атом</strong> это объект-обертка вокруг целевого значения. Чтобы получить его
содержимое, применяют оператор <code class="language-plaintext highlighter-rouge">@</code> или форму <code class="language-plaintext highlighter-rouge">(deref &lt;atom&gt;)</code>. Можно сообщить
атому новое значение функцией <code class="language-plaintext highlighter-rouge">reset!</code>. Но чаще атом изменяют итеративно с
помощью функции, которая рассчитывает новое значение на базе старого.</p>

<p>В атомах хранят состояние отдельных частей проекта. Это счетчики, сессии,
локальный кеш для ускорения расчетов. Атомы участвуют в императивном коде как
изменяемые переменные. Иногда в атомах хранят состояние модуля, например,
текущее подключение к БД. Но в этом случае перед ним приходится ставить оператор
<code class="language-plaintext highlighter-rouge">@</code>, что не всегда удобно.</p>

<p>Особый объект <strong>volatile</strong> это облегченный вариант атома. В отличии от него,
volatile не поддерживает валидаторы и вотчеры.</p>

<p>Переходные или <strong>транзиентные коллекции</strong> это особая форма их постоянных
аналогов. Когда коллекция транзиентна, меняются ее внутренные элементы. На таких
коллекциях работают функции <code class="language-plaintext highlighter-rouge">conj!</code>, <code class="language-plaintext highlighter-rouge">assoc!</code> и другие с восклицательным знаком
на конце. Особая функция persistent! запечатывает изменяемую коллекцию и
возвращает ее постоянную версию.</p>

<p>Транзиентные коллекции полезны на больших объемах данных, поскольку быстрее
неизменяемых. Изменять коллекцию можно только из одного потока. Изменения должны
быть изолированы строго внутри функции. Другие части кода не должны знать о том,
что внутри коллекция изменяется. Обмен переходными коллекциями между функциями
считается грубой ошибкой.</p>

<p>Функция <strong>alter-var-root</strong> заменяет <code class="language-plaintext highlighter-rouge">def</code>-определение на произвольное значение. С
помощью функции можно вторгнутся в чужое пространство имен и что-то исправить
уже после его загрузки. Как правило, к <code class="language-plaintext highlighter-rouge">alter-var-root</code> прибегают, чтобы
скорректировать код, которым мы не распоряжаемся. Например, улучшить
логирование, улучшить поведение чужой функции.</p>

<p>Форма <strong>set!</strong> назначает новое значение глобальной переменной Clojure. Обычно
это служебные переменные с “ушками”. Форма редко встречается в коде, чаще всего
значения этих переменных задают в настройках проекта.</p>

<p>Форма <strong>binding</strong> выполняет произвольный код в рамках временных
изменений. Макрос связывает динамические переменные с новыми значениями на
период его работы. Чтобы переменная была динамической, в момент определения ей
сообщают флаг <code class="language-plaintext highlighter-rouge">^:dynamic</code>. Синтаксически такие переменные выделяют “ушками”.</p>

<p>К binding прибегают, чтобы временно назначить глобальным переменным Clojure
другие значения. Например, направить стандартный вывод в файл для конктретного
участка кода. Эффект binding действует только в текущем потоке. В других случах
макрос сокращает число аргументов для функции. Например, любой вызов tr внутри
формы <code class="language-plaintext highlighter-rouge">(with-locale :en)</code> вернет перевод для английского языка.</p>

<p>Макрос <strong>with-local-vars</strong> выполняет тело в контексте произвольных
переменных. Эти переменные похожи на объекты с двумя действиями: прочитать и
записать значения. Форма полезна, когда имеем дело со сложной императивной
логикой. При выходе из макроса переменные становятся недоступны.</p>

<p>Конструкция <strong>with-redefs</strong> временно изменяет <code class="language-plaintext highlighter-rouge">def</code>-определения. В отличии от
<code class="language-plaintext highlighter-rouge">binding</code>, она действует глобально. Все фоновые процессы (треды, футуры,
агенты), если они работают в момент действия макроса, подхватят
изменения. Технически <code class="language-plaintext highlighter-rouge">with-redefs</code> это обертка над более низкоуровневой формой
<code class="language-plaintext highlighter-rouge">with-redefs-fn</code>. В основном <code class="language-plaintext highlighter-rouge">with-redefs</code> используют чтобы подготовить систему
к прогону тестов (мокинг).</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-book-mutability/">
    <input required name="captcha" type="hidden" value="4 &#215; 6">

    <div class="block">
        <span class="comment-form-label"><small>4 &#215; 6 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
