<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ivan Grishaev's blog</title>
  <meta name="description" content="Writing on programming, education, books and negotiations.
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/page7/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="home">

    <ul class="post-list">
        
        <li>

            <h2>
                <a class="post-link" href="/mobile-deg/">Мобильная деградация</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2022-10-31T00:00:00+00:00">
        Oct 31, 2022
    </time>

    <a href="/tag/web/" rel="tag">web</a>, <a href="/tag/ui/" rel="tag">ui</a>, <a href="/tag/github/" rel="tag">github</a>

</div>


            <div class="entry">
                
                    <p>Последнее время я делю экран пополам: слева браузер, справа Емакс. Такой сетап нужен для определенной работы, связанной с редактированием текста.</p>

<p>Заметил, что с браузером происходят странные вещи. Стоит только поджать окно на жалкие пиксели, включается мобильный режим. Лучше всего это наблюдать на Гитхабе. Нормальный режим:</p>

<p><img src="/assets/static/aws/mobdeg/1.jpg" /></p>

<p>Но стоит уменьшить окно на пиксель, как вдруг:</p>

<p><img src="/assets/static/aws/mobdeg/2.jpg" /></p>

<p>Кто-нибудь в курсе, зачем это? Код — самое главное на этой странице — пропал под выпадашку, хотя места достаточно. Появилась адская разреженность, кнопки сплющились, как будто по ним проехали катком. Кто вообще просил? Остается выругаться и расширить окно обратно.</p>

<p>Досадно от того, что кто-то сидел над этой хитрожопой версткой, трекал часы в Джире, презентовал менеджерам. А пользователь мечтает развидеть и вернуть все взад.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/autocomplete/">Автодополнение</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2022-10-31T00:00:00+00:00">
        Oct 31, 2022
    </time>

    <a href="/tag/chrome/" rel="tag">chrome</a>, <a href="/tag/autocomplete/" rel="tag">autocomplete</a>, <a href="/tag/web/" rel="tag">web</a>

</div>


            <div class="entry">
                
                    <p>В хромо-подобных браузерах есть полезная функция — сохранение форм. Дико выручает, когда в сотый раз вводишь имя, фамилию и почту на сайте. Буквально сегодня я заполнял форму на сайте налоговой шестнадцать(!) раз. Если бы не автокомплит, я бы, наверное, стер пальцы. Тем более умники-разработчики повы..бывались с некоторыми полями, и в них не работает вставка. Какой-то скрипт блокирует событие, я начал было смотреть в консоли, но в итоге плюнул на это.</p>

<p>Удивляет, однако, то, что автокомплит нельзя редактировать. В очередной раз я вставил не то значение, и оно осталось в выпадашке навсегда. Теперь каждый раз, выбирая из нее пункт, надо быть осторожнее, чтобы не тыкнуть не туда.</p>

<p><img src="/assets/static/aws/autocomplete/1.png" /></p>

<p>Не понимаю, почему автокомплит нельзя редактировать? Хватило бы удаления: напротив каждого элемента сделать крестик, который удаляет его из выпадашки. Просто и дешево.</p>

<p>Между прочим, такая функция есть в Телеграме. Предположим, вы искали сообщество LaTeX, а нашли латекс и доминирование:</p>

<p><img src="/assets/static/aws/autocomplete/2.png" /></p>

<p>Если тыкнуть в любой канал <em>(ну, просто так)</em>, он останется в истории поиска. Будет неприятно, если это всплывет на созвоне при шаринге экрана. Крестик справа удаляет элемент из истории поиска, и с ним я спокоен: никакого доминирования мой собеседник не увидит.</p>

<p><img src="/assets/static/aws/autocomplete/3.png" /></p>

<p>В общем смысле это ведет к правилу: собираешь данные — позволь клиенту их удалить. Удаление стоит усилий, порой огромных (привет GDPR), но тогда незачем и начинать.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/win-win/">Win-win</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2022-10-27T00:00:00+00:00">
        Oct 27, 2022
    </time>

    <a href="/tag/win-win/" rel="tag">win-win</a>, <a href="/tag/%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D0%BE%D0%B2%D0%BE%D1%80%D1%8B/" rel="tag">переговоры</a>

</div>


            <div class="entry">
                
                    
<p>Читаю книгу Егора <a href="https://www.piter.com/product/nash-kod-remeslo-professiya-iskusstvo">“Наш код”</a>. Хорошая книга, местами спорная, но ничего — просто держите в голове, что это Егор. Есть, однако, момент, мимо которого я не мог пройти молча — это эпизод с переговорами между двумя группами.</p>

<p>Я хотел привести оригинальный текст, однако электронной версии, откуда можно скопировать и вставить, в интернете нет. Поэтому расскажу завязку своими словами.</p>

<p>Есть группа разработчиков, которые пилят REST API, и есть группа потребителей. Понадобилась доработка сервиса, и потребители выдвигают условие: чтобы новые данные можно было забрать одним запросом. Разработчикам сервиса это неудобно: они сделали несколько новых методов, полагая, что потребители пошлют несколько запросов. Группы не сошлись во мнении, и начинается совещание.</p>


                    <p><a href="/win-win/">Read more &rarr;</a></p>
                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/preview/">Программа Preview</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2022-10-07T00:00:00+00:00">
        Oct 7, 2022
    </time>

    <a href="/tag/ui/" rel="tag">ui</a>, <a href="/tag/preview/" rel="tag">preview</a>, <a href="/tag/mac/" rel="tag">mac</a>, <a href="/tag/software/" rel="tag">software</a>

</div>


            <div class="entry">
                
                    <p>Если я когда-нибудь пересяду с Мака на что-либо другое, больше всего мне будет не хватать… программы Preview. Да, встроенной программы просмотра изображений. Все потому, что Preview — невероятно мощный софт. Просмотр картинок и PDF лишь малая часть ее возможностей. Ниже я расскажу, что именно она умеет.</p>

<p>(1) Банально, но все-таки — Preview открывает картинки и PDF. Не нужно ставить сторонний софт, который пропишет себя в автозагрузку и службы. С тяжелым сердцем вспоминаю Adobe Reader, который разросся до размера офисного пакета.</p>

<p>Поставив Windows 10 на игровой комп, был удивлен, что в ней нечем открыть PDF (браузер Edge не в счет). По клику на PDF открывается магазин Microsoft – как это возможно в 2022 году, не понимаю. А на Маке сел — и читаешь PDF.</p>


                    <p><a href="/preview/">Read more &rarr;</a></p>
                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/lndir/">Коротко об lndir</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2022-10-07T00:00:00+00:00">
        Oct 7, 2022
    </time>

    <a href="/tag/lndir/" rel="tag">lndir</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/symlink/" rel="tag">symlink</a>, <a href="/tag/make/" rel="tag">make</a>

</div>


            <div class="entry">
                
                    <p>Небольшая заметка о утилите, которая требуется редко, но метко – <code class="language-plaintext highlighter-rouge">lndir</code>.</p>

<p>Когда у меня стало больше одного Мака, появилась проблема синхронизации настроек. Другими словами, чтобы всякие <code class="language-plaintext highlighter-rouge">.thisrc</code> и <code class="language-plaintext highlighter-rouge">.thatrc</code> были одинаковы и подхватывались при изменении. Сюда входит конфиг Emacs, ssh, словари aspell, профили AWS, конфиги ctags, zshell и многое другое.</p>

<p>Легче всего держать dot-файлы в репозитории и ставить симлинки. Неожиданно я столкнулся с тем, что не так легко написать shell-скрипт, который бы поставил симлинки на файлы из папки. Пытался при помощи <code class="language-plaintext highlighter-rouge">find ... -execute</code> и <code class="language-plaintext highlighter-rouge">xargs</code>, но постоянно что-то мешало. То отсутствие файла, то его существование, словом, всякие досадные случаи. В итоге было две команды: сначала одна удаляет симлинки, а вторая создает их заново.</p>

<p>Оказалось, что <code class="language-plaintext highlighter-rouge">lndir</code> делает именно то, что я искал. Они принимает две папки и строит дерево симлинков из первой во вторую. При этом учитывает случаи, что я перечислил, например если симлинк уже есть. Благодаря этому дерево можно обновлять итеративно.</p>

<p>Пример: в каталоге <code class="language-plaintext highlighter-rouge">~/work/System/Dotfiles</code> хранятся оригинальные файлы Emacs, <code class="language-plaintext highlighter-rouge">.ssh</code> и прочие. Следующая команда make расставит симлинки в домашнюю папку:</p>

<div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">HOME</span> <span class="o">=</span> /Users/ivan
<span class="nv">PWD</span> <span class="o">=</span> <span class="nf">$(</span><span class="nb">shell</span> <span class="nb">pwd</span><span class="nf">)</span>

<span class="nl">create-symlinks</span><span class="o">:</span>
	lndir <span class="nv">${PWD}</span>/Dotfiles <span class="nv">${HOME}</span>
	<span class="nb">chmod </span>600 <span class="nv">${HOME}</span>/.ssh/<span class="k">*</span>
</code></pre></div></div>

<p>Для файлов ssh необходимо выставить права 600, иначе утилита ругается.</p>

<p>Синхронизация происходит обычным способом через git. Как только вы поменяли один из файлов, делаете коммит и пуш. На другой машине пулл и <code class="language-plaintext highlighter-rouge">make create-symlinks</code>, и все подхватывается. Репозиторий, понятно, должен быть приватным.</p>

<p>По умолчанию <code class="language-plaintext highlighter-rouge">lndir</code> нет в поставке Линукса и Мака. Ставится из привычных <code class="language-plaintext highlighter-rouge">apt</code> и <code class="language-plaintext highlighter-rouge">brew</code>.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/github-ui/">Интерфейс Гитхаба</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2022-10-04T00:00:00+00:00">
        Oct 4, 2022
    </time>

    <a href="/tag/github/" rel="tag">github</a>, <a href="/tag/ui/" rel="tag">ui</a>

</div>


            <div class="entry">
                
                    <p>У меня бомбит от интерфейса Гитхаба. Он работает по странному принципу: показывает то, что не нужно и не показывает то, что нужно.</p>

<p>Когда я открываю pull request, то хочу увидеть изменения в файлах. Поскольку я обычный программист, не гений и без заскоков, полагаю, это желание подходит большинству. Почти всегда, когда мне кидают PR, я знаю заранее, с какой задачей он связан, и сразу смотрю файлы. Только в редких случаях мне нужно прочесть описание.</p>

<p>В интерфейсе PR файлы задвинуты на последнюю вкладку “Files changes”, и я не верю, что этому есть разумная причина. Файлы это суть PR, с какой стати задвигать их в конец? Это же самое нужное! Изменения должны быть сразу под описанием, чтобы не кликать, а просто смотать экран.</p>

<p><img src="/assets/static/aws/github-ui/1.jpeg" /></p>

<p><em>Есть ли на этой вкладке хоть грамм полезной информации? Если да, чем он важнее 18 измененных файлов?</em></p>

<p>Далее эти дурацкие табы. Проблема в том, что на вкладках располагаются не только данные, но и кнопки. Например, закрыть PR можно только со вкладки “Conversation”. А поставить аппрув только со вкладки “Files”. В итоге постоянно кликаешь на первый и последний табы.</p>

<p>Первый и последний, Карл! Уже это говорит, что как минимум они должны быть рядом, если не объединены в один.</p>

<p>По этой причине я пользуюсь трюком: когда кидаю ссылку на PR, добавляю к концу <code class="language-plaintext highlighter-rouge">/files</code>, то есть не <code class="language-plaintext highlighter-rouge">...project/pull/3</code>, а <code class="language-plaintext highlighter-rouge">...project/pull/3/files</code>. При таком раскладе у человека сразу откроются файлы, и не придется переключать табы. Мелочь, а приятно, особенно если собеседник понимает этикет и отвечает тем же.</p>

<p>Судите сами: вот мне пришел PR с комментарием. Рассмотрим действия, которые я должен выполнить для мерджа:</p>

<ul>
  <li>открыть ссылку на PR;</li>
  <li>перейти на files, чтобы бегло посмотреть, что внутри;</li>
  <li>если все хорошо, вернуться на вкладку conversation;</li>
  <li>нажать merge;</li>
  <li>нажать delete branch.</li>
</ul>

<p>По мне все можно уместить на одной странице и работать без кликов.</p>

<p>Из-за особенностей интерфейса кнопка “delete branch” находится выше “merge”, то есть сначала нажимаешь ту кнопку, что ниже, а потом выше. Это ни в какие ворота: экран мотают сверху вниз, и чем ниже кнопка, тем она важнее.</p>

<p><img src="/assets/static/aws/github-ui/5.jpeg" /></p>

<p>В целом интерфейс Гитхаба шумный и грязный. На закладке “Conversation” схематично указаны коммиты, хотя есть отдельная вкладка “Commits”. Зачем размазывать их по двум вкладкам? Все, что касается коммитов, должно быть в “Commits”.</p>

<p>Даже если у PR нет описания, будет пустой комментарий вида:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>igrishaev commented 20 minutes ago
No description provided
</code></pre></div></div>

<p>Спрашивается, что именно commented? Зачем писать о том, чего нет?</p>

<p>Особую грусть вызывает мобильное приложение Гитхаба. Почему-то оно не может нормально показать код: кнопка “Browse code” вечно болтается внизу. Что мешает сделать ее первой? В этом плане Гитхаб напоминает современный Дропбокс: приложение плохо показывает то, с чем работает.</p>

<p>Однажды я хотел закрыть PR со спамом, но не нашел кнопку “Close pull request”. Возможно, она была под выпадашкой или вроде того, но увы, я пас.</p>

<p><img src="/assets/static/aws/github-ui/4.jpeg" /></p>

<p><em>Слева: где посмотреть код? Справа: как закрыть PR?</em></p>

<p>Мне кажется, интерфейс Гитхаба разжирел, и пора устроить ему чистку. Он достиг стадии “впихнуть невпихуемое”, как это бывает с продуктами, которые часто выкатывают фичи. Интерфейс должен щадить пользователя: не вываливать на голову все подряд в надежде, что кому-то пригодится. Интерфейс — это оборона пользователя от того ада, что творится на серверах. Давайте помнить об этом, хоть я и не верю, что дизайнеры Гитхаба меня услышат.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/de-js-4/">Деджаваскриптизиция (4)</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2022-10-01T00:00:00+00:00">
        Oct 1, 2022
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/javascript/" rel="tag">javascript</a>, <a href="/tag/blog/" rel="tag">blog</a>, <a href="/tag/disqus/" rel="tag">disqus</a>, <a href="/tag/comments/" rel="tag">comments</a>

</div>


            <div class="entry">
                
                    <p>Пора заканчивать эпопею про избавление от Js. Чтобы не утомлять, расскажу о последнем штрихе — как внедрил капчу для комментариев.</p>

<p>Как только я убрал Disqus, полезли спамные комментарии. Каждый день приходят два-три предложения купить виагру, надувную лодку или просто левые ссылки. Поскольку каждый комментарий открывает PR в репозиторий, все остается в истории Гитхаба. Посмотреть на это добро <a href="https://github.com/igrishaev/blog/pulls?q=is%3Apr+is%3Aclosed">можно по ссылке</a>.</p>

<p>Разгребать подобные комментарии нет желания, поэтому должна быть минимальная защита от спама. С условием — без Js. Надумал такую схему:</p>

<ul>
  <li>капча генерируется на этапе сборки блога. На выходе получается HTML-форма с полем captcha и значением 2 × 5.</li>
  <li>В форму добавляется поле для решения.</li>
  <li>Сервер парсит капчу, решает и сверяет с ответом. Если что-то не так, заворачивает комментарий.</li>
</ul>

<p>Как ни странно, даже на таком примитиве боты отваливаются. Разве что с оговоркой: когда был оператор +, боты решали капчу. Как только заменил на <code class="language-plaintext highlighter-rouge">×</code> (знак умножения в юникоде), стала тишь да благодать. Надеюсь, читатель не забыл таблицу умножения! Тестируя форму, сам подвис с примером <code class="language-plaintext highlighter-rouge">8 × 9</code>.</p>

<p>Техническая сторона: вот построить капчу в шаблоне:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
{% assign val1 = '1 2 3 4 5 6 7 8 9' | split: ' ' | sample %}
{% assign val2 = '1 2 3 4 5 6 7 8 9' | split: ' ' | sample %}
{% assign op   = '&amp;#215;'            | split: ' ' | sample %}
{% assign captcha = val1 | append: " " | append: op | append: " " | append: val2 %}

</code></pre></div></div>

<p>Замечу, что при каждой сборке блога значения будут разные.</p>

<p>Скрытое поле в форме:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nt">&lt;input</span> <span class="na">required</span> <span class="na">name=</span><span class="s">"captcha"</span> <span class="na">type=</span><span class="s">"hidden"</span> <span class="na">value=</span><span class="s">"{{ captcha }}"</span><span class="nt">&gt;</span>

</code></pre></div></div>

<p>Виджет для ввода решения:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"block"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"comment-form-label"</span><span class="nt">&gt;&lt;small&gt;</span>{{ captcha }} = <span class="nt">&lt;/small&gt;&lt;/span&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">required</span> <span class="na">id=</span><span class="s">"comment-form-solution"</span> <span class="na">name=</span><span class="s">"solution"</span> <span class="na">type=</span><span class="s">"text"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/div&gt;</span>

</code></pre></div></div>

<p>Наконец, серверный код проверки капчи:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">d</span><span class="err">е</span><span class="k">fn</span><span class="w"> </span><span class="n">validate-captcha</span><span class="w"> </span><span class="p">[</span><span class="n">captcha</span><span class="w"> </span><span class="n">solution</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[[</span><span class="n">_</span><span class="w"> </span><span class="n">val1-raw</span><span class="w"> </span><span class="n">op-raw</span><span class="w"> </span><span class="n">val2-raw</span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="nb">re-find</span><span class="w"> </span><span class="o">#</span><span class="s">"^(-?\d+) (.+?) (-?\d+)$"</span><span class="w"> </span><span class="n">captcha</span><span class="p">)]</span><span class="w">

    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">val1</span><span class="w">
          </span><span class="p">(</span><span class="nf">Integer/parseInt</span><span class="w"> </span><span class="n">val1-raw</span><span class="p">)</span><span class="w">

          </span><span class="n">val2</span><span class="w">
          </span><span class="p">(</span><span class="nf">Integer/parseInt</span><span class="w"> </span><span class="n">val2-raw</span><span class="p">)</span><span class="w">

          </span><span class="n">op</span><span class="w">
          </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">op-raw</span><span class="w">
            </span><span class="p">(</span><span class="s">"+"</span><span class="w"> </span><span class="s">"&amp;#43;"</span><span class="p">)</span><span class="w"> </span><span class="nb">+</span><span class="w">
            </span><span class="p">(</span><span class="s">"*"</span><span class="w"> </span><span class="s">"×"</span><span class="w"> </span><span class="s">"&amp;#215;"</span><span class="p">)</span><span class="w"> </span><span class="nb">*</span><span class="w">
            </span><span class="n">nil</span><span class="p">)]</span><span class="w">

      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">val1</span><span class="w"> </span><span class="n">val2</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">op</span><span class="w"> </span><span class="n">val1</span><span class="w"> </span><span class="n">val2</span><span class="p">))</span><span class="w">
           </span><span class="p">(</span><span class="nf">str/trim</span><span class="w"> </span><span class="n">solution</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Грубо, неуклюже, но работает.</p>

<p>На этом я закончу тему с избавлением от Js. На мой взгляд, цели достигнуты, жить с новыми комментариями можно. Это был интересный опыт, в будущем пригодится.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/de-js-3/">Деджаваскриптизиция (3)</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2022-09-20T00:00:00+00:00">
        Sep 20, 2022
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/javascript/" rel="tag">javascript</a>, <a href="/tag/blog/" rel="tag">blog</a>, <a href="/tag/disqus/" rel="tag">disqus</a>, <a href="/tag/comments/" rel="tag">comments</a>

</div>


            <div class="entry">
                
                    <p>Сбылась мечта идиота: теперь на сайте работают комментарии без строчки кода на Джаваскрипте. Смотайте экран вниз, там форма. Требуется только имя и тело комментария. Ввели, отправили, и через некоторое время он появится в блоге.</p>

<p>Форма:</p>

<p><img src="/assets/static/aws/de-js3/1.jpg" /></p>

<p>Экран возврата:</p>

<p><img src="/assets/static/aws/de-js3/2.jpg" /></p>

<p>А что, мне нравится.</p>

<p>Расскажу, как это работает. <a href="/de-js-2/">В прошлый раз</a> я перенес комментарии Disqus в репозиторий. Каждый комментарий — это файл формата YAML + markdown. В числе прочего он хранит ссылку на пост. Когда я собираю блог, в подвал каждой заметки подставляются ее комментарии.</p>

<p>Для приема комментариев я следую тому же принципу: чтобы они появились на сайте, нужно создать файл в репозитории. Теоретически любой может оформить pull request, но это сложно. Должен быть сервис, который преобразует ввод пользователя в pull request для блога. Этот сервис я написал и назвал <a href="https://github.com/igrishaev/blog-backend">blog-backend</a>.</p>

<p>Сервис напоминает веб-приложение: оно принимает HTTP-запрос с формой. После прелюдии с валидацией перехожу к главному: интеграции с Гитхабом. Это оказалось не так-то просто. У Гитхаба уже <a href="https://docs.github.com/en/rest">три рестовых API</a>, но ни одно не покрывает все возможности. Кроме REST есть <a href="https://docs.github.com/en/graphql">убер-апишка на GraphQL</a> — она-то мне и нужна.</p>

<p>Интеграция с GraphQL была нелегкой: это самобытный язык и вещь в себе. Если бы в текущем проекте не было GraphQL, я бы полез на стенку. Во-вторых, сложность процесса: чтобы сделать PR силами API, нужно четыре вызова:</p>

<ol>
  <li>получить метаданные репозитория, в том числе последний коммит;</li>
  <li>создать ветку от этого коммита;</li>
  <li>сделать коммит в новую ветку;</li>
  <li>сделать PR.</li>
</ol>

<p>Как по мне, апишка не консистентна: где-то на репозиторий ссылаешься по имени, а где-то по машинному ID, который приходит из метаданных. То же самое с ветками: где-то имя, где-то айдишник. Ответы GraphQL развесистые, с глубокой вложенностью. Например, последний коммит ветки погружен на пять уровней:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(-&gt; resp-get-repo :data :repository :ref :target :oid)
</code></pre></div></div>

<p>С такой апишкой невозможно программировать без образца данных.</p>

<p>Когда подружился с Гитхабом, настала проблема хостинга: где и как размещать логику. Мне понравился опыт с облаком Яндекса, и я продолжил эксперименты. Сервис написан на Кложе, скомпилирован Граалем в бинарь и хостится в <a href="https://cloud.yandex.ru/docs/functions/concepts/">Яндекс.Функции</a> — аналоге AWS Lambda.</p>

<p>В свою очередь, Яндекс.Функция — это облачный сервис, где размещают какой-то код и дергают его по запросу. Отличие от обычного хостинга в том, что у лямбды нет состояния: она запускается на короткое время и умирает. В зависимости от окружения лямбда может умереть не сразу, и если ее дернуть повторно, сработает уже запущенный экземпляр. На базе этого делают “прогрев” лямбд, у которых окружение стартует медленно, например Java. В моем случае граальный бинарник быстрый как не весть что, прогрева ему не надо.</p>

<p>Лямбду можно вызывать разными способами, в том числе HTTP-запросом. У каждой лямбды свой урл, который может быть приватным и публичным. Его можно указать в разных сервисах, что отлично подходит для ботов.</p>

<p>По сравнению с VM-хостингом у лямбды следующие плюсы:</p>

<ul>
  <li>не нужна виртуальная машина и ее настройка;</li>
  <li>не нужен домен;</li>
  <li>лямбды экстремально дешевы, потому оплачивается только время работы с округлением до 0.1 секунды;</li>
  <li>лямбды поощряют писать код без компонентов и состояния, что как бальзам на душу после проектов по работе.</li>
</ul>

<p>Поначалу я был крайне скептичен к лямбдам, но теперь вижу в них особую прелесть. Единственный момент — пришлось написать код, чтобы подружить Кложу и Ring с окружением лямбды. Также поправил компиляцию Граалем, чтобы в бинарнике была верная кодировка. В будущем я планирую вынести код Яндекс.Облака в отдельную библиотеку, чтобы избавиться от копипасты.</p>

<p>Форма поддерживает синтаксис Markdown. Пока что нет кнопок выделения текста болдом и италиком, сделаю потом. Форма отправляется чистым POST, никаких аяксов, хотя первую версию я сделал на fetch, JSON и CORS. Про CORS я все забыл, и пришлось читать <a href="/cors/">свою же статью</a> о том, как все настроить.</p>

<p>Новые комментарии совмещают модерацию. После отправки создается PR в блог, мне приходит письмо, а пользователь переходит на прошлую страницу. Если все в порядке, я мерджу ветку и заливаю свежий билд блога. Таким образом, с момента публикации комментария может пройти от пяти минут до нескольких дней, но это ничего.</p>

<p>Первые комментарии я получил от кого? Правильно, от спамеров. Этим утром предложили виагру, казино и просто левые ссылки. Вот ссылка <a href="https://github.com/igrishaev/blog/pull/120/files">на уже закрытый RP</a> и его содержимое:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
id: 1663659055173
is_spam: false
is_deleted: false
post: /bookshelf/
date: 2022-09-20 07:30:55 +0000
author_fullname: 'epiehuliqukib'
---

http://slkjfdf.net/ - Tatacatay &lt;a href="http://slkjfdf.net/"&gt;Aebaluk&lt;/a&gt;
lwk.wlgg.grishaev.me.mrq.mn http://slkjfdf.net/
</code></pre></div></div>

<p>Очевидно, нужно вводить капчу для защиты от ботов. Я рассматриваю это как новый вызов: как сделать капчу без Javascript в статичном блоге? Уже есть мыслишки, расскажу в четвертой части эпопеи.</p>

<p>Наконец, последний тезис — зачем вы это делаете, мистер Андерсон? Зачем эти отказы, костыли, превозможения? Ответ — потому что могу. Просто хочется экспериментов. Надоели тормозные сайты с JS, хочу маленький оазис в своем огороде.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/clj-repl-part-4/">REPL, Cider, Emacs (часть 4/4)</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2022-09-14T00:00:00+00:00">
        Sep 14, 2022
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/repl/" rel="tag">repl</a>, <a href="/tag/emacs/" rel="tag">emacs</a>, <a href="/tag/cider/" rel="tag">cider</a>

</div>


            <div class="entry">
                
                    
<h2>Все части</h2>

<ul>
  <li><a href="/clj-repl-part-1/">Первая часть</a></li>
  <li><a href="/clj-repl-part-2/">Вторая часть</a></li>
  <li><a href="/clj-repl-part-3/">Третья часть</a></li>
  <li><a href="/clj-repl-part-4/">Четвертая часть</a></li>
</ul>

<h2>

    Оглавление

</h2>

<ul id="toc-item-clojure-repl-toc">
  <li><a href="#отладка-в-cider" id="toc-item-clojure-repl-toc-отладка-в-cider">Отладка в Cider</a>    <ul>
      <li><a href="#ограничения" id="toc-item-clojure-repl-toc-ограничения">Ограничения</a></li>
      <li><a href="#итог" id="toc-item-clojure-repl-toc-итог">Итог</a></li>
    </ul>
  </li>
  <li><a href="#nrepl-в-docker" id="toc-item-clojure-repl-toc-nrepl-в-docker">nREPL в Docker</a></li>
  <li><a href="#nrepl-в-боевом-режиме" id="toc-item-clojure-repl-toc-nrepl-в-боевом-режиме">nREPL в боевом режиме</a>    <ul>
      <li><a href="#nrepl-в-системе" id="toc-item-clojure-repl-toc-nrepl-в-системе">nREPL в системе</a></li>
      <li><a href="#безопасность" id="toc-item-clojure-repl-toc-безопасность">Безопасность</a></li>
    </ul>
  </li>
  <li><a href="#repl-в-других-средах" id="toc-item-clojure-repl-toc-repl-в-других-средах">REPL в других средах</a>    <ul>
      <li><a href="#поддержка-cider" id="toc-item-clojure-repl-toc-поддержка-cider">Поддержка Cider</a></li>
      <li><a href="#прочие-сведения" id="toc-item-clojure-repl-toc-прочие-сведения">Прочие сведения</a></li>
      <li><a href="#rebl" id="toc-item-clojure-repl-toc-rebl">REBL</a></li>
    </ul>
  </li>
  <li><a href="#заключение" id="toc-item-clojure-repl-toc-заключение">Заключение</a></li>
</ul>

<h2 id="отладка-в-cider">Отладка в Cider</h2>

<p>Мы исследовали отладку так долго, чтобы читатель убедился: в ней нет никакой магии. Отладчик — это код, который внедряется в исходный код и заставляет его работать с паузами. Во время паузы отладчик ждет команду пользователя и исполняет ее.</p>

<p>Теперь когда вы знакомы с самодельным отладчиком, рассмотрим, что предлагает Cider. В нашем распоряжении два тега: <code class="language-plaintext highlighter-rouge">#break</code> и <code class="language-plaintext highlighter-rouge">#dbg</code>. Первый тег означает точку останова (брейкпоинт) в месте, где он расположен. Поставьте <code class="language-plaintext highlighter-rouge">#break</code> в середину произвольного кода. Перед тем как запустить код, выполните его командой <code class="language-plaintext highlighter-rouge">cider-eval-...</code>, иначе эффект не вступит в силу.</p>

<p>Тег <code class="language-plaintext highlighter-rouge">#break</code> ссылается на функцию <code class="language-plaintext highlighter-rouge">breakpoint-reader</code> из модуля <code class="language-plaintext highlighter-rouge">cider.nrepl.middleware.debug</code>. Она принимает форму и добавляет в ее метаданные особое поле – признак отладки. Далее сработает оснащение (или инструментирование) — алгоритм, который ищет отмеченные формы и оборачивает их кодом, который запускает отладку.</p>

<p>Когда оснащенный код запущен, в нужных местах он прерывается, и от клиента ожидают команду. Можно узнать локальные переменные, выполнить выражение или перейти к следующей точке. Так продолжается до тех пор, пока код не выполнен целиком.</p>

<p>В Emacs нет графических средств отладки. Информация выводится либо рядом с кодом, либо в отдельных буферах. В режиме отладки файл нельзя редактировать; клавиши не вводят текст, а вызывают команды. Ошибка новичков в том, что, попав в отладку, они нажимают все подряд, и процесс протекает с ошибками. Ниже мы рассмотрим процедуру так, чтобы с вами этого не случилось.</p>


                    <p><a href="/clj-repl-part-4/">Read more &rarr;</a></p>
                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/de-js-2/">Деджаваскриптизиция (2)</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2022-09-13T00:00:00+00:00">
        Sep 13, 2022
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/javascript/" rel="tag">javascript</a>, <a href="/tag/blog/" rel="tag">blog</a>, <a href="/tag/disqus/" rel="tag">disqus</a>

</div>


            <div class="entry">
                
                    <p>Сделал то, что намеревался: удалил с сайта все сторонние сервисы. Больше нет социальных кнопок, гугло-аналитики и, самое важное, комментариев Disqus. На страницах вообще нет аякса за тем исключением, когда встроен плеер Ютуба. Красота.</p>

<p>Отдельно расскажу про комментарии. Теперь они встроены в блог, являются его частью, а не лежат на серверах Disqus. Для этого я написал импорт из XML. Ясное дело, на Кложе, <a href="https://github.com/igrishaev/blog/blob/master/clj-comments/src/clj_comments/core.clj">исходники на Гитхабе</a>.</p>

<p>Если вкратце, код пробегает по XML, строит мапы и индексы по ID. Для каждого комментария он создает файл вроде <code class="language-plaintext highlighter-rouge">_comments/2016-08-08-08-27-14.md</code> с содержимым:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
id: 2826354744
is_spam: false
is_deleted: false
post: /interview/
date: 2016-08-08T08:27:14Z
author_fullname: 'Александр'
author_nickname: 'VinokurovAlexnader'
author_is_anon: false
---

&lt;p&gt;Вопрос "Есть кортеж из трех элементов. Назначить переменным a, b, c его значения".&lt;/p&gt;
&lt;p&gt;У Вас ответ:&lt;br&gt;a, b, c = [1, 2, 3]&lt;/p&gt;
&lt;p&gt;Но это список, а не кортеж. С кортежом будет вот так:&lt;br&gt;a, b, c = (1, 2, 3)&lt;/p&gt;
</code></pre></div></div>

<p>Всего таких файлов 993. В шаблон заметки я добавил код для вывода комментариев:</p>

<pre><code class="language-jinja2">{% assign comments = site.comments | where:'post', include.permalink %}
{% if comments.size == 0 %}
&lt;center&gt;Комментариев пока нет&lt;/center&gt;
{% else %}
&lt;center&gt;Комментарии&lt;/center&gt;
&lt;div class="comments-block"&gt;
  {% for comment in comments %}
    &lt;div class="comment-block"&gt;
      &lt;p class="comment-lead"&gt;
        &lt;small&gt;
          &lt;em&gt;{{ comment.author_fullname or comment.author_nickname }}, {{ comment.date | date_to_string: "ordinal", "RU" }}&lt;/em&gt;
        &lt;/small&gt;
      &lt;/p&gt;
      &lt;div&gt;{{ comment.content | markdownify }}&lt;/div&gt;
    &lt;/div&gt;
  {% endfor %}
&lt;/div&gt;
{% endif %}
</code></pre>

<p>Получилось неоптимально, потому что на каждый пост происходит линейный поиск. В идеале нужно один раз построить словарь URL =&gt; список комментариев и затем брать оттуда. Но я не настолько хорошо знаю Jekyll и Ruby, чтобы это запилить.</p>

<p>Ради интереса проверьте страницы, где много комментариев, например <a href="/ivi/#comments-block">про сервис IVI</a> или <a href="/interview/#comments-block">про интервью</a>. Лично мне результат нравится: чистенький HTML, минимум CSS, все лаконично. На текущий момент не учитывается структура, но технически это возможно: каждый комментарий знает ID родителя, и однажды их вывод можно улучшить.</p>

<p><img src="/assets/static/aws/de-js2/2.png" /></p>

<p>Теперь главное: как сделать прием комментариев. Мне накидали советов, плюс я гуглил, и все сводится двум решениям: Гитхаб или self-hosted сервис.</p>

<p>Напомню, как работает Гитхаб: люди пишут комменты к какому-либо issue. Зная номер issue, легко выгрести комментарии GET-запросом, сгенерить HTML и вставить под заметкой. <a href="https://blog.rpsl.info/2020/09/how-migrate-comments-from-disqus-to-github/">Выглядит красиво</a>:</p>

<p><img src="/assets/static/aws/de-js2/1.png" /></p>

<p>, но меня тревожат две вещи.</p>

<ol>
  <li>Комментарии лежат в чужом сервисе, который может отвалиться из-за санкций или Роскомнадзора.</li>
  <li>Обязательна авторизация через Гитхаб — не у всех есть учетная запись.</li>
</ol>

<p>Self-hosted-решения вроде <a href="https://remark42.com/">Remark42</a> интересны, но вынуждают держать виртуалку, платить за нее и делать бекапы. Придется возиться.</p>

<p>Я придумал так. Пишем лямбду для Яндекс.Облака (на Кложе с компиляцией Граалем). Лямбда принимает POST-запросы с сайта. На сайте висит статичная форма с полем action=URL нашей лямбды. Отправить форму может любой желающий, даже тот, у кого нет учетки в Гитхабе, Твиттере, Инстаграме и так далее.</p>

<p>Получив запрос, лямбда создает pull request в репозитории блога. Для этого не нужен git: все возможности Гитхаба доступны <a href="https://docs.github.com/en/rest/pulls/pulls#create-a-pull-request">в REST API</a>. Pull request содержит новый файл с комментарием в папке <code class="language-plaintext highlighter-rouge">_comments</code>. Мне приходит письмо. Если норм, я нажимаю Merge, блог собирается и выкатывается новая версия.</p>

<p>Одновременно получается модерация: если кто-то написал дичь, я отклоняю PR, и делу конец.</p>

<p>Открыв PR, лямбда перенаправляет пользователя обратно в блог со словами “спасибо, ваш комментарий скоро появится”.</p>

<p>Вот такую штуку я хочу запилить. А пока что комментации работают только в Телеграме.</p>

                
            </div>

        </li>
        
    </ul>

    <h4>
        
        <a href="/page6" class="previous">&larr;</a>
        
        <span class="page_number ">Страница 7 из 65</span>
        
        <a href="/page8" class="next">&rarr;</a>
        
    </h4>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
