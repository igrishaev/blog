<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Мультиметоды в Кложе</title>
  <meta name="description" content="Возможно, я упоминал, что недавно сменил проект и теперь пишу на Кложе. Этосовременный диалект Лиспа под Джава-машину. Кложа довольно проста, и многиезадачи ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/defmulti/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Мультиметоды в Кложе</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2016-12-29T00:00:00+00:00">
        Dec 29, 2016
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Возможно, я упоминал, что недавно сменил проект и теперь пишу на Кложе. Это
современный диалект Лиспа под Джава-машину. Кложа довольно проста, и многие
задачи в ней решаются исключительно функциями и коллекциями. Так, на
собеседованиях в проект я беседовал с разработчиками, которые ничего кроме
словарей и коробочных функций не знали.</p>

<p>Не скажу, чтобы это плохо: язык должен быть простым. Чем меньше правил и
бест-практик нужно помнить, тем легче на нем писать. Однако, есть в Кложе
классные штуки, точечное применение которых сэкономит время и объем кода.</p>

<p>С сегодняшнего для я решил коротко описывать Кложные фишки, на изучение которых
вечно не хватает времени. В сегодняшнем выпуске речь пойдет о мультиметодах. Но
сначала коротко о том, что такое мультиметоды вообще.</p>

<p>Мы знаем, что ООП базируется на инкапсуляции, наследовании и
полиморфизме. Рассмотрим последний. Полиморфизм – это когда у метода может быть
несколько реализаций. Конкретная реализация выбирается в зависимости от типов
параметров.</p>

<p>В классическом ООП нам бы привели такой пример. У класса <code class="language-plaintext highlighter-rouge">Geometry</code> есть метод
square для вычисления фигур. На вход могут подать окружность, квадрат и
треугольник. Запишу на каком-то выдуманном языке:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Geometry:

    real square(Circle c):
        return Math.PI * c.radius * c.radius;

    real square(Rectangle rect):
        return rect.a * rect.b;

    real square(Triangle tri):
        real p = (tri.a + tri.b + tri.c) / 2;
        return Math.sqrt(p * (p - tri.a) * (p - tri.b) * (p - tri.c))
</code></pre></div></div>

<p>В зависимости от типа фигуры подбирается нужный метод. Не может быть два метода
с одинаковым набором параметров, даже если их имена различаются. Если передать
совершенно другой объект, например, <code class="language-plaintext highlighter-rouge">Rombus</code>, будет ошибка, причем еще на этапе
компиляции.</p>

<p>Уверен, каждый помнит это с университетских времен. Но полиморфизм на типах –
всего лишь частный случай мультиметодов. В отличии от полиморфизма, мультиметоды
не прибиты гвоздями к ООП, а значит, дают б<strong>о</strong>льшую свободу в идеи и
реализации.</p>

<p>Для адептов ООП это, возможно, прозвучит сюпризом, но мультиметоды существуют во
многих языках, в т.ч. в которых объектов не существует. Почти любой
функциональный язык поддерживает множественные <em>клозы (clause)</em> для функций. Но
если в ООП все сводится к типам, то в функциональных языках действует более
мощный механизм подбора основанный на паттерн-матчинге.</p>

<p>Рассмотрим Хаскель. То, что выше я записал на выдуманном языке, в Хаскеле будет
так:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Circle</span> <span class="o">=</span> <span class="kt">Circle</span> <span class="kt">Float</span>
<span class="kr">data</span> <span class="kt">Rectangle</span> <span class="o">=</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span>
<span class="kr">data</span> <span class="kt">Triangle</span> <span class="o">=</span> <span class="kt">Triangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span>

<span class="n">square</span> <span class="o">::</span> <span class="kt">Circle</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
<span class="n">square</span> <span class="p">(</span><span class="kt">Circle</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.1415</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span>

<span class="n">square</span> <span class="o">::</span> <span class="kt">Rectangle</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
<span class="n">square</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="n">square</span> <span class="o">::</span> <span class="kt">Triangle</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
<span class="n">square</span> <span class="p">(</span><span class="kt">Triangle</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="o">$</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span>
<span class="kr">where</span>
  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div></div>

<p>Видно, что функция <code class="language-plaintext highlighter-rouge">square</code> работает с типами окружность, прямоугольник,
треугольник. В любой момент мы можем дополнить ее новой фигурой.</p>

<p>Есть мультиметоды и в классических диалектах Лиспа. Вот, например, копипаста из
Википедии, взятая из кода Астероидов:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defmethod collide-with ((x asteroid) (y asteroid))
   ;; deal with asteroid hitting asteroid
   )
 (defmethod collide-with ((x asteroid) (y spaceship))
   ;; deal with asteroid hitting spaceship
   )
 (defmethod collide-with ((x spaceship) (y asteroid))
   ;; deal with spaceship hitting asteroid
   )
 (defmethod collide-with ((x spaceship) (y spaceship))
   ;; deal with spaceship hitting spaceship
   )
</code></pre></div></div>

<p>Особенность примера с Лиспом в том, что второй параметр в каждой паре ведет себя
как предикат. В данном случае тип <code class="language-plaintext highlighter-rouge">spaceship</code> срабатывает как проверка того, что
<code class="language-plaintext highlighter-rouge">x</code> – экземпляр космического корабля. Однако, вместо <code class="language-plaintext highlighter-rouge">spaceship</code> можно передать
другие проверки: <code class="language-plaintext highlighter-rouge">integer?</code>, <code class="language-plaintext highlighter-rouge">string?</code>, <code class="language-plaintext highlighter-rouge">even?</code>, словом, любой унарный предикат.</p>

<p>Столь гибкая система мультиметодов позволяет определить разное поведение для
одного и того же типа, но разных значений. Например, для отрицательной суммы
денег одно поведение, для нуля – второе, для положительной – третье. Для даты:
выходной или нет, високосный год или нет и т.д.</p>

<p>Думаю, ясно теперь, чем это выгодней банального полиморфизма на типах.</p>

<p>В Кложе более гибкая система мультиметодов. В рассмотренных выше примерах мы не
могли изменить сам принцип подбора метода, или диспатча. В Кложе, наоборот, <em>вы
обязаны</em> определить диспатч! Рассмотрим пример:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmulti</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="nb">class</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Данное определение говорит: прежде чем искать реализацию, метод получит класс
аргумента.</p>

<p>Следующее определение <strong>расширяет</strong> мульти-метод реализацией для <code class="language-plaintext highlighter-rouge">Long</code>: если
передано длинное целое, получим строку <code class="language-plaintext highlighter-rouge">"an integer"</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="s">"an integer"</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">multifn</span><span class="p">[</span><span class="n">foo</span><span class="w"> </span><span class="mi">0</span><span class="n">x478c7d41</span><span class="p">]</span><span class="w">
</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w">
</span><span class="s">"an integer"</span><span class="w">
</span></code></pre></div></div>

<p>Добавим для строки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s is a string"</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="n">multifn</span><span class="p">[</span><span class="n">foo</span><span class="w"> </span><span class="mi">0</span><span class="n">x478c7d41</span><span class="p">]</span><span class="w">
</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="s">"test"</span><span class="p">)</span><span class="w">
</span><span class="s">"test is a string"</span><span class="w">
</span></code></pre></div></div>

<p>Если ни одно соответствие не подошло, будет ошибка:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="n">IllegalArgumentException</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">multimethod</span><span class="w"> </span><span class="ss">'foo</span><span class="o">'</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">dispatch</span><span class="w"> </span><span class="n">value</span><span class="err">:</span><span class="w"> </span><span class="n">null</span><span class="w">
</span><span class="n">clojure.lang.MultiFn.getFn</span><span class="w"> </span><span class="p">(</span><span class="nf">MultiFn.java</span><span class="no">:156</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Не страшно, добавим реализацию по умолчанию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="no">:default</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"you passed %s"</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="s">"you passed null"</span><span class="w">
</span></code></pre></div></div>

<p>Диспатч может работать самым разным способом, например, проверять на типы все
аргументы. Повторим пример с площадью фигур:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmulti</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="nb">class</span><span class="w"> </span><span class="n">args</span><span class="p">)))</span><span class="w">

</span><span class="c1">;; rectangle</span><span class="w">
</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="p">[</span><span class="n">Long</span><span class="w"> </span><span class="n">Long</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">square</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">;; 6</span><span class="w">

</span><span class="c1">;; circle</span><span class="w">
</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="p">[</span><span class="n">Double</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">Math/PI</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">r</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">square</span><span class="w"> </span><span class="mf">1.1</span><span class="p">)</span><span class="w"> </span><span class="c1">;; 3.8013271108436504</span><span class="w">

</span><span class="c1">;; triangle</span><span class="w">
</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="p">[</span><span class="n">Long</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">Long</span><span class="p">]</span><span class="w">
               </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w">
               </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)]</span><span class="w">
                 </span><span class="p">(</span><span class="nf">Math/sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">c</span><span class="p">)))))</span><span class="w">
</span><span class="p">(</span><span class="nf">square</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">;; 1.7320508075688772</span><span class="w">
</span></code></pre></div></div>

<p>Замечу, что на самом деле Кложа проверяет значения диспатча и образца не простым
сравнением, а функцией <code class="language-plaintext highlighter-rouge">isa?</code>, что подразумевает иерархию. Так, чтобы проверку
проходили типы <code class="language-plaintext highlighter-rouge">PersistentArrayMap</code> и <code class="language-plaintext highlighter-rouge">PersistentHashMap</code>, достаточно указать
базовый класс <code class="language-plaintext highlighter-rouge">clojure.lang.APersistentMap</code>.</p>

<p>Наконец, проверять можно не только на типы, а банально на значения, диапазоны,
предикаты и тд. В текущем проекте я проверяю последний переданный аргумент. Это
может быть как айдишка, так и запись БД. В зависимости от этого условия
срабатывает разная логика.</p>

<p>Каждый мультиметод может вызвать внутри другой, тогда процесс диспатча начнется
заново.</p>

<p>Мультиметоды в Кложе отличаются еще и тем, что расширяемы извне. Это значит,
если разработчик определил мультиметод для определенных типов, ничто не мешает
расширить его до других типов. И это будет все тот же экземпляр.</p>

<p>Напомню ситуацию с примерами на Джаве и Хаскеле выше. Пусть фукция <code class="language-plaintext highlighter-rouge">square</code> и
класс <code class="language-plaintext highlighter-rouge">Geometry</code> находятся в чужих библиотеах. Тогда вы никак не сможете
изменить их! В лучшем случае вы унаследуете класс <code class="language-plaintext highlighter-rouge">Geometry</code>, добавите свой
метод для ромба. Но если есть еще одна библиотека, которая работает с
<code class="language-plaintext highlighter-rouge">Geometry</code>, <em>вы никак не сможете на это повлиять</em>.</p>

<p>Напротив, идея расширения чужих определений работает в Кложе просто
убийственно. Я нигде не видел ничего подобного.</p>

<p>В Кложе мультиметоды используют когда трудно предугадать, какие типы данных
будут поступать на вход. Это прекрасное решение для абстракций вроде работы с
БД, парсингом данных, декораторов и тд.</p>

<p>Мультиметоды в Лиспах – мощнейшей инструмент, порой в корне меняющий принцип
мышления и разработки.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/defmulti/">
    <input required name="captcha" type="hidden" value="1 &#215; 6">

    <div class="block">
        <span class="comment-form-label"><small>1 &#215; 6 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
