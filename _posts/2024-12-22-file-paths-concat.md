---
layout: post
title: "Файловые пути"
permalink: /file-paths-concat/
tags: programming files
---

У меня пожелание: давайте не будем строить файловые пути конкатенацией строк. Не
будем сами и не позволим другим. Как увидите в ревью что-то вроде

~~~
file_path = some_dir + "/" + file_name
~~~

, сразу пишите комментарий: не клей строки, используй функции, для этого
предназначенные.

Достоверно известен случай, когда человек потерял бизнес из-за ошибки в
файлах. Это был небольшой хостинг, и чел выполнил на всех машинах `sudo rm -rf
$FOO/$BAR`. Беда в том, что переменные не подхватились, и получилось `sudo rm
-rf /`.

Вы скажете, что есть флаг `-e`, чтобы вылететь с ошибкой, если переменная среды
не задана. Ну, допустим. Однако ничто не мешает сделать такую же ошибку в
коде. Например, кложуристы (которые, как известно, боги программирования),
строят пути конкатенацией строк:

~~~
(str some-dir "/" subdir "/" file-name)
~~~

И не знают, что функция `str` молча пропускает нуллы. Это значит, если
`file-name` равен nil, то путь получится `/some/dir/subdir/`. Если передать его
в функцию удаления, можно удалить всю папку.

По закону подлости, если что-то "можно", то оно случается. Сегодня отлаживал
этот баг. Человек строит путь примерно так:

~~~
(str "/tmp/" (get-dir-name ...))
~~~

Этот путь передается в функцию, которая рекурсивно удаляет папку. Но во-первых,
функция удаления была с багом и ничего не удаляла. А как только я починил,
выяснилось: при особых условиях `(get-dir-name...)` выдает nil, и путь
получается /tmp/. Функция исправно удаляет весь /tmp, в котором масса нужных
файлов.

Мораль: работая с путями как строками, легко отстрелить ногу. Вдвойне печально,
что это делают снова и снова. Я с этим борюсь, и вы помогайте.

Если речь про Кложу без библиотек, испольуйте `io/file`:

~~~
(io/file "/tmp" subdir filename)

java.io.File<"/tmp/subsir/filename.txt">
~~~

Если один из аргументов nil, оно свалится с ошибкой. А так есть либы вроде
`babashka/fs`.
