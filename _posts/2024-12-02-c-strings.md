---
layout: post
title: "Сишные строки"
permalink: /c-strings/
tags: programming c string
---

Одна из самых худших вещей в айти — это сишные нуль-терминированные
строки. Другими словами, цепочка байтов, которая завершается нулем. Керниган и
Ричи были гениями, никто не спорит, но решение с нулем на конце трудно назвать
удобным.

Беда в том, что, читая эту строку, никогда не знаешь, где конец. Сколько байтов
резервировать — 32 или килобайт? Немало ошибок в сишных программах связано с
тем, что неверно определяется конец строки.

Интересно наблюдать сишные строки в бинарном протоколе Postgres. В оригинальной
его части строки передаются как в Си — то есть неизвестной длины с нулем на
конце. Скажем, сообщение StartupMessage строится по принципу

~~~text
u s e r n a m e 0 d a t a b a s e 0
~~~

А в расширениях, которые появились позже, строки передаются нормально: сначала
длина в int32, потом байты без нуля:

~~~text
0 0 0 5 h e l l o
~~~

Пример — расширение `hstore`, в нем строки передаются с фиксированной
длиной. Видимо, разработчики поняли, что жить с нулем на конце нельзя и сделали
нормально.

Чтение строки известной длины — это две строчки кода. Чтение неизвестной строки
— это цикл, выделения буферов, конкатенация и прочий бред.

Общий тезис таков: главное должно быть первым. В строке чаще всего нас
интересует длина, поэтому она должна быть в начале. Бывает, содержимое вообще
неважно, нужно только переложить строку в другое место и не ошибиться на байт
туда-сюда. Сишные строки делают все, что такая ошибка случилась.

С любовью вспоминаю Паскаль, где строки были правильными: сначала байт с длиной,
потом содержимое. Правда, из-за этого строки не могли быть больше 256
байтов. Разные компиляторы предлагали строки, где под длину выделялось два байта
или четыре.

Можно долго рассуждать, что было и по каким причинам, но к делу это отношения не
имеет. Важно запомнить, что главное должно быть первым — как на экране, так и в
байтиках.
