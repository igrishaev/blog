---
layout: post
title:  "Вложенность"
permalink: /nesting-01/
tags: programming nesting
---

Об этом никто не пишет, а ведь проблема серьезная. Я говорю о лишней вложенности
данных. Недавний пример:

~~~clojure
{:manager
 {:risk
  {:time "10:30"
   :task-id 100400}}
 :accounter
 {:business
  {:time "12:35"
   :task-id 100500}}}
~~~

Это вложенная мапа: на первом уровне роль менеджера, на втором тип апрува, на
третьем — детали апрува: дата и ссылка на задачу. Спрашивается, зачем было
группировать события по роли и типу? Какой смысл? Почему не записать два
события:

~~~clojure
[{:role :manager
  :type :risk
  :time "10:30"
  :task-id 100400}
 {:role :accounter
  :type :business
  :time "12:35"
  :task-id 100500}]
~~~

Плоско, понятно, нет вложенности. Кому надо, сгруппируют и по роли, и по дате, и
бог знает как еще. А когда сгруппировано до нас, сперва нужно распутать, а потом
группировать как надо.

Второй пример: есть мапа с ключом children, в которой вектор мап. В каждой мапе
— айдишка и имя:

~~~clojure
{:children
 [{:id 1 :name "test1"}
  {:id 2 :name "test2"}
  {:id 3 :name "test3"}]}
~~~

Нужно построить индекс `id => name`, чтобы потом по нему искать. Я быстренько
прошел по children и собрал словарь:

~~~clojure
{1 "test2"
 2 "test2"
 3 "test3"}
~~~

На проде — сплошные промахи мимо индекса. Что такое? Оказалось, не до конца
прокрутил файлик. У некоторых children есть свои children, то есть структура
такая:

~~~clojure
{:children
 [{:id 1 :name "test1"}
  {:id 2 :name "test2"}
  {:id 3 :name "test3"}
  {:id 4
   :name "test4"
   :children
   [{:id 5
     :name "test5"}
    {:id 6
     :name "test6"
     :children
     [...]}]}]}
~~~

При этом ограничения в глубину нет: может быть два уровня, может двадцать.

Вот опять: кто этот гений, который сгруппировал? Как ты будешь это обходить?
Ладно у меня Кложа, я написал `(tree-seq :children :children data)` и готово. А
на каком-нибудь Питоне или Джаве голову сломаешь -- тут дерево с обходом, нужен
стек или очередь. Алгоритмы!

Сделай ты плоский список и добавь parent_id. Кому надо, построит иерархию:

~~~clojure
[{:id 1 :name "test1"}
 {:id 2 :name "test2"}
 {:id 3 :name "test3"}
 {:id 4 :name "test4"}
 {:id 5 :name "test5" :parent-id 4}
 {:id 6 :name "test6" :parent-id 5}]
~~~

И такое постоянно. Беру любой JSON и вижу, как его можно упростить, убрав лишнюю
вложенность. Вдвойне обидно, что на эту вложенность кто-то тратил время, а она
не нужна!

Особенно я не люблю, когда вкладывают равнозначные сущности. Например, у нас два
автора и у каждого две книги. JSON выглядит так:

~~~clojure
[{:id 1
  :name "John Smith"
  :books
  [{:id 20
    :title "The Best Novels"}
   {:id 30
    :title "Poems"}]}
 {:id 2
  :name "Sam Doe"
  :books
  [{:id 40
    :title "Some Story"}
   {:id 50
    :title "Achieves"}]}]
~~~

Что если нужны не книги по авторам, а просто все книги? Опять ходи собирай.

Я придумал способ как бороться такими случаями. О нем — в следующий раз.
