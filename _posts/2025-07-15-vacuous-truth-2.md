---
layout: post
title: "Пустая истина (2)"
permalink: /vacuous-truth-2/
tags: programming logic
telegram_id: 878
---

После прошлой заметки мне стали приходить, что называется, письма читателей. Их
можно разделить на два вида.

Первый — ты не шаришь в логике, сейчас я все объясню. Гляди... (далее километр
греческих букв, термины "антецедент", "консеквент" и другие). Вывалив все это,
человек считает, что открыл мне глаза. Я ничего из этого не понимаю, поэтому
прошу — не утруждайтесь подобными доказательствами.

Второй тип писем — в языке X предикат every работает так же: для пустого
множества вернет истину независимо от предиката. Да, согласен. Еще пять лет
назад выполнил в Постгресе такой запрос:

~~~sql
select 1 = ALL (array[]::int[]);
t
~~~

, получил истину и опечалился. Если же поменять `ALL` на `ANY`, получим
противоположный результат:

~~~sql
select 1 = ANY (array[]::int[]);
f
~~~

Здесь мы уподобляемся Джаваскриптерам: подаем нелепый ввод, получаем нелепый
вывод. При этом силимся подвести его под какую-то базу: антецеденты-консеквенты,
кванторы и прочее.

А дело в другом: аппарат логики не учитывает неопределенность. Это утопичная
модель, где есть только истина и ложь — третьего не дано. В тех местах, где
модель не ложится на реальность, начинаются подтасовки: истину раз — и обозвали
"пустой". То есть как бы истина, но не совсем.

Меня это страшно бесит, прям так, что не передать словами. Если результат
отличен от истины и лжи, заведи под него тип. Переработай модель логики, в конце
концов. Признай, что старая модель ограничена и не подходит под прикладные
задачи. И уж чего точно я не пойму, так это того, почему в языках
программирования мы опираемся на логику бог знает какой давности. Нужно делать
так, чтобы удобно здесь и сейчас, а не как принято в учебнике логики.

Правильный ответ в том, что в функции every пустое множество — это
неопределенность, краевой случай. То же самое, что получить первый элемент
массива, когда он пуст. В зависимости от языка мы получим null или исключение,
но точно не число 42 с пометкой "пустое" — это нонсенс.

Обратимся к более достойной науке, чем логика — математике. Рассмотрим функцию
`y = 1/x` (см. график ниже). Прелесть этой функции в том, что в точке 0 ее
значение не определено. Если точнее, при `x=0` результат будет бесконечностью,
причем даже нельзя сказать, какой именно — положительной или отрицательной. В
зависимости от того, с какой стороны приближаться к нулю — правой или левой —
функция будет уходить в плюс- и минус-бесконечность.

{% include static.html path="vacuous-truth-2/1.jpeg" %}

Область определения этой функции записывается так: `(-inf, 0);(0, +inf)`. В нуле
функция не определена — и при этом никто не умер. Бывают функции и с большим
количеством точек и даже целых областей, где они не определены. И ничего — нас
это устраивает, с функцией можно работать.

(В скобках отмечу, стандарт чисел с плавающей запятой предусматривает комбинации
битов, которые трактуются как обычная бесконечность, а также плюс- и
минус-версии. То же самое касается нуля: может быть ноль, минус ноль и плюс
ноль. Это помогает при сходимости рядов, когда мы пришли к нулю и хотим знать
откуда — справа или слева. По крайней мере в Фортране этими штуками
пользовались).

Другой пример из математики — решение квадратного уравнения вида `ax^2 + bx + c
= 0`. У него может быть либо два корня, либо один, либо никаких. Во втором
случае еще можно слукавить: сказать, что один корень — это два
одинаковых. Ладно, но с третьим вариантом это не прокатит. Нельзя вернуть
какое-то левое число и сказать, что это пустой корень. Они не определены.

Пример из географии: чтобы попасть на северный полюс, нужно идти на
сервер. Каким же будет северное направление на Северном полюсе? Ответ — никаким,
оно не определено.

То же самое с предикатами: когда нас просят сказать, что все камни белые, но
камней нет, это неопределенность. Потому что если сказать да, оказывается, что
камни в том числе черные, прозрачные, резиновые — и все это одновременно. Этого
не было, если бы every возвращал NULL — я имею в виду не в коде, а на уровне
логики.

Уж не говорю, что пустая истина совершенно неприемлема на бытовом уровне. Это
либо троллинг, либо саботаж, либо неразбериха.

Когда я читаю в документации: *if the stream is empty then true is returned and
the predicate is not evaluated* — мне немного плохеет. Выходит так, что функция
возвращает один и тот же результат при РАЗНЫХ случаях. А значит, ответственность
перекладывается на тебя — будь добр сам проверяй, пустое множество или не
пустое.

Это просто плохой API — что, в общем-то, не редкость. Надо это признать и больше
так не делать. А вот оправдываться логикой и чепухой а-ля "антецедент-квантор" —
это отстой.

Под конец напомню вам о Булгакове. Если свежесть отлична от первой, это уже не
свежесть. Если перед истиной стоит какой-то тег — пустая, неполная, вторичная —
то это не истина. Вот и все, что нужно запомнить. И это — истина.
