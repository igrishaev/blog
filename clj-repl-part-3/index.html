<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>REPL, Cider, Emacs (часть 3/4)</title>
  <meta name="description" content="Все части  Первая часть  Вторая часть  Третья часть  Четвертая часть">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-repl-part-3/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">REPL, Cider, Emacs (часть 3/4)</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2022-09-05T00:00:00+00:00">
        Sep 5, 2022
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/repl/" rel="tag">repl</a>, <a href="/tag/emacs/" rel="tag">emacs</a>, <a href="/tag/cider/" rel="tag">cider</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<h2>Все части</h2>

<ul>
  <li><a href="/clj-repl-part-1/">Первая часть</a></li>
  <li><a href="/clj-repl-part-2/">Вторая часть</a></li>
  <li><a href="/clj-repl-part-3/">Третья часть</a></li>
  <li><a href="/clj-repl-part-4/">Четвертая часть</a></li>
</ul>

<h2>

    Оглавление

</h2>

<ul id="toc-item-clojure-repl-toc">
  <li><a href="#пространства-имен" id="toc-item-clojure-repl-toc-пространства-имен">Пространства имен</a></li>
  <li><a href="#переход-к-определению" id="toc-item-clojure-repl-toc-переход-к-определению">Переход к определению</a>    <ul>
      <li><a href="#xref" id="toc-item-clojure-repl-toc-xref">Xref</a></li>
      <li><a href="#imenu" id="toc-item-clojure-repl-toc-imenu">Imenu</a></li>
    </ul>
  </li>
  <li><a href="#тесты-в-cider" id="toc-item-clojure-repl-toc-тесты-в-cider">Тесты в Cider</a></li>
  <li><a href="#отладка-сообщений-nrepl" id="toc-item-clojure-repl-toc-отладка-сообщений-nrepl">Отладка сообщений nREPL</a></li>
  <li><a href="#отладка-кода" id="toc-item-clojure-repl-toc-отладка-кода">Отладка кода</a>    <ul>
      <li><a href="#наивные-способы" id="toc-item-clojure-repl-toc-наивные-способы">Наивные способы</a></li>
      <li><a href="#внедрение-в-чужой-код" id="toc-item-clojure-repl-toc-внедрение-в-чужой-код">Внедрение в чужой код</a></li>
      <li><a href="#подготовка-к-отладке" id="toc-item-clojure-repl-toc-подготовка-к-отладке">Подготовка к отладке</a></li>
      <li><a href="#продвинутый-eval" id="toc-item-clojure-repl-toc-продвинутый-eval">Продвинутый eval</a></li>
      <li><a href="#отладчик-своими-руками" id="toc-item-clojure-repl-toc-отладчик-своими-руками">Отладчик своими руками</a></li>
      <li><a href="#множественная-отладка-теория" id="toc-item-clojure-repl-toc-множественная-отладка-теория">Множественная отладка (теория)</a></li>
      <li><a href="#отладочный-тег" id="toc-item-clojure-repl-toc-отладочный-тег">Отладочный тег</a></li>
    </ul>
  </li>
</ul>

<h2 id="пространства-имен">Пространства имен</h2>

<p>При работе с REPL мы всегда находимся в каком-то пространстве. По умолчанию оно написано в приглашении:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Если перейти в другое пространство, изменится и приглашение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">in-ns</span><span class="w"> </span><span class="ss">'foobar</span><span class="p">)</span><span class="w">
</span><span class="n">foobar=&gt;</span><span class="w">
</span></code></pre></div></div>

<p>Код, что мы вводим в REPL, вычисляется в текущем пространстве. Если объявить в модуле <code class="language-plaintext highlighter-rouge">user</code> переменную:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">in-ns</span><span class="w"> </span><span class="ss">'user</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>, а затем сослаться на нее в пространстве <code class="language-plaintext highlighter-rouge">foobar</code>, получим ошибку, что символ <code class="language-plaintext highlighter-rouge">number</code> не найден в текущем контексте:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">in-ns</span><span class="w"> </span><span class="ss">'foobar</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w">

</span><span class="n">Syntax</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">compiling</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="p">(</span><span class="nf">repl-chapter</span><span class="no">:localhost:53495</span><span class="p">(</span><span class="nf">clj</span><span class="p">)</span><span class="nb">*</span><span class="no">:1:8440</span><span class="p">)</span><span class="nb">.</span><span class="w">
</span><span class="n">Unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nb">resolve</span><span class="w"> </span><span class="nb">symbol</span><span class="err">:</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">context</span><span class="w">
</span></code></pre></div></div>

<p>Другой пример: объявим в модулях <code class="language-plaintext highlighter-rouge">user</code> и <code class="language-plaintext highlighter-rouge">foobar</code> переменные <code class="language-plaintext highlighter-rouge">number</code> со значениями 1 и 2. Теперь одна и та же форма <code class="language-plaintext highlighter-rouge">(inc number)</code> даст разный результат в зависимости от того, какое пространство текущее. Поэтому перед вычислением мы должны убедиться, что находимся в нужном пространстве имен.</p>

<p>Чтобы уберечь нас от подобных ошибок, nREPL учитывает параметр <code class="language-plaintext highlighter-rouge">ns</code> в сообщениях. Когда мы выполняем код при помощи <code class="language-plaintext highlighter-rouge">cider-eval-...</code>, в сообщении, помимо полей <code class="language-plaintext highlighter-rouge">op</code> и <code class="language-plaintext highlighter-rouge">code</code>, передается <code class="language-plaintext highlighter-rouge">ns</code>. Его значение Cider находит из формы <code class="language-plaintext highlighter-rouge">(ns...)</code> в начале файла. Вычисляя форму, сервер временно меняет пространство, и результат совпадает с тем, что ожидают.</p>

<!-- more -->

<p>Все же ручного контроля за текущим пространством не избежать. Переключить его понадобится, например, для того, чтобы вызывать приватную функцию, объявленную с помощью <code class="language-plaintext highlighter-rouge">(defn- ...)</code> или <code class="language-plaintext highlighter-rouge">(def ^:private ...)</code>. Обратиться к ней извне можно только формой <code class="language-plaintext highlighter-rouge">resolve</code> или оператором <code class="language-plaintext highlighter-rouge">#'</code>, что неудобно:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="nb">resolve</span><span class="w"> </span><span class="ss">'some-ns/private-func</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="c1">;; or</span><span class="w">
</span><span class="p">(</span><span class="o">#</span><span class="ss">'some-ns/private-func</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Проще выполнить код в пространстве <code class="language-plaintext highlighter-rouge">some-ns</code> — внутри него приватное определение не отличается от обычного.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">in-ns</span><span class="w"> </span><span class="ss">'some-ns</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">private-func</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Смена пространства важна при отладке кода, как своего, так и чужого. Мы подробно рассмотрим отладку чуть позже.</p>

<p>Перечислим возможности Cider для контроля за пространствами имен. Команда <code class="language-plaintext highlighter-rouge">cider-find-ns</code> вернет список загруженных модулей. В него входят модули проекта, Clojure и сторонние библиотеки. Имена следуют в алфавитном порядке; диалог поддерживает автодополнение.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x cider-find-ns

Click on a completion to select it.
In this buffer, type RET to select the completion near point.

Possible completions are:
- aleph.http
- aleph.http.client
- bogus.core
- borkdude.dynaload
- buddy.core.bytes
...
</code></pre></div></div>

<p>При выборе элемента откроется исходный код модуля. Cider поддерживает в том числе модули из jar-архивов. Например, при выборе <code class="language-plaintext highlighter-rouge">clojure.core</code> на ноутбуке автора открывается файл:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/Users/ivan/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1-sources.jar
</code></pre></div></div>

<p>Буферы из архивов доступны в режиме чтения. Без особых ухищрений нельзя изменить файл в архиве и сохранить его. В особых случаях это необходимо; в секции про отладку мы рассмотрим, как это сделать.</p>

<p>Команда <code class="language-plaintext highlighter-rouge">cider-browse-ns</code> покажет переменные модуля. Приведем фрагмент для модуля <code class="language-plaintext highlighter-rouge">clojure.core.async</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clojure.core.async</span><span class="w">
</span><span class="nb">-</span><span class="w"> </span><span class="n">&lt;!</span><span class="w"> </span><span class="n">takes</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">port.</span><span class="w">
</span><span class="nb">-</span><span class="w"> </span><span class="n">&lt;!!</span><span class="w"> </span><span class="n">takes</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">port.</span><span class="w">
</span><span class="nb">-</span><span class="w"> </span><span class="n">&gt;!</span><span class="w"> </span><span class="n">puts</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="nb">into</span><span class="w"> </span><span class="n">port.</span><span class="w">
</span><span class="nb">-</span><span class="w"> </span><span class="n">&gt;!!</span><span class="w"> </span><span class="n">puts</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="nb">into</span><span class="w"> </span><span class="n">port.</span><span class="w">
</span></code></pre></div></div>

<p>Каждый элемент открывает буфер с подробностями: документацией, спекой, ссылкой на файл. Работают ссылки на другие определения: из буфера с макросом <code class="language-plaintext highlighter-rouge">&gt;!!</code> можно перейти к <code class="language-plaintext highlighter-rouge">&gt;!</code>, <code class="language-plaintext highlighter-rouge">put!</code> и другим, указанным в секции “Also see”. С помощью <code class="language-plaintext highlighter-rouge">cider-browse-ns</code> иногда отпадает нужда в документации.</p>

<p>Cider предлагает многие другие команды для работы с пространствами. Ознакомьтесь с ними на <a href="https://docs.cider.mx/cider/index.html">странице документации</a>.</p>

<h2 id="переход-к-определению">Переход к определению</h2>

<p>Программный код — не просто текст; он обладает структурой. Классы, функции и другие элементы строят его скелет. Продвинутый редактор понимает структуру кода и поддерживает переходы по элементам. Например, по нажатию клавиши открыть файл с определением функции под курсором. По нажатию другой клавиши вернуться назад.</p>

<p>Emacs и Cider предлагают разные способы навигации по коду. В этом разделе мы рассмотрим некоторые из них.</p>

<p>Команда <code class="language-plaintext highlighter-rouge">M-x cider-find-var</code> запрашивает данные о символе под курсором. Предположим, вы написали код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="s">"John"</span><span class="w">
      </span><span class="n">email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s &lt;%s&gt;"</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">email</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Поместите курсор на слово <code class="language-plaintext highlighter-rouge">format</code> и выполните команду. Откроется буфер <code class="language-plaintext highlighter-rouge">core.clj</code> из jar-архива на строке 5738, где объявлена функция <code class="language-plaintext highlighter-rouge">format</code>.</p>

<p>Информацию о символе находит сервер. Пространство, в котором мы ищем символ, должно быть предварительно загружено. В зависимости от технических деталей клиент посылает команду <code class="language-plaintext highlighter-rouge">info</code> или <code class="language-plaintext highlighter-rouge">lookup</code>. С сервера приходят данные об имени файла и позиции в нем.</p>

<p>Чтобы вернуться прежний буфер, выполните <code class="language-plaintext highlighter-rouge">M-x cider-pop</code>-back. Обратный переход нужен столь же часто, что и прямой. Опытным путем автор пришел к комбинации клавиш  <code class="language-plaintext highlighter-rouge">C-x .</code>. Добавьте в настройки Emacs выражение:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">"C-x ."</span><span class="p">)</span> <span class="ss">'cider-pop-back</span><span class="p">)</span>
</code></pre></div></div>

<p>Переход к определению работает не только с функциями, но и переменными, объектами <code class="language-plaintext highlighter-rouge">defmulti</code>, <code class="language-plaintext highlighter-rouge">defprotocol</code> и другими. В случае с <code class="language-plaintext highlighter-rouge">defmulti</code> вы перейдете к объявлению мультиметода, но не его методов. Убедитесь в этом на примере <code class="language-plaintext highlighter-rouge">print-method</code> из <code class="language-plaintext highlighter-rouge">clojure.core</code>.</p>

<p>Команда <code class="language-plaintext highlighter-rouge">cider-find-var</code> учитывает пространства имен и их псевдонимы. Предположим, в файле следующий заголовок <code class="language-plaintext highlighter-rouge">ns</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some-ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.walk</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">walk</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы открыть пространство <code class="language-plaintext highlighter-rouge">clojure.walk</code>, поместите курсор на <code class="language-plaintext highlighter-rouge">walk</code> и выполните <code class="language-plaintext highlighter-rouge">cider-find-var</code>.</p>

<p>В последних версиях Cider произошли изменения: вместо <code class="language-plaintext highlighter-rouge">cider-find-var</code> используется более абстрактная команда <code class="language-plaintext highlighter-rouge">xref-find-definitions</code>. Она принадлежит встроенному в Emacs <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Xref.html">пакету Xref</a> для поиска определений и перекрестных ссылок. Особенность Xref в том, что его легко расширить под нужный язык или платформу. Об нем мы расскажем чуть ниже.</p>

<p>Команда <code class="language-plaintext highlighter-rouge">cider-javadoc</code> открывает документацию к классу Java. Предположим, мы работаем с сертификатами, и в заголовке <code class="language-plaintext highlighter-rouge">ns</code> находятся импорты:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="no">:import</span><span class="w">
   </span><span class="n">java.security.cert.CertificateFactory</span><span class="w">
   </span><span class="n">java.security.cert.X509Certificate</span><span class="w">
   </span><span class="n">java.security.PublicKey</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Наведите курсор на любой класс и выполните <code class="language-plaintext highlighter-rouge">M-x cider-javadoc</code> — откроется браузер с документацией к классу и текущей версии JVM. В случае автора страница для <code class="language-plaintext highlighter-rouge">X509Certificate</code> оказалась следующей:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/cert/X509Certificate.html
</code></pre></div></div>

<p>Команда <code class="language-plaintext highlighter-rouge">cider-find-keyword</code> служит для поиска кейвордов. Если навести курсор на ключ <code class="language-plaintext highlighter-rouge">:some.ns/name</code> и выполнить ее, Cider попытается:</p>

<ul>
  <li>перейти в пространство <code class="language-plaintext highlighter-rouge">some.ns</code></li>
  <li>сместиться до первого упоминания <code class="language-plaintext highlighter-rouge">::name</code>.</li>
</ul>

<p>Мы написали “попытается”, потому что способ работает только для ключей, пространство которых совпадает с одноименным модулем. Если у кейворда произвольное пространство, например <code class="language-plaintext highlighter-rouge">:book/name</code>, поиск не сработает: пространства <code class="language-plaintext highlighter-rouge">book</code> не существует, а перебор всех модулей будет слишком долгим.</p>

<p>Переход к кейворду работает в том числе с псевдонимами (алиасами). Например, если в шапке <code class="language-plaintext highlighter-rouge">ns</code> указать пространству псевдоним <code class="language-plaintext highlighter-rouge">user</code> и сослаться на кейворд по нему:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some-ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">company.api.user</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">user</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="no">::user/email</span><span class="p">)</span><span class="w"> </span><span class="c1">;; M-x cider-find-keyword</span><span class="w">
</span></code></pre></div></div>

<p>, то поиск пройдет успешно. До двойному двоеточию nREPL определит, что пространство — псевдоним и раскроет его.</p>

<p>Переход по кейвордам полезен в работе с <code class="language-plaintext highlighter-rouge">clojure.spec</code>. Спеки объявляют макросом <code class="language-plaintext highlighter-rouge">s/def</code>, который принимает кейворд. Макрос не создает переменную в модуле, а помещает спеку в глобальный реестр с указанными ключом. Найти ее командой <code class="language-plaintext highlighter-rouge">cider-find-var</code> будет невозможно. Здесь и выручит вас команда <code class="language-plaintext highlighter-rouge">cider-find-keyword</code>, которая работает как навигатор по спекам.</p>

<p>Предположим, вы пишете конфигурацию приложения. Поле <code class="language-plaintext highlighter-rouge">:db</code> базы данных использует спеку из модуля <code class="language-plaintext highlighter-rouge">clojure.java.jdbc.spec</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some-ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.spec.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.java.jdbc.spec</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::db</span><span class="w"> </span><span class="no">::jdbc/db-spec</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::config</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-in</span><span class="w"> </span><span class="p">[</span><span class="no">::db</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы перейти к определению <code class="language-plaintext highlighter-rouge">::jdbc/db-spec</code>, наведите на него курсор и выполните <code class="language-plaintext highlighter-rouge">cider-find-keyword</code>. Вы окажетесь в файле <code class="language-plaintext highlighter-rouge">spec.clj</code> на строке 78 с макросом <code class="language-plaintext highlighter-rouge">s/def</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; clojure/clojure/java/jdbc/spec.clj</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::db-spec</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Примеры выше подсказывают: используйте ключи, связанные с текущим пространством имен (с двойным двоеточием):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">::name</span><span class="w">
</span><span class="no">::description</span><span class="w">
</span><span class="no">::not-found</span><span class="w">
</span></code></pre></div></div>

<p>В этом случае между ключом и пространством возникает связь, и по одному легко узнать другое. Наоборот, ключ с произвольным пространством словно оторван от кода, и это снижает его возможности:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:user/id</span><span class="w">
</span><span class="no">:error/not-found</span><span class="w">
</span><span class="no">:api/limit</span><span class="w">
</span></code></pre></div></div>

<p>Представьте, что встретили в коде названную так спеку или событие re-frame. Ни один ключ не дает информации о том, где искать его определение. К сожалению, Cider тоже будет не в силах вам помочь.</p>

<h3 id="xref">Xref</h3>

<p>С версии 26 в Emacs появился новый способ навигации по коду. Он называется Xref — от английского cross-reference, перекрестная ссылка. Особенность Xref в дизайне: модуль поддерживает разные источники (бэкенды), откуда приходят данные об определениях. Источником может быть файл тегов, созданный <a href="https://en.wikipedia.org/wiki/Ctags">командой ctags</a> для индексирования кода. Также источником может быть функция, если известен иной алгоритм поиска. Например, если это проект на Python, специальный плагин перехватывает вызов Xref и возвращает данные, полученные библиотекой <a href="https://pypi.org/project/fast-autocomplete/">fast-autocomplete</a> или похожей.</p>

<p>Тип бэкенда не влияет на работу пользователя. Поиск и переход по коду сводятся к нескольким командам семейства <code class="language-plaintext highlighter-rouge">xref-find-...</code></p>

<p>Чтобы Cider перехватывал вызовы Xref, установите переменную <code class="language-plaintext highlighter-rouge">cider-use-xref</code> в истину. По умолчанию это так, но на всякий случай выполните в <code class="language-plaintext highlighter-rouge">*scratch*</code> выражение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">setq</span><span class="w"> </span><span class="n">cider-use-xref</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Откройте любой модуль, загруженный в nREPL. Поместите курсор на символ функции и выполните <code class="language-plaintext highlighter-rouge">M-x xref-find-definitions</code>. По аналогии с <code class="language-plaintext highlighter-rouge">cider-find-var</code> откроется файл на той строке, где объявлена функция. Способ работает с макросами, протоколами, пространствами имен.</p>

<p>Команде <code class="language-plaintext highlighter-rouge">xref-find-definitions</code> назначена комбинация <code class="language-plaintext highlighter-rouge">M-.</code> (альт с точкой). Она работает и в других режимах Emacs, например <code class="language-plaintext highlighter-rouge">lisp-mode</code> или <code class="language-plaintext highlighter-rouge">python-mode</code> (с модулем Anaconda и аналогами).</p>

<p>Чтобы участвовать в поиске, пространство должно быть загружено в REPL. Cider не ищет в локальных файлах, а посылает сообщение серверу. Код на сервере обходит загруженные пространства. Определения получают функцией <a href="https://clojuredocs.org/clojure.core/ns-map"><code class="language-plaintext highlighter-rouge">ns-map</code></a>, которая возвращает словарь вида символ =&gt; определение. Поиск сводится к доступу по словарю, что довольно быстро.</p>

<p>Команда <code class="language-plaintext highlighter-rouge">xref-find-references</code> находит места, где встречается указанный символ. С ее помощью легко проверить, нуждается ли проект в определенной функции или нет. Если ссылок на нее не найдено, удалите функцию без опасений. Другое применение команды — рефакторинг, когда вы изменили сигнатуру функции и теперь исправляете ее вызовы.</p>

<p>Другие возможности Xref вы найдете на сайте проекта GNU <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Xref.html">в разделе Emacs</a>.</p>

<h3 id="imenu">Imenu</h3>

<p>Плагин <a href="https://github.com/clojure-emacs/clojure-mode">Clojure mode</a> расширяет Imenu в Emacs. Imenu (сокращение от Interactive menu) — это встроенный модуль для показа определений в файле. По команде <code class="language-plaintext highlighter-rouge">M-x imenu</code> откроется буфер с оглавлением — именами функций, макросов, типов — и приглашением ввода. Приведем краткую версию буфера для модуля <code class="language-plaintext highlighter-rouge">clojure.core</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Function / any?
- Function / str
- Function / symbol?
- Function / keyword?
</code></pre></div></div>

<p>Для каждого языка Imenu хранит набор правил, по которым ищутся определения. В случае с Clojure это шаблоны <code class="language-plaintext highlighter-rouge">(def ...)</code>, <code class="language-plaintext highlighter-rouge">(defn ...)</code> и другие. Правила можно расширить, чтобы учесть кейворды или особые формы. В этом редко бывает нужда, потому что по умолчанию в Clojure mode заданы обширные правила, в том числе для пакетов <code class="language-plaintext highlighter-rouge">clojure.spec</code> и <code class="language-plaintext highlighter-rouge">clojure.test</code> (формы <code class="language-plaintext highlighter-rouge">s/def</code>, <code class="language-plaintext highlighter-rouge">deftest</code> и другие).</p>

<p>Чтобы Imenu работало в файлах Clojure, добавьте в настройки выражение:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">'clojure-mode-hook</span> <span class="nf">#'</span><span class="nv">imenu-add-menubar-index</span><span class="p">)</span>
</code></pre></div></div>

<p>Задайте команде <code class="language-plaintext highlighter-rouge">imenu</code> комбинацию клавиш. Автор предпочитает <code class="language-plaintext highlighter-rouge">C-i</code>:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">"&lt;C-i&gt;"</span><span class="p">)</span> <span class="ss">'imenu</span><span class="p">)</span>
</code></pre></div></div>

<p>Если вы пользуетесь графической версией Emacs, меню удивит вас. Появится системное окно со списком определений. Предполагается, что пользователь переложит руку на мышь и выберет нужный пункт.</p>

<p>Странность решения в том, что всплывающее окно полностью оторвано от Emacs. В нем не работают клавиши перехода по строкам; на больших файлах меню не влазит в экран. Перенос руки с клавиатуры на мышь и обратно нарушает идеи редактора. Поэтому назначьте следующей переменной <code class="language-plaintext highlighter-rouge">nil</code>:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">setq</span> <span class="nv">imenu-use-popup-menu</span> <span class="no">nil</span><span class="p">)</span>
</code></pre></div></div>

<p>Теперь вместо всплывающего окна появится буфер Emacs. В нем работает привычная навигация по элементам.</p>

<p>Интерактивное меню станет еще удобней с пакетом <a href="https://github.com/emacs-helm/helm">Helm</a>. Установите его командой:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x package-install &lt;RET&gt; helm &lt;RET&gt;
</code></pre></div></div>

<p>Задайте клавишам <code class="language-plaintext highlighter-rouge">C-i</code> команду <code class="language-plaintext highlighter-rouge">helm-imenu</code>:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">"&lt;C-i&gt;"</span><span class="p">)</span> <span class="ss">'helm-imenu</span><span class="p">)</span>
</code></pre></div></div>

<p>Helm предлагает более удобные диалоги. При вводе текста он покажет элементы, которые включают его. Для ввода <code class="language-plaintext highlighter-rouge">user</code> получим <code class="language-plaintext highlighter-rouge">get-user</code>, <code class="language-plaintext highlighter-rouge">delete-user</code> и другие имена. Обычный <code class="language-plaintext highlighter-rouge">imenu</code> ищет элементы, которые начинаются с текста, что неудобно, если вы не помните точное имя функции.</p>

<h2 id="тесты-в-cider">Тесты в Cider</h2>

<p>Работая над программой, мы постоянно запускаем код в REPL. По-другому подход называют REPL-driven development. У людей, не знакомых с Lisp и Clojure, складывается ошибочное мнение, что тесты не нужны: зачем их писать, если все проверено в REPL?</p>

<p>Это не так: запуск кода в REPL не отменяет тестов. Когда программа закончена, проверки оформляют в тест, чтобы их зафиксировать. Далее код улучшают, постоянно сверяясь с тем, что тест проходит.</p>

<p>Перед тем как начать работу над кодом, убедитесь, что он покрыт тестом. В идеале вы запускаете тест до изменений, чтобы знать предпосылки. Если тест проходит, это гарантирует, что вы отталкиваетесь от штатной ситуации. Если после изменений тест “падает”, ищите причину в ваших действиях.</p>

<p>Случается, что тесты “сломаны” уже до работы над кодом. Например, кто-то измененил код в обход регламента (CI, review). Предварительный прогон тестов покажет, что дело не в ваших изменениях.</p>

<p>В прошлой книге мы подробно разобрали тесты в Clojure. Если коротко, макрос <code class="language-plaintext highlighter-rouge">deftest</code> объявляет функцию, чье тело находится в поле метаданных <code class="language-plaintext highlighter-rouge">:test</code>. Тесты запускают в особом режиме, когда включены фикстуры и сборщик данных (reporter).</p>

<p>Cider предлагает ряд функций для запуска тестов. Чтобы опробовать их, загрузите модуль с тестами в nREPL. Для этого выполните либо <code class="language-plaintext highlighter-rouge">cider-load-buffer</code> (<code class="language-plaintext highlighter-rouge">C-c C-k</code>), либо <code class="language-plaintext highlighter-rouge">cider-ns-refresh</code> (<code class="language-plaintext highlighter-rouge">C-C M-n r</code>). Во втором случае путь к тестам должен быть в classpath. В lein это легко задать полем <code class="language-plaintext highlighter-rouge">resource-paths</code> в профиле <code class="language-plaintext highlighter-rouge">dev</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:profiles</span><span class="w">
 </span><span class="p">{</span><span class="no">:dev</span><span class="w">
  </span><span class="p">{</span><span class="no">:resource-paths</span><span class="w"> </span><span class="p">[</span><span class="s">"test"</span><span class="p">]}}}</span><span class="w">
</span></code></pre></div></div>

<p>Приведем минимальный модуль с тестами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">sample-test</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.test</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">deftest</span><span class="w"> </span><span class="n">is</span><span class="p">]]))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-orwell</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Установите курсор в любое место <code class="language-plaintext highlighter-rouge">deftest</code> и выполните <code class="language-plaintext highlighter-rouge">M-x cider-test-run-test</code>. Команда запустит одиночный тест, при этом на сервер уйдут два сообщения. В первом клиент запросит данные о символе <code class="language-plaintext highlighter-rouge">sample/test-orwell</code>. Это необходимо, чтобы убедиться, что <code class="language-plaintext highlighter-rouge">sample/test-orwell</code> — действительно тест:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  op   "info"
  sym  "sample/test-orwell"
</code></pre></div></div>
<p>В
о втором сообщении клиент отправит команду <code class="language-plaintext highlighter-rouge">test</code> со списком из одного теста:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  op     "test"
  tests  ("test-orwell")
</code></pre></div></div>

<p>Middleware из пакета <code class="language-plaintext highlighter-rouge">cider-nrepl</code> перестроит эту команду в выражение ниже, и тест будет выполнен.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">clojure.test/test-var</span><span class="w"> </span><span class="o">#</span><span class="ss">'test-orwell</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Также middleware перехватит вывод теста и вернет его в структурированном виде. Вот что получит клиент в положительном случае:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  id      "317"
  column  1
  file    "file:/Users/ivan/work/book-sessions/repl-chapter/src/sample.clj"
  line    6
  name    "test-orwell"
  ns      "sample"
  status  ("done")
</code></pre></div></div>

<p>и при ошибке:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  id         "320"
  session    "65cc0cad-5a9f-4faa-ba3f-6b2e276b5ba0"
  time-stamp "2022-05-21 20:02:51.069229000"
  gen-input  nil
  results    (dict
               sample (dict
                        test-orwell ((dict "actual" "4\n" "context" nil "diffs"
       (("4\n"
         ("5\n" "4\n")))
       "expected" "5\n" "file" "sample.clj" "index" 0 "line" 7 "message" "" "ns" "sample" "type" "fail" "var" "test-orwell"))))
  summary    (dict
               error 0
               fail  1
               ns    1
               pass  0
               test  1
               var   1)
  testing-ns "sample"
</code></pre></div></div>

<p>Во втором случае откроется буфер <code class="language-plaintext highlighter-rouge">*cider-test-report*</code> с отчетом. Красным цветом показаны места, где оператор <code class="language-plaintext highlighter-rouge">(is ...)</code> вернул ложь. Желтым отмечены формы, где возникло исключение. Ниже — отчет о том, что вычисление <code class="language-plaintext highlighter-rouge">(* 2 2)</code> не сошлось с ожидаемым результатом (5):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Test Summary
sample

Tested 1 namespaces
Ran 1 assertions, in 1 test functions
1 failures

Results

sample
1 non-passing tests:

Fail in test-orwell

expected: 5
  actual: 4
    diff: - 5
          + 4
</code></pre></div></div>

<p>Исправьте тест, заменив 5 на 4. Чтобы изменения вступили в силу, выполните <code class="language-plaintext highlighter-rouge">deftest</code> при помощи <code class="language-plaintext highlighter-rouge">cider-eval-defun-at-point</code>. По аналогии с функциями и переменными, тесты нужно переопределять после изменений. Если запустить тест без этого шага, сработает прошлая версия с ошибкой.</p>

<p>Cider предлагает многие другие удобства для тестов. Команда <code class="language-plaintext highlighter-rouge">cider-test-rerun-test</code> повторно выполнит последний запущенный тест. С ней отпадает нужна переключаться между кодом, который вы редактируете, и его тестом. Достаточно выполнить тест и продолжить работу над кодом, время от времени вызывая <code class="language-plaintext highlighter-rouge">cider-test-rerun-test</code>.</p>

<p>Команда <code class="language-plaintext highlighter-rouge">cider-test-run-ns-tests</code> выполняет тесты определенного пространства. Если вызвать ее в модуле <code class="language-plaintext highlighter-rouge">project.sample</code>, Cider запустит тесты в пространстве <code class="language-plaintext highlighter-rouge">project.sample-test</code> (при условии, что оно найдено). Следовать этому правилу не обязательно: можно именовать тесты иначе, например с частичкой <code class="language-plaintext highlighter-rouge">test</code> в начале:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">test.project.sample</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Однако в первом случае их легче выполнить в Cider.</p>

<p>Команда <code class="language-plaintext highlighter-rouge">cider-test-rerun-failed-tests</code> выполнит только те тесты из прошлого прогона, что окончились неудачей.</p>

<p>Этих команд достаточно для работы с тестами в Clojure. Полный список вы найдете в документации Cider в разделе <a href="https://docs.cider.mx/cider/testing/running_tests.html">Running Tests</a>.</p>

<h2 id="отладка-сообщений-nrepl">Отладка сообщений nREPL</h2>

<p>В редких случаях понадобится перехват сообщений между сервером nREPL и Emacs. Например, вы пишете клиент для другого редактора и хотели бы знать, какие сообщения шлет и принимает Emacs, чтобы сделать так же у себя.</p>

<p>Утилиты <code class="language-plaintext highlighter-rouge">tcpdump</code> и Wireshark, что мы рассмотрели выше, в данном случае избыточны. Воспользуйтесь командой <code class="language-plaintext highlighter-rouge">nrepl-toggle-message-logging</code>. Она откроет буфер <code class="language-plaintext highlighter-rouge">*nrepl-messages*</code> с сообщениями текущей сессии. Приведем пару из них в сокращении:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(--&gt;
  id        "27"
  op        "eval"
  session   "444ea459-4165-4f82-afbc-b9cfbae4d2c5"
  code      "(+ 1 2)"
  column    6
  line      28
  ns        "foo"
)
(&lt;--
  id         "27"
  session    "444ea459-4165-4f82-afbc-b9cfbae4d2c5"
  time-stamp "2022-06-18 17:15:30.451402000"
  value      "3"
)
</code></pre></div></div>

<p>Направление стрелки означает характер сообщения: от клиента серверу – вправо и обратно – влево. Данные показаны независимо от транспорта (Bencode, EDN), что упрощает их анализ.</p>

<p>Перехват сообщений замедляет работу клиента и поэтому выключен. Повторный ввод команды отключит его.</p>

<h2 id="отладка-кода">Отладка кода</h2>

<p>Перейдем к наиболее важной части главы: рассмотрим, как отлаживать код на Clojure.</p>

<p>Cider предлагает полноценный отладчик (дебаггер), но по некоторым причинам им пользуются редко. Так происходит потому, что концепции Clojure — неизменяемость, чистые функции, REPL — уже отсекают многие ошибки, свойственные другим языкам. Однако в сложных проектах вам не избежать отладки.</p>

<h3 id="наивные-способы">Наивные способы</h3>

<p>Прежде чем перейти к отладчику Cider, рассмотрим простые, “народные” способы отладить код — иногда их бывает достаточно. Предположим, функция принимает словарь опций с точками в названии. В ответ она возвращает вложенный словарь кейвордов. Входные данные и результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">remap-props</span><span class="w"> </span><span class="p">{</span><span class="s">"db.host"</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
              </span><span class="s">"db.port"</span><span class="w"> </span><span class="mi">5432</span><span class="w">
              </span><span class="s">"db.settings.ssl"</span><span class="w"> </span><span class="n">false</span><span class="p">})</span><span class="w">

</span><span class="p">{</span><span class="no">:db</span><span class="w">
 </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
  </span><span class="no">:port</span><span class="w"> </span><span class="mi">5432</span><span class="w">
  </span><span class="no">:settings</span><span class="w"> </span><span class="p">{</span><span class="no">:ssl</span><span class="w"> </span><span class="n">false</span><span class="p">}}}</span><span class="w">
</span></code></pre></div></div>

<p>Тело функции:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-props</span><span class="w"> </span><span class="p">[</span><span class="n">props</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">reduce-kv</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">path</span><span class="w">
           </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="nb">keyword</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">#</span><span class="s">"\."</span><span class="p">))]</span><span class="w">
       </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="nb">path</span><span class="w"> </span><span class="n">v</span><span class="p">)))</span><span class="w">
   </span><span class="p">{}</span><span class="w">
   </span><span class="n">props</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Если в словаре окажется поле, отличное от строки, получим ошибку приведения типа:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(remap-props {"db.host" "127.0.0.1" :db/port 5432})

1. Unhandled java.lang.ClassCastException
   class clojure.lang.Keyword cannot be cast to class java.lang.CharSequence
   (clojure.lang.Keyword is in unnamed module of loader 'app';
   java.lang.CharSequence is in module java.base of loader 'bootstrap')

                string.clj:  219  clojure.string/split
                string.clj:  219  clojure.string/split
                      REPL:   28  sample/remap-props/fn
   PersistentArrayMap.java:  377  clojure.lang.PersistentArrayMap/kvreduce
   ...
</code></pre></div></div>

<p>В отчете нет ни слова о том, какой именно ключ породил исключение. Самый простой способ подглядеть его — вывести на экран на каждом шаге. Для этого добавим <code class="language-plaintext highlighter-rouge">println</code> во внутреннюю функцию <code class="language-plaintext highlighter-rouge">reduce</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-props</span><span class="w"> </span><span class="p">[</span><span class="n">props</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">reduce-kv</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"&gt;&gt;&gt; "</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="c1">;; debugging</span><span class="w">
     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">path</span><span class="w">
           </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="nb">keyword</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">#</span><span class="s">"\."</span><span class="p">))]</span><span class="w">
       </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="nb">path</span><span class="w"> </span><span class="n">v</span><span class="p">)))</span><span class="w">
   </span><span class="p">{}</span><span class="w">
   </span><span class="n">props</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Перезагрузите функцию командами <code class="language-plaintext highlighter-rouge">cider-eval-last-sexp</code> или <code class="language-plaintext highlighter-rouge">cider-eval-defun-at-point</code>, поместив на нее курсор. Вызовите <code class="language-plaintext highlighter-rouge">remap-props</code>, и кроме результата в консоли появятся промежуточные шаги <code class="language-plaintext highlighter-rouge">reduce</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt;  db.host 127.0.0.1
&gt;&gt;&gt;  db.port 5432
&gt;&gt;&gt;  db.settings.ssl false
</code></pre></div></div>

<p>В случае с ошибочным словарем увидим, что дело в ключе <code class="language-plaintext highlighter-rouge">:db/port</code>, который не работает с функцией <code class="language-plaintext highlighter-rouge">split</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt;  :db/port 5432
</code></pre></div></div>

<p>Исправьте функцию так, чтобы она проверяла ключ функцией <code class="language-plaintext highlighter-rouge">string?</code>. Если это не так, бросьте исключение с именем ключа. С таким подходом отладка не нужна, потому что ошибка станет явной. Удалите <code class="language-plaintext highlighter-rouge">println</code> и перезагрузите функцию.</p>

<p>Печать на экран, при всей примитивности, позволяет быстро найти ошибку в коде. Ниже мы рассмотрим ее вариации.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">println</code> выводит данные в одну строку, что неудобно для коллекций. Воспользуйтесь печатью с отступами из пакета <code class="language-plaintext highlighter-rouge">clojure.pprint</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="ss">'clojure.pprint</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="p">{</span><span class="no">:key</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="no">:value</span><span class="w"> </span><span class="n">v</span><span class="p">})</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>С ней удобно исследовать запросы и ответы HTTP, потому что они описаны большими словарями.</p>

<p>Вернемся к функции <code class="language-plaintext highlighter-rouge">get-joke</code> для поиска шуток о программировании. Освежим в памяти ее код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-joke</span><span class="w"> </span><span class="p">[</span><span class="n">lang</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w">
        </span><span class="p">{</span><span class="no">:url</span><span class="w"> </span><span class="s">"https://v2.jokeapi.dev/joke/Programming"</span><span class="w">
         </span><span class="no">:method</span><span class="w"> </span><span class="no">:get</span><span class="w">
         </span><span class="no">:query-params</span><span class="w"> </span><span class="p">{</span><span class="no">:contains</span><span class="w"> </span><span class="n">lang</span><span class="p">}</span><span class="w">
         </span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="p">}</span><span class="w">

        </span><span class="n">response</span><span class="w">
        </span><span class="p">(</span><span class="nf">client/request</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">

        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">body</span><span class="p">]}</span><span class="w">
        </span><span class="n">response</span><span class="w">

        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">setup</span><span class="w"> </span><span class="n">delivery</span><span class="p">]}</span><span class="w">
        </span><span class="n">body</span><span class="p">]</span><span class="w">

    </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s %s"</span><span class="w"> </span><span class="n">setup</span><span class="w"> </span><span class="n">delivery</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы исследовать ответ сервера, добавьте в <code class="language-plaintext highlighter-rouge">let</code> псевдопеременную <code class="language-plaintext highlighter-rouge">_</code> (подчеркивание) и печать <code class="language-plaintext highlighter-rouge">response</code>. Это спорный прием, потому что переменная <code class="language-plaintext highlighter-rouge">_</code> не используется: она только уравновешивает форму печати. С другой стороны, не придется разрывать цепочку <code class="language-plaintext highlighter-rouge">let</code>-вычислений.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-joke</span><span class="w"> </span><span class="p">[</span><span class="n">lang</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="w">
        </span><span class="n">response</span><span class="w">
        </span><span class="p">(</span><span class="nf">client/request</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">

        </span><span class="n">_</span><span class="w">
        </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w">

        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">body</span><span class="p">]}</span><span class="w">
        </span><span class="n">response</span><span class="w">

        </span><span class="n">...</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>При поиске шутки вы увидите ответ сервера со статусом, заголовками и телом. Как только печать станет не нужна, мы легко удалим ее.</p>

<p>Вызов <code class="language-plaintext highlighter-rouge">pprint</code> влечет несколько неудобств. Во-первых, набирать выражение <code class="language-plaintext highlighter-rouge">(clojure.pprint/pprint ...)</code> долго. Во-вторых, нужно импортировать <code class="language-plaintext highlighter-rouge">clojure.pprint</code> в REPL, иначе получим ошибку, что модуль не загружен. Пойдем на хитрость: сделаем так, чтобы модуль загружался автоматически. Откройте локальные настройки lein (файл <code class="language-plaintext highlighter-rouge">~/.lein/profiles.clj</code>). В профиль <code class="language-plaintext highlighter-rouge">:user</code> добавьте ключ <code class="language-plaintext highlighter-rouge">:injections</code> с вектором:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:user</span><span class="w">
 </span><span class="no">:injections</span><span class="w"> </span><span class="p">[(</span><span class="nf">require</span><span class="w"> </span><span class="ss">'clojure.pprint</span><span class="p">)]}</span><span class="w">
</span></code></pre></div></div>

<p>Выражения <code class="language-plaintext highlighter-rouge">injections</code> будут выполнены при запуске nREPL. В них размещают код с побочными эффектами, в том числе загрузку модулей. Эта техника служит только для разработки.</p>

<p>Перезагрузите nREPL и выполните <code class="language-plaintext highlighter-rouge">(clojure.pprint/pprint ...)</code> в любом месте проекта. Печать сработает без ошибок, и не понадобится импорт <code class="language-plaintext highlighter-rouge">clojure.pprint</code> в объявлении пространства <code class="language-plaintext highlighter-rouge">(ns ...)</code>.</p>

<p>Чтобы быстро вставить <code class="language-plaintext highlighter-rouge">pprint</code> в код, обратимся к плагину Emacs <a href="https://github.com/rejeep/wrap-region.el">wrap-region</a>. С его помощью выделенный текст оборачивают указанными строками. Установите плагин командой:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x package-install &lt;RET&gt; wrap-region &lt;RET&gt;
</code></pre></div></div>

<p>и добавьте в настройки код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="ss">'wrap-region</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">wrap-region-mode</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">wrap-region-add-wrapper</span><span class="w"> </span><span class="s">"(clojure.pprint/pprint "</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="s">"p"</span><span class="w"> </span><span class="ss">'clojure-mode</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Если теперь выделить <code class="language-plaintext highlighter-rouge">response</code> и нажать <code class="language-plaintext highlighter-rouge">p</code>, появится выражение <code class="language-plaintext highlighter-rouge">(clojure.pprint/pprint response)</code>. Вместо <code class="language-plaintext highlighter-rouge">response</code> может быть любой текст, в том числе коллекция, макрос, вызов функции.</p>

<p>Иногда <code class="language-plaintext highlighter-rouge">pprint</code> выводит слишком много информации, и данные уходят за пределы видимости терминала. Модуль <code class="language-plaintext highlighter-rouge">clojure.inspector</code> решает это проблему. Он выводит графическое окно Swing с виджетом дерева. Коллекции обозначены папкой, а их элементы — файлом.</p>

<p>Окно не блокирует поток, который его вызвал. Код отработает без задержек, и вы без спешки изучите данные в инспекторе. Это особенно важно для задач, которые зависят от времени, например отправка HTTP-запросов, чтение и запись в каналы.</p>

<p>По аналогии с <code class="language-plaintext highlighter-rouge">clojure.pprint</code>, добавьте в секцию <code class="language-plaintext highlighter-rouge">injections</code> форму <code class="language-plaintext highlighter-rouge">(require 'clojure.inspector)</code>. Задайте клавишу для обертки символа в функцию <code class="language-plaintext highlighter-rouge">inspect-tree</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">wrap-region-add-wrapper</span><span class="w"> </span><span class="s">"(clojure.inspector/inspect-tree "</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="s">"i"</span><span class="w"> </span><span class="ss">'clojure-mode</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h3 id="внедрение-в-чужой-код">Внедрение в чужой код</h3>

<p>До сих пор мы отлаживали код в директории <code class="language-plaintext highlighter-rouge">src</code>. Этот код под вашим контролем: в него легко добавить печать и инспекцию, а затем откатить изменения.</p>

<p>Все меняется, когда нужно отладить стороннюю библиотеку. Код библиотек упакован в jar-файлы и находится в недрах директории <code class="language-plaintext highlighter-rouge">~/.m2</code>. Технически возможно распаковать архив jar, исправить код, упаковать обратно, а затем перезагрузить REPL. Однако это займет массу времени. Способ ниже описывает, как исправить код чужой библиотеки на лету.</p>

<p>Вернемся к функции <code class="language-plaintext highlighter-rouge">get-joke</code> для получения шуток. Функция обращается к сервису при помощи библиотеки <code class="language-plaintext highlighter-rouge">clj-http</code>. Давайте шагнем в недра <code class="language-plaintext highlighter-rouge">clj-http</code>, чтобы отследить, какие данные уходят в сеть.</p>

<p>Наведите курсор на символ <code class="language-plaintext highlighter-rouge">client/request</code> и нажмите <code class="language-plaintext highlighter-rouge">M-.</code> (или выполните <code class="language-plaintext highlighter-rouge">M-x cider-find-var</code>). Откроется модуль <code class="language-plaintext highlighter-rouge">clj-http.client</code> из jar-файла в директории <code class="language-plaintext highlighter-rouge">~/.m2/repository/clj-http/clj-http/3.12.0</code>. Вы окажетесь на строке 1134, где объявлена переменная <code class="language-plaintext highlighter-rouge">request</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">request</span><span class="w">
  </span><span class="s">"..."</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-request</span><span class="w"> </span><span class="o">#</span><span class="ss">'core/request</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>У функции длинная документация, которую мы заменили многоточием. Видно, что <code class="language-plaintext highlighter-rouge">request</code> на самом деле ссылается на функцию <code class="language-plaintext highlighter-rouge">core/request</code>, обернутую многими middleware. Установите курсор на <code class="language-plaintext highlighter-rouge">core/request</code> и снова выполните <code class="language-plaintext highlighter-rouge">M-.</code> — вы окажетесь в модуле <code class="language-plaintext highlighter-rouge">clj-http.core</code> из того же jar-файла на строке 546:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">request</span><span class="w">
  </span><span class="p">([</span><span class="n">req</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">request</span><span class="w"> </span><span class="n">req</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">
  </span><span class="p">([{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
     </span><span class="no">:as</span><span class="w"> </span><span class="n">req</span><span class="p">}</span><span class="w"> </span><span class="n">respond</span><span class="w"> </span><span class="n">raise</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
     </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Буфер <code class="language-plaintext highlighter-rouge">clj-http.core</code> открыт в режиме чтения, потому что связан с архивом. Чтобы редактировать код, выполните <code class="language-plaintext highlighter-rouge">M-x toggle-read-only</code>. Теперь когда буфер доступен для изменений, добавьте инспекцию перед формой <code class="language-plaintext highlighter-rouge">let</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">request</span><span class="w">
  </span><span class="p">([</span><span class="n">req</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">request</span><span class="w"> </span><span class="n">req</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">
  </span><span class="p">([{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
     </span><span class="no">:as</span><span class="w"> </span><span class="n">req</span><span class="p">}</span><span class="w"> </span><span class="n">respond</span><span class="w"> </span><span class="n">raise</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">clojure.inspector/inspect-tree</span><span class="w"> </span><span class="n">req</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
     </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Обновите функцию на сервере командой <code class="language-plaintext highlighter-rouge">M-x cider-eval-defun-at-point</code>. Теперь вызов <code class="language-plaintext highlighter-rouge">client/request</code> покажет окно инспектора с полями запроса. Это справедливо не только для функции <code class="language-plaintext highlighter-rouge">get-joke</code>, но и для любого обращения к <code class="language-plaintext highlighter-rouge">clj-http</code>.</p>

<p>Как только инспекция станет не нужна, вернитесь в буфер <code class="language-plaintext highlighter-rouge">clj-http.core</code>. Откатите изменения командой <code class="language-plaintext highlighter-rouge">C-/</code> (undo) и обновите функцию на сервере. Буфер <code class="language-plaintext highlighter-rouge">clj-http.core</code> будет отмечен как измененный, и при закрытии Emacs предложит его сохранить. Откажитесь, потому что отладка не должна менять исходный код библиотек. В противном случае Emacs обновит jar-файл, и изменения коснуться каждого проекта с этой библиотекой.</p>

<p>Описанная техника работает со всеми модулями, в том числе встроенными в Clojure. Ради интереса перейдите в модули <code class="language-plaintext highlighter-rouge">clojure.walk</code>, <code class="language-plaintext highlighter-rouge">clojure.string</code> и другие. Добавьте в код побочные эффекты, проверьте изменения в REPL и откатите их.</p>

<h3 id="подготовка-к-отладке">Подготовка к отладке</h3>

<p>Кроме печати и инспекции Cider предлагает полноценный отладчик. С ним можно выполнить код по шагам, проверить локальные переменные и стек вызовов, словом, делать все, что доступно в современных IDE. Чтобы читатель лучше понял отладку, поговорим об ее устройстве.</p>

<p>Вспомним, как работает отладка в IDE. Напротив строки ставят красную метку (точку останова) и запускают код. Когда исполнение достигает метки, программа останавливается и ждет команды пользователя. При выходе из отладки программа продолжит ход.</p>

<p>Можно сказать, отладка работает как REPL, запущенный в середине кода. Это бесконечный цикл, который читает команду, выполняет ее, выводит результат и ожидает новую команду. Разница в том, что отладчик не только выполняет код. Он хранит локальные переменные, стек вызовов, метрики и так далее.</p>

<p>Напишем простой отладчик для Clojure. Предположим, мы ничего не знаем о Cider и nREPL, поэтому используем только встроенные средства. Подготовим функцию <code class="language-plaintext highlighter-rouge">format-user</code>, которую подвергнем отладке:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">debug</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.main</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">main</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">format-user</span><span class="w">
  </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">username</span><span class="w"> </span><span class="n">email</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s &lt;%s&gt;"</span><span class="w"> </span><span class="n">username</span><span class="w"> </span><span class="n">email</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Проверим ее, подав на вход простой словарь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">format-user</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w"> </span><span class="s">"John"</span><span class="w">
              </span><span class="no">:email</span><span class="w"> </span><span class="s">"john@test.com"</span><span class="p">})</span><span class="w">
</span><span class="c1">;; "John &lt;john@test.com&gt;"</span><span class="w">
</span></code></pre></div></div>

<p>Теперь добавим в функцию REPL:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">format-user</span><span class="w">
  </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">username</span><span class="w"> </span><span class="n">email</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">main/repl</span><span class="w"> </span><span class="no">:prompt</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="s">"DEBUG&gt;&gt; "</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s &lt;%s&gt;"</span><span class="w"> </span><span class="n">username</span><span class="w"> </span><span class="n">email</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">repl</code> из модуля <code class="language-plaintext highlighter-rouge">clojure.main</code> запустит сеанс REPL с вводом с клавиатуры. Если вставить ее в тело <code class="language-plaintext highlighter-rouge">format-user</code>, при запуске она прервется, и откроется приглашение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user=&gt; (format-user {:username "John"
  #_=&gt;               :email "john@test.com"})
DEBUG&gt;&gt; (+ 1 2)
3
</code></pre></div></div>

<p>Обратите внимание на разницу в приглашении. Мы задали внутреннему REPL параметр <code class="language-plaintext highlighter-rouge">:prompt</code>, чтобы лучше понимать, в каком сеансе пребываем сейчас. Для выхода из отладки нажмите <code class="language-plaintext highlighter-rouge">Ctrl/Command+D</code>. Это сочетание подаст на вход символ <code class="language-plaintext highlighter-rouge">EOF</code>, что расценивается как сигнал завершения. Управление выйдет из внутреннего REPL, и вы получите результат <code class="language-plaintext highlighter-rouge">format-user</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEBUG&gt;&gt; ;; Ctrl/Command+D
"John &lt;john@test.com&gt;"
user=&gt;
</code></pre></div></div>

<p>Во время отладки вам захочется узнать локальные переменные, например выяснить, чему равны <code class="language-plaintext highlighter-rouge">username</code> и <code class="language-plaintext highlighter-rouge">email</code>. Тут вас ждет неприятность: если ввести <code class="language-plaintext highlighter-rouge">username</code>, REPL выдаст исключение о том, что символ неизвестен. То же самое относится к переменным <code class="language-plaintext highlighter-rouge">let</code>: в примере ниже символы <code class="language-plaintext highlighter-rouge">a</code> и <code class="language-plaintext highlighter-rouge">b</code> окажутся недоступны.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user=&gt; (let [a 1
  #_=&gt;       b 2]
  #_=&gt;   (main/repl :prompt #(print "DEBUG&gt;&gt; ")))
DEBUG&gt;&gt; a
Syntax error compiling at (REPL:1:1).
Unable to resolve symbol: a in this context
DEBUG&gt;&gt;
</code></pre></div></div>

<p>Причина в том, что функция <code class="language-plaintext highlighter-rouge">eval</code>, с помощью которой REPL выполняет код, не учитывает локальные переменные. Мы упоминали эту проблему в начале главы, и настало время решить ее.</p>

<h3 id="продвинутый-eval">Продвинутый eval</h3>

<p>В этом разделе мы напишем функцию <code class="language-plaintext highlighter-rouge">eval+</code> – улучшенную версию обычной <code class="language-plaintext highlighter-rouge">eval</code>. Она принимает пространство имен, словарь локальных переменных и форму, которую нужно вычислить. Вот как выглядит ее сигнатура:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">eval+</span><span class="w"> </span><span class="p">[</span><span class="n">ns</span><span class="w"> </span><span class="n">locals</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Представим вызов функции: вычислим форму <code class="language-plaintext highlighter-rouge">'(+ a b)</code> при <code class="language-plaintext highlighter-rouge">a</code> = 1 и <code class="language-plaintext highlighter-rouge">b</code> = 2 в пространстве <code class="language-plaintext highlighter-rouge">clojure.core</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">eval+</span><span class="w"> </span><span class="p">(</span><span class="nf">the-ns</span><span class="w"> </span><span class="ss">'clojure.core</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="ss">'a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">'b</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span><span class="c1">;; 3</span><span class="w">
</span></code></pre></div></div>

<p>Прежде чем писать тело, выясним, где взять входные параметры. С аргументом <code class="language-plaintext highlighter-rouge">ns</code> нет сложностей, потому что текущее пространство имен доступно в переменной <code class="language-plaintext highlighter-rouge">*ns*</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">&gt;</span><span class="w"> </span><span class="n">*ns*</span><span class="w">
</span><span class="c1">;; #namespace[user]</span><span class="w">
</span></code></pre></div></div>

<p>Если мы знаем имя пространства, его объект легко получить функцией <code class="language-plaintext highlighter-rouge">the-ns</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">the-ns</span><span class="w"> </span><span class="ss">'clojure.core</span><span class="p">)</span><span class="w">
</span><span class="c1">;; #namespace[clojure.core]</span><span class="w">
</span></code></pre></div></div>

<p>Локальные переменные (второй аргумент <code class="language-plaintext highlighter-rouge">locals</code>) — это словарь, ключи которого символы. Он выполняет роль контекста при вычислении формы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">eval+</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="p">{</span><span class="ss">'a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">'b</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="c1">;; 3</span><span class="w">
</span><span class="p">(</span><span class="nf">eval+</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="p">{</span><span class="ss">'a</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="ss">'b</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="c1">;; 7</span><span class="w">
</span></code></pre></div></div>

<p>Как получить локальные переменные для текущего участка кода? Очевидно, их сбор должен быть автоматическим, а не ручным. Поможет макрос <code class="language-plaintext highlighter-rouge">get-locals</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">get-locals</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">sym</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="o">&amp;</span><span class="n">env</span><span class="p">)]</span><span class="w">
             </span><span class="p">[(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'quote</span><span class="w"> </span><span class="n">sym</span><span class="p">)</span><span class="w"> </span><span class="n">sym</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>Он опирается на скрытую переменную <code class="language-plaintext highlighter-rouge">&amp;env</code>, доступную только макросам. Это словарь, где ключи — символы, а значения — экземпляры класса <code class="language-plaintext highlighter-rouge">LocalBinding</code>. Класс <code class="language-plaintext highlighter-rouge">LocalBinding</code> содержит метаданные о локальных переменных. В метаданных нет значения переменной, но оно не понадобится. Форма <code class="language-plaintext highlighter-rouge">(get-locals)</code> возвращает словарь вида:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="ss">'a</span><span class="w"> </span><span class="n">a,</span><span class="w"> </span><span class="ss">'b</span><span class="w"> </span><span class="n">b,</span><span class="w"> </span><span class="n">...</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>При вычислении он становится тем, что ожидали — словарем локальных переменных:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="n">...</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Макрос в действии:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w">
      </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-locals</span><span class="p">))</span><span class="w">

</span><span class="c1">;; {a 1, b 2}</span><span class="w">
</span></code></pre></div></div>

<p>Более сложный пример вызовом функции. Видно, что <code class="language-plaintext highlighter-rouge">get-locals</code> захватил аргументы <code class="language-plaintext highlighter-rouge">a</code> и <code class="language-plaintext highlighter-rouge">b</code> и переменную <code class="language-plaintext highlighter-rouge">c</code> из формы <code class="language-plaintext highlighter-rouge">let</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">get-locals</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)))</span><span class="w">

</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">add</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="c1">;; {a 1, b 2, c 3}</span><span class="w">
</span><span class="mi">6</span><span class="w">
</span></code></pre></div></div>

<p>Теперь когда у нас есть все нужное, подумаем, как выполнить форму. Задача сводится к тому, чтобы связать локальные переменные с <code class="language-plaintext highlighter-rouge">eval</code>. Для этого есть несколько способов. Первый — временно сделать локальные переменные глобальными. Назовем этот трюк глобализацией. Чтобы “глобализировать” переменные, нужно:</p>

<ul>
  <li>обойти словарь <code class="language-plaintext highlighter-rouge">locals</code> в цикле <code class="language-plaintext highlighter-rouge">doseq</code>;</li>
  <li>внедрить переменные в пространство имен функцией <code class="language-plaintext highlighter-rouge">intern</code>;</li>
  <li>вычислить форму при помощи <code class="language-plaintext highlighter-rouge">eval</code> и запомнить результат;</li>
  <li>удалить внедренные переменные при помощи <code class="language-plaintext highlighter-rouge">ns-unmap</code>;</li>
  <li>вернуть результат.</li>
</ul>

<p>Вот как выглядит черновик <code class="language-plaintext highlighter-rouge">eval+</code> с этим алгоритмом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">eval+</span><span class="w"> </span><span class="p">[</span><span class="n">ns</span><span class="w"> </span><span class="n">locals</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[[</span><span class="n">sym</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="n">locals</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">intern</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="n">sym</span><span class="w"> </span><span class="n">value</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w">
        </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*ns*</span><span class="w"> </span><span class="n">ns</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="n">form</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[[</span><span class="n">sym</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="n">locals</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">ns-unmap</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="n">sym</span><span class="p">))</span><span class="w">
    </span><span class="n">result</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Проверка показывает, что все верно:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">eval+</span><span class="w"> </span><span class="n">*ns*</span><span class="w"> </span><span class="p">{</span><span class="ss">'a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">'b</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span><span class="c1">;; 3</span><span class="w">
</span></code></pre></div></div>

<p>Убедимся, что мы не оставили за собой глобальных переменных: вне формы <code class="language-plaintext highlighter-rouge">eval+</code> символ a неизвестен:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>=&gt; a
Syntax error compiling at (repl-chapter:localhost:62378(clj)*:1:8441).
Unable to resolve symbol: a in this context
</code></pre></div></div>

<p>Обратите внимание, что <code class="language-plaintext highlighter-rouge">(eval form)</code> (строка 6) выполняется в рамках <code class="language-plaintext highlighter-rouge">binding</code> с привязкой пространства, которое передали в <code class="language-plaintext highlighter-rouge">eval+</code>. Без этого вычисление сработает в пространстве <code class="language-plaintext highlighter-rouge">clojure.core</code>, и переменные не подхватятся.</p>

<p>Недостаток глобализации в том, что она не учитывает некоторые обстоятельства. Например, если в словаре указана переменная <code class="language-plaintext highlighter-rouge">a</code> и такая же переменная задана в пространстве, после очистки мы потеряем ее:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">eval+</span><span class="w"> </span><span class="n">*ns*</span><span class="w"> </span><span class="p">{</span><span class="ss">'a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">'b</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span><span class="mi">3</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w">
</span><span class="n">Unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nb">resolve</span><span class="w"> </span><span class="nb">symbol</span><span class="err">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">context</span><span class="w">
</span></code></pre></div></div>

<p>Доработайте код, чтобы перед вызовом <code class="language-plaintext highlighter-rouge">intern</code> и <code class="language-plaintext highlighter-rouge">ns-unmap</code> была проверка, существует ли переменная с таким именем. Если существует, переименуйте ее в <code class="language-plaintext highlighter-rouge">__old_&lt;var&gt;__</code>. На обратном пути проверьте: если <code class="language-plaintext highlighter-rouge">__old_&lt;var&gt;__</code> существует, верните <code class="language-plaintext highlighter-rouge">&lt;var&gt;</code> с прежним значением. Для проверки переменной на существование используйте <code class="language-plaintext highlighter-rouge">resolve</code>. Результат будет либо <code class="language-plaintext highlighter-rouge">nil</code>, либо <code class="language-plaintext highlighter-rouge">Var</code>. Значение переменной легко получить, “дерефнув” <code class="language-plaintext highlighter-rouge">Var</code> оператором <code class="language-plaintext highlighter-rouge">@</code> или функций <code class="language-plaintext highlighter-rouge">deref</code>, предварительно проверив на <code class="language-plaintext highlighter-rouge">nil</code> или с помощью оператора <code class="language-plaintext highlighter-rouge">some-&gt;</code>.</p>

<p>Второй и более правильный способ выполнить форму с локальными переменными — сдвинуть их внутрь <code class="language-plaintext highlighter-rouge">eval</code>. Для этого погрузим форму в оператор <code class="language-plaintext highlighter-rouge">let</code> по следующему принципу:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; locals</span><span class="w">
</span><span class="p">{</span><span class="ss">'a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">'b</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">

</span><span class="c1">;; form</span><span class="w">
</span><span class="o">'</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">

</span><span class="c1">;; final form</span><span class="w">
</span><span class="o">'</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Если выполнить итоговую форму в REPL, получим ожидаемый результат 3. В этом подходе нет махинаций с глобальными переменными, что делает его безопасней.</p>

<p>Рассмотрим, составить подобную форму <code class="language-plaintext highlighter-rouge">let</code>. На первый взгляд задача кажется легкой: это список, где первый элемент — символ <code class="language-plaintext highlighter-rouge">let</code>, второй — вектор связывания, а третий — форма, которую вычисляют. Составим функцию <code class="language-plaintext highlighter-rouge">make-eval-form</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-eval-form</span><span class="w"> </span><span class="p">[</span><span class="n">locals</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'let</span><span class="w"> </span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="nb">identity</span><span class="w"> </span><span class="n">locals</span><span class="p">))</span><span class="w"> </span><span class="n">form</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>и убедимся в ее работе:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">make-eval-form</span><span class="w"> </span><span class="p">{</span><span class="ss">'a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">'b</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span><span class="c1">;; (let [a 1 b 2] (+ a b))</span><span class="w">
</span></code></pre></div></div>

<p>Если выполнить результат в <code class="language-plaintext highlighter-rouge">eval</code>, получим 3. Однако более сложные примеры не сработают. Предположим, одна из переменных содержит список — не вектор, а именно список чисел:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">make-eval-form</span><span class="w"> </span><span class="p">{</span><span class="ss">'numbers</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)}</span><span class="w">
                </span><span class="o">'</span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">numbers</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>В результате получится форма:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">numbers</span><span class="w"> </span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">numbers</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Компилятор не сможет вычислить <code class="language-plaintext highlighter-rouge">(1 2 3)</code>, потому что 1 не является функцией. Чтобы список остался списком, он должен предстать в виде <code class="language-plaintext highlighter-rouge">(list 1 2 3)</code>, что требует лишних усилий.</p>

<p>Еще одна ловушка кроется в представлении значений: не все из них могут быть прочитаны парсером Clojure. Например, если напечатать вектор <code class="language-plaintext highlighter-rouge">[1 2 3]</code>, получим строку, которую можно вставить в код. В широком смысле представление вектора совпадает с его синтаксисом. То же самое относится к словарю и простым типам: числам, строкам, кейвордам. Каждый из них выглядит так же, как в коде.</p>

<p>Однако другие классы представляют объект строкой, которая нарушает синтаксис Clojure. Примером служит класс <code class="language-plaintext highlighter-rouge">File</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.io.File</span><span class="w"> </span><span class="s">"test.txt"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; #object[java.io.File 0x3c4b88d3 "test.txt"]</span><span class="w">
</span></code></pre></div></div>

<p>Очевидно, строку <code class="language-plaintext highlighter-rouge">#object[java.io.File ... "test.txt"]</code> нельзя вычислить в REPL. Выражение с переменной <code class="language-plaintext highlighter-rouge">file</code> как в примере ниже:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">make-eval-form</span><span class="w">
 </span><span class="p">{</span><span class="ss">'file</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.io.File</span><span class="w"> </span><span class="s">"test.txt"</span><span class="p">)}</span><span class="w">
 </span><span class="o">'</span><span class="p">(</span><span class="nf">.getAbsolutePath</span><span class="w"> </span><span class="n">file</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>даст форму, несовместимую с eval:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">file</span><span class="w"> </span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">java.io.File</span><span class="w"> </span><span class="mi">0</span><span class="n">x4e293fac</span><span class="w"> </span><span class="s">"test.txt"</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="nf">.getAbsolutePath</span><span class="w"> </span><span class="n">file</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы избежать ошибки, идут на интересный трюк. В правой части вектора <code class="language-plaintext highlighter-rouge">let</code> помещают не значение, а код, который получает его из некоего источника. Теперь не нужно опасаться, что объект <code class="language-plaintext highlighter-rouge">File</code> вызовет ошибку синтаксиса:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">file</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="ss">'file</span><span class="p">)]</span><span class="w">
         </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="n">file</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Осталось понять, чем является источник. Подойдет глобальная динамическая переменная <code class="language-plaintext highlighter-rouge">*locals*</code>, которую временно связывают с локальными переменными. Это еще одна тонкость функции <code class="language-plaintext highlighter-rouge">eval</code>: она игнорирует локальные переменные, но учитывает динамические. Проверим это на примере:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">*num*</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*num*</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">*num*</span><span class="w"> </span><span class="n">*num*</span><span class="p">)))</span><span class="w">
</span><span class="c1">;; 9</span><span class="w">
</span></code></pre></div></div>

<p>Объявим приватную динамическую переменную <code class="language-plaintext highlighter-rouge">*locals*</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="o">^</span><span class="no">:private</span><span class="w">
  </span><span class="n">*locals*</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>С ней новая версия <code class="language-plaintext highlighter-rouge">eval+</code> выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">eval+</span><span class="w"> </span><span class="p">[</span><span class="n">ns</span><span class="w"> </span><span class="n">locals</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*locals*</span><span class="w"> </span><span class="n">locals</span><span class="w">
            </span><span class="n">*ns*</span><span class="w"> </span><span class="n">ns</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">reduce</span><span class="w">
                  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">sym</span><span class="p">]</span><span class="w">
                    </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">sym</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">*locals*</span><span class="w"> </span><span class="o">'~</span><span class="n">sym</span><span class="p">)))</span><span class="w">
                  </span><span class="p">[]</span><span class="w">
                  </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">locals</span><span class="p">))</span><span class="w">
             </span><span class="o">~</span><span class="n">form</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Внутренняя форма <code class="language-plaintext highlighter-rouge">reduce</code> производит вектор связывания, который становится частью <code class="language-plaintext highlighter-rouge">let</code>. Обратите внимание, что значения переменных не участвуют в коде — нужны только их имена, чтобы составить пары вида <code class="language-plaintext highlighter-rouge">[x (get *locals* x)]</code>. Поэтому в <code class="language-plaintext highlighter-rouge">reduce</code> передаются ключи локальных переменных (форма <code class="language-plaintext highlighter-rouge">(keys locals)</code>). Вот что построит <code class="language-plaintext highlighter-rouge">reduce</code> для переменных <code class="language-plaintext highlighter-rouge">a</code> и <code class="language-plaintext highlighter-rouge">b</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">*locals*</span><span class="w"> </span><span class="ss">'a</span><span class="p">)</span><span class="w">
 </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">*locals*</span><span class="w"> </span><span class="ss">'b</span><span class="p">)]</span><span class="w">
</span></code></pre></div></div>

<p>Теперь когда функция <code class="language-plaintext highlighter-rouge">eval+</code> готова, перейдем к последнему шагу — напишем свой отладчик для Clojure.</p>

<h3 id="отладчик-своими-руками">Отладчик своими руками</h3>

<p>Наш отладчик представлен макросом <code class="language-plaintext highlighter-rouge">break</code>, который работает как точка останова. Он принимает форму и запускает внутренний REPL. Выполнение формы откладывается, и пользователю доступны команды: справка, просмотр переменных, выполнение кода. При выходе из отладки управление переходит к форме. Вот как это выглядит в коде:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w">
      </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)))</span><span class="w">
</span><span class="c1">;; 3</span><span class="w">
</span></code></pre></div></div>

<p>Перед вычислением <code class="language-plaintext highlighter-rouge">(+ a b)</code> запустится REPL, в котором доступны переменные <code class="language-plaintext highlighter-rouge">a</code> и <code class="language-plaintext highlighter-rouge">b</code>. Когда отладка закончена, получим результат 3.</p>

<p>Отладчик предваряет форму функцией <code class="language-plaintext highlighter-rouge">break-inner</code>, которая принимает пространство и локальные переменные. Функция <code class="language-plaintext highlighter-rouge">break-inner</code> работает как внутренний REPL с той особенностью, что некоторый ввод считается командой. Пока что реализуем четыре команды: печать локальных переменных, выполнение кода, справку и выход.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">break</span><span class="w"> </span><span class="p">[</span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nf">do</span><span class="w">
     </span><span class="p">(</span><span class="nf">break-inner</span><span class="w"> </span><span class="n">*ns*</span><span class="w"> </span><span class="p">(</span><span class="nf">get-locals</span><span class="p">))</span><span class="w">
     </span><span class="o">~</span><span class="n">form</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Договоримся о синтаксисе: ввод <code class="language-plaintext highlighter-rouge">!locals</code> означает вывести локальные переменные; по команде <code class="language-plaintext highlighter-rouge">!exit</code> отладка завершается. Символ <code class="language-plaintext highlighter-rouge">!help</code> служит для справки. Все остальное отладчик воспринимает как код, который нужно выполнить. Вот как выглядит <code class="language-plaintext highlighter-rouge">break-inner</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">break-inner</span><span class="w"> </span><span class="p">[</span><span class="n">ns</span><span class="w"> </span><span class="n">locals</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">input</span><span class="w"> </span><span class="p">(</span><span class="nb">read-line</span><span class="p">)</span><span class="w">
          </span><span class="n">form</span><span class="w"> </span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="n">input</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">form</span><span class="w"> </span><span class="ss">'!exit</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Bye"</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w">
              </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">form</span><span class="w">
                </span><span class="n">!locals</span><span class="w"> </span><span class="n">locals</span><span class="w">
                </span><span class="n">!help</span><span class="w"> </span><span class="s">"Help message..."</span><span class="w">
                </span><span class="p">(</span><span class="nf">eval+</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="n">locals</span><span class="w"> </span><span class="n">form</span><span class="p">))]</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Добавьте макрос <code class="language-plaintext highlighter-rouge">break</code> в любом месте кода и запустите его. Он сработает как точка останова в IDЕ: код прервется, и вы окажетесь в отладке. Приведем сеанс отладчика с простой формой <code class="language-plaintext highlighter-rouge">let</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)))</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w">
</span><span class="mi">1</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">b</span><span class="w">
</span><span class="mi">2</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
</span><span class="mi">6</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">!locals</span><span class="w">
</span><span class="p">{</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">!help</span><span class="w">
</span><span class="n">Help</span><span class="w"> </span><span class="n">message...</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="n">!exit</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre></div></div>

<p>Команда <code class="language-plaintext highlighter-rouge">!exit</code> завершит отладку, и вы получите результат <code class="language-plaintext highlighter-rouge">let</code> — число 3.</p>

<p>Примените к отладчику улучшения, что мы рассмотрели в начале главы: печать при помощи <code class="language-plaintext highlighter-rouge">pprint</code>, перехват исключений, переменные <code class="language-plaintext highlighter-rouge">*1</code>, <code class="language-plaintext highlighter-rouge">*2</code>, <code class="language-plaintext highlighter-rouge">*3</code> и <code class="language-plaintext highlighter-rouge">*e</code> и все остальное.</p>

<p>Недостаток брейкпоинта в том, что он принимает команды только с клавиатуры. Продвинутая версия должна использовать сетевой протокол или графический интерфейс. В случае с сетью отладчик можно совместить с nREPL. Понадобится middleware, которое расширит протокол новыми полями и их обработкой.</p>

<p>Для интерфейса можно использовать встроенный пакет Swing или веб-сервер с браузером. В момент отладки запускается локальный HTTP-сервер. Функция <code class="language-plaintext highlighter-rouge">browse-url</code> из модуля <code class="language-plaintext highlighter-rouge">clojure.java.browse</code> открывает браузер по адресу <code class="language-plaintext highlighter-rouge">http://127.0.0.1:&lt;port&gt;/debug</code>. Интерфейс строится на технологиях HTML, CSS и JavaScript. Браузер и сервер обмениваются данными через JSON API.</p>

<h3 id="множественная-отладка-теория">Множественная отладка (теория)</h3>

<p>Выше мы покрыли отладкой только одну форму <code class="language-plaintext highlighter-rouge">(+ a b)</code>. На ней исполнение прервется, а затем продолжится. На практике сложный код исследуют по шагам: от одной формы переходят к другой, пока проблема не устранена. Так происходит потому, что порой трудно понять, где именно закралась ошибка. Точку останова ставят приблизительно и шагают по коду, сверяясь с состоянием программы.</p>

<p>Легко написать макрос <code class="language-plaintext highlighter-rouge">debug</code>, который принимает сложную форму и расставляет точки останова в ее содержимом, в том числе вложенным формам. Например, форма <code class="language-plaintext highlighter-rouge">let</code> со сложением двух чисел после обработки макросом выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">   </span><span class="c1">;; 1</span><span class="w">
      </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="mi">2</span><span class="p">)]</span><span class="w">  </span><span class="c1">;; 2</span><span class="w">
  </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)))</span><span class="w">  </span><span class="c1">;; 3</span><span class="w">
</span></code></pre></div></div>

<p>Если ее выполнить, процесс станет похож на настоящую отладку. Сперва вы окажетесь в первой точке <code class="language-plaintext highlighter-rouge">(break 1)</code>. В этот момент не доступна ни одна локальная переменная. В точке <code class="language-plaintext highlighter-rouge">(break 2)</code> появится доступ к переменной <code class="language-plaintext highlighter-rouge">a</code>. Выйдя из нее, вы окажетесь в третьей точке, где доступны <code class="language-plaintext highlighter-rouge">a</code> и <code class="language-plaintext highlighter-rouge">b</code>. Покинув третью точку, вы получите результат 3.</p>

<p>Обратите внимание, что в <code class="language-plaintext highlighter-rouge">let</code> нельзя оборачивать левую часть связывания. Если сделать как в примере ниже, получим ошибку синтаксиса:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[(</span><span class="nf">break</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="mi">2</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Let</code>, точнее ее внутренний вариант <code class="language-plaintext highlighter-rouge">let*</code>, относится к особым формам, синтаксис которых нельзя нарушать. Похоже устроены формы <code class="language-plaintext highlighter-rouge">def</code>, <code class="language-plaintext highlighter-rouge">defn</code>, <code class="language-plaintext highlighter-rouge">if</code> и другие. Некоторые их элементы опорные, потому что на них полагается парсер Clojure.</p>

<p>Мы не будем писать макрос <code class="language-plaintext highlighter-rouge">debug</code>, а только предположим, как он выглядит. Макрос принимает форму и обходит ее сверху вниз. Для обхода и изменения дерева понадобятся модули <code class="language-plaintext highlighter-rouge">clojure.walk</code> или <code class="language-plaintext highlighter-rouge">clojure.zip</code>. Напишем наивную версию макроса:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.walk</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">walk</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">debug</span><span class="w"> </span><span class="p">[</span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">walk/postwalk</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="n">wrap</span><span class="w"> </span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'break</span><span class="w"> </span><span class="n">el</span><span class="p">))</span><span class="w">
   </span><span class="n">form</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Проверим, что получится, если передать в макрос форму <code class="language-plaintext highlighter-rouge">let</code>. Для развертки макроса служит функция <code class="language-plaintext highlighter-rouge">macroexpand</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">macroexpand</span><span class="w">
 </span><span class="o">'</span><span class="p">(</span><span class="nf">debug</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">break</span><span class="w">
 </span><span class="p">((</span><span class="nf">break</span><span class="w"> </span><span class="k">let</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="p">[(</span><span class="nf">break</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="mi">2</span><span class="p">)])</span><span class="w">
  </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="p">((</span><span class="nf">break</span><span class="w"> </span><span class="nb">+</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="n">b</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>На выходе форма <code class="language-plaintext highlighter-rouge">let</code>, где каждый элемент покрыт точкой останова. Очевидно, мы перестарались, потому что в таком виде результат нельзя скомпилировать. Функция <code class="language-plaintext highlighter-rouge">wrap</code> из <code class="language-plaintext highlighter-rouge">walk/postwalk</code> должна действовать более тонко. Например, определять формы <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">def</code>, <code class="language-plaintext highlighter-rouge">if</code> и обрабатывать их особо.</p>

<p>Измените <code class="language-plaintext highlighter-rouge">wrap</code> таким образом, чтобы она опиралась на функции <code class="language-plaintext highlighter-rouge">needs-debug?</code> и <code class="language-plaintext highlighter-rouge">wrap-debug</code>. Первая проверяет, нужно ли оборачивать форму, а вторая делает это с учетом синтаксиса.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="n">wrap</span><span class="w"> </span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">needs-debug?</span><span class="w"> </span><span class="n">el</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">wrap-debug</span><span class="w"> </span><span class="n">el</span><span class="p">))</span><span class="w">
  </span><span class="n">el</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Это нетривиальное задание: с учетом всех тонкостей оно займет несколько экранов. Сделайте так, чтобы код был расширяемым при помощи мультиметода. Начните с форм <code class="language-plaintext highlighter-rouge">let</code> и <code class="language-plaintext highlighter-rouge">def</code>, потому что они встречаются чаще других.</p>

<p>Некоторые формы допускают разную запись. Например, у формы <code class="language-plaintext highlighter-rouge">defn</code> может быть несколько тел, в <code class="language-plaintext highlighter-rouge">def</code> может быть строка документации, pre- и post-проверки и многое другое. Приведите их к единому виду, чтобы не усложнять код проверками if/else. Один из способов это сделать – разобрать форму на части функцией <code class="language-plaintext highlighter-rouge">conform</code> из Clojure.spec. Для разбора понадобятся определения; взять их можно из пакета <a href="https://github.com/clojure/core.specs.alpha"><code class="language-plaintext highlighter-rouge">clojure.core.specs.alpha</code></a>, где собраны спеки основных конструкций: <code class="language-plaintext highlighter-rouge">ns</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">def</code> и других.</p>

<h3 id="отладочный-тег">Отладочный тег</h3>

<p>Макросом <code class="language-plaintext highlighter-rouge">(break ...)</code> будет проще пользоваться, если назначать ему тег <code class="language-plaintext highlighter-rouge">#my/break</code> или похожий. Вот как это выглядит в коде:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
  </span><span class="o">#</span><span class="n">my/break</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Мы добавили пространство <code class="language-plaintext highlighter-rouge">my</code>, потому что тег <code class="language-plaintext highlighter-rouge">#break</code> уже занят пакетом Cider. Чтобы связать тег с функцией, создайте в директории <code class="language-plaintext highlighter-rouge">src</code> файл <code class="language-plaintext highlighter-rouge">data_readers.clj</code> с содержимым:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">my/break</span><span class="w"> </span><span class="n">my.namespace/break-reader</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Ключ этого словаря — имя тега, а значение — полный путь к функции, которая его раскрывает. Функция принимает форму, которая стоит перед тегом и возвращает новую форму. В нашем случае <code class="language-plaintext highlighter-rouge">break-reader</code> обернет форму в <code class="language-plaintext highlighter-rouge">break</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">break-reader</span><span class="w"> </span><span class="p">[</span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nf">break</span><span class="w"> </span><span class="o">~</span><span class="n">form</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Проведите эксперименты с тегом <code class="language-plaintext highlighter-rouge">#my/break</code>. Расставьте их в коде и убедитесь, что отладка запускается. Добавьте в редактор сочетание клавиш, которое ставит тег на текущее место курсора.</p>

<h2>Все части</h2>

<ul>
  <li><a href="/clj-repl-part-1/">Первая часть</a></li>
  <li><a href="/clj-repl-part-2/">Вторая часть</a></li>
  <li><a href="/clj-repl-part-3/">Третья часть</a></li>
  <li><a href="/clj-repl-part-4/">Четвертая часть</a></li>
</ul>

<!--
Local Variables:
ispell-local-dictionary: "ru"
fill-column: 99999
truncate-lines: nil
End:
-->

    
<div class="prev-next">

    <div class="prev-next-left">
    
        <p><small><a href="/en/zippo/">&larr; Zippo: additions to the standard clojure.zip package.</a></small></p>
    
    </div>

    <div class="prev-next-mid">
    </div>

    <div class="prev-next-right">
    
        <p><small><a href="/de-js/">Деджаваскриптизиция &rarr;</a></small></p>
    
    </div>

</div>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-repl-part-3/">
    <input required name="captcha" type="hidden" value="2 &#215; 2">

    <div class="block">
        <span class="comment-form-label"><small>2 &#215; 2 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="https://t.me/igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
