<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ivan Grishaev's blog</title>
  <meta name="description" content="Writing on programming, education, books and negotiations.
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/page6/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="home">

    <ul class="post-list">
        
        <li>

            <h2>
                <a class="post-link" href="/write-and-check/">Приши, улучшай</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2024-12-22T00:00:00+00:00">
        Dec 22, 2024
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/code/" rel="tag">code</a>

</div>


            <div class="entry">
                
                    <p>Кто читал Ильяхова, знает формулу “пиши, сокращай”. Суть в том, что хороший
текст не пишут сразу. Пишется болванка, полная косяков, а потом по ней
многократно проходят: здесь снимают стружку, тут, наоборот, доливают
свинца. Только тогда текст становится сильным.</p>

<p>То же самое с кодом: недостаточно его написать и проверить. Когда тесты написаны
и код рабочий, нужно пройтись по нему и причесать. Дать нормальные имена,
вынести анонимные функции на верхний уровень. Одни участки кода разнести на
промежуточные шаги, чтобы не было слишком плотно. Другие, наоборот, сократить.</p>

<p>Здесь нет точных правил, важно чутье — как воспримет этот код другой
человек. Будет ему ли понятна логика, насколько легко внести изменения.</p>

<p>И если есть программисты, которые комитят рабочий код, то со второй фазой все
очень плохо. Кажется, что когда код заработал, у программиста щелкает какое-то
реле — работа сделана, закрывай таску. Потратить двадцать минут на причесывание
кода — не знаем, не слышали.</p>

<p>И да, этим страдают в том числе кложуристы. Кто-то напел им, что на Кложе
получается божественный код, который хорош сам по себе. Иммутабельность, лисп,
дэ-эс-эль, бла-бла.</p>

<p>Читаю чужой код: коллекцию пропускают через пачку <code class="language-plaintext highlighter-rouge">map</code> и <code class="language-plaintext highlighter-rouge">partition-by</code>. В
каждой из них — анонимная функция со вложенными reduce и другими анонимными
функциями. Партицирование замкнуто на другой коллекции, которая что-то достает
из первой. Неделимый блок кода размером с экран. Функция в функции внутри
функции.</p>

<p>Нечитаемый ад. Писал его не молодой программист, надо полагать, с опытом. И то
же самое: как только он дошел до стадии “работает”, то оформил PR — и получил
апрув коллег.</p>

<p>Давайте не будем так делать. Если код работает, это не значит, что задачу пора
закрывать. От двадцати минут, потраченных сверху, вреда не будет — прод не
сгорит, менеджер подождет. Зато спасет день коллеги, который вкатывается в
проект.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/two-hotkey-systems/">Две системы клавиш</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2024-12-22T00:00:00+00:00">
        Dec 22, 2024
    </time>

    <a href="/tag/text/" rel="tag">text</a>, <a href="/tag/emacs/" rel="tag">emacs</a>, <a href="/tag/vim/" rel="tag">vim</a>

</div>


            <div class="entry">
                
                    <p>Это короткая заметка, которую хотелось бы развить в будущем.</p>

<p>Есть только два редактора, в которых хоткеи сделаны правильно — это Вим и
Емакс. Не то чтобы я маньяк, но других вариантов не вижу.</p>

<p>Возьмем современный редактор и посмотрим на хоткеи. Нажатие на кнопку приводит к
печати символа, и это логично. Чтобы вместо печати было действие, кнопку
нажимают со служебной клавишей, скажем Ctrl, Alt, Command. Все это тоже логично.</p>

<p>Но вот беда — многие комбинации заняты дефолтами! Ctrl-Q, T, N, O, P — все это
системные действия. Еще десяток клавиш уходит на навигацию каретки, еще десяток
— на удаление строк, слов и символов, и привет — Ctrl уже исчерпан. Попутно
нужно учесть, что на Маке роль Ctrl играет Command, поэтому удвоения емкости это
не дает.</p>

<p>Остается Alt, но на него могут быть повешены хоткеи терминала и операционки, и в
итоге какой-нибудь Alt-N просто не дойдет до редактора. Ну и часто на Альт тоже
много чего навешено.</p>

<p>Только в двух редакторах подумали о том, как решить проблему комплексно: это Vim
и Emacs. В первом разграничили режимы ввода и команд. Я пытался в Вим, но не
зашло. Уважаю тех, кто сидит в нем, потому что нравится сама концепция.</p>

<p>В Емаксе хоткеи сделали последовательностями, или цепочками. Например, <code class="language-plaintext highlighter-rouge">C-x f</code>
открывает файл, <code class="language-plaintext highlighter-rouge">C-x o</code> открывает новое окно, <code class="language-plaintext highlighter-rouge">C-x C-c</code> —закрывает Емакс. Подход
с цепочками позволяет делать домены хоткеев, когда на <code class="language-plaintext highlighter-rouge">C-x</code> вешаются базовые
функции, на <code class="language-plaintext highlighter-rouge">C-h</code> — все, что имеет отношение к справке, на <code class="language-plaintext highlighter-rouge">C-x r</code> — операции с
прямоугольниками и так далее. Все это легко наращивается вглубь, не мешая
остальным.</p>

<p>Недавно загуглил, как вызвать в Идее выпадашку с методами. Знаете как? Command +
F12! Если учесть, что F-клавиши на маке работают с зажатым Ctrl, получается три
кнопки одновременно! Пользователь Идеи должен быть осьминогом, чтобы с этим
совладать. А в Xcode на полном серьезе одна из функций навешена на
Shift+Alt+Command+V. Я уже не помню какая, но точно помню подсказку в меню.</p>

<p>Не то чтобы это большая проблема; можно продуктивно работать в любом
редакторе. Но повторюсь, системно к проблеме хоткеев подошли только в двух
редакторах: Виме и Емаксе. Все остальное — ситуативно и нерасширяемо.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/straight-data/">Выпрямить данные</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2024-12-22T00:00:00+00:00">
        Dec 22, 2024
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/data/" rel="tag">data</a>

</div>


            <div class="entry">
                
                    <p>В кложурном чатике скинули очередную задачу: дана такая-то мапа, нужно перегнать
ее в другую мапу. Примерный исходник:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(var DATA
  {:kek {:foo {:type :LOL}
         :bar {:type :KEK}}
   :owo {:pip {:type :AGA}}})
</code></pre></div></div>

<p>Ожидание:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{:LOL {:foo :kek}
 :KEK {:bar :kek}
 :AGA {:pip :owo}}
</code></pre></div></div>

<p>Это очень упрощенный пример. Грубо говоря, нужно вывернуть вложенную мапу
наизнанку: поместить наверх то, что сейчас внизу.</p>

<p>Большинство кложуристов подходят к этой задаче как есть. Они берут мапу и
прогоняют ее через комбо <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">mapcat</code> и анонимных функций. Кто-то накручивает
<code class="language-plaintext highlighter-rouge">reduce</code> внутри <code class="language-plaintext highlighter-rouge">reduce</code>. В целом работает, но как это читать и отлаживать — я
не знаю.</p>

<p>Я тоже скинул решение, точнее его часть, и оно зашло: понаставили пальчиков и
огней. Раз так, стоит рассказать подробней, тем более что я замечаю, что никто
так не делает.</p>

<p>Итак, если посмотреть на исходную мапу, станет ясно, что когда-то она была
плоской таблицей:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kek foo LOL
kek bar KEK
owo pip AGA
</code></pre></div></div>

<p>Из-за того, что в левой части были повторы, кто-то решил избавиться от них
группировкой. Но данные никуда не пропали: мы по-прежнему знаем, у кого какой
атрибут. Посмотрев на самый вложенный элемент, легко проследить его
путь. Например, обнаружить, что AGA начинается с owo.</p>

<p>Так вот, чтобы переколбасить эту мапу во что-то другое, нужно сперва выправить
данные — привести их к таблице. Поможет макрос for. Он принимает несколько
коллекций и строит декартово произведение их элементов. Примечательно, что
каждая следующая коллекция может быть получена из предыдущих элементов. Код ниже
строит ленивую таблицу:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(for [[k1 submap1]
      DATA

      [k2 submap2]
      submap1

      [_ item]
      submap2]

  [k1 k2 item])

([:kek :foo :LOL]
 [:kek :bar :KEK]
 [:owo :pip :AGA])
</code></pre></div></div>

<p>Теперь когда мапа развернута, можно сгруппировать ее по-другому. Как именно —
это уже тривиальное дело, потому что, имея плоские данные, это делается на
раз-два. Кроме того, нужно спросить себя — действительно ли нужна новая
группировка? Может быть, лучше оставить как есть? Возможно, на той стороне тоже
хотели бы плоские данные.</p>

<p>Я как-то рассказывал о нелепой ситуации со вложенностью. На одной стороне
человек потеет, чтобы построить из списка вложенную мапу вида:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{:node shit
 :children
 [{:node crap
   :children
   [{:node fuck
     :children
     [...]}]}]}
</code></pre></div></div>

<p>А на второй стороне другой человек потеет, чтобы обойти ее как список. Оба пишут
быдлокод и матерятся, а ради чего — не ясно. Такую структуру даже не каждый
кложурист обойдет, потому что не все знают про tree-seq и зипперы.</p>

<p>Возвращаясь к теме переколбаса данных: хорошо бы запомнить аналогию. Плоские
данные — это как лист бумаги, из которого можно сложить самолет, кораблик или
лягушку-квакушку. Но переход от одной фигуры к другой происходит через развертку
— то есть откату к нулевому состоянию. Только потом можно переходить к новому.</p>

<p>Наверняка найдется японец, который может сложить самолет в лягушку, минуя
лист. Точно так же можно написать быдлокод, который переколбасит одну мапу в
другую. Но это сложно, не очевидно, хрупко. Лучше избегать.</p>

<p>Видеть простейшую форму и возвращаться к ней, когда что-то идет не так — важный
навык.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/file-paths-concat/">Файловые пути</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2024-12-22T00:00:00+00:00">
        Dec 22, 2024
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/files/" rel="tag">files</a>

</div>


            <div class="entry">
                
                    <p>У меня пожелание: давайте не будем строить файловые пути конкатенацией строк. Не
будем сами и не позволим другим. Как увидите в ревью что-то вроде</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file_path = some_dir + "/" + file_name
</code></pre></div></div>

<p>, сразу пишите комментарий: не клей строки, используй функции, для этого
предназначенные.</p>

<p>Достоверно известен случай, когда человек потерял бизнес из-за ошибки в
файлах. Это был небольшой хостинг, и чел выполнил на всех машинах <code class="language-plaintext highlighter-rouge">sudo rm -rf
$FOO/$BAR</code>. Беда в том, что переменные не подхватились, и получилось <code class="language-plaintext highlighter-rouge">sudo rm
-rf /</code>.</p>

<p>Вы скажете, что есть флаг <code class="language-plaintext highlighter-rouge">-e</code>, чтобы вылететь с ошибкой, если переменная среды
не задана. Ну, допустим. Однако ничто не мешает сделать такую же ошибку в
коде. Например, кложуристы (которые, как известно, боги программирования),
строят пути конкатенацией строк:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(str some-dir "/" subdir "/" file-name)
</code></pre></div></div>

<p>И не знают, что функция <code class="language-plaintext highlighter-rouge">str</code> молча пропускает нуллы. Это значит, если
<code class="language-plaintext highlighter-rouge">file-name</code> равен nil, то путь получится <code class="language-plaintext highlighter-rouge">/some/dir/subdir/</code>. Если передать его
в функцию удаления, можно удалить всю папку.</p>

<p>По закону подлости, если что-то “можно”, то оно случается. Сегодня отлаживал
этот баг. Человек строит путь примерно так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(str "/tmp/" (get-dir-name ...))
</code></pre></div></div>

<p>Этот путь передается в функцию, которая рекурсивно удаляет папку. Но во-первых,
функция удаления была с багом и ничего не удаляла. А как только я починил,
выяснилось: при особых условиях <code class="language-plaintext highlighter-rouge">(get-dir-name...)</code> выдает nil, и путь
получается /tmp/. Функция исправно удаляет весь /tmp, в котором масса нужных
файлов.</p>

<p>Мораль: работая с путями как строками, легко отстрелить ногу. Вдвойне печально,
что это делают снова и снова. Я с этим борюсь, и вы помогайте.</p>

<p>Если речь про Кложу без библиотек, испольуйте <code class="language-plaintext highlighter-rouge">io/file</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(io/file "/tmp" subdir filename)

java.io.File&lt;"/tmp/subsir/filename.txt"&gt;
</code></pre></div></div>

<p>Если один из аргументов nil, оно свалится с ошибкой. А так есть либы вроде
<code class="language-plaintext highlighter-rouge">babashka/fs</code>.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/why-openapi/">Зачем OpenAPI?</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2024-12-19T00:00:00+00:00">
        Dec 19, 2024
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/openapi/" rel="tag">openapi</a>, <a href="/tag/web/" rel="tag">web</a>, <a href="/tag/rpc/" rel="tag">rpc</a>

</div>


            <div class="entry">
                
                    <p>Чего не могу понять, так это одержимость OpenAPI. Казалось бы, нужна апишка на
сайте — ну, сделай как тебе удобно. Но люди берут OpenAPI, крафтят спеку,
генерят по ней контроллеры, схемы, тесты. Превозмогают, потеют и потом
рассказывают: смотрите, наша апишка по стандарту OpenAPI.</p>

<p>А кого волнует этот ваш OpenAPI? Расстрою: никому не интересно, какая у вас
апишка. Пользователю все равно, что гоняетя под капотом. Для программистов на
Питоне, как правило, пишут клиентские библиотеки. Вызывая метод
<code class="language-plaintext highlighter-rouge">client.get_user(id=42)</code>, программист в гробу видал, что там у вас — <code class="language-plaintext highlighter-rouge">GET</code>,
<code class="language-plaintext highlighter-rouge">POST</code>, джейсон или XML. Никто на это не смотрит.</p>

<p>Если точнее, на это смотрят только кложуристы, потому что для них клиентских
библиотек никто не пишет. Но кого интересуют проблемы кложуристов? Они сами
напишут клиент поверх чего нужно.</p>

<p>За много лет я не припомню, чтобы от OpenAPI была какая-то польза. А вот проблем
— целый мешок. Это стандарт, которому нужно следовать; это определенные
инструменты, которые навязывают игру. Инструмент X написан на Руби, ставь его и
миллион пакетов. Инструмент Y написан на Ноде, ставь ее тоже и качай половину
npm. Я неделю настраивал swagger в докере, чтобы он показывал веб-страничку со
спекой. Команда привязала гирю к ноге и удивляется: почему разработка идет так
медленно?</p>

<p>Когда мне нужна апишка, я делаю простой RPC: команда-параметры,
команда-параметры. Все в теле запроса, а не как в REST, где один параметр в
заголовке, второй в адресной строке, третий черт знает где. В теле гоняю либо
JSON, либо message pack в зависимости от content type.</p>

<p>Это просто, это быстро, это прозрачно. В коде большая мапа вида</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{action {doc ...
         schema-in
         schema-out
         handler ...}}
</code></pre></div></div>

<p>По текущей команде я вынимаю схему, проверяю вход, вызываю функцию <code class="language-plaintext highlighter-rouge">handler</code> с
параметрами. Если дебаг, то проверяю выходные данные. Один раз настроил этот
словарь и потом только наращиваешь.</p>

<p>Если нужна документация, пишется код, который пробегает по словарю и рендерит
markdown-файл. В нем список команд, описание из поля <code class="language-plaintext highlighter-rouge">doc</code> и схемы
ввода-вывода. Если нужно, md-файлик рендерится в HTML или PDF.</p>

<p>Но серьезным людям этого не понять. Им нужна OpenAPI-спека, чтобы что-то
генерить и чему-то соответсвовать. Пишутся запредельные объемы тулинга под
OpenAPI. Бывает, в Кложу приходит бывший рубист и заводит песню: мол, в моих
Рельсах есть библиотека, которая по спеке сгенерит контроллер и модели, напишет
тесты, а у вас в Кложе ничего нет… блин, потому я и довольный, что нет.</p>

<p>На самом деле я был разок в проекте на Кложе, где по OpenAPI-спеке генерили
код. Два слова: это ужасно. Ни при каких обстоятельствах не сяду за это
снова. Генерация — это стремно, это хрупко, это километровые диффы. Духота,
трение и тошнота.</p>

<p>И никому не прихоит в голову спросить — зачем? Какую проблему ты решаешь своим
OpenAPI? Зачем соответствовать чужому стандарту, который не контролируешь? Чтобы
что?</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/pg-meetup-video/">Видео с митапа о Postgres</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2024-12-19T00:00:00+00:00">
        Dec 19, 2024
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/postgres/" rel="tag">postgres</a>, <a href="/tag/meetup/" rel="tag">meetup</a>

</div>


            <div class="entry">
                
                    <p>Появилась запись митапа:</p>

<iframe width="100%" height="500" src="https://www.youtube.com/embed/PDaLQLSCuJ8" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p>Примерно час я рассказываю про всякие технические кишки, потом дискуссия с
Николаем (CTO Самураев) и Владимиром (разработчиком JDBC-драйвера для Postgres).</p>

<p>Не обещаю, что будет интересно, скорее сильно на любителя.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/copilot-test/">Copilot и документация</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2024-12-19T00:00:00+00:00">
        Dec 19, 2024
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/copilot/" rel="tag">copilot</a>, <a href="/tag/ai/" rel="tag">ai</a>

</div>


            <div class="entry">
                
                    <p>Вчера провел с коллегой эксперимент.</p>

<p>Коллега подключил в редакторе Copilot и говорит — смотри, как круто он генерит
комментарии к функции! Скажем, для функции <code class="language-plaintext highlighter-rouge">generate-time-buckets(account,
time-frames)</code> пишет что-то вроде “generate time buckets for given account and
time frames”.</p>

<p>Мда, содержательно: для <code class="language-plaintext highlighter-rouge">generate-time-buckets</code> получить “generate time
buckets”… Мне такой подход кажется малоинформативным: очевидно, Copilot берет
сигнатуру и аргументы, конкатит их, разбивает на лексемы и причесывает, чтобы
смотрелось по-человечески.</p>

<p>Предложил эксперимент: пишем фукнцию, которая тупо складывает два числа: <code class="language-plaintext highlighter-rouge">return
a + b</code>. Называем функцию <code class="language-plaintext highlighter-rouge">delete-file</code> и просим Copilot написать докстринг. Что
он пишет? Правильно, “Delete а file”. Есть и второй вариант — “Delete a file
from S3”, видимо, для корпоративных клиентов в облаке.</p>

<p>Словом, теперь у нас ИИ-комментарии, а чего мы добились и какую проблему решили
— не понятно.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/why-sprints/">Зачем спринты?</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2024-12-02T00:00:00+00:00">
        Dec 2, 2024
    </time>

    <a href="/tag/work/" rel="tag">work</a>, <a href="/tag/sprint/" rel="tag">sprint</a>

</div>


            <div class="entry">
                
                    <p>За все время работы в айти я не понял, зачем нужны спринты.</p>

<p>Как правило, спринт — это период от двух недель до месяца. В него набирают задач
и пытаются их сделать к концу спринта. Потом спринты оценивают: этот был лучше,
чем в прошлый раз, а этот хуже. Тут собрали двадцать стори-поинтов, а тут
восемнадцать. Проводят ретро, которые убивают время.</p>

<p>Все это кажется мне бредом. Зачем делить время на равные участки? Зачем считать
стори-поинты? Какое знание дает цифра 18 стори-поинтов? Чем это хуже, чем 20
поинтов?</p>

<p>В чем проблема, если задача из одного спринта переносится в другой? Кто от этого
пострадал? Если задача не умещается в спринт, то может просто не впихивать
невпихуемое?</p>

<p>Нужно обсудить процесс? Так проведи серию звонков 1 на 1 с разработчиками. Не
обязательно ждать ретро.</p>

<p>В моем понимании процесс управляется релизами. Скажем, поставили мы задачу
выкатить новый релиз через два месяца. Договорились, что в релиз войдет то, се,
пятое-десятое. Не успеваем? Что-то упрощаем, что-то откладываем в следующий
релиз.</p>

<p>Зачем нам спринты? Почему все следуют карго-культу гуглов-амазонов? Нужно думать
своей головой, а не как менеджер Гугла.</p>

<p>UPD: сюда же относятся эстимейты. Воистину, самое тупое и бесмыссленое, что есть
в айти. Эстимейтить все и вся, ошибаться на порядок и потом рвать задницу, чтобы
успеть.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/oop-gauge/">Шкала ООП</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2024-12-02T00:00:00+00:00">
        Dec 2, 2024
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/oop/" rel="tag">oop</a>

</div>


            <div class="entry">
                
                    <p>Когда говорят про ООП, упоминают всякие солиды, наследование и прочее. И не
говорят вот про что (а надо бы).</p>

<p>Если в языке присутствует ООП, то типизация объектов размывается. Только
структуры и функции дают четкие типы; объекты, наоборот, разрушают их путем
абстракций. Они замыливают глаз.</p>

<p>Скажем, у нас есть классы <code class="language-plaintext highlighter-rouge">Dog</code> и <code class="language-plaintext highlighter-rouge">Cat</code>, унаследованные от <code class="language-plaintext highlighter-rouge">Animal</code>. Пока мы
передаем собак и котов явно, все хорошо. Но когда мы передаем их как животных
(<code class="language-plaintext highlighter-rouge">Animal</code>), там может быть что угодно. В итоге на одни и те же данные смотришь
по-разному.</p>

<p>Если предположить, что <code class="language-plaintext highlighter-rouge">Animal</code> наследуется еще от чего-то, то получится шкала
от <code class="language-plaintext highlighter-rouge">Object</code> к <code class="language-plaintext highlighter-rouge">Dog</code>/<code class="language-plaintext highlighter-rouge">Cat</code>, и как смотреть на объект — зависит от контекста. В
некоторых случаях делают даун-каст и ап-каст: передают кота в виде объекта, а
потом проверяют: если это кот, то одно, если собака, то другое, иначе эксепшен.</p>

<p>Эту шкалу (<code class="language-plaintext highlighter-rouge">Object</code> — <code class="language-plaintext highlighter-rouge">Animal</code> — <code class="language-plaintext highlighter-rouge">Mammal</code> — <code class="language-plaintext highlighter-rouge">Dog</code>) важно держать в голове и
знать, где находишься сейчас. Лично мне она доставляет много хлопот, когда я
пишу на ООП-языках, например Джаве. Шкала — это не вкл/выкл, а некая доля,
позиция в в дереве, следить за которой сложнее.</p>

<p>Может быть, кто-то лучше выразил эту мысль, но либо я не слышал, либо забыл.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/no-regex/">Не люблю регулярки</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2024-12-02T00:00:00+00:00">
        Dec 2, 2024
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/regex/" rel="tag">regex</a>

</div>


            <div class="entry">
                
                    <p>Признаться, я не особо люблю регулярные выражения. Я знаю их где-то на троечку,
время от времени применяю, но стараюсь, чтобы их было меньше.</p>

<p>Дело в том, что регулярные выражения — это сверхплотный, сверхкраткий язык
описания шаблонов в тексте. Из его главного преимущества — краткости — следует
главный недостаток. Когда регулярка больше какого-то порога, ее понимание и
поддержка резко идут вниз. В этом случае следует отказаться от регулярки, однако
в проекте запросто может оказаться маньяк, который накрутит еще пару этажей
регулярок.</p>

<p>Другой момент — с регуляркой часто оказывается, что ты не все учел. Предположим,
нужно искать в тексте числа с плавающей запятой. Вы написали регулярку, которая
ищет числа вроде <code class="language-plaintext highlighter-rouge">-12.0042</code>. А потом оказалось, что у чисел может не быть целой
части, например <code class="language-plaintext highlighter-rouge">-.0042</code>. А еще оказались числа в научной нотации: <code class="language-plaintext highlighter-rouge">-1.2E9</code>. И
регулярку нужно допиливать, допиливать и накидывать тесты.</p>

<p>У регулярок есть хорошее применение: ими удобно разбивать текст. Как правило, я
разбиваю текст на части и проверяю, что их количество и содержимое чему-то
соответствует. Это проще отлаживать, это лучше в плане сообщения об ошибке. Если
текст не натягивается на монструозную регулярку, ты не можешь объяснить, что
пошло не так. А если обрабатывать текст по частям, легко сказать, в чем
проблема.</p>

<p>В одном из проектов у нас была библиотека для генерации регулярок. Это когда
декларативно указываешь: либо это слово, либо это, либо то, но не это и не то, и
библиотека строит одну регулярку. В ней учитываются общие начала слов, например
для <code class="language-plaintext highlighter-rouge">fuck</code> и <code class="language-plaintext highlighter-rouge">fuckoff</code> получим <code class="language-plaintext highlighter-rouge">fuck(?=off)</code>. Выбрал такой пример, потому что
фильтровали сообщения в чате. Было много других слов, значения которых я не знал
и смотрел в словаре.</p>

<p>Этот подход интересен тем, что регуляркам отводится служебная
часть. Конфигурация делается словарями и списками, все ясно и прозрачно.</p>

<p>Вместо регулярок мне больше нравится парсинг грамматикой. Пару лет назад я
прочитал пару статей про комбинаторные парсеры и решил сделать свой. В
результате я написал огрызок, который назвал Ostap (потому что великий
комбинатор). В библиотеке были простые парсеры и те, что составляются из других
(and, or). Можно задать грамматику словарем и получить из нее парсер.</p>

<p>В результате у меня получилось составить <a href="https://github.com/igrishaev/ostap/blob/master/src/ostap/json.clj">грамматику JSON</a>, и парсер
разбирал произвольный JSON-документ. Правда, это было медленней джавного Jackson
раз в десять, но за скоростью я не гнался. Почему-то зачесались руки сесть и
переписать его на Джаве и собрать парсеры для JSON, INI, Tolm и других форматов.</p>

<p>Словом, регулярки хороши, но я предпочитаю держать их на расстоянии вытянутой
руки. Чем они ближе, тем строже я слежу за ними.</p>

                
            </div>

        </li>
        
    </ul>

    <h4>
        
        <a href="/page5" class="previous">&larr;</a>
        
        <span class="page_number ">Страница 6 из 92</span>
        
        <a href="/page7" class="next">&rarr;</a>
        
    </h4>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="https://t.me/igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
