<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Исключения в Clojure</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-book-exceptions/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Исключения в Clojure</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2019-05-11T00:00:00+00:00">
        May 11, 2019
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/exceptions/" rel="tag">exceptions</a>, <a href="/tag/programming/" rel="tag">programming</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<p><em>Это третья глава предполагаемой книги по Кложе на русском языке.</em></p>

<h2>

    Содержание

</h2>

<ul id="toc-item-clj-book-exceptions">
  <li><a href="#основы-исключений" id="toc-item-clj-book-exceptions-основы-исключений">Основы исключений</a></li>
  <li><a href="#цепочки-исключений-и-контекст" id="toc-item-clj-book-exceptions-цепочки-исключений-и-контекст">Цепочки исключений и контекст</a></li>
  <li><a href="#переходим-к-clojure" id="toc-item-clj-book-exceptions-переходим-к-clojure">Переходим к Clojure</a></li>
  <li><a href="#контекст-ошибки" id="toc-item-clj-book-exceptions-контекст-ошибки">Контекст ошибки</a></li>
  <li><a href="#когда-бросать-исключения" id="toc-item-clj-book-exceptions-когда-бросать-исключения">Когда бросать исключения</a></li>
  <li><a href="#подробнее-о-цепочках" id="toc-item-clj-book-exceptions-подробнее-о-цепочках">Подробнее о цепочках</a></li>
  <li><a href="#печать-исключения" id="toc-item-clj-book-exceptions-печать-исключения">Печать исключения</a></li>
  <li><a href="#логирование" id="toc-item-clj-book-exceptions-логирование">Логирование</a></li>
  <li><a href="#исключения-как-данные-сбор-исключений" id="toc-item-clj-book-exceptions-исключения-как-данные-сбор-исключений">Исключения как данные. Сбор исключений</a></li>
  <li><a href="#переходы" id="toc-item-clj-book-exceptions-переходы">Переходы</a></li>
  <li><a href="#finally-и-контекстный-менеджер" id="toc-item-clj-book-exceptions-finally-и-контекстный-менеджер">Finally и контекстный менеджер</a></li>
  <li><a href="#исключения-на-предикатах" id="toc-item-clj-book-exceptions-исключения-на-предикатах">Исключения на предикатах</a></li>
  <li><a href="#приемы-и-функции" id="toc-item-clj-book-exceptions-приемы-и-функции">Приемы и функции</a></li>
  <li><a href="#заключение" id="toc-item-clj-book-exceptions-заключение">Заключение</a></li>
</ul>

<p>В этой главе речь пойдет об исключениях. Поговорим о том, как они устроены и в
чем их особенность. Когда лучше кидать, а когда ловить исключения. Как записать
их так, чтобы расследовать инцидент было легко.</p>

<p class="draft-warn">Внимание! Вы читаете черновик к книге <a href="/clojure-in-prod/">“Clojure на производстве”</a>. Для
книги я переписывал его много раз, но в блоге осталась старая версия. Здесь она
для истории, а вам я рекомендую купить книжку.</p>

<p>Возможно, читателю покажется странным, что на столь простую тему написано так
много. Но исключения не так просты, как принято считать. По мнению автора,
другие книги уделяют им возмутительно мало внимания. Считается, что программисту
достаточно знать, что исключения бросают, ловят и пишут в лог. Движемся дальше.</p>

<p>Это не так. Технически исключения просты, но несут обширную семантику. Когда их
кидать, когда перехватывать? Как извлечь полезную информацию из цепочки
исключений? Куда их записывать? Возможно ли ловить исключения предикатами?
Трудно вспомнить книгу или руководство, которое отвечает хотя бы на часть этих
вопросов.</p>

<p>Начинающие программисты пишут код, следуя только положительному пути. Отчасти
поэтому так трудно расследовать ошибки. Сервер вернул статус 500. Почему?
Возможны сотни причин, по которым запрос не удался. Но запись в логе слишком
скупа, чтобы расследовать инцидент.</p>

<p>Опытный программист внимателен к ошибкам. Приходит понимание, что сэкономив на
обработке исключений, разработчик на самом деле не выиграет. В перспективе он
потратит время на расследование непонятных ошибок.</p>

<p>Будет правильным считать, что ошибки столько же равноправны, как и нормальное
поведение программы. Ошибки типичны в сетевых сервисах, в больших распределенных
системах.</p>

<!-- more -->

<h2 id="основы-исключений">Основы исключений</h2>

<p>Прежде чем углубляться в детали, вспомним, что такое исключения и как они себя
ведут.</p>

<p>Исключение — это объект, чаще всего экземпляр условного класса <code class="language-plaintext highlighter-rouge">Exception</code>. От
других классов его отличает особая операция выбрасывания. В разных языках этот
оператор называется <code class="language-plaintext highlighter-rouge">throw</code>, <code class="language-plaintext highlighter-rouge">raise</code>, <code class="language-plaintext highlighter-rouge">report</code>.</p>

<p>Брошенный объект прерывает порядок исполнения и всплывает вверх по стеку
вызовов. У такого всплытия два исхода. Либо объект пойман оператором <code class="language-plaintext highlighter-rouge">catch</code> на
одном из уровней, либо перехват так и не состоялся.</p>

<p>В первом случае программист получает объект исключения. К нему обращаются как
обычно: читают поля, вызывают методы, передают в функции. Дальнейшее поведение
зависит от логики программы. Когда-то исключение пишут в лог и завершают
программу корректно, в других случаях продолжают работу.</p>

<p>Когда исключение не поймано, программа завершается с ошибкой. Как правило, перед
выходом программа выводит в <code class="language-plaintext highlighter-rouge">stderr</code> исключение в виде текста. Чаще всего это
класс исключения, сообщение к нему и то, что называют стектрейс. Это цепочка
вызовов, сквозь которые всплыло исключение.</p>

<p>Отдельные платформы разрешают установить обработчик на не пойманное
исключение. Например, чтобы записать исключение в файл или завершить программу с
особым сообщением и кодом выхода.</p>

<p>Clojure это гостевой язык. Он пользуется возможностями, которые предлагает
домашняя платформа (далее хост). Исключения — одна из тех областей, в которую
Clojure предпочитает не вмешиваться. По умолчанию Clojure использует формы <code class="language-plaintext highlighter-rouge">try</code>
и <code class="language-plaintext highlighter-rouge">catch</code>, аналогичные Java.</p>

<p>Рассмотрим исключения на Java-уровне. Платформа содержит базовый класс
<code class="language-plaintext highlighter-rouge">Throwable</code>. Это общий предок всех исключений. Другие классы наследуют
<code class="language-plaintext highlighter-rouge">Throwable</code>, тем самым расширяя его семантику. Например, наследники первого
порядка это классы <code class="language-plaintext highlighter-rouge">Error</code> и <code class="language-plaintext highlighter-rouge">Exception</code>. Последний наследует
<code class="language-plaintext highlighter-rouge">RuntimeException</code>, и так далее. На схеме ниже базовое дерево исключений:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌─────────────┐
                │   Object    │
                └─────────────┘
                       │
                       ▼
                ┌─────────────┐
             ┌──│  Throwable  │──┐
             │  └─────────────┘  │
             │                   │
             ▼                   ▼
      ┌─────────────┐     ┌─────────────┐
      │    Error    │     │  Exception  │──┐
      └─────────────┘     └─────────────┘  │
                                           │
                                           ▼
                                ┌─────────────────────┐
                                │  RuntimeException   │
                                └─────────────────────┘
</code></pre></div></div>

<p>Каждый из пакетов Java поставляет дополнительные исключения, унаследованные от
описанных выше. Например, <code class="language-plaintext highlighter-rouge">java.io.IOException</code> для ошибок ввода-вывода,
<code class="language-plaintext highlighter-rouge">java.net.ConnectException</code> для проблем в сети и другие.</p>

<p>Выбрасывать <code class="language-plaintext highlighter-rouge">Throwable</code> напрямую считается плохой практикой. Он несет слишком
мало информации о том, что случилось. В дереве исключений каждый следующий класс
дополняет семантику предка.</p>

<p>Рассмотрим класс <code class="language-plaintext highlighter-rouge">FileNotFoundException</code>. Такое исключение возникает, когда мы
обращаемся к несуществующему файлу. Его полная родословная выглядит так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.lang.Object
  java.lang.Throwable
    java.lang.Exception
      java.io.IOException
        java.io.FileNotFoundException
</code></pre></div></div>

<p>Такую схему читают как “выбрасываемое —&gt; исключение —&gt; ошибка ввода-вывода —&gt;
файл не найден”. По имени <code class="language-plaintext highlighter-rouge">FileNotFoundException</code> легко догадаться, с чем
связана проблема. Если же разработчик выбросил <code class="language-plaintext highlighter-rouge">Throwable</code>, это осложнит поиск
причины.</p>

<p>Различают <code class="language-plaintext highlighter-rouge">checked</code> и <code class="language-plaintext highlighter-rouge">unchecked</code> исключения, они же проверяемые и нет. Разница
между ними в семантике. Считается, что разработчик должен предвидеть <code class="language-plaintext highlighter-rouge">checked</code>
исключения и обработать их в коде. При чтении файла справедливо ожидать, что его
не окажется на диске. Поэтому <code class="language-plaintext highlighter-rouge">FileNotFoundException</code> относится к категории
checked, проверяемое.</p>

<p>Предвидеть нехватку памяти трудно, поэтому <code class="language-plaintext highlighter-rouge">OutOfMemoryError</code> относится к не
проверяемым исключениям. Теоретически любая строка когда способна выбросить
подобное исключение. Перехватывать его нет смысла, поскольку при нехватке памяти
система ведет себя непредсказуемо.</p>

<p>Классы, унаследованные от <code class="language-plaintext highlighter-rouge">Error</code> и <code class="language-plaintext highlighter-rouge">RuntimeException</code> относятся к не проверяемым
(unchecked) исключениям. Другие, унаследованные от <code class="language-plaintext highlighter-rouge">Exception</code> — проверяемые
(checked).</p>

<p>Чтобы выбросить исключение, достаточно создать его экземпляр и передать
оператору <code class="language-plaintext highlighter-rouge">throw</code>. Другой оператор <code class="language-plaintext highlighter-rouge">catch</code> перехватывает всплывающие
исключения. В Java и других языках работает одинаковый критерий отлова — по
иерархии классов. Например, если тип искомого исключения <code class="language-plaintext highlighter-rouge">IOException</code>, мы
поймаем все исключения, унаследованные от этого класса.</p>

<p>Чем выше класс в дереве наследования, тем больше возможных исключений поймает
<code class="language-plaintext highlighter-rouge">catch</code>. В мире Java считается плохим тоном отлавливать все возможные ошибки
классами <code class="language-plaintext highlighter-rouge">Throwable</code> или <code class="language-plaintext highlighter-rouge">Exception</code>. Современные IDE называют это “too wide
catch expression” и показывают предупреждение. Ситуацию решают заменой
<code class="language-plaintext highlighter-rouge">Exception</code> на несколько специализированных исключений. Например, отдельно
ошибки ввода-вывода и сети.</p>

<p>Одного только имени исключения не достаточно, чтобы понять причину его
появления. Так, у <code class="language-plaintext highlighter-rouge">FileNotFoundException</code> нет поля типа <code class="language-plaintext highlighter-rouge">java.io.File</code>, чтобы
отследить, какой именно файл не был найден. Большинство исключений принимают
строку с сообщением об ошибке. Сообщение формируют так, чтобы его было удобно
читать человеку. Например, “File С:/windows/system32/cmd.exe not found”.</p>

<p>Иногда возможностей текста не хватает, чтобы объяснить причину
ошибки. Предположим, данные не проходят валидацию, и нам хотелось бы исследовать
их позже. Если записать их в сообщение, текст может получиться слишком большим.</p>

<p>Такой подход к тому же небезопасен. В данных могут быть личные данные или ключи
доступа. Сообщение с такими данными нельзя писать в лог или показывать
пользователю. Даже путь к файлу способен выдать злоумышленнику полезную
информацию.</p>

<p>Принято отделять сообщение от данных. Если нужно передать информацию для
расследования, обычно создают особый класс исключения. У такого класса отдельные
поля, чтобы хранить данные, из-за которых произошла ошибка. Поля заполняют в
конструкторе исключения. Сообщение формируют так, чтобы оно не выдало деликатную
информацию.</p>

<h2 id="цепочки-исключений-и-контекст">Цепочки исключений и контекст</h2>

<p>Исключения умеют строиться в цепочку. Каждый новый экземпляр исключения
принимает необязательный параметр <code class="language-plaintext highlighter-rouge">cause</code> (причина). Он может быть либо <code class="language-plaintext highlighter-rouge">Null</code>,
либо другим экземпляром.</p>

<p>Цепочки образуются, когда участок кода перехватил исключение, но не знает, что с
ним делать. Это нормально, потому что разные уровни кода отвечают за разные
задачи. Например, метод нижнего, исполнительного уровня только исполняет логику.
Если случилась ошибка, он формирует исключение, передает в него максимально
полный контекст и отправляет вверх.</p>

<p>Метод, который вызвал его, перехватывает исключение. Но и он не знает, что с ним
делать. Все, что может метод — доложить об ошибке наверх. Он формирует новое
исключение, сообщает контекст и причину — пойманное исключение.</p>

<p>Так продолжается до тех пор, пока управление не перейдет к методу, который
знает, что делать. Его логика зависит от типа исключения и
бизнес-правил. Например, если файла нет на диске, программа попытается его
создать или поищет в других директориях. Если не удалось извлечь данные,
необходимые для дальнейшей работы, вывести понятное сообщение и завершить
программу.</p>

<p>Хорошо, если в системе предусмотрен последний рубеж защиты, где отлавливают все
исключения. Если ошибка дошла до этого уровня, это значит, ее не сумели поймать
обработчики рангом ниже. Это говорит о нештатном поведении системы. Пользователю
выводят нейтральный текст о том, что его запрос не прошел. Чтобы расследовать
причину, исключение пишут в лог и передают сборщику ошибок.</p>

<p>Современный код пишут так, что его верхний уровень это бизнес-логика. Это
действия, которые диктует руководство фирмы. При спуске вниз начинается плавный
переход в техническую часть. Каждый высокоуровневый шаг сводится к сетевым
вызовам или чтению файлов.</p>

<p>Представим, что функция <code class="language-plaintext highlighter-rouge">get-user</code> извлекает пользователя по его номеру. Снаружи
это черный ящик, и мы ничего не знаем о том, каким способом приходят
данные. Бывает, что сперва это база данных, но затем пользователей выносят в
отдельный сервис и шлют сетевой запрос. Выразим это на псевдокоде:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func get-user(id):
  let url = "http://api.company.com/user/" + str(id)
  return http.GET(url).body.json()
</code></pre></div></div>

<p>Если вызвать функцию с номером, которого не существует в системе, мы получим
исключение <code class="language-plaintext highlighter-rouge">HTTP Error: status 404</code>. Сообщение ничего не говорит о
пользователе. Если встретить такую запись в журнале, то мы даже не поймем, к
какому сервису обращались.</p>

<p>Чем ниже мы углубляемся в технические детали, тем меньше знаем о
бизнес-сущностях. В мире HTTP-клиента нет понятия пользователя. Ему доступны
лишь метод, адрес и другие поля. Но чтобы расследовать инцидент, важно знать,
что именно мы пытались сделать с точки зрения бизнеса.</p>

<p>Логично разделить ошибку на две части. Ее верхняя часть называет бизнес-причину:
не удалось получить пользователя с номером 42. Почему? Из-за технического сбоя:
запрос HTTP GET к адресу http://api.company.com/user/42 вернул ответ с кодом
404.</p>

<p>Расставим в коде дополнительные <code class="language-plaintext highlighter-rouge">try/catch</code>. Каждый раз, когда поймано
исключение их технических недр, мы дополняем его контекстом и отправляем
наверх. Этот паттерн называется <code class="language-plaintext highlighter-rouge">re-throw</code>, повторный выброс.</p>

<p>Улучшенная версия псевдокода:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func get-user(id):
  try {
    let url = "http://api.company.com/user/" + str(id)
    return http.GET(url).body.json()
  } catch error {
    throw Error("Cannot fetch a user #" + str(id), error)
  }
</code></pre></div></div>

<p>Новое исключение описывает бизнес-проблему, но при этом ссылается на
техническую. Так образуются цепочки исключений. В реальных проектах они
достигают длины в пять, десять и более звеньев.</p>

<p>Логично предположить, что проблема с HTTP-запросом тоже имеет причину, например,
проблему с установкой TLS-соединения. Это путь ниже в техническую часть. И
наоборот, доступ к пользователю может быть одним из шагов, чтобы построить
сложный отчет. В таком случае на верхнем уровне проблема с построением отчета, а
ее причина – отказ при запросе пользователя.</p>

<p>Спуск по цепочке исключений напоминает допрос. На каждое почему мы получаем
новую пищу для размышлений, пока не доберемся до сути. Но это не значит, что
самое нижнее исключение важнее других. Как мы уже выяснили, одно лишь <code class="language-plaintext highlighter-rouge">HTTP
Error</code> не описывает ситуацию. Важно то, как мы к нему пришли.</p>

<p>По такому принципу устроены исключения в промышленных языках, например Java или
Python. Каждая платформа добавляет небольшие изменения, но в целом картина
остается прежней. Ниже мы рассмотрим, что предлагает Clojure.</p>

<h2 id="переходим-к-clojure">Переходим к Clojure</h2>

<p>Лучший способ познакомиться с исключением это спровоцировать его. Подойдет
старый, как мир, прием — поделить число на ноль. Откройте новый сеанс REPL и
выполните выражение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Ниже появятся строки примерно такого содержания:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Execution error (ArithmeticException) at user/eval5848...
Divide by zero
</code></pre></div></div>

<p>Это рапорт об ошибке. В зависимости от редактора и настроек его вид может
отличаться. Например, редактор Emacs с модуле Cider откроет дополнительный буфер
<code class="language-plaintext highlighter-rouge">*cider-error*</code> с детальной информацией.</p>

<p>Заметим, что в интерактивном сеансе исключение не останавливает его работу. Мы
по-прежнему можем выполнить любое выражение. В боевом режиме Clojure-программы
ведут себя как обычно. Если в главном треде не поймано исключение, программа
останавливается.</p>

<p>Чтобы отловить исключение, выражение помещают в форму <code class="language-plaintext highlighter-rouge">try</code>. За выражением
следует одна и более форм <code class="language-plaintext highlighter-rouge">catch</code>. В них указывают, какие исключения
перехватывать и что делать с экземпляром.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Weird arithmetics"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Форма <code class="language-plaintext highlighter-rouge">catch</code> принимает класс исключения и символ, с которым становится связан
пойманный экземпляр. В нашем случае это <code class="language-plaintext highlighter-rouge">ArithmeticException</code> и символ
<code class="language-plaintext highlighter-rouge">e</code>. Далее следует произвольный код. Выражения этого кода обращаются к
исключению как к локальной переменной <code class="language-plaintext highlighter-rouge">e</code>.</p>

<p>В примере выше мы просто вывели на экран текст о том, что вычисления прошли
неудачно. Но могли бы извлечь сообщение. Метод <code class="language-plaintext highlighter-rouge">.getMessage</code> класса <code class="language-plaintext highlighter-rouge">Throwable</code>
возвращает текст исключения. Начиная с версии 1.10 Clojure предлагает функцию
<code class="language-plaintext highlighter-rouge">ex-message</code>, которая делает то же самое:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))))</span><span class="w">

</span><span class="c1">;; Divide by zero</span><span class="w">
</span></code></pre></div></div>

<p>Класс <code class="language-plaintext highlighter-rouge">ArithmeticException</code> ловит не все ошибки, связанные с вычислениями. Что
случится, если сложить 1 и <code class="language-plaintext highlighter-rouge">nil</code>? Даже если поместить расчеты в try/catch, это
не спасет от ошибки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Weird arithmetics"</span><span class="p">)))</span><span class="w">

</span><span class="c1">;; Execution error (NullPointerException) at user/eval6159</span><span class="w">
</span></code></pre></div></div>

<p>Дело в том, что классы <code class="language-plaintext highlighter-rouge">ArithmeticException</code> и <code class="language-plaintext highlighter-rouge">NullPointerException</code> не
пересекаются с друг с другом. У них разные пути в дереве исключений, которое мы
обсуждали в начале главы. Поэтому перехват одного не влияет на другой. Это
правильно, потому что семантика классов разная. Ошибка в арифметике это не то же
самое, что <code class="language-plaintext highlighter-rouge">Null</code> вместо значения.</p>

<p>Форма <code class="language-plaintext highlighter-rouge">try</code> принимает несколько форм <code class="language-plaintext highlighter-rouge">catch</code>. Вот как перехватить оба случая:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Weird arithmetics"</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">NullPointerException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"You've got a null value"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Макрос перебирает классы из каждого <code class="language-plaintext highlighter-rouge">catch</code>. Он остановится на первом подходящем
варианте. Результатом <code class="language-plaintext highlighter-rouge">try</code> станет последнее выражения из блока <code class="language-plaintext highlighter-rouge">catch</code>, который
подошел. В примере выше результат будет <code class="language-plaintext highlighter-rouge">nil</code>, потому что это значение вернет
функция <code class="language-plaintext highlighter-rouge">println</code>. Если ни один вариант не поймал исключение, оно продолжит путь
вверх по стеку вызовов.</p>

<p>Ранее мы упоминали, что чем выше класс исключения в дереве, тем больше ситуаций
он поймает. Если заменить <code class="language-plaintext highlighter-rouge">ArithmeticException</code> на <code class="language-plaintext highlighter-rouge">Throwable</code>, такой <code class="language-plaintext highlighter-rouge">catch</code>
перехватит любое исключение, будь то деление на ноль или <code class="language-plaintext highlighter-rouge">Null</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"I catch everything"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>В отличие от Java, в мире Clojure нет строгих правил о том, какие исключения
перехватывать. Этот вопрос остается на усмотрение разработчика. Здравый смысл
подсказывает, что перехват <code class="language-plaintext highlighter-rouge">Throwable</code> опасен. Создается ложное ощущение, что
код работает без ошибок.</p>

<p>В случае в <code class="language-plaintext highlighter-rouge">ArithmeticException</code> проблема очевидно в расчетах, но для
<code class="language-plaintext highlighter-rouge">NullPointerException</code> это не так. <code class="language-plaintext highlighter-rouge">Nil</code> вместо числа говорит о том, что
проблема не в арифметике, а в функции, которая вернула <code class="language-plaintext highlighter-rouge">nil</code>. Иными словами,
ошибка кроется в другом месте. Вот почему перехват <code class="language-plaintext highlighter-rouge">NullPointerException</code> вредит
разработке.</p>

<p>Форму <code class="language-plaintext highlighter-rouge">try/catch</code> с широким классом ставят на верхних уровнях кода. Например,
когда важно, чтобы программа не прекращала работу никогда. Такой подход
используют в HTTP-серверах, при обработке сообщений из очередей, в сетевом ПО.</p>

<p>Иногда мы намеренно бросаем исключения, чтобы сообщить о нештатной
ситуации. Форма <code class="language-plaintext highlighter-rouge">throw</code> принимает объект исключения и запускает стандартный
механизм выброса. Оператор <code class="language-plaintext highlighter-rouge">new</code> создает новый Java-объект. Ему передают класс и
параметры конструктора:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="s">"something is wrong"</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Сообщение такого рода не информативно. Даже если мы указали, что проблема в
арифметике или базе данных, хотелось бы знать, какие именно значения были на
момент ошибки. Поэтому сообщение строят функцией format. Она принимает шаблон и
параметры подстановки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">message</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Value error, a: %s, b: %s"</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">message</span><span class="p">))))</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Если вызвать функцию выше с одним и параметров <code class="language-plaintext highlighter-rouge">nil</code>, текст сообщения будет
информативнее:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Execution</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">book.exceptions/add</span><span class="w"> </span><span class="p">(</span><span class="nf">exceptions.clj</span><span class="no">:86</span><span class="p">)</span><span class="nb">.</span><span class="w">
</span><span class="n">Value</span><span class="w"> </span><span class="n">error,</span><span class="w"> </span><span class="n">a</span><span class="err">:</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="n">b</span><span class="err">:</span><span class="w"> </span><span class="n">null</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">format</code> хороша тем, что отображает <code class="language-plaintext highlighter-rouge">nil</code> как null. Это значимое
преимущество перед <code class="language-plaintext highlighter-rouge">str</code>, которая трактует nil как пустую строку. Вариант с
<code class="language-plaintext highlighter-rouge">str</code> выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Value error, a:"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">", b: "</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">;; Value error, a:1, b:</span><span class="w">
</span></code></pre></div></div>

<p>Результат вводит в заблуждение. Это мы потеряли значение <code class="language-plaintext highlighter-rouge">b</code>? Или <code class="language-plaintext highlighter-rouge">b</code> пустая
строка? Непонятно.</p>

<h2 id="контекст-ошибки">Контекст ошибки</h2>

<p>Выше мы упоминали, что запись данных в текст — рискованное занятие. Сообщение
может оказаться слишком большим или выдать лишние сведения. Проблему решает
класс <code class="language-plaintext highlighter-rouge">ExceptionInfo</code>. Это особое исключение из поставки Clojure. Оно
спроектировано так, чтобы хранить произвольные данные. Вместе с ним Clojure
предлагает набор функций, чтобы упростить работу.</p>

<p>Ключевая функция <code class="language-plaintext highlighter-rouge">ex-info</code> создает экземпляр <code class="language-plaintext highlighter-rouge">ExceptionInfo</code>. Она принимает
сообщение и словарь данных. Это контекст, в котором возникло
исключение. Например, если не удалось выполнить HTTP-запрос, полезно указать в
словаре HTTP-метод и адрес запроса.</p>

<p><code class="language-plaintext highlighter-rouge">Ex-info</code> только создает исключение, но не бросает его. Поэтому вызов <code class="language-plaintext highlighter-rouge">ex-info</code>
сразу передают в <code class="language-plaintext highlighter-rouge">throw</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w">
        </span><span class="s">"Cannot get the data from remote server."</span><span class="w">
        </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="mi">42</span><span class="w">
         </span><span class="no">:http-method</span><span class="w"> </span><span class="s">"POST"</span><span class="w">
         </span><span class="no">:http-url</span><span class="w"> </span><span class="s">"http://some.host/api"</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>В примере выше мы разделили сообщение и данные. Сообщение не выдает номер
пользователя и адрес подсистемы. Текст запишут в лог или отправят пользователю,
а контекст обработают отдельно.</p>

<p>При работе с контекстом помните несколько правил. Словарь не может быть
<code class="language-plaintext highlighter-rouge">nil</code>. Конструктор <code class="language-plaintext highlighter-rouge">ExceptionInfo</code> проверяет значение на <code class="language-plaintext highlighter-rouge">Null</code> и бросает ошибку
входных параметров. Нежелательно хранить в словаре значения, которые не
сериализируются. Например, поток или сетевое подключение. В идеале контекст
можно записать в JSON-документ. Позже мы рассмотрим, что делать с данными
контекста.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">ex-data</code> возвращает данные из пойманного исключения. Если это было
<code class="language-plaintext highlighter-rouge">ExceptionInfo</code>, мы получим словарь. Если исключение другого типа, то <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>Вообразим, что в модуле объявлена функция <code class="language-plaintext highlighter-rouge">authorize-user</code>. При неудачных
обстоятельствах она выкидывает исключение как в последнем примере. Код из формы
<code class="language-plaintext highlighter-rouge">catch</code> получает его контекст и разбивает на отдельные ключи. Затем формирует
строку.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nf">authorize-user</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-data</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
          </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">http-method</span><span class="w"> </span><span class="n">http-url</span><span class="p">]}</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"HTTP error: %s %s"</span><span class="w"> </span><span class="n">http-method</span><span class="w"> </span><span class="n">http-url</span><span class="p">))))</span><span class="w">

</span><span class="c1">;; HTTP error: POST http://some.host/api</span><span class="w">
</span></code></pre></div></div>

<h2 id="когда-бросать-исключения">Когда бросать исключения</h2>

<p>На этом этапе читатель наверняка сомневается, в каких случаях кидать исключения,
а когда ограничиться проверкой. Действительно, эту тему обходят стороной
большинство материалов по Clojure. Рассмотрим типовые ситуации и оптимальные
решения.</p>

<p><strong>При обработке коллекций</strong> вам не нужно бросать исключения. Как правило, в этом
не возникает потребности. Коллекции Clojure спроектированы так, что проблемы
<code class="language-plaintext highlighter-rouge">nil</code> пройдут мимо вас незамеченными. Например, значение <code class="language-plaintext highlighter-rouge">nil</code> трактуется как
пустая коллекция, поэтому выражения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:test</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:test</span><span class="w"> </span><span class="p">(</span><span class="nf">fnil</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nb">merge</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span><span class="no">:test</span><span class="w"> </span><span class="mi">42</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>вернут коллекции. Любой ключ от <code class="language-plaintext highlighter-rouge">nil</code> вернет <code class="language-plaintext highlighter-rouge">nil</code>, ровно как и разбор словаря
или вектора на отдельные переменные сообщает им <code class="language-plaintext highlighter-rouge">nil</code>, если подстановка не
сработала:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">]}</span><span class="w"> </span><span class="n">nil</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="n">nil</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Оба случая вернут вектор из трех <code class="language-plaintext highlighter-rouge">nil</code>, исключения не произойдет.</p>

<p>Термин “nil punning” означает лояльность к <code class="language-plaintext highlighter-rouge">nil</code>. С таким подходом ситуацию с
пустым значением разрешают без ошибок. Нельзя утверждать, что Clojure целиком
nil punning. Пустое значение не влияет на коллекции, но не работает с
арифметикой, регулярными выражениями и в других случаях.</p>

<p>Если вы сомневаетесь в коллекции перед ее обработкой, используйте
спеку. Вспомните <code class="language-plaintext highlighter-rouge">s/valid?</code> и <code class="language-plaintext highlighter-rouge">s/conform</code> из <a href="/clj-book-spec">прошлой главы</a>. Тем
самым вы отделите стадию проверки от обработки. Если валидация не прошла,
бросайте исключение. Передайте в контекст данные <code class="language-plaintext highlighter-rouge">s/explain-data</code>, чтобы
разобрать их позже.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.spec.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::data</span><span class="w"> </span><span class="p">(</span><span class="nf">s/coll-of</span><span class="w"> </span><span class="n">int?</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">explain</span><span class="w"> </span><span class="p">(</span><span class="nf">s/explain-data</span><span class="w"> </span><span class="no">::data</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])]</span><span class="w">
  </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"Validation failed"</span><span class="w"> </span><span class="p">{</span><span class="no">:explain</span><span class="w"> </span><span class="n">explain</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Другой случай, когда прибегают к исключениями — это <strong>отказ ресурса</strong>. Если не
удалось считать файл, недостаточно просто сказать об этом. Возможны десятки
причин: файла нет, он занят другим процессом, кончилось место на диске, ошибка в
кодировке. От причины зависит, кто будет ее исправлять и как доработать
окружение, чтобы не допустить ошибку снова.</p>

<p>Бывает, функция доступа к ресурсу не бросает исключение. Это справедливо для
различных HTTP API. Согласно протоколу HTTP, ответ со статусом 404 такой же
верный, как и 200. В индустрии нет единого мнения о том, стоит ли бросать
исключение на негативные HTTP-ответы. Как правило, библиотеки предлагают флаг,
который регулирует это поведение.</p>

<p>Посылая HTTP-запрос, мы передаем флаг с семантикой “не бросать исключение”. Тем
самым мы гарантируем, что исключение возникнет только в аварийных случаях вроде
проблем соединения. Но сетевое взаимодействие пройдет без ошибок. Затем
анализируем ответ. Если код не был положительным, бросаем исключение. В его
контекст передаем основные части запроса и ответа: метод, адрес, статус.</p>

<p>В примере ниже функция, которая извлекает данные о пользователе из сервиса
авторизации. Это слегка измененный код из реального проекта. Обмен с сервисом
происходит по протоколу HTTP. В качестве клиента используем библиотеку
<code class="language-plaintext highlighter-rouge">clj-http</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">auth-user</span><span class="w">
  </span><span class="p">[</span><span class="n">user-id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">url</span><span class="w"> </span><span class="s">"http://auth.company.com"</span><span class="w">
        </span><span class="n">params</span><span class="w"> </span><span class="p">{</span><span class="no">:form-params</span><span class="w"> </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="n">user-id</span><span class="p">}</span><span class="w">
                </span><span class="no">:throw-exceptions?</span><span class="w"> </span><span class="n">false</span><span class="w">
                </span><span class="no">:coerce</span><span class="w"> </span><span class="no">:always</span><span class="w">
                </span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="w">
                </span><span class="no">:content-type</span><span class="w"> </span><span class="no">:json</span><span class="p">}</span><span class="w">
        </span><span class="n">response</span><span class="w"> </span><span class="p">(</span><span class="nf">client/post</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">status</span><span class="w"> </span><span class="n">body</span><span class="p">]}</span><span class="w"> </span><span class="n">response</span><span class="p">]</span><span class="w">

    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w">
      </span><span class="n">body</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"Authentication error"</span><span class="w">
                      </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="n">user-id</span><span class="w">
                       </span><span class="no">:url</span><span class="w"> </span><span class="n">url</span><span class="w">
                       </span><span class="no">:http-status</span><span class="w"> </span><span class="n">status</span><span class="w">
                       </span><span class="no">:http-body</span><span class="w"> </span><span class="n">body</span><span class="p">})))))</span><span class="w">
</span></code></pre></div></div>

<p>Еще один случай, когда пригодятся исключения — <strong>библиотеки</strong>. Весь код условно
делится на два типа: исполнение и координация. Библиотеки относятся с
исполнительному коду. На уровне библиотеки мы не знаем, в разрезе какой логики
будет запущен код. В одной ситуации ошибка критична, в другой нет.</p>

<p>Если бросить исключение на уровне исполнения, бизнес-логика вправе перехватить
его и продолжить работу. Но если исполнитель молча подавляет ошибки, это чревато
неожиданным поведением. Сюда же относится паттерн “вернуть nil и записать в
лог”. Это банальное игнорирование проблемы.</p>

<h2 id="подробнее-о-цепочках">Подробнее о цепочках</h2>

<p>Выше мы говорили про цепочки исключений. Рассмотрим, как формировать их на
практике. Функция <code class="language-plaintext highlighter-rouge">ex-info</code> принимает третий необязательный параметр
<code class="language-plaintext highlighter-rouge">cause</code>. Это либо <code class="language-plaintext highlighter-rouge">nil</code>, либо другое исключение. Оно становится частью нового
экземпляра. В примере ниже функция divide перехватывает ошибку деления. Затем
оборачивает ее в другое исключение с контекстом.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w">
              </span><span class="s">"Calculation error"</span><span class="w">
              </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="n">b</span><span class="p">}</span><span class="w">
              </span><span class="n">e</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">ex-cause</code> возвращает исключение-причину, если оно было передано в
<code class="language-plaintext highlighter-rouge">ex-info</code>. Если причины нет, результат будет nil.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nf">divide</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">ex-message</span><span class="w"> </span><span class="nb">println</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">ex-cause</span><span class="w"> </span><span class="n">ex-message</span><span class="w"> </span><span class="nb">println</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Этот код выведет строки:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Calculation error
Divide by zero
</code></pre></div></div>

<p>Пример выше неаккуратен. Мы не можем быть уверены, что у исключения строго одна
причина. Их может быть много или ни одной. Напишем функцию, которая вернет
последовательность исключений. Расположим их по убыванию старшинства. На первом
месте самое главное, на втором его причина, затем причина причины и так
далее. Проще всего сделать это формой <code class="language-plaintext highlighter-rouge">loop</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">ex-chain</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="n">e</span><span class="w">
         </span><span class="n">result</span><span class="w"> </span><span class="p">[]]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
      </span><span class="n">result</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-cause</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">e</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Для экспериментов объявим переменную <code class="language-plaintext highlighter-rouge">e</code>. Она понадобится здесь и ниже по тексту
главы, чтобы проверять код. Это будет цепочка из трех звеньев. На ее первом
уровне ошибка бизнес-логики: не удалось извлечь данные о пользователе. На втором
уровне техническая проблема, что-то не так с авторизацией. На третьем ошибка
транспорта: не прошел HTTP-запрос.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">e</span><span class="w">
  </span><span class="p">(</span><span class="nf">ex-info</span><span class="w">
   </span><span class="s">"Get user info error"</span><span class="w">
   </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">42</span><span class="p">}</span><span class="w">
   </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"Auth error"</span><span class="w">
            </span><span class="p">{</span><span class="no">:api-key</span><span class="w"> </span><span class="s">"........."</span><span class="p">}</span><span class="w">
            </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"HTTP error"</span><span class="w">
                     </span><span class="p">{</span><span class="no">:method</span><span class="w"> </span><span class="s">"POST"</span><span class="w">
                      </span><span class="no">:url</span><span class="w"> </span><span class="s">"http://api.site.com"</span><span class="p">}))))</span><span class="w">
</span></code></pre></div></div>

<p>Это дерево искючений, но не всегда удобно работать с деревом. Плоская структура
лучше поддается обходу. Здесь и пригодится <code class="language-plaintext highlighter-rouge">ex-chain</code>. Вот как получить
сообщения всех звеньев в том же порядке:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">ex-message</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-chain</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="s">"Get user info error"</span><span class="w"> </span><span class="s">"Auth error"</span><span class="w"> </span><span class="s">"HTTP error"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>А вот как вывести их на экран:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-chain</span><span class="w"> </span><span class="n">e</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">ex-message</span><span class="w"> </span><span class="nb">println</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Get user info error</span><span class="w">
</span><span class="c1">;; Auth error</span><span class="w">
</span><span class="c1">;; HTTP error</span><span class="w">
</span></code></pre></div></div>

<p>Выразим <code class="language-plaintext highlighter-rouge">ex-chain</code> короче и изящней через <code class="language-plaintext highlighter-rouge">iterate</code>. Это функция, которая шаг за
шагом применяет другую функцию к аргументу. Ограничение <code class="language-plaintext highlighter-rouge">take-while some?</code> нужно
для того, чтобы остановиться на первом же <code class="language-plaintext highlighter-rouge">nil</code>-элементе.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">ex-chain</span><span class="w">
  </span><span class="p">[</span><span class="o">^</span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">take-while</span><span class="w"> </span><span class="n">some?</span><span class="w"> </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="n">ex-cause</span><span class="w"> </span><span class="n">e</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h2 id="печать-исключения">Печать исключения</h2>

<p>Разберемся, что делать с пойманным исключением. В приложении что-то пошло не
так, и форма <code class="language-plaintext highlighter-rouge">try/catch</code> на вершине стека вернула экземпляр ошибки. Как с ним
посупить?</p>

<p>Самое простое, что можно сделать с исключением — вывести в консоль. Функция
<code class="language-plaintext highlighter-rouge">println</code> достаточно умна. Она выводит не только верхний уровень, но и всю
цепочку исключений. Для каждого уровня функция печатает путь к классу, словарь
данных и текст.</p>

<p>Самое нижнее исключение в цепочке иногда наывают корнем, root. Для нашего
удобства <code class="language-plaintext highlighter-rouge">println</code> дублирует корень в начале вывода. Так мы сразу увидим
первопричину ошибки. Вот что напечатает выражение <code class="language-plaintext highlighter-rouge">(println e)</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="n">error</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="no">:cause</span><span class="w"> </span><span class="n">HTTP</span><span class="w"> </span><span class="n">error</span><span class="w">
 </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:method</span><span class="w"> </span><span class="n">POST,</span><span class="w"> </span><span class="no">:url</span><span class="w"> </span><span class="n">http</span><span class="no">://api.site.com</span><span class="p">}</span><span class="w">
 </span><span class="no">:via</span><span class="w">
 </span><span class="p">[{</span><span class="no">:type</span><span class="w"> </span><span class="n">clojure.lang.ExceptionInfo</span><span class="w">
   </span><span class="no">:message</span><span class="w"> </span><span class="n">Get</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="n">error</span><span class="w">
   </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">42</span><span class="p">}</span><span class="w">
   </span><span class="no">:at</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.lang.AFn</span><span class="w"> </span><span class="n">applyToHelper</span><span class="w"> </span><span class="n">AFn.java</span><span class="w"> </span><span class="mi">160</span><span class="p">]}</span><span class="w">
  </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="n">clojure.lang.ExceptionInfo</span><span class="w">
   </span><span class="no">:message</span><span class="w"> </span><span class="n">Auth</span><span class="w"> </span><span class="n">error</span><span class="w">
   </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:api-key</span><span class="w"> </span><span class="n">.........</span><span class="p">}</span><span class="w">
   </span><span class="no">:at</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.lang.AFn</span><span class="w"> </span><span class="n">applyToHelper</span><span class="w"> </span><span class="n">AFn.java</span><span class="w"> </span><span class="mi">160</span><span class="p">]}</span><span class="w">
  </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="n">clojure.lang.ExceptionInfo</span><span class="w">
   </span><span class="no">:message</span><span class="w"> </span><span class="n">HTTP</span><span class="w"> </span><span class="n">error</span><span class="w">
   </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:method</span><span class="w"> </span><span class="n">POST,</span><span class="w"> </span><span class="no">:url</span><span class="w"> </span><span class="n">http</span><span class="no">://api.site.com</span><span class="p">}</span><span class="w">
   </span><span class="no">:at</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.lang.AFn</span><span class="w"> </span><span class="n">applyToHelper</span><span class="w"> </span><span class="n">AFn.java</span><span class="w"> </span><span class="mi">156</span><span class="p">]}]</span><span class="w">
 </span><span class="no">:trace</span><span class="w">
 </span><span class="p">[[</span><span class="n">clojure.lang.AFn</span><span class="w"> </span><span class="n">applyToHelper</span><span class="w"> </span><span class="n">AFn.java</span><span class="w"> </span><span class="mi">156</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">clojure.lang.AFn</span><span class="w"> </span><span class="n">applyTo</span><span class="w"> </span><span class="n">AFn.java</span><span class="w"> </span><span class="mi">144</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">clojure.lang.Compiler$InvokeExpr</span><span class="w"> </span><span class="nb">eval</span><span class="w"> </span><span class="n">Compiler.java</span><span class="w"> </span><span class="mi">3701</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">clojure.lang.Compiler$DefExpr</span><span class="w"> </span><span class="nb">eval</span><span class="w"> </span><span class="n">Compiler.java</span><span class="w"> </span><span class="mi">457</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">clojure.lang.Compiler</span><span class="w"> </span><span class="nb">eval</span><span class="w"> </span><span class="n">Compiler.java</span><span class="w"> </span><span class="mi">7181</span><span class="p">]</span><span class="w">
  </span><span class="n">..........</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Многоточия на конце скрывают часть стек-трейса. Это Java-методы, через которые
прошло исключение с момента выброса до перехвата. Каждый элемент трейса это
вектор с именем класса, метода, файла и номера строки.</p>

<p>Выше мы сократили трейс, чтобы не тратить на него полезное пространство. В
реальности трейсы очень длинные и порой достигают нескольких экранов. Это
справедливый упрек в адрес Clojure. Действительно, трейсы несут скудную
информацию и зашумляют вывод.</p>

<p>Цепочки исключений с контекстом несут больше пользы, чем стек-трейс. Фактически,
цепочка — это альтернативный трейс, построенный на данных. Различие в том, что
он компактней и в целом больше ориентирован на человека, чем машинный список
методов.</p>

<p>Пакет <code class="language-plaintext highlighter-rouge">clojure.stacktrace</code> предлагает несколько функций для печати
исключений. Так, <code class="language-plaintext highlighter-rouge">print-throwable</code> печатает класса и данные исключения без
трейса и цепочки причин.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">clojure.stacktrace/print-throwable</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Результат:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clojure.lang.ExceptionInfo: Get user info error
{:user-id 42}
</code></pre></div></div>

<p>Вывод на печать легко захватить в строку макросом <code class="language-plaintext highlighter-rouge">with-out-str</code>. Форма ниже
ничего не напечатает, но вернет строку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">with-out-str</span><span class="w">
  </span><span class="p">(</span><span class="nf">clojure.stacktrace/print-stack-trace</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Отдельные функции <code class="language-plaintext highlighter-rouge">print-stack-trace</code> и <code class="language-plaintext highlighter-rouge">print-cause-trace</code> печатают трейсы
исключений. Вывод каждой из них можно ограничить параметром <code class="language-plaintext highlighter-rouge">n</code>, максимальной
глубиной трейса.</p>

<h2 id="логирование">Логирование</h2>

<p>Печать исключений считается слабой практикой. Это частный случай, когда мы хотим
зафиксировать ошибку для дальнейшего разбора. Печать в стандартный поток не
подходит для этого по многим причинам.</p>

<p>Для любого сообщения важны его <strong>вспомогательные данные</strong>: время, модуль, номер
процесса. Сообщения различают по уровню критичности: информационное,
предупреждение, ошибка. Оператор печати не сообщает эти сведения, а их ручной
сбор увеличит код.</p>

<p>Если программа работает на многих серверах, сбор сообщений должен быть
<strong>централизованным</strong>. Представьте, что администратор переключается между сотней
машин, чтобы читать логи. Передача сообщений по сети подсказывает, что для
каждого сообщения нужно знать адрес машины, с которой оно было отправлено.</p>

<p>Не все сообщения одинаково полезны. Некоторые библиотеки порождают сотни
отладочных сообщений в минуту. К ним прибегают только в редких случаях,
например, при потере данных. Нужен механизм, чтобы <strong>подавлять лишние
сообщения</strong> по некоторым признакам.</p>

<p>Наконец, консоль или файл — далеко <strong>не единственные каналы данных</strong>. Особо
важные сообщения пишут в журнал операционной системы, отправляют на почту, в
чаты с помощью ботов или даже в смс ответственным лицам.</p>

<p>Названные выше проблемы разрешает логирование. Это центральная система, которая
фиксирует сообщения от разных частей программы.</p>

<p>Библиотека <code class="language-plaintext highlighter-rouge">clojure.tools.logging</code> предлагает набор функций и макросов, чтобы
записывать сообщения. Это сторонняя библиотека, поэтому перед использованием
добавьте ее в зависимости:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">org.clojure/tools.logging</span><span class="w"> </span><span class="s">"0.4.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Импортируем библиотеку и запишем простое сообщение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.tools.logging</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">log</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"A message from my module"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>В REPL-сессии появится запись лога:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INFO: A message from my module
</code></pre></div></div>

<p>Видим, что лог дополняет сообщение уровнем критичности.</p>

<p>В Clojure логирование устроено из двух уровней. Верхний уровень — это макросы
<code class="language-plaintext highlighter-rouge">log/info</code>, <code class="language-plaintext highlighter-rouge">log/error</code> и другие. Второй уровень называют бекендом. Под ним
понимают Java-библиотеку, которая непосредственно пишет сообщения в файлы,
отправляет их по сети и выполняет всю работу.</p>

<p>Такое устройство на первый взгляд кажется необычным, но на практике несет
преимущества. Исторически сложилось так, что для Java написано много библиотек
логирования. Каждая из них предлагает свои классы и методы. Если проект явно
использует одну из библиотек, то переход на другую вынуждает править код.</p>

<p>В Clojure эту проблему решили на уровне дизайна библиотеки. Модуль <code class="language-plaintext highlighter-rouge">logging</code> в
момент старта ищет библиотеки <code class="language-plaintext highlighter-rouge">Logback</code>, <code class="language-plaintext highlighter-rouge">Log4j</code> и другие. Если ничего не
найдено, он использует стандартный <code class="language-plaintext highlighter-rouge">java.util.logging</code>.</p>

<p>Из этого правила следует, что достаточно добавить бекенд логирования в
зависимости, чтобы он начал работать. Большинство библиотек автоматически ищут
свои настройки в текущем пути. Например, если в папку <code class="language-plaintext highlighter-rouge">resources</code> подложить
специальный XML-файл для бекенда, он прочтет его в момент старта и применит
настройки.</p>

<p>Из бекендов большой популярностью пользуется проект <code class="language-plaintext highlighter-rouge">Logback</code>. От аналогов его
отличает большой выбор т.н. аппендеров (appenders). Так называют пункт
назначения, куда писать сообщения. Это может быть файл с автоматической
ротацией, удаленный <code class="language-plaintext highlighter-rouge">syslog</code>, почтовый сервер и много что еще. Чтобы добавить
Logback в проект, добавьте в зависимости запись:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ch.qos.logback/logback-classic</span><span class="w"> </span><span class="s">"1.2.3"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>В папку resources положите файл logback.xml следующего содержания:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;configuration&gt;</span>
  <span class="nt">&lt;appender</span> <span class="na">name=</span><span class="s">"STDOUT"</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.ConsoleAppender"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;encoder&gt;</span>
      <span class="nt">&lt;charset&gt;</span>UTF-8<span class="nt">&lt;/charset&gt;</span>
      <span class="nt">&lt;pattern&gt;</span>%date{ISO8601} %-5level %logger{36} - %msg %n<span class="nt">&lt;/pattern&gt;</span>
    <span class="nt">&lt;/encoder&gt;</span>
  <span class="nt">&lt;/appender&gt;</span>
  <span class="nt">&lt;root</span> <span class="na">level=</span><span class="s">"INFO"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;appender-ref</span> <span class="na">ref=</span><span class="s">"STDOUT"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/root&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div></div>

<p>Это укороченный пример конфигурации. В данном случае мы задали appender для
вывода в консоль. Под тегом <code class="language-plaintext highlighter-rouge">pattern</code> указан шаблон сообщения. Параметры шаблона
начинаются со знака процента. Подстановка <code class="language-plaintext highlighter-rouge">%msg</code> означает текст сообщения,
<code class="language-plaintext highlighter-rouge">%date</code> — дату и ее формат в фигурных скобках.</p>

<p>Теперь записанное сообщение выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"Hello Logback!"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2019-05-03 17:36:04,001 INFO  book.exceptions - Hello Logback!
</code></pre></div></div>

<p>Макросы <code class="language-plaintext highlighter-rouge">log/info</code>, <code class="language-plaintext highlighter-rouge">log/error</code> и другие допускают, что первым аргументом может
быть не текст, а пойманное исключение. В этом случае бекенд запишет исключение в
лог. Выше мы объявили переменную <code class="language-plaintext highlighter-rouge">e</code> для экспериментов. Воспользуемся ей:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">log/error</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"Error while processing the request"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Сокращенный результат:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2019-05-03 17:41:03,913 ERROR book.exceptions - Error while processing the request
clojure.lang.ExceptionInfo: Get user info error
	at java.lang.Thread.run(Thread.java:745)
Caused by: clojure.lang.ExceptionInfo: Auth error
	at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
	... 30 common frames omitted
Caused by: clojure.lang.ExceptionInfo: HTTP error
	at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
	... 31 common frames omitted
</code></pre></div></div>

<p>Для экономии места мы удалили строки трейса, так как они не несут пользы. Из
примера видно, что цепочка исключений состоит из трех звеньев. Это совпадает с
определением переменной <code class="language-plaintext highlighter-rouge">e</code>. Проблема в том, что у каждого звена пропали его
данные. Logback практикует Java-подход в работе с исключениями. В мире Java
принято искать ошибку по стек-трейсу, а не данным.</p>

<p>Logback предлагает несколько модификаций для вывода исключений. Они влияют на
длину и детализацию трейса, но игнорируют данные. Аналогично ведут себя Log4j и
другие библиотеки.</p>

<p>Общее решение проблемы в том, чтобы задать в конфигурации путь к специальному
классу. Как правило, библиотека содержит стандартный класс, который переводит
исключение в строку. Достаточно унаследовать его, переопределить нужный метод и
указать в конфигурации.</p>

<p>Это довольно сложный путь. Чтобы унаследовать класс в Clojure, нужны навыки
работы с Java выше среднего. Придется читать документацию к конкретной
библиотеке, исследовать ее классы и интерфейсы.</p>

<p>Такое решение завязано на конкретную библиотеку. Класс для Logback не будет
работать с Log4j и наоборот. В мире Clojure это называют “не Clojure-way”, то
есть не тот способ, которому принято следовать.</p>

<p>Напишем свою функцию для логирования ошибок. Пусть она принимает исключение и
переводит его в текст, как удобно нам. Затем пишет текст в лог с уровнем
<code class="language-plaintext highlighter-rouge">error</code>.</p>

<p>Чтобы вывести все данные об ошибке, потребуется обойти цепочку исключений. Выше
мы определили <code class="language-plaintext highlighter-rouge">ex-chain</code> для этой цели. Функция <code class="language-plaintext highlighter-rouge">ex-print</code> пробегается по
цепочке и печатает данные в консоль. Если нужна строка, вызов <code class="language-plaintext highlighter-rouge">ex-print</code>
оборачивают в <code class="language-plaintext highlighter-rouge">with-out-str</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">ex-print</span><span class="w">
  </span><span class="p">[</span><span class="o">^</span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">indent</span><span class="w"> </span><span class="s">"  "</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-chain</span><span class="w"> </span><span class="n">e</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="nb">class</span><span class="w"> </span><span class="n">.getCanonicalName</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="n">indent</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-data</span><span class="w"> </span><span class="n">e</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="n">indent</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="n">data</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Результат выглядит приятнее, чем пирамида из трейсов. Четко видны данные,
которые привели к ошибке:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clojure.lang.ExceptionInfo
  Get user info error
  {:user-id 42}
clojure.lang.ExceptionInfo
  Auth error
  {:api-key "........."}
clojure.lang.ExceptionInfo
  HTTP error
  {:method "POST", :url "http://api.site.com"}
</code></pre></div></div>

<p>Осталось собрать функцию для записи в лог. Вот она:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">log-error</span><span class="w">
  </span><span class="p">[</span><span class="o">^</span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="n">message</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/error</span><span class="w">
   </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w">
     </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="s">"Error"</span><span class="p">))</span><span class="w">
     </span><span class="p">(</span><span class="nf">ex-print</span><span class="w"> </span><span class="n">e</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Функцию можно вызвать с дополнительным сообщением или без. Если сообщения не
было, запишем нейтральное “Error”. Чтобы сообщение и тело исключения не
слипались, используем <code class="language-plaintext highlighter-rouge">println</code>. Эта функция добавляет перенос строки в конец.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">log-error</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">log-error</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"An error occurred during request"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Последнее выражение запишет в лог следующее:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2019-05-03 19:00:05,590 ERROR book.exceptions - An error occurred during request
clojure.lang.ExceptionInfo
  Get user info error
  ...
</code></pre></div></div>

<p>Сообщения об ошибках принято отделять от остальных записей. Для этого заводят
минимум два аппендера: консоль и файл. В консоль выводят все сообщения, чтобы
программист был в курсе дела. Ошибки требуют ответной реакции, поэтому их
записывают в файл. Позже этот файл анализируют вручную или специальными
программами.</p>

<h2 id="исключения-как-данные-сбор-исключений">Исключения как данные. Сбор исключений</h2>

<p>В прошлом разделе мы придумали как показать исключение в удобном виде. В широком
смысле речь шла о том, как выразить исключение текстом. Это важный рубеж. Как
только способ найден, вы сможете передать исключение в файле, письме и даже на
бумаге.</p>

<p>Недостаток текста в том, что он не структурирован. С точки зрения кода это
цепочка символов, и нет данных о том, что есть что. Наоборот, при сборе ошибок
важно выделить их ключевые данные, например, тип, подсистему, модуль. Это
необходимо по следующим причинам.</p>

<p><strong>Предотвратить дублирование.</strong> Во время наплыва пользователей может вскрыться
ошибка, которую не заметили ранее. Если каждый раз писать исключение в файл,
получим десятки тысяч одинаковых записей. Это не имеет смысла, расточительно в
плане ресурсов, затрудняет поиск. Вдруг среди них закралось еще одно исключение?</p>

<p>Системы сбора ошибок научились определять схожесть исключений по особым
правилам. С точки зрения текста сообщения “user 1 not found” и “user 2 not
found” отличаются. Но система сбора схлопнет их в одну ошибку и по запросу
покажет все варианты.</p>

<p><strong>Поиск.</strong> Невозможно устроить эффективный поиск по данным без структуры. Когда
ошибки в виде текста, приходится искать только по вхождению слова или
регулярному выражению. Такой поиск нерелевантен, то есть не учитывает, насколько
точно сущность совпадает с запросом. Еще он не учитывает дубли. Мы бы не хотели
видеть тысячу одинаковых сообщений в выдаче.</p>

<p><strong>Статистика.</strong> Когда ошибки разобраны на составные части, можно строить
отчеты. Например, сколько ошибок случилось за последний месяц или
год. Группировать данные по системам или командам. Выявить проекты, где ошибки
случаются чаще всего.</p>

<p><strong>База знаний.</strong> В системе сбора каждая ошибка становится артефактом. К ней
пишут комментарии, прикрепляют скриншоты или записи с экрана. Хорошей практикой
будет ставить ссылку на артефакт в пулл-реквест. В широком плане польза в том,
что на ошибку всегда можно сослаться как на документ. Если ошибки хранятся в
текстовых файлах, это невозможно.</p>

<p>Среди прочих систем достойно выглядит Sentry. Это приложение на Python и
Django. Sentry работает как веб-сервер. На главной страницы видны проекты и
краткая статистика по ним. Каждый проект накапливает ошибки, которые он получил
от клиентов.</p>

<p>Чтобы отправить ошибку в Sentry, приложение обращается к нему HTTP API методом
POST. В теле передают JSON-документ с различными полями. Протокол Sentry
предлагает несколько десятков полей, чтобы описать ошибку. Сюда входят параметры
физической машины, операционной системы, контекст HTTP-запроса, стек-трейс и
другие.</p>

<p>Как правило, приложение не формирует эти данные вручную, а пользуется готовыми
библиотеками. Часто они называются Raven или похожим образом. Имеется в виду,
сторожевой ворон (анг. raven) несет вести дозорному (анг. sentry).</p>

<p>Для Clojure написаны две библиотеки к Sentry: <a href="https://github.com/getsentry/sentry-clj">getsentry/sentry-clj</a>
и <a href="https://github.com/exoscale/raven">exoscale/raven</a>. Первая опирается на официальную Java-библиотеку. Это
частая практика в мире Clojure — не писать код с нуля, а предоставить обвязку
вокруг проверенной Java-библиотеки.</p>

<p>Чтобы воспользоваться sentry-clj, добавьте зависимость в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">io.sentry/sentry-clj</span><span class="w"> </span><span class="s">"0.7.2"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>На первом шаге инициализируйте библиотеку с нужным DSN. Под DSN понимают
уникальный адрес проекта в Sentry. Проект объединяет сообщения по какому-то
глобальному признаку. Например, ошибки бекенда в одном проекте, фронтенда – во
втором, мобильного приложения – в третьем. Получить DSN проекта можно на
странице его дополнительной информации в разделе “интеграция”.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">sentry-clj.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">sentry</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">DSN</span><span class="w"> </span><span class="s">"https://.....@sentry.io/....."</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">sentry/init!</span><span class="w"> </span><span class="n">DSN</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Теперь когда проект задан, отправим сообщение. Функция <code class="language-plaintext highlighter-rouge">send-event</code> принимает
словарь параметров сообщения. Нас интересует сценарий, когда мы поймали
исключение и хотели бы отправить его без лишних усилий. Достаточно передать ключ
<code class="language-plaintext highlighter-rouge">:throwable</code> с экземпляром исключения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">sentry/send-event</span><span class="w"> </span><span class="p">{</span><span class="no">:throwable</span><span class="w"> </span><span class="n">e</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Sentry вернет номер сообщения, а в проекте появится новая запись Предположим, мы
передали эксземпляр <code class="language-plaintext highlighter-rouge">e</code>, который объявили выше. Это цепочка из трех
исключений. В веб-интерфейсе увидим информацию о каждом из них. В поле <code class="language-plaintext highlighter-rouge">:extra</code>
будут данные верхнего звена исключения, то есть словарь <code class="language-plaintext highlighter-rouge">{:user-id 42}</code>.</p>

<p>Недостаток <code class="language-plaintext highlighter-rouge">sentry-clj</code> в том, что он полагается на Java-библиотеку. Вспомним,
что в мире Java не популярны принципы, которые мы обсуждали в этой
главе. Например, хотелось бы иметь данные со всех уровней, а не только
верхнего. Иначе мы не узнаем, какой был API-ключ, по какому адресу мы обращались
в сеть и другие детали. Технически возможно собрать эти данные вручную и
передать в ключ <code class="language-plaintext highlighter-rouge">:extra</code>. Но будет привильней научить этому библиотеку.</p>

<p>Это и другие замечания исправлены в <code class="language-plaintext highlighter-rouge">exoscale/raven</code>. Библиотека написана на
Clojure и потому более гибка. С недавний версий она передает максимально полные
данные об исключении. Подключите ее в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">exoscale/raven</span><span class="w"> </span><span class="s">"0.4.8"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>и отправье исключение <code class="language-plaintext highlighter-rouge">e</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">raven.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">raven</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">raven/capture!</span><span class="w"> </span><span class="n">DSN</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Теперь откройте сообщение в Sentry и промотайте вниз. В секции <code class="language-plaintext highlighter-rouge">extra</code> будет
ключ <code class="language-plaintext highlighter-rouge">:via</code> с очень детальной информацией:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"type"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"clojure.lang.ExceptionInfo"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Get user info error"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"data"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"user-id"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">42</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"at"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">"clojure.lang.AFn"</span><span class="p">,</span><span class="w"> </span><span class="s2">"applyToHelper"</span><span class="p">,</span><span class="w"> </span><span class="s2">"AFn.java"</span><span class="p">,</span><span class="w"> </span><span class="mi">160</span><span class="w"> </span><span class="p">]</span><span class="w">
</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"type"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"clojure.lang.ExceptionInfo"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Auth error"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"data"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"api-key"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"........."</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"at"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">"clojure.lang.AFn"</span><span class="p">,</span><span class="w"> </span><span class="s2">"applyToHelper"</span><span class="p">,</span><span class="w"> </span><span class="s2">"AFn.java"</span><span class="p">,</span><span class="w"> </span><span class="mi">160</span><span class="w"> </span><span class="p">]</span><span class="w">
</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"type"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"clojure.lang.ExceptionInfo"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"HTTP error"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"data"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"method"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"POST"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"url"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"http://api.site.com"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"at"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">"clojure.lang.AFn"</span><span class="p">,</span><span class="w"> </span><span class="s2">"applyToHelper"</span><span class="p">,</span><span class="w"> </span><span class="s2">"AFn.java"</span><span class="p">,</span><span class="w"> </span><span class="mi">156</span><span class="w"> </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w"> </span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Это вектор словарей, где каждый словарь состоит из класса исключения, его
сообщения и данных. В поле <code class="language-plaintext highlighter-rouge">:at</code> вектор четырех элементов. Это класс, метод, имя
файла и строка, на которой возникло исключение. С таким отчетом расследовать
инцидент становится проще.</p>

<p>Структуру выше легко получить в любом месте Clojure. Нам доступна функция
<code class="language-plaintext highlighter-rouge">Throwable-&gt;map</code>. Она принимает исключение и возвращает словарь с ключами
<code class="language-plaintext highlighter-rouge">:via</code>, <code class="language-plaintext highlighter-rouge">:cause</code> и другими. В этом словаре вся информация об исключении, в
т.ч. цепочка исключений и трейс.</p>

<p>Зачем нужна функция, если ту же информацию можно извлечь самостоятельно?
Преимущество в том, что результат <code class="language-plaintext highlighter-rouge">Throwable-&gt;map</code> состоит из структур и типов
Clojure. Это комбинация словарей, векторов и символов. Такой словарь
обрабатывают как обычную Clojure-коллекцию. Его легко записать в форматы EDN или
JSON.</p>

<p>Ключ <code class="language-plaintext highlighter-rouge">:via</code> представляет особую ценность. Это те данные, что мы привели выше:
цепочка исключений с данными. Вот как извлечь их:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">Throwable-&gt;map</span><span class="w"> </span><span class="no">:via</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Теперь когда вы знакомы с логированием и Sentry, напишем защитный декоратор для
Ring-приложения. Напомним, мы разобрали декораторы <a href="/clj-book-web-1">в главе про
веб-разработку</a>. Такой декоратор ставят на вершину стека middleware. Он
перехватывает все потенциальные ошибки, отправляет в Sentry и возвращает
нейтральный ответ о том, что запрос не удался.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-exception</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="p">(</span><span class="nf">try</span><span class="w">
          </span><span class="p">(</span><span class="nf">raven/capture!</span><span class="w"> </span><span class="n">DSN</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e-sentry</span><span class="w">
            </span><span class="p">(</span><span class="nf">log/errorf</span><span class="w"> </span><span class="n">e-sentry</span><span class="w"> </span><span class="s">"Sentry error: %s"</span><span class="w"> </span><span class="n">DSN</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nf">log/error</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"HTTP Error"</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="nf">finally</span><span class="w">
            </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">500</span><span class="w">
             </span><span class="no">:body</span><span class="w"> </span><span class="s">"Internal error, please try later"</span><span class="p">}))))))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что запрос к Sentry тоже обернут в <code class="language-plaintext highlighter-rouge">try/catch</code>. Как мы
выяснили ранее, обращение в сеть потенциально несет ошибки. Sentry это отдельный
сервис и может быть недоступен. В противном случае мы пишем в файл оба
исключения: и оригинальное, и связанное с Sentry. Это лучше, чем просто
проигнорировать их.</p>

<h2 id="переходы">Переходы</h2>

<p>До сих пор мы рассматривали исключения как оповещения об ошибке. Вспомним
ключевое свойство исключения. Оно прерывает исполнение и всплывает вверх, пока
не будет поймано. Поэтому иногда исключения трактуют как моментальный прыжок
вверх по стеку.</p>

<p>Действительно, если бросить какое-то специфичное исключение, например
<code class="language-plaintext highlighter-rouge">MyGOTOException</code>, а вызов сверху обернуть в <code class="language-plaintext highlighter-rouge">catch</code> с этим классом, то перед
нами классический оператор <code class="language-plaintext highlighter-rouge">GOTO</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nf">do-first-step</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">do-second-step</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nf">condition</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">MyGOTOException</span><span class="p">)))</span><span class="w">
  </span><span class="p">(</span><span class="nf">do-third-step</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">MyGOTOException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Skipped the third one"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Если что-то пошло не так, мы прыгаем через третий шаг. Трюк называют “исключение
как способ управления исполнением”.</p>

<p>Это очень противоречивая практика, и прибегать к ней следует с
осторожностью. Исключения не были задуманы для подобных рывков. Тот, кто
злоупотребляет прыжками по коду, использует инструмент не по назначению. Код
становится неочевидным и трудным в поддержке.</p>

<p>Все же, порой бывают моменты, когда нужно прервать текущий запрос на
середине. Например, мы выяснили, что у пользователя нет прав на доступ к
ресурсу, поэтому продолжать нет смысла.</p>

<p>Усложним задачу тем, что требуется выполнить ряд проверок, и на каждом отказе
прерывать исполнение. Для императивных языков это легкая задача. Код на Python
выглядел бы так:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AccountHandler</span><span class="p">(</span><span class="n">RequestHandler</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">on_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">check_this</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">BadRequest</span><span class="p">(</span><span class="s">"Wrong input data"</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">check_that</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">NotFound</span><span class="p">(</span><span class="s">"No such an account"</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">check_quotas</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">QuotasReached</span><span class="p">(</span><span class="s">"Request rate is limited"</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">JSONResponse</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">get_data_from_db</span><span class="p">())</span>
</code></pre></div></div>

<p>В Clojure нет оператора <code class="language-plaintext highlighter-rouge">return</code>. Результат нескольких форм это результат
последней. Мы не можем расположить несколько форм <code class="language-plaintext highlighter-rouge">if</code> на одном уровне друг под
другом. Это не имеет смысла, поскольку даже если какая-то из них вернет ложь,
исполнение перейдет к следующей форме.</p>

<p>Вариант с каскадным деревом работает, но выглядит слишком громоздко. Получилось
то, что называют The Pile of Doom, пирамида судьбы. Чем больше в ней уровней,
тем больше проблем у разработчика. Ради интереса добавьте новое условие в
середину:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">account-handler</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">check-this</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">check-that</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">check-quotas</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
        </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
         </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">get-data-from-db</span><span class="p">)}</span><span class="w">
        </span><span class="p">(</span><span class="nf">quotas-reached</span><span class="w"> </span><span class="s">"Request rate is limited"</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">not-found</span><span class="w"> </span><span class="s">"No such an account"</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">bad-request</span><span class="w"> </span><span class="s">"Wrong input data"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Подобный случай решают разными способами, в том числе исключениями. Библиотека
<code class="language-plaintext highlighter-rouge">metosin/ring-http-response</code> предлагает функции, которые выбрасывают исключения
с данными HTTP-ответа. В стек middleware добавляют особый декоратор, который
перехватывает такие исключения и возвращает ответ клиенту.</p>

<p>Добавьте библиотеку в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">metosin/ring-http-response</span><span class="w"> </span><span class="s">"0.9.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Теперь обработчик выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.util.http-response</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">not-found!</span><span class="w">
                   </span><span class="n">bad-request!</span><span class="w">
                   </span><span class="n">enhance-your-calm!</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">account-handler</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">

  </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nf">check-this</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">bad-request!</span><span class="w"> </span><span class="s">"Wrong input data"</span><span class="p">))</span><span class="w">

  </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nf">check-that</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">not-found!</span><span class="w"> </span><span class="s">"No such an account"</span><span class="p">))</span><span class="w">

  </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nf">check-quotas</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">enhance-your-calm!</span><span class="w"> </span><span class="s">"Request rate is limited"</span><span class="p">))</span><span class="w">

  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">get-data-from-db</span><span class="p">)})</span><span class="w">
</span></code></pre></div></div>

<p>Такой код похож на императивный. Некоторых разработчиков уязвляет факт, что в
Clojure мы пользуемся императивным подходом. Это нормально. Наша задача –
сделать так, чтобы код был максимально понятным и удобным в поддержке. Вопрос
какую парадигму при этом использовать остается на усмотрение команды.</p>

<p>Функции из модуля <code class="language-plaintext highlighter-rouge">ring.util.http-response</code> бывают с восклицательным знаком на
конце и без него. Это сигнал о том, что функция несет побочный эффект, в данном
случае бросает исключение. Так, <code class="language-plaintext highlighter-rouge">not-found!</code> бросает знакомый нам <code class="language-plaintext highlighter-rouge">ex-info</code>, в
теле которого HTTP-ответ со статусом 404.</p>

<p>Чтобы схема работала, добавим в стек middleware декоратор
<code class="language-plaintext highlighter-rouge">wrap-http-response</code>. Он ловит ошибки, выброшенные функциями с восклицательным
знаком, достает из них ответ и возвращает пользователю.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.http-response</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-http-response</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">app-naked</span><span class="w">
      </span><span class="n">wrap-params</span><span class="w">
      </span><span class="n">wrap-session</span><span class="w">
      </span><span class="n">wrap-cookies</span><span class="w">
      </span><span class="n">wrap-http-response</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Не злоупотребляйте исключениями для переходов. Убедитесь, что это крайняя
мера. Хорошо, если вы используете библиотеку, а не сиюминутное
решение. Преимущество библиотеки в том, что она несет документацию и опыт других
людей.</p>

<h2 id="finally-и-контекстный-менеджер">Finally и контекстный менеджер</h2>

<p>Иногда мы выполняем код в рамках какого-то ресурса. Это может быть файл, сетевой
порт или база данных. В начале работы эти ресурсы “открывают”, а в конце
“закрывают”. В других терминах говорят, что кто-то занял ресурс, а затем
освободил его.</p>

<p>Когда ресурс занят, другие клиенты не могут пользоваться им в полной
мере. Например, открытый кем-то файл можно только читать, но не
изменять. Считается правильным освобождать ресурс сразу же, как только в нем
отпала потребность. Технически это сводится к вызову метода <code class="language-plaintext highlighter-rouge">.close</code> у объекта.</p>

<p>Этому может помешать непредвиденная ошибка. Если код, который работает с
ресурсом, не перехватил исключение, то файл или порт останется занятым до конца
работы программы. Чтобы гарантированно закрыть ресурс даже в случае ошибки,
прибегают к форме <code class="language-plaintext highlighter-rouge">finally</code>.</p>

<p>Эту форму ставят последней внутри <code class="language-plaintext highlighter-rouge">try</code>. Исключения в JVM устроены так, что
управление переходит в <code class="language-plaintext highlighter-rouge">finally</code> даже в случае исключения. Если ошибки не было,
<code class="language-plaintext highlighter-rouge">finally</code> срабатывает после основного кода из <code class="language-plaintext highlighter-rouge">try</code>. Если ошибка возникла,
<code class="language-plaintext highlighter-rouge">finally</code> будет выполнен в промежутке между ее появлением и выбрасыванием.</p>

<p>Вот как выглядит низкоуровневый доступ к файлу. В примере ниже мы записываем в
него несколько байт. Форма <code class="language-plaintext highlighter-rouge">finally</code> гаранитрует, что файл будет закрыт, даже
если если что-то пойдет не так.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">java.io</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="n">FileWriter</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">FileWriter</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="s">"test.txt"</span><span class="p">))]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nf">.write</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">.write</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="s">" "</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">.write</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="s">"Clojure"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">finally</span><span class="w">
      </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="n">out</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы программист не забыл закрыть файл, современные языки предлагают
контекстные менеджеры. В зависимости от платформы это может быть класс, оператор
или макрос. Менеджер исполняет произвольный блок кода с дополнительными
эффектами. Он гарантирует, что перед блоком сработает логика входа, а после него
– логика выхода. При этом выход сработает даже в том случае, если блок выбросил
исключение. Платформа удержит его, выполнит логику выхода и снова бросит.</p>

<p>В языке Python контекстный менеджер выполнен изящно. Это оператор <code class="language-plaintext highlighter-rouge">with</code>,
который ожидает объект. У объекта должны быть методы <code class="language-plaintext highlighter-rouge">__enter__</code> и <code class="language-plaintext highlighter-rouge">__exit__</code>,
которые вызываются в момент входа и выхода. Чаще всего <code class="language-plaintext highlighter-rouge">with</code> используют при
чтении файла. В методе <code class="language-plaintext highlighter-rouge">__exit__</code> срабатывает его закрытие:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"/path/to/file.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">"test"</span><span class="p">)</span>
</code></pre></div></div>

<p>Не составит труда написать такой же менеджер в Clojure. Это будет макрос,
который принимает символ объекта для записи и путь к файлу. Объект назначается
первому символу. Форма <code class="language-plaintext highlighter-rouge">finally</code> гарантирует, что файл будет закрыт при выходе
из тела макроса.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-file-writer</span><span class="w">
  </span><span class="p">[[</span><span class="n">bind</span><span class="w"> </span><span class="nb">path</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="o">~</span><span class="n">bind</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">FileWriter</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="o">~</span><span class="nb">path</span><span class="p">))]</span><span class="w">
     </span><span class="p">(</span><span class="nf">try</span><span class="w">
       </span><span class="o">~@</span><span class="n">body</span><span class="w">
       </span><span class="p">(</span><span class="nf">finally</span><span class="w">
         </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="o">~</span><span class="n">bind</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Пример:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-file-writer</span><span class="w"> </span><span class="p">[</span><span class="n">out</span><span class="w"> </span><span class="s">"test.txt"</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">.write</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="s">"Hello macro!"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Принято называть контекстные менеджеры с префикса <code class="language-plaintext highlighter-rouge">with-</code>. Так вы делаете акцент
на том, что код работает в рамках временного ресурса.</p>

<p>В библиотеке Clojure уже предусмотрен макрос <code class="language-plaintext highlighter-rouge">with-open</code>. Это улучшенная версия
кода, что мы написали выше. В отличии от нашего примера, <code class="language-plaintext highlighter-rouge">with-open</code> работает с
более абстрактной сущностью <code class="language-plaintext highlighter-rouge">Reader</code>. Это источник данных, который может быть в
том числе и файлом. Выход из макроса, даже с ошибкой, гарантирует закрытие
источника.</p>

<p>Как правило, в форме <code class="language-plaintext highlighter-rouge">finally</code> нет смысла при обработке коллекций или действий
без побочных эффектов. Пользуйтесь ей только если источник данных должен быть
занят и освобожден.</p>

<h2 id="исключения-на-предикатах">Исключения на предикатах</h2>

<p>Система <code class="language-plaintext highlighter-rouge">try/catch</code> работает на классах и наследовании. Это значит, если
требуется отловить особый случай, мы создаем специальный класс и бросаем его
экземпляр.</p>

<p>Типичный проект на Java или Python несет на борту отдельный модуль с
собственными исключениями. Как правило, это базовое <code class="language-plaintext highlighter-rouge">CommonProjectException</code> и
унаследованные от него <code class="language-plaintext highlighter-rouge">UserNotFound</code>, <code class="language-plaintext highlighter-rouge">UserAccessDenied</code> и другие. Это длинный
однообразный код, написанный вручную.</p>

<p>В главе про <code class="language-plaintext highlighter-rouge">clojure.spec</code> мы упоминали, что предикаты мощнее типов. Это верно и
для исключений. Если бы можно было перехватить исключение функцией, нам бы не
потребовались классы. В Clojure это возможно при помощи библиотеки <code class="language-plaintext highlighter-rouge">Slingshot</code>
(анг. рогатка).</p>

<p>Библиотека предлагает улучшенные версии <code class="language-plaintext highlighter-rouge">try</code>, <code class="language-plaintext highlighter-rouge">catch</code> и <code class="language-plaintext highlighter-rouge">throw</code>. Новичкам
покажется это странным, но в Clojure с ее мощной системой макросов можно сделать
очень много. В том числе определить иной способ работы с исключениями.
Пользователи других языков ждут новый оператор годами, а в Clojure это решается
библиотекой.</p>

<p>Автор Slingshot предположил, что ошибкой может быть не только экземпляр
исключения, а любое значение в принципе. Например, строка, число, словарь. Выше
мы выяснили, что контекст – самый важный элемент исключения. Поэтому логично
сосредоточить внимание на словарях, а не Java классах.</p>

<p>В техническом плане библиотека реализует макросы <code class="language-plaintext highlighter-rouge">throw+</code> и <code class="language-plaintext highlighter-rouge">try+</code>. Оба они
совместимы с обычными <code class="language-plaintext highlighter-rouge">throw</code> и <code class="language-plaintext highlighter-rouge">try</code>. Если заменить стандартные формы на версии
с плюсом, ничего не изменится. Однако новые формы дают следующие преимущества.</p>

<p>Макрос throw+ принимает не только исключение, но и <strong>любой
Java-объект</strong>. Словарь лучше всего подходит на роль этого объекта, потому что
передает несколько значений и их семантику по имени ключей. Пример ниже выбросит
<code class="language-plaintext highlighter-rouge">ex-info</code> с переданным словарем:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">slingshot.slingshot</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">try+</span><span class="w"> </span><span class="n">throw+</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">throw+</span><span class="w"> </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">42</span><span class="w">
         </span><span class="no">:action</span><span class="w"> </span><span class="no">:create</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Более детальная форма этого макроса: словарь, причина (cause), сообщение и
переметры форматирования:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">path</span><span class="w"> </span><span class="s">"/var/lib/file.txt"</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="nb">path</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw+</span><span class="w"> </span><span class="p">{</span><span class="no">:path</span><span class="w"> </span><span class="nb">path</span><span class="p">}</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"Cannot open a file %s"</span><span class="w"> </span><span class="nb">path</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Форма <code class="language-plaintext highlighter-rouge">catch</code> внутри <code class="language-plaintext highlighter-rouge">try+</code>, помимо классов, ловит исключения по <strong>селектору и
предикату</strong>. Под селектором понимают вектор, где нечетный элемент ключ словаря,
а четный – значение. Селектор проверяет, что такие ключи и значения есть в
контексте исключения. Если да, исключение считается пойманным, и управление
переходит в форму <code class="language-plaintext highlighter-rouge">catch</code> с этим селектором.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try+</span><span class="w">
 </span><span class="p">(</span><span class="nf">throw+</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">::user-error</span><span class="w">
          </span><span class="no">:user</span><span class="w"> </span><span class="mi">42</span><span class="w">
          </span><span class="no">:action</span><span class="w"> </span><span class="no">:update</span><span class="w">
          </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}})</span><span class="w">
 </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="p">[</span><span class="no">:type</span><span class="w"> </span><span class="no">::user-error</span><span class="p">]</span><span class="w"> </span><span class="n">e</span><span class="w">
   </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="n">e</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Считается хорошей практикой добавлять в словарь поле <code class="language-plaintext highlighter-rouge">:type</code>. В него записывают
тип исключения с текущим простанстом имен. В нашем случе это
<code class="language-plaintext highlighter-rouge">:book.exceptions/user-error</code>. При отлове исключений прибегают к этому же
полю. Пространство гарантирует, что мы не отреагируем на <code class="language-plaintext highlighter-rouge">:user-error</code> из
другого модуля.</p>

<p>Пример выше напечатает в консоль переданный словарь. Макрос <code class="language-plaintext highlighter-rouge">catch</code> достаточно
умен и подставляет в переменную <code class="language-plaintext highlighter-rouge">e</code> не исключение, а данные, что мы выбросили.</p>

<p>Вариант с предикатом аналогичен примеру выше. Разница лишь в том, что вместо
селектора указывают функцию одного аргумента. Она принимает исключение или
данные и возвращает истину или ложь. Функция должна быть готова к тому, что ее
параметр разного типа.</p>

<p>Пример ниже предполагает, что операции над пользователем с номером 1 заслуживают
особого внимания. В этом есть смысл, потому что первый пользователь, как
правило, это супер-админ, основатель фирмы или системный пользователь.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">special-user-case?</span><span class="w">
  </span><span class="p">[</span><span class="n">data</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">map?</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">type</span><span class="w"> </span><span class="n">user</span><span class="p">]}</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="no">::user-error</span><span class="p">)</span><span class="w">
           </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>С таким предикатом любой пользователь сможет удалить себя из системы, но не
админ:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try+</span><span class="w">
 </span><span class="p">(</span><span class="nf">throw+</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">::user-error</span><span class="w">
          </span><span class="no">:user</span><span class="w"> </span><span class="mi">1</span><span class="w">
          </span><span class="no">:action</span><span class="w"> </span><span class="no">:delete</span><span class="p">})</span><span class="w">
 </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">special-user-case?</span><span class="w"> </span><span class="n">e</span><span class="w">
   </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Attempt to delete a system account"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Рассмотрим пример из реального проекта. Это предикат для проверки исключения при
работе с Java AWS SDK. При определенных обстоятельствах возможен случай, когда
исключение возникло после того, как файл загружен в S3. Такая загрузка считается
неудачной, и мы должны удалить файл, чтобы он не занимал место. К сожалению, для
этого сценария не существует отдельного класса. Приходится ловить стандартный
AmazonS3Exception и проверять его регулярным выражением.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">aws-special-case?</span><span class="w">
  </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w">
   </span><span class="p">(</span><span class="nb">instance?</span><span class="w"> </span><span class="n">AmazonS3Exception</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">some?</span><span class="w">
    </span><span class="p">(</span><span class="nb">re-find</span><span class="w">
     </span><span class="o">#</span><span class="s">"(?i)The Content-Md5 you specified did not match"</span><span class="w">
     </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Библиотеку Slingshot используют другие проекты, например <code class="language-plaintext highlighter-rouge">clj-http</code>. Это
популярный HTTP-клиент для Clojure. В случае ошибки он кидает ответ через
<code class="language-plaintext highlighter-rouge">throw+</code>. Если код оборачивает HTTP-запрос в <code class="language-plaintext highlighter-rouge">try+</code>, вам доступен более тонкий
разбор ошибок. Например, отдельные ветки для статуса 500 и негативного ответа в
целом.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clj-http.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">client</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">try+</span><span class="w">
 </span><span class="p">(</span><span class="nf">client/get</span><span class="w"> </span><span class="s">"http://example.com/test"</span><span class="p">)</span><span class="w">
 </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="p">[</span><span class="no">:status</span><span class="w"> </span><span class="mi">500</span><span class="p">]</span><span class="w"> </span><span class="n">e</span><span class="w">
   </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"The service is unavailable"</span><span class="p">))</span><span class="w">
 </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="p">[</span><span class="no">:type</span><span class="w"> </span><span class="no">:client/unexceptional-status</span><span class="p">]</span><span class="w"> </span><span class="n">e</span><span class="w">
   </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"The response was not 200"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Подход Slingshot дает несколько преимуществ. Он скрывает внутренний механизм
классов и наследования, дает новый слой абстракции. Чем меньше мы прибегаем к
взаимодействию с JVM, тем лучше Clojure-код. Невозможно избежать этого
полностью, но по крайней мере доступ к JVM становится изолирован.</p>

<p>Библиотека выводит на первое место данные, а не классы. Это хорошая практика, и
она всячески поощряется языком. Clojure спроектирована так, что данные занимают
в ней первое место.</p>

<p>Slingshot относится к расширенной технике Clojure. Начинающим не очевидны плюсы,
которые библиотека несет в проект. Это нормально. Автор советует сначала
разобраться со стандартными формами <code class="language-plaintext highlighter-rouge">try/catch</code>. Подключайте Slingshot только
если вы остро чувствуете в нем потребность.</p>

<h2 id="приемы-и-функции">Приемы и функции</h2>

<p>В последнем разделе мы рассмотрим несколько интересных функций. Их объединяет
тема исключений. Функции достаточно просты и потому не стоят того, чтобы
выносить их в отдельную библиотеку. Как правило, их копируют из проекта в проект
с небольшими изменениями. Автор уверен, у каждого Clojure-разработчика найдется
что-то подобное.</p>

<p><strong>Безопасный вызов функции.</strong> В замечательном языке Lua нет операторов <code class="language-plaintext highlighter-rouge">try</code> и
<code class="language-plaintext highlighter-rouge">catch</code>. Чтобы обезопасить вызов функции от ошибки, используют <code class="language-plaintext highlighter-rouge">pcall</code>. Это
сокращение от protected call, защищенный вызов.</p>

<p>В <code class="language-plaintext highlighter-rouge">pcall</code> передают целевую функцию и аргументы. Результатом будет пара и более
элементов (в Lua функция может вернуть несколько значений). Первый их них
определяет успех выполнения. Если истина, то на втором месте результат
вычисления. Если ложь, то экземпляр исключения.</p>

<p>Тот же самое в Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">pcall</span><span class="w">
  </span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">[</span><span class="n">true</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">[</span><span class="n">false</span><span class="w"> </span><span class="n">e</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы получить доступ к элементам пары, пользуйтесь векторным разбиением в форме
<code class="language-plaintext highlighter-rouge">let</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">ok?</span><span class="w"> </span><span class="n">result-error</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">pcall</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">ok?</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"The result is "</span><span class="w"> </span><span class="n">result-error</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Failure"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><strong>Ошибка и результат.</strong> В мире JavaScript популярны функции-колбеки. Они
выполняются асинхронно и поэтому не прерывают главный тред в случае
ошибки. Существует особое соглашение, что коллбек принимает аргументы <code class="language-plaintext highlighter-rouge">error</code> и
<code class="language-plaintext highlighter-rouge">result</code>. Функция pcall-js это измененный вариант <code class="language-plaintext highlighter-rouge">pcall</code>, который возвращает
пару “ошибка-результат” по этому соглашению.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">pcall-js</span><span class="w">
  </span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">[</span><span class="n">nil</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="n">nil</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p><strong>Попытки с задержкой.</strong> Иногда функция не гарантирует, что отработает
успешно. Такое случается, когда мы обращаемся ко внешнему нестабильному
сервису. Функция <code class="language-plaintext highlighter-rouge">pcall-retry</code> пытается выполнить целевую функцию за несколько
попыток. Первый же удачный вызов станет результатом. Если была ошибка, но число
попыток еще не превысило порога, то функция ждет небольшой интервал времени и
повторяет вызов. Когда все попытки закончились, функция вызывает исключение.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">pcall-retry</span><span class="w">
  </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">attempt</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">ok?</span><span class="w"> </span><span class="n">res</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">pcall</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="k">cond</span><span class="w">
        </span><span class="n">ok?</span><span class="w"> </span><span class="n">res</span><span class="w">

        </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">attempt</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">do</span><span class="w">
          </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">attempt</span><span class="w"> </span><span class="mi">1000</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">n</span><span class="p">)))</span><span class="w">

        </span><span class="no">:else</span><span class="w">
        </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="n">res</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Это наивная версия функции, и в реальных проектах ее дорабатывают. Например,
меняют стратегию задержки, добавляют логирование. Но основа остается прежней.</p>

<p>Любопытно, что функции выше стыкуются между собой. Чтобы предотвратить выброс
исключения из <code class="language-plaintext highlighter-rouge">pcall-retry</code>, завернем ее в <code class="language-plaintext highlighter-rouge">pcall</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pcall</span><span class="w"> </span><span class="n">pcall-retry</span><span class="w"> </span><span class="n">get-user-by-id</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Тогда даже в случае ошибки получим пару <code class="language-plaintext highlighter-rouge">[ok? result]</code>.</p>

<p>Форма <code class="language-plaintext highlighter-rouge">loop</code> заслуживает особого упоминания. Ее дочерняя форма <code class="language-plaintext highlighter-rouge">recur</code> не может
располагаться внутри <code class="language-plaintext highlighter-rouge">try/catch</code>. Пример ниже не просто ошибочный в плане
семантики. При при попытке ее скомпилировать вы получите исключение “Can only
recur from tail position”:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">pcall-retry</span><span class="w">
  </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">attempt</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">pcall</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">n</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Это один их тех случаев, когда мы не можем использовать <code class="language-plaintext highlighter-rouge">try/catch</code>. На помощь
приходит <code class="language-plaintext highlighter-rouge">pcall</code> и его вариации.</p>

<p><strong>Throw in place.</strong> До сих пор мы кидали исключения двумя формами: <code class="language-plaintext highlighter-rouge">ex-info</code> и
<code class="language-plaintext highlighter-rouge">throw</code>. Первая формирует исключение, а вторая его бросает. Логично совместить
их в функцию <code class="language-plaintext highlighter-rouge">error!</code>. Заодно сделаем часть аргументов необязательными:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">error!</span><span class="w">
  </span><span class="p">[</span><span class="n">message</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="w"> </span><span class="n">e</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">{})</span><span class="w"> </span><span class="n">e</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь достаточно написать:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">error!</span><span class="w"> </span><span class="s">"Some error!"</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">::error</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>, чтобы кинуть исключение с нужными данными.</p>

<p><strong>Форматированное сообщение.</strong> Иногда нам нужен не контекст, а подробное
сообщение об ошибке. В этом случае <code class="language-plaintext highlighter-rouge">ex-info</code> избыточен, поскольку без контекста
он не имеет смысла. Достаточно выкинуть <code class="language-plaintext highlighter-rouge">Exception</code> с форматированным
сообщением. В параметры функции передают шаблон и значения для подстановки. В
этом и других примерах часть <code class="language-plaintext highlighter-rouge">f</code> на конце означает форматирование.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">errorf!</span><span class="w">
  </span><span class="p">[</span><span class="n">template</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">message</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="n">message</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">errorf!</span><span class="w"> </span><span class="s">"Cannot process a user %s with the action %s"</span><span class="w"> </span><span class="s">"AAA"</span><span class="w"> </span><span class="no">:UPDATE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>Безопасный макрос.</strong> Примеры выше можно переписать на макросах. Преимущество
макросов в том, что они изящней встраиваются в код. С другой стороны, на них
нельзя ссылаться как на объект. Макрос нельзя передать в <code class="language-plaintext highlighter-rouge">apply</code>, <code class="language-plaintext highlighter-rouge">map</code> и другие
высшие функции.</p>

<p>Пример ниже показывает, как выполнить часть кода в безопасном режиме, игнорируя
ошибку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-safe</span><span class="w">
  </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nf">try</span><span class="w">
     </span><span class="o">~@</span><span class="n">body</span><span class="w">
     </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="o">#</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Пустая форма catch возвращает nil. Мы получим его, если случится ошибка:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-safe</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Nil</code> может быть положительным результатом кода, который мы передали в
макрос. На практике ошибку передают другим значением. Обычно это кейворд
<code class="language-plaintext highlighter-rouge">:error</code> или <code class="language-plaintext highlighter-rouge">:invalid</code>. По такому принципу работает пакет <code class="language-plaintext highlighter-rouge">clojure.spec</code>,
который мы разобрали в прошлой главе. Если валидация не прошла, результат будет
<code class="language-plaintext highlighter-rouge">:clojure.spec.alpha/invalid</code>.</p>

<p>В реальности редко бывает так, что нам безразлично, была ошибка или нет. Поэтому
на практике макрос дорабатывают: добавляют в форму <code class="language-plaintext highlighter-rouge">catch</code> код для записи
исключения в лог или отправки в Sentry.</p>

<h2 id="заключение">Заключение</h2>

<p>Перечислим основные тезисы главы. Clojure использует систему исключений
Java. Эта система работает на классах и дереве наследования. Формы <code class="language-plaintext highlighter-rouge">try</code> и
<code class="language-plaintext highlighter-rouge">catch</code> похожи на одноименные операторы Java.</p>

<p>Особая форма <code class="language-plaintext highlighter-rouge">finally</code> дает шанс закрыть ресурс в случае ошибки. Чтобы упростить
работу с ресурсом, пользуйтесь контекстными менеджерами. Это макросы вида
<code class="language-plaintext highlighter-rouge">with-&lt;something&gt;</code>. Для доступа к файлам Clojure предлагает макрос <code class="language-plaintext highlighter-rouge">with-open</code>.</p>

<p>Класс <code class="language-plaintext highlighter-rouge">ExceptionInfo</code> разработан специально для Clojure. Его преимущество в поле
<code class="language-plaintext highlighter-rouge">data</code>, куда можно записать любой словарь. Функция <code class="language-plaintext highlighter-rouge">ex-info</code> упрощает создание
этого исключения.</p>

<p>У каждой ошибки может быть причина, <code class="language-plaintext highlighter-rouge">cause</code>. Если вы поймали исключение, лучше
бросить новое с текущим контекстом и причиной-оригинальным исключением. Так
исключения собираются в цепочку.</p>

<p>В приложении должен быть код, который решает, что делать с пойманным
исключением. Лучше всего отправить его в единую систему сбора ошибок. Sentry
будет хорошим решением. Проследите, что ваш клиент к Sentry передает всю нужную
информацию, а не только стек-трейс.</p>

<p>В особых случаях исключениями пользуются, чтобы мгновенно перейти в другое место
в коде. На это у вас должны быть веские причины.</p>

<p>Проект Slingshot предлагает улучшенную схему <code class="language-plaintext highlighter-rouge">try/catch</code>. При таком подходе мы
оперируем не исключениями, а данными.</p>

<p>Ряд функций и макросов упрощают контроль над исключениями. Изучите их, чтобы
уменьшить код.</p>

<p>Код этой главы доступен <a href="https://github.com/igrishaev/book-sessions/blob/master/src/book/exceptions.clj">в одном модуле</a> на Гитхабе.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментарии</center>

<div id="comments">
  
    <div id="comment-4521865904" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            jrb,
            30th Jun 2019,
            <a href="#comment-4521865904">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Добрый день. Вопрос не по теме – в чем вы делаете такие схемы <a href="https://scrn.janitorrb.com/wMXa3h94aKE1snMYK39XFestvM9Ld119Ga.png" rel="nofollow noopener" title="https://scrn.janitorrb.com/wMXa3h94aKE1snMYK39XFestvM9Ld119Ga.png">https://scrn.janitorrb.com/...</a> ?</p>
</div>
    </div>
  
    <div id="comment-4522589828" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            1st Jul 2019,
            <a href="#comment-4522589828">link</a>
            , <a href="#comment-4521865904">parent</a>
          </em>
        </small>
      </p>
      <div><p>Это программа для Мака, узнал о ней недавно: <a href="https://monodraw.helftone.com/" rel="nofollow noopener" title="https://monodraw.helftone.com/">https://monodraw.helftone.com/</a></p>
</div>
    </div>
  
</div>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-book-exceptions/">
    <input required name="captcha" type="hidden" value="3 &#215; 1">

    <div class="block">
        <span class="comment-form-label"><small>3 &#215; 1 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
