<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>REPL, Cider, Emacs (часть 2/4)</title>
  <meta name="description" content="Все части  Первая часть  Вторая часть  Третья часть  Четвертая часть">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-repl-part-2/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">REPL, Cider, Emacs (часть 2/4)</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2022-08-20T00:00:00+00:00">
        Aug 20, 2022
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/repl/" rel="tag">repl</a>, <a href="/tag/emacs/" rel="tag">emacs</a>, <a href="/tag/cider/" rel="tag">cider</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<h2>Все части</h2>

<ul>
  <li><a href="/clj-repl-part-1/">Первая часть</a></li>
  <li><a href="/clj-repl-part-2/">Вторая часть</a></li>
  <li><a href="/clj-repl-part-3/">Третья часть</a></li>
  <li><a href="/clj-repl-part-4/">Четвертая часть</a></li>
</ul>

<h2>

    Оглавление

</h2>

<ul id="toc-item-clojure-repl-toc">
  <li><a href="#repl-в-редакторе" id="toc-item-clojure-repl-toc-repl-в-редакторе">REPL в редакторе</a>    <ul>
      <li><a href="#недостатки" id="toc-item-clojure-repl-toc-недостатки">Недостатки</a></li>
    </ul>
  </li>
  <li><a href="#знакомство-с-nrepl" id="toc-item-clojure-repl-toc-знакомство-с-nrepl">Знакомство с nREPL</a>    <ul>
      <li><a href="#запуск-nrepl" id="toc-item-clojure-repl-toc-запуск-nrepl">Запуск nREPL</a></li>
      <li><a href="#внутреннее-устройство" id="toc-item-clojure-repl-toc-внутреннее-устройство">Внутреннее устройство</a></li>
      <li><a href="#транспорт" id="toc-item-clojure-repl-toc-транспорт">Транспорт</a></li>
      <li><a href="#middleware" id="toc-item-clojure-repl-toc-middleware">Middleware</a></li>
    </ul>
  </li>
  <li><a href="#подключение-из-clojure" id="toc-item-clojure-repl-toc-подключение-из-clojure">Подключение из Clojure</a>    <ul>
      <li><a href="#коротко-о-bencode" id="toc-item-clojure-repl-toc-коротко-о-bencode">Коротко о Bencode</a></li>
    </ul>
  </li>
  <li><a href="#клиенты-nrepl-для-редакторов" id="toc-item-clojure-repl-toc-клиенты-nrepl-для-редакторов">Клиенты nREPL для редакторов</a></li>
  <li><a href="#emacs-и-cider" id="toc-item-clojure-repl-toc-emacs-и-cider">Emacs и Cider</a>    <ul>
      <li><a href="#первые-шаги" id="toc-item-clojure-repl-toc-первые-шаги">Первые шаги</a></li>
      <li><a href="#выполнение-кода" id="toc-item-clojure-repl-toc-выполнение-кода">Выполнение кода</a></li>
      <li><a href="#dev-секции" id="toc-item-clojure-repl-toc-dev-секции">Dev-секции</a></li>
      <li><a href="#сниппеты" id="toc-item-clojure-repl-toc-сниппеты">Сниппеты</a></li>
    </ul>
  </li>
</ul>

<h2 id="repl-в-редакторе">REPL в редакторе</h2>

<p>До сих пор мы набирали код в терминале, что не совсем удобно. Терминал подходит для коротких команд, но плохо справляется с многострочным вводом. Будет правильно набрать код в редакторе, а затем скопировать в терминал. Код останется в файле, и не придется печатать его в следующий раз.</p>

<p>Со временем вы заметите, что переключение между редактором и терминалом отнимает время. Было бы здорово связать редактор с REPL напрямую. Вы набираете код и с помощью комбинации клавиш выполняете в REPL. В отдельной области редактор показывает результат. С таким подходом нам доступна мощь обеих сред: REPL и редактора.</p>

<!-- more -->

<p>Описанный способ предлагает <a href="https://www.gnu.org/software/emacs/">Emacs</a> — текстовый редактор с историей более сорока лет. Emacs запускает любой Лисп, будь то Common Lisp, Scheme или Clojure, и управляет им из редактора. В терминах Emacs запущенный Лисп называется внешним (external) в противоположность встроенному диалекту ELisp. Режим, когда код вычисляется внешним Лиспом, назывыется inferior lisp mode (анг. inferior — низший). Название объясняется тем, что, поскольку режим нацелен на любой Лисп, он поддерживает только базовые операции.</p>

<p>Проведем короткий сеанс REPL из Emacs. Запустите редактор и выполните команду:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x inferior-lisp
</code></pre></div></div>

<p>Emacs запросит путь интерпретатору Лиспа. Введите <code class="language-plaintext highlighter-rouge">clojure</code> или <code class="language-plaintext highlighter-rouge">lein repl</code> в зависимости от того, какая утилита у вас установлена. Чтобы не указывать программу каждый раз, объявите в настройках переменную <code class="language-plaintext highlighter-rouge">inferior-lisp-program</code>. Того же эффекта можно добиться, выполнив одно из выражений в буфере <code class="language-plaintext highlighter-rouge">*scratch*</code>:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">setq</span> <span class="nv">inferior-lisp-program</span> <span class="s">"clojure"</span><span class="p">)</span> <span class="c1">;; C-j</span>
<span class="p">(</span><span class="k">setq</span> <span class="nv">inferior-lisp-program</span> <span class="s">"lein repl"</span><span class="p">)</span> <span class="c1">;; C-j</span>
</code></pre></div></div>

<p>Emacs запустит процесс и соединится с каналами ввода и вывода. В буфере <code class="language-plaintext highlighter-rouge">*inferior-lisp*</code> появится сеанс REPL. Он работает как в терминале: ожидает выражение, вычисляет, печатает и снова ожидает.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Clojure</span><span class="w"> </span><span class="mf">1.10</span><span class="n">.1</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">6</span><span class="w">
</span></code></pre></div></div>

<p>Поскольку это буфер Emacs, нам доступно больше возможностей. Можно свободно перемещать по нему курсор, копировать и вставлять код, искать в прямом и обратном направлении, сохранить буфер в файл и многое другое.</p>

<p>Особые команды передают код из редактора в REPL без ручного копирования. Переключитесь в буфер с кодом на Clojure и включите режим Lisp командой:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x lisp-mode
</code></pre></div></div>

<p>Установите курсор после закрывающей скобки любого выражения, например <code class="language-plaintext highlighter-rouge">(+ 1 2)</code>. Выполните команду <code class="language-plaintext highlighter-rouge">M-x lisp-eval-last-sexp</code>, которая означает вычислить последнее S-выражение. В буфере <code class="language-plaintext highlighter-rouge">*inferior-lisp*</code> появится результат:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user=&gt; 3
</code></pre></div></div>

<p>Эффект аналогичен тому, как если бы вы скопировали код, вставили в REPL и нажали Enter. Заметим, что выражение не обязательно вычислять целиком. Можно выполнить форму, которая находится внутри другой формы. Предположим, в вашем файле следующий код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"inner form"</span><span class="p">)</span><span class="w"> </span><span class="err">|</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Подведите курсор на место вертикальной черты. Выполните <code class="language-plaintext highlighter-rouge">M-x lisp-eval-last-sexp</code>, и REPL вычислит <code class="language-plaintext highlighter-rouge">(println "inner form")</code>. Ошибки не будет, потому что <code class="language-plaintext highlighter-rouge">(println ...)</code> не зависит от переменных <code class="language-plaintext highlighter-rouge">a</code> и <code class="language-plaintext highlighter-rouge">b</code>. Если же вычислить <code class="language-plaintext highlighter-rouge">(+ a b)</code>, получим ошибку, что символы не известны.</p>

<p>Команды с приставкой <code class="language-plaintext highlighter-rouge">lisp-eval-...</code> отвечают за то, какую часть файла выполнить в REPL. Например, <code class="language-plaintext highlighter-rouge">lisp-eval-region</code> отправит только выделенную область, а <code class="language-plaintext highlighter-rouge">lisp-eval-defun</code> — функцию, на которой сейчас установлен курсор. Команды с окончанием <code class="language-plaintext highlighter-rouge">...-and-go</code> делают то же самое, но дополнительно переключат вас в REPL.</p>

<p>Проделайте упражнения из разделов выше. Подключите встроенные модули, объявите несколько функций, спровоцируйте исключение.</p>

<p>Обратите внимание, что команды <code class="language-plaintext highlighter-rouge">lisp-eval-...</code> вычисляют код без учета текущего пространства. Контроль за тем, какое пространство активно в данный момент, ложится на вас. Если вы работаете с двумя и более модулями, это станет проблемой. Легко объявить функцию в одном пространстве:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">test1</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>и вызвать в другом, что приведет к ошибке:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ns test2)

(add 1 2)

test2=&gt; Syntax error compiling at (REPL:1:1).
Unable to resolve symbol: add in this context
</code></pre></div></div>

<p>Эта проблема решена в более продвинутых системах, о которых мы поговорим уже скоро.</p>

<p>Запуск REPL из Emacs кажется примитивным подходом, но на самом деле это не так. Вам доступны все возможности Clojure и Emacs одновременно. Для эффективной работы требуется не так уж много команд: выполнить s-выражение, регион или <code class="language-plaintext highlighter-rouge">def</code>-определение.</p>

<p><a href="https://batsov.com/articles/2014/12/04/introducing-inf-clojure-a-better-basic-clojure-repl-for-emacs/">По словам Рича Хикки</a>, автора Clojure, он работал над языком, используя Emacs и режим <code class="language-plaintext highlighter-rouge">inferior-lisp</code>. Это подтверждает: можно достичь значимых результатов малыми средствами. И хотя сегодня для Clojure созданы более мощные инструменты, полезно знать этот спартанский метод.</p>

<h3 id="недостатки">Недостатки</h3>

<p>Способ, когда Emacs запускает внешний Лисп, не лишен недостатков. Перечислим основные из них.</p>

<p>Обмен данными между средами происходит по стандартным каналам операционной системы (stdin, stdout и stderr). Скорость их передачи ниже, чем по сети, что заметно на больших файлах.</p>

<p>Интерпретатор Лиспа, библиотеки и окружение должны быть установлены локально. Без специальных ухищрений нельзя подключиться к Лиспу, запущенному на удаленной машине.</p>

<p>Emacs и REPL передают друг другу плоский текст, из-за чего Emacs показывает результат без каких-либо улучшений. Это сделано намеренно, поскольку режим <code class="language-plaintext highlighter-rouge">inferior-lisp</code> рассчитан на любой REPL, будь то Common Lisp, Racket или Clojure.</p>

<p>Заметим, что Clojure поддерживает сетевой режим в REPL. Чтобы его включить, передайте следующий аргумент:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clojure <span class="nt">-J-Dclojure</span>.server.repl<span class="o">=</span><span class="s2">"{:port 5555 :accept clojure.core.server/repl}"</span>
</code></pre></div></div>

<p>С ним REPL принимает ввод не только с клавиатуры, но и с порта 5555. Чтобы это проверить, подключимся к серверу через <code class="language-plaintext highlighter-rouge">telnet</code> и введем код на Clojure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; telnet 127.0.0.1 5555

Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
user=&gt; (defn add [a b]
         (+ a b))
#'user/add
</code></pre></div></div>

<p>В результате <code class="language-plaintext highlighter-rouge">telnet</code> работает как обычный REPL; разница в том, что данные передаются по сети. Подключитесь по <code class="language-plaintext highlighter-rouge">telnet</code> с другой машины, на которой нет Clojure. Введите сумму чисел, переменную и другой код. Перейдите к машине, где запущен REPL и убедитесь, что изменения, проделанные удаленно, вступили в силу.</p>

<p>Хотя сетевой режим снимает одну из проблем, озвученных выше, особой популярности он не получил. Данные по-прежнему передаются плоским текстом, что мешает эффективному обмену. Со временем появился проект nREPL, который закрывает этот и другие недостатки.</p>

<h2 id="знакомство-с-nrepl">Знакомство с nREPL</h2>

<p>В названии <a href="https://nrepl.org">nREPL</a> буква n означает network, то есть сетевой REPL. Проект нацелен на то, чтобы обеспечить работу REPL по сети. В отличие от терминала, nREPL обладает более сложной архитектурой; перечислим ее главные свойства.</p>

<p>Сервер nREPL принимает команды по протоколу TCP. С одним проектом могут работать несколько клиентов. Сервер может быть запущен на удаленной машине или в изолированном окружении (Docker, VirtualBox).</p>

<p>Сообщения nREPL обладают структурой. Каждое из них содержит номер сеанса, тип операции, ее аргументы и текущее пространство имен. Сообщение легко дополнить или изменить при помощи промежуточных слоев — middleware.</p>

<p>nREPL опирается на транспорт сообщений. Транспортом называют соглашение о том, как писать и читать сообщения. По умолчанию nREPL предлагает транспорты Bencode, EDN и TTY. Создать новый транспорт означает расширить протокол библиотеки.</p>

<p>Обычный REPL работает синхронно: получив команду с клавиатуры, он не принимает текст до тех пор, пока не вычислит и напечатает результат. nREPL устроен асинхронно, когда команда выполняется в отдельном потоке. В ответ на одну операцию сервер может прислать несколько сообщений. По специальному полю клиент определяет, последнее это сообщение или нет.</p>

<p>Технически nREPL — библиотека, доступная в Clojars. У нее нет зависимостей, что упрощает развитие и поддержку. Несмотря на свою роль в экосистеме, nREPL остается отдельным, а не встроенным модулем. С таким подходом он не зависит от цикла версий Clojure.</p>

<h3 id="запуск-nrepl">Запуск nREPL</h3>

<p>Чтобы запустить nREPL вместо обычного REPL, добавьте библиотеку в проект. Если вы пользуетесь lein, откройте файл <code class="language-plaintext highlighter-rouge">project.clj</code> и расширьте зависимости:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">...</span><span class="w">
 </span><span class="no">:dependencies</span><span class="w">
 </span><span class="p">[</span><span class="n">...</span><span class="w"> </span><span class="p">[</span><span class="n">nrepl/nrepl</span><span class="w"> </span><span class="s">"0.9.0"</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<p>Сохраните файл и выполните <code class="language-plaintext highlighter-rouge">lein repl</code>. Утилита <code class="language-plaintext highlighter-rouge">lein</code> устроена так, что если nREPL найден в зависимостях, предпочтение отдается ему. Убедиться, что вы запустили именно nREPL можно по фразе “nREPL server started”, которая появится в терминале:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; lein repl

nREPL server started on port 52002 on host 127.0.0.1 - nrepl://127.0.0.1:52002
REPL-y 0.4.4, nREPL 0.8.3
Clojure 1.10.1
OpenJDK 64-Bit Server VM 11.0.12+6-jvmci-21.2-b08
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&gt;
</code></pre></div></div>

<p>В случае с <code class="language-plaintext highlighter-rouge">deps.edn</code> укажите профиль <code class="language-plaintext highlighter-rouge">:nrepl</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:aliases</span><span class="w">
 </span><span class="p">{</span><span class="no">:nrepl</span><span class="w">
  </span><span class="p">{</span><span class="no">:extra-deps</span><span class="w">
   </span><span class="p">{</span><span class="n">nrepl/nrepl</span><span class="w"> </span><span class="p">{</span><span class="no">:mvn/version</span><span class="w"> </span><span class="s">"0.9.0"</span><span class="p">}}</span><span class="w">
   </span><span class="no">:main-opts</span><span class="w"> </span><span class="p">[</span><span class="s">"-m"</span><span class="w"> </span><span class="s">"nrepl.cmdline"</span><span class="w"> </span><span class="s">"-i"</span><span class="p">]}}}</span><span class="w">
</span></code></pre></div></div>

<p>Ключ <code class="language-plaintext highlighter-rouge">-i</code> в <code class="language-plaintext highlighter-rouge">:main-opts</code> означает интерактивный режим, то есть с вводом с клавиатуры. Без него nREPL работает в “безголовом” (headless) режиме, слушая только сетевой порт. Запустите утилиту <code class="language-plaintext highlighter-rouge">clj</code> с профилем <code class="language-plaintext highlighter-rouge">:nrepl</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; clj -M:nrepl

nREPL server started on port 55113 on host localhost - nrepl://localhost:55113
nREPL 0.9.0
Clojure 1.11.1
OpenJDK 64-Bit Server VM 11.0.12+6-jvmci-21.2-b08
Interrupt: Control+C
Exit:      Control+D or (exit) or (quit)
user=&gt;
</code></pre></div></div>

<p>На первый взгляд nREPL не отличается от обычного REPL. Он по-прежнему принимает ввод с клавиатуры, вычисляет и печатает результат. Истинная мощь nREPL проявляется в работе из редактора, и уже скоро мы дойдем до этого раздела.</p>

<p>После запуска nREPL вы обнаружите файл <code class="language-plaintext highlighter-rouge">.nrepl-port</code> в папке проекта. Если не указать порт явно, nREPL случайно выберет свободный порт для подключения. Дополнительно он запишет порт в файл, чтобы редактор прочитал его, не запрашивая у пользователя.</p>

<p>Выше мы указали nREPL в главных зависимостях проекта — векторе <code class="language-plaintext highlighter-rouge">:dependencies</code> формы <code class="language-plaintext highlighter-rouge">defproject</code>. Поскольку nREPL относится к разработке, поместим его в профиль <code class="language-plaintext highlighter-rouge">:dev</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:profiles</span><span class="w">
</span><span class="p">{</span><span class="no">:dev</span><span class="w"> </span><span class="p">{</span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">nrepl/nrepl</span><span class="w"> </span><span class="s">"0.9.0"</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<p>В этом случае nREPL доступен при запуске <code class="language-plaintext highlighter-rouge">lein repl</code>, потому что профиль <code class="language-plaintext highlighter-rouge">:dev</code> активен по умолчанию. При сборке проекта его не окажется в зависимостях. Это легко проверить, вызвав команду <code class="language-plaintext highlighter-rouge">deps :tree</code> с профилем <code class="language-plaintext highlighter-rouge">uberjar</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lein with-profile uberjar deps :tree | <span class="nb">grep </span>nrepl
<span class="p">;;</span> nothing
</code></pre></div></div>

<p>Быстро окажется, что nREPL нужен во всех проектах.Чтобы не добавлять его в каждый <code class="language-plaintext highlighter-rouge">project.clj</code>, прибегают к пользовательскому профилю. Создайте файл <code class="language-plaintext highlighter-rouge">~/.lein/profiles.clj</code> со словарем внутри. В поле <code class="language-plaintext highlighter-rouge">:user</code> укажите словарь с зависимостями. Утилита <code class="language-plaintext highlighter-rouge">lein</code> объединит его с полем <code class="language-plaintext highlighter-rouge">:profiles</code> при запуске.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="p">{</span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">nrepl/nrepl</span><span class="w"> </span><span class="s">"0.9.0"</span><span class="p">]]}}</span><span class="w">
</span></code></pre></div></div>

<p>Теперь по команде <code class="language-plaintext highlighter-rouge">lein repl</code> запусится nREPL, неважно указан ли он в <code class="language-plaintext highlighter-rouge">project.clj</code> или нет. Это полезно, когда в проекте несколько человек и их редакторы требуют разные версии nREPL (например, Cider и Calva). Каждый укажет свою версию в файле <code class="language-plaintext highlighter-rouge">~/.lein/profiles.clj</code>, избежав конфликта.</p>

<p>Если вы используете Clojure CLI, похожий файл называется <code class="language-plaintext highlighter-rouge">~/.clojure/deps.edn</code>. При запуске <code class="language-plaintext highlighter-rouge">clj</code> или <code class="language-plaintext highlighter-rouge">clojure</code> он дополняет текущий файл <code class="language-plaintext highlighter-rouge">deps.edn</code>. Поместите в него профиль <code class="language-plaintext highlighter-rouge">:nrepl</code>, созданный выше. Чтобы подчеркнуть, что это локальный профиль, добавьте ему пространство <code class="language-plaintext highlighter-rouge">local</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:aliases</span><span class="w">
 </span><span class="p">{</span><span class="no">:local/nrepl</span><span class="w">
  </span><span class="p">{</span><span class="no">:extra-deps</span><span class="w"> </span><span class="p">{</span><span class="n">nrepl/nrepl</span><span class="w"> </span><span class="p">{</span><span class="no">:mvn/version</span><span class="w"> </span><span class="s">"0.9.0"</span><span class="p">}}</span><span class="w">
   </span><span class="no">:main-opts</span><span class="w"> </span><span class="p">[</span><span class="s">"-m"</span><span class="w"> </span><span class="s">"nrepl.cmdline"</span><span class="p">]}}}</span><span class="w">
</span></code></pre></div></div>

<p>Включите проект командой:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> clj <span class="nt">-M</span>:local/nrepl
</code></pre></div></div>

<p>Поведение nREPL меняют с помощью параметров. В <code class="language-plaintext highlighter-rouge">lein</code> для этого служит ключ <code class="language-plaintext highlighter-rouge">:repl-options</code>. Перечислим опции, которые понадобятся чаще других.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:port</code> — сетевой порт, по которому nREPL принимает сообщения от клиентов. Если не задан, будет выбран случайно. В редких случаях порт указывают явно, например когда nREPL запущен в Docker или на удаленной машине — эти случаи мы рассмотрим в конце главы.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:prompt</code> — функция приглашения. Принимает один аргумент — пространство имен — и по умолчанию выводит его имя.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:init-ns</code> — символ пространства, которое nREPL загрузит при запуске. В разработке используют <code class="language-plaintext highlighter-rouge">dev</code>, <code class="language-plaintext highlighter-rouge">user</code> или <code class="language-plaintext highlighter-rouge">sandbox</code> — своего рода песочницу с запуском системы, прогоном миграций другими служебными функциями.</p>
  </li>
</ul>

<p>Пример с нестандартными параметрами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">...</span><span class="w">
  </span><span class="no">:repl-options</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">9911</span><span class="w">
                 </span><span class="no">:init-ns</span><span class="w"> </span><span class="n">dev</span><span class="w">
                 </span><span class="no">:prompt</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">current-ns</span><span class="p">]</span><span class="w">
                           </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"[%s] &gt;&gt; "</span><span class="w"> </span><span class="n">current-ns</span><span class="p">))}}</span><span class="w">
</span></code></pre></div></div>

<p>Вот что получим при запуске <code class="language-plaintext highlighter-rouge">lein repl</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>dev] <span class="o">&gt;&gt;</span> <span class="o">(</span>+ 1 2 3<span class="o">)</span>
6
</code></pre></div></div>

<p>Остальные параметры вы найдете в документации <a href="https://github.com/technomancy/leiningen/blob/master/sample.project.clj#L368">Leiningen</a> и <a href="https://nrepl.org/nrepl/usage/server.html">nREPL</a>.</p>

<h3 id="внутреннее-устройство">Внутреннее устройство</h3>

<p>Дизайн nREPL включает три важные части: обработчик запроса, middleware и транспорт. Коротко опишем каждую из них.</p>

<p>Обработчик (<code class="language-plaintext highlighter-rouge">handler</code>) — это функция одного аргумента, которая принимает словарь сообщения. В nREPL сообщения структурированы, то есть разбиты на поля. По полю <code class="language-plaintext highlighter-rouge">:op</code> (operation) функция понимает, что от нее требуется, и выполняет действие. Вот как выглядит команда вычислить код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w"> </span><span class="no">:code</span><span class="w"> </span><span class="s">"(+ 1 2 3)"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>и ответ на нее:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:session</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:value</span><span class="w"> </span><span class="mi">6</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Мы привели сообщения в виде EDN для читаемости; в транспорте они выглядят иначе. На месте многоточий должны быть длинные идентификаторы, которые мы сократили за ненадобностью.</p>

<p>Логично ожидать, что обработчик возвращает словарь сообщения подобно библиотеке <a href="https://github.com/ring-clojure/ring">Ring</a>. Это приводит к ограничению “один запрос – один ответ”, что нарушает сказанное выше: на одно входящее сообщение может быть несколько исходящих.</p>

<p>Сообщение, переданное обработчику, содержит поле <code class="language-plaintext highlighter-rouge">:transport</code> с текущим объектом транспорта. Чтобы отправить ответ клиенту, обработчик вызывает метод <code class="language-plaintext highlighter-rouge">send</code> транспорта со словарем ответа:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="p">[{</span><span class="no">:as</span><span class="w"> </span><span class="n">message</span><span class="w">
                </span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">transport</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">code</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="n">...</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">t/send</span><span class="w"> </span><span class="n">transport</span><span class="w"> </span><span class="p">{</span><span class="no">:value</span><span class="w"> </span><span class="n">value</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Простейший случай, когда ответов несколько — вычисление двух форм за раз. Выделим в редакторе две формы и выполним <code class="language-plaintext highlighter-rouge">M-x cider-eval-region</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>На сервер уйдет сообщение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w"> </span><span class="no">:code</span><span class="w"> </span><span class="s">"(+ 1 2 3)(+ 1 2 3 4)"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>В ответ получим три сообщения: по одному на каждую форму плюс завершающее, которое означает, что задача окончена. У всех трех сообщений одинаковый ID, чтобы понять, к какому запросу они относятся.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:session</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:value</span><span class="w"> </span><span class="s">"6"</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:session</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:value</span><span class="w"> </span><span class="s">"10"</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:session</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"done"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Если бы обработчик был чистой функцией, он должен был вернуть список ответов. Но список нельзя отправить клиенту, пока не вычислен последний элемент. В этом случае мы вынудим клиента ждать до тех пор, пока не будут готовы все ответы. Это неоптимально: гораздо лучше отправлять сообщения по мере готовности.</p>

<h3 id="транспорт">Транспорт</h3>

<p>В терминах nREPL транспорт — это соглашение о том, какой канал связи использовать и как кодировать и декодировать сообщения. Чтобы клиент и сервер понимали друг друга, они должны использовать одинаковый транспорт. На уровне кода это объект, реализующий протокол <code class="language-plaintext highlighter-rouge">nrepl.transport.Transport</code>. В него входят методы <code class="language-plaintext highlighter-rouge">recv</code> и <code class="language-plaintext highlighter-rouge">send</code>, которые отвечают за прием и отправку сообщений.</p>

<p>nREPL предлагает три транспорта: Bencode, EDN и TTY. Мы перечислили их по убыванию важности. Большинство клиентов используют Bencode, поэтому он задан по умолчанию. Bencode опирается на одноименный формат данных, который мы рассмотрим чуть позже.</p>

<p>Транспорт EDN передает данные в формате, принятом в Clojure. Его используют в ClojureScript, поскольку там возможностей Bencode не хватает, чтобы покрыть все типы данных. Транспорт TTY предназначен для подключения из терминала. Это наиболее скудный формат, которым пользуются в крайних случаях.</p>

<h3 id="middleware">Middleware</h3>

<p>По аналогии с Ring, middleware — это прослойка между запросом и обработчиком. Задача middleware в том, чтобы расширить логику сервера, не меняя обработчик.</p>

<p>Предположим, мы бы хотели, чтобы команда “classpath” вернула текущий список <a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">путей JVM</a>. Для этого напишем middleware с логикой: если поле <code class="language-plaintext highlighter-rouge">:op</code> сообщения равно “classpath”, отправить сообщение со списком строк. В противном случае вызвать обработчик по умолчанию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-classpath</span><span class="w"> </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[{</span><span class="no">:as</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">op</span><span class="w"> </span><span class="n">transport</span><span class="p">]}]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"classpath"</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">paths</span><span class="w"> </span><span class="p">(</span><span class="nf">get-classpath</span><span class="w"> </span><span class="n">...</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">t/send</span><span class="w"> </span><span class="n">transport</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="w"> </span><span class="no">:classpath</span><span class="w"> </span><span class="n">paths</span><span class="p">}))</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">msg</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Как и в Ring, цепочка middleware образует стек. В примере выше переменная <code class="language-plaintext highlighter-rouge">handler</code> не обязательно конечный обработчик nREPL. Скорей всего, он многократно обернут другими middleware выше по стеку.</p>

<p>Проект Cider, который мы скоро рассмотрим, предлагает <a href="https://github.com/clojure-emacs/cider-nrepl/tree/master/src/cider/nrepl/middleware">множество подобных middleware</a>. Вместе они радикально расширяют возможности nREPL.</p>

<h2 id="подключение-из-clojure">Подключение из Clojure</h2>

<p>Опробуем nREPL на практике: подключимся к серверу и выполним несколько выражений. Пока что мы не знаем, как подключиться из редактора, поэтому воспользуемся клиентом на Clojure. У нас будет два сеанса nREPL: первый в роли сервера, второй в качестве клиента.</p>

<p>Запустите оба сеанса командой <code class="language-plaintext highlighter-rouge">lein repl</code> или <code class="language-plaintext highlighter-rouge">clj -M:nrepl</code>. Напомним, библиотека <code class="language-plaintext highlighter-rouge">nrepl/nrepl</code> должна быть указана в профиле по умолчанию (файлы <code class="language-plaintext highlighter-rouge">~/.lein/profiles.clj</code> и <code class="language-plaintext highlighter-rouge">~/.clojure/deps.edn</code>). Запомните порт первого сеанса (в случае автора это 50411). Его можно увидеть в терминале при nREPL или в файле <code class="language-plaintext highlighter-rouge">.nrepl-port</code> той директории, где запущен сеанс.</p>

<p>Во втором сеансе выполните:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">nrepl.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">nrepl</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/connect</span><span class="w"> </span><span class="no">:port</span><span class="w"> </span><span class="mi">50411</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/client</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="mi">1000</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">connect</code> открывает соединение с сервером, на базе которого работает клиент (в рамках одного соединения их может быть несколько). Клиент отвечает за отправку и получение сообщений. Код выше подключит вас к удаленному nREPL. Для начала сложим несколько чисел. Отправьте сообщение с операцией <code class="language-plaintext highlighter-rouge">eval</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w"> </span><span class="no">:code</span><span class="w"> </span><span class="s">"(+ 1 2 3)"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Получим два ответа: первый с результатом, второй с признаком окончания:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">({</span><span class="no">:id</span><span class="w"> </span><span class="s">"1ac6cbc4-74d4-4b3a-bf3f-97dcf7ca07c2"</span><span class="w">
  </span><span class="no">:ns</span><span class="w"> </span><span class="s">"my-repl"</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"fec9d5a3-3c22-4640-b089-c1cecc041068"</span><span class="w">
  </span><span class="no">:value</span><span class="w"> </span><span class="s">"6"</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"1ac6cbc4-74d4-4b3a-bf3f-97dcf7ca07c2"</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"fec9d5a3-3c22-4640-b089-c1cecc041068"</span><span class="w">
  </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"done"</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Проверим, что случится, если возникнет исключение. Поделим число на ноль:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w"> </span><span class="no">:code</span><span class="w"> </span><span class="s">"(/ 0 0)"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Ответ:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">({</span><span class="no">:err</span><span class="w"> </span><span class="s">"Execution error (ArithmeticException) at my-repl/eval5984 (form-init9833672407535844907.clj:1).\nDivide by zero\n"</span><span class="w">
  </span><span class="no">:id</span><span class="w"> </span><span class="s">"a8444b3c-7b54-4e04-9b48-04b8bda170f4"</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"17d02cb6-45ff-464c-a01c-c87da89cdfa7"</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:ex</span><span class="w"> </span><span class="s">"class java.lang.ArithmeticException"</span><span class="w">
  </span><span class="no">:id</span><span class="w"> </span><span class="s">"a8444b3c-7b54-4e04-9b48-04b8bda170f4"</span><span class="w">
  </span><span class="no">:root-ex</span><span class="w"> </span><span class="s">"class java.lang.ArithmeticException"</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"17d02cb6-45ff-464c-a01c-c87da89cdfa7"</span><span class="w">
  </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"eval-error"</span><span class="p">]}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"a8444b3c-7b54-4e04-9b48-04b8bda170f4"</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"17d02cb6-45ff-464c-a01c-c87da89cdfa7"</span><span class="w"> </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"done"</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Получили краткие сведения об исключении: класс, текст и последний элемент стектрейса. Сбором этих данных занимается функция, которую можно задать параметром <code class="language-plaintext highlighter-rouge">:nrepl.middleware.caught/caught</code>. Функция должна быть объявлена на сервере, и в сообщении передают путь к ней:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:nrepl.middleware.caught/caught</span><span class="w"> </span><span class="ss">'project.util/caught-func</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Убедимся, что изменения, переданные клиентом, вступили в силу. Объявите функцию <code class="language-plaintext highlighter-rouge">add</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w"> </span><span class="no">:code</span><span class="w"> </span><span class="s">"
(defn add [a b]
  (+ a b))
"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Перейдите в первый терминал с сервером. Выполните <code class="language-plaintext highlighter-rouge">(add 1 2)</code> — функция сработает без ошибок.</p>

<p>Другая полезная команда называется <code class="language-plaintext highlighter-rouge">lookup</code>. Она принимает символ и возвращает данные о переменной, связанной с ним. Данные содержат путь к исходному файлу, позицию в нем, документацию и сигнатуру. На <code class="language-plaintext highlighter-rouge">lookup</code> завязана поддержка редактора: переход к определению, вывод документации, всплывающее окно с сигнатурой вызова по мере набора. Запросим информацию о символе <code class="language-plaintext highlighter-rouge">+</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"lookup"</span><span class="w"> </span><span class="no">:sym</span><span class="w"> </span><span class="s">"+"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Символ может быть как с пространством, так и без него. Во втором случае поиск происходит в текущем пространстве имен. В ответ получим все необходимое для перехода к определению (файл, строка), вызова (список аргументов) и документации (поле <code class="language-plaintext highlighter-rouge">:doc</code>):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">({</span><span class="no">:id</span><span class="w"> </span><span class="s">"e66092b8-c6aa-49a9-9cff-cc3557e421c6"</span><span class="n">,</span><span class="w">
  </span><span class="no">:info</span><span class="w"> </span><span class="p">{</span><span class="no">:protocol</span><span class="w"> </span><span class="s">""</span><span class="n">,</span><span class="w">
         </span><span class="no">:added</span><span class="w"> </span><span class="s">"1.2"</span><span class="n">,</span><span class="w">
         </span><span class="no">:ns</span><span class="w"> </span><span class="s">"clojure.core"</span><span class="n">,</span><span class="w">
         </span><span class="no">:name</span><span class="w"> </span><span class="s">"+"</span><span class="n">,</span><span class="w">
         </span><span class="no">:file</span><span class="w"> </span><span class="s">"jar:file:/Users/ivan/.m2/repository/org/clojure/clojure/1.10.0/clojure-1.10.0.jar!/clojure/core.clj"</span><span class="n">,</span><span class="w">
         </span><span class="no">:arglists-str</span><span class="w"> </span><span class="s">"([] [x] [x y] [x y &amp; more])"</span><span class="n">,</span><span class="w">
         </span><span class="no">:column</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w">
         </span><span class="no">:line</span><span class="w"> </span><span class="mi">984</span><span class="n">,</span><span class="w">
         </span><span class="no">:arglists</span><span class="w"> </span><span class="s">"([] [x] [x y] [x y &amp; more])"</span><span class="n">,</span><span class="w">
         </span><span class="no">:doc</span><span class="w"> </span><span class="s">"Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'"</span><span class="p">}</span><span class="n">,</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"63a4ba3f-6a19-4597-919d-3136ebbfa1cb"</span><span class="n">,</span><span class="w">
  </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"done"</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Команда <code class="language-plaintext highlighter-rouge">completions</code> возвращает список определений по префиксу. Это полезно, когда пользователь ввел часть текста и ожидает выпадающее окно с вариантами. Например, функции семейства <code class="language-plaintext highlighter-rouge">ex-...</code> служат для работы с исключениями. Проверим, что найдет сервер по префиксу <code class="language-plaintext highlighter-rouge">ex-</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"completions"</span><span class="w"> </span><span class="no">:prefix</span><span class="w"> </span><span class="s">"ex-"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Получили четыре функции для работы с исключениями:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">({</span><span class="no">:completions</span><span class="w">
  </span><span class="p">[{</span><span class="no">:candidate</span><span class="w"> </span><span class="s">"ex-cause"</span><span class="n">,</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="s">"function"</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:candidate</span><span class="w"> </span><span class="s">"ex-data"</span><span class="n">,</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="s">"function"</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:candidate</span><span class="w"> </span><span class="s">"ex-info"</span><span class="n">,</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="s">"function"</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:candidate</span><span class="w"> </span><span class="s">"ex-message"</span><span class="n">,</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="s">"function"</span><span class="p">}]</span><span class="n">,</span><span class="w">
  </span><span class="no">:id</span><span class="w"> </span><span class="s">"e6f3b77b-5689-484e-8743-76f9682caaa7"</span><span class="n">,</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"f15bb73c-e3f9-49c8-8aa5-0ebc592d038d"</span><span class="n">,</span><span class="w">
  </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"done"</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>nREPL поддерживает другие полезные команды, например <code class="language-plaintext highlighter-rouge">:load-file</code> для загрузки кода из файла. Сообщение передает не путь к файлу на сервере, а его содержимое и метаданные. Создайте файл <code class="language-plaintext highlighter-rouge">src/sample.clj</code> с кодом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">sample</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">multiply</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>После чего отправьте его на сервер (функция <code class="language-plaintext highlighter-rouge">slurp</code> читает файл в строку):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"load-file"</span><span class="w">
                       </span><span class="no">:file</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="s">"src/sample.clj"</span><span class="p">)})</span><span class="w">
</span></code></pre></div></div>

<p>Сервер скомпилирует код из файла, и в результате появится пространство имен <code class="language-plaintext highlighter-rouge">sample</code>. Перейдите в терминал с сервером и опробуйте новую функцию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">sample/multiply</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="mi">12</span><span class="w">
</span></code></pre></div></div>

<p>Мы не будем перечислять все команды nREPL. Любопытный читатель найдет их в <a href="https://nrepl.org/nrepl/ops.html">документации</a> проекта. Завершим раздел командой <code class="language-plaintext highlighter-rouge">close</code>. Она принимает строго один параметр — номер сессии — и освобождает ресурсы, связанные с ней:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w">
               </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"close"</span><span class="w">
                </span><span class="no">:session</span><span class="w"> </span><span class="s">"97ec6c4b-28ee-4402-87e3-43f3275a7430"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<h3 id="коротко-о-bencode">Коротко о Bencode</h3>

<p>Исследуем трафик, которым обмениваются клиент и сервер nREPL. Пока открыты оба сеанса, запустите команду <code class="language-plaintext highlighter-rouge">tcpdump</code> для записи трафика в файл. В системах Linux и MacOS утилита доступна по умолчанию. <code class="language-plaintext highlighter-rouge">Tcpdump</code> требует прав суперпользователя, поэтому запускается с <code class="language-plaintext highlighter-rouge">sudo</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sudo</span><span class="w"> </span><span class="n">tcpdump</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="mi">50411</span><span class="w"> </span><span class="n">-i</span><span class="w"> </span><span class="n">lo0</span><span class="w"> </span><span class="n">-w</span><span class="w"> </span><span class="n">nrepl.log</span><span class="w">
</span></code></pre></div></div>

<p>Число 50411 — это порт сервера nREPL, а <code class="language-plaintext highlighter-rouge">nrepl.log</code> — выходной файл с TCP-пакетами. После запуска <code class="language-plaintext highlighter-rouge">tcpdump</code> перейдите в REPL и выполните несколько действий. Завершите <code class="language-plaintext highlighter-rouge">tcpdump</code> нажатием <code class="language-plaintext highlighter-rouge">Ctrl+C</code> и откройте файл в программе <a href="https://www.wireshark.org">Wireshark</a>. Это бесплатное приложение для анализа сетевого трафика. Содержимое файла в нем выглядит примерно так (переносы строк отделяют запрос и ответ):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d4:code9:(+ 1 2 3)2:id36:c88f2dcb-d502-4c90-9529-2dd843bc56d02:op4:evale
d2:id36:c88f2dcb-d502-4c90-9529-2dd843bc56d02:ns7:my-repl7:session36:1fdd9575-881e-4be1-80ca-dd8e64bdff185:value1:6e
</code></pre></div></div>

<p>Каждая строка — структура данных в формате <a href="https://en.wikipedia.org/wiki/Bencode">Bencode</a>. Форма создали как часть протокола BitTorrent, и позже его переняли другие системы, в том числе nREPL. Bencode передает числа, строки, словари и списки. Несмотря на меньший по сравнению с JSON набор типов, он обладает решительным преимуществом — простотой.</p>

<p>Описание формата занимает меньше страницы. Числа записываются в виде <code class="language-plaintext highlighter-rouge">i&lt;число&gt;e</code>, например <code class="language-plaintext highlighter-rouge">i2020e</code> означает <code class="language-plaintext highlighter-rouge">2020</code>. Цепочка байтов — в виде <code class="language-plaintext highlighter-rouge">&lt;длина&gt;:&lt;содержимое&gt;</code>; строка <code class="language-plaintext highlighter-rouge">"hello"</code> становится <code class="language-plaintext highlighter-rouge">"5:hello"</code>. Выражение <code class="language-plaintext highlighter-rouge">l&lt;...&gt;e</code> означает список. Значения, найденные между <code class="language-plaintext highlighter-rouge">l</code> и <code class="language-plaintext highlighter-rouge">e</code>, станут его содержимым. В строке <code class="language-plaintext highlighter-rouge">"l5:helloi42ee"</code> записан список с элементами <code class="language-plaintext highlighter-rouge">"hello"</code> и <code class="language-plaintext highlighter-rouge">42</code>. Форма <code class="language-plaintext highlighter-rouge">d&lt;...&gt;e</code> служит для словаря. От списка он отличается тем, что перед каждым значением идет строка с именем ключа. Сообщение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"d5:title4:19844:yeari1948ee"
</code></pre></div></div>

<p>означает словарь</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:title</span><span class="w"> </span><span class="s">"1984"</span><span class="w"> </span><span class="no">:year</span><span class="w"> </span><span class="mi">1948</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Формат допускает вложенность одних коллекций в другие, например список словарей или словарь, значения которого списки. Упакуем в Bencode следующие данные:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:title</span><span class="w"> </span><span class="s">"1984"</span><span class="w">
 </span><span class="no">:year</span><span class="w"> </span><span class="mi">1948</span><span class="w">
 </span><span class="no">:tags</span><span class="w"> </span><span class="p">[</span><span class="s">"novel"</span><span class="w"> </span><span class="s">"fiction"</span><span class="w"> </span><span class="s">"dystopia"</span><span class="p">]</span><span class="w">
 </span><span class="no">:author</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"George"</span><span class="w"> </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Orwell"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"d6:authord5:fname6:George5:lname6:Orwelle4:tagsl5:novel7:fiction8:dystopiae5:title4:19844:yeari1948ee"</span><span class="w">
</span></code></pre></div></div>

<p>Всё, вы знаете Bencode!</p>

<p>Этих правил достаточно для передачи сообщений в nREPL. Конечно, при кодировании теряется часть семантики: тип <code class="language-plaintext highlighter-rouge">Keyword</code> становится строкой, но обратной операции не предусмотрено — получив строку, нельзя определить, была ли она раньше кейвордом. По аналогии вектор, список и множество становятся в Bencode списком, и узнать исходный тип коллекции невозможно. Однако чаще всего этого и не требуется.</p>

<p>Почему бы не использовать более продвинутый формат, например JSON? Причина в том, что, в отличие от него, Bencode экстремально прост: код упаковки и чтения данных занимает около ста строк. Это важно для встроенных в редактор языков, которые не всегда поддерживают JSON. Написание для них JSON-парсера потребует усилилий.</p>

<p>Транспорт Bencode назначен в nREPL по умолчанию. Когда nREPL работает с ClojureScript, используется EDN. Сообщения в ClojureScript требуют больше типов данных, и возможностей Bencode уже недостаточно.</p>

<p>Ради эксперимента укажите серверу и клиенту транспорт EDN. Для сервера это делается ключом <code class="language-plaintext highlighter-rouge">:repl-options</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:repl-options</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="w">
               </span><span class="no">:transport</span><span class="w"> </span><span class="n">nrepl.transport/edn</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Если выполнить <code class="language-plaintext highlighter-rouge">lein repl</code>, вы увидите в консоли фразу <code class="language-plaintext highlighter-rouge">nrepl+edn://127.0.0.1:&lt;port&gt;</code>, при этом ввод с клавиатуры будет недоступен. Чтобы подключиться к серверу, измените параметры клиента:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">nrepl.transport</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">transport</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/connect</span><span class="w">
           </span><span class="no">:port</span><span class="w"> </span><span class="mi">61093</span><span class="w">
           </span><span class="no">:transport-fn</span><span class="w"> </span><span class="n">transport/edn</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запишите трафик в файл и исследуйте в Wireshark. Вы увидите привычные данные в формате Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w">
 </span><span class="no">:code</span><span class="w"> </span><span class="s">"(+ 1 2 3)"</span><span class="w">
 </span><span class="no">:id</span><span class="w"> </span><span class="s">"f4fcb617-74a7-4be8-978a-6f788787d360"</span><span class="p">}</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"f4fcb617-74a7-4be8-978a-6f788787d360"</span><span class="w">
 </span><span class="no">:session</span><span class="w"> </span><span class="s">"29e04d1a-06b2-463b-8b5b-878424958780"</span><span class="w">
 </span><span class="no">:ns</span><span class="w"> </span><span class="s">"my-repl"</span><span class="w">
 </span><span class="no">:value</span><span class="w"> </span><span class="s">"6"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Bencode для Clojure доступен в двух вариантах: как часть nREPL и в виде отдельной библиотеки <a href="https://github.com/nrepl/bencode">nrepl/bencode</a>. Последняя является копией модуля из nREPL и обновляется параллельно с ним.</p>

<h2 id="клиенты-nrepl-для-редакторов">Клиенты nREPL для редакторов</h2>

<p>Мы провели достаточно опытов, чтобы понять, как устроен клиент для nREPL. Это код, который отправляет сообщения по особому протоколу. Клиенты пишут на разных языках, в том числе встроенных в редактор. Так получаются плагины — программные модули, которые служат прослойкой между пользователем и nREPL. По нажатию клавиш плагин посылает сообщение и выводит результат в отдельной области или рядом с кодом.</p>

<p>На GitHub вы найдете клиенты nREPL, написанные на Clojure, Emacs Lisp, Java, Python, Lua, JavaScript, TypeScript, VimScript и других языках. Это многообразие объясняется тем, каждый редактор использует свой язык для внутренних нужд. Например, плагины Emacs пишут на старом диалекте Elisp; редактор VS Code поддерживает JavaScript и TypeScript; модули к продуктам JetBrains создают на Java и так далее.</p>

<p>В этом разделе мы не будем перебирать все клиенты. Наоборот, остановим выбор на модуле Cider для редактора Emacs. В его пользу говорят следующие факты.</p>

<p><strong>Долгая история.</strong> Первый коммит в репозиторий Cider <a href="https://github.com/clojure-emacs/cider/tree/v0.1.0">сделан в 2012 году</a>. На момент написания книги проекту полных десять лет. Cider давно вышел из стадии любительского решения: у него обширное сообщество и документация.</p>

<p><strong>Популярность.</strong> Согласно ежегодному опросу <a href="https://clojure.org/news/2022/06/02/state-of-clojure-2022">Clojure Survey</a>, связка Cider/Emacs держит первое место по популярности у разработчиков. Доля голосов в пользу Cider превышает 40%, хоть и плавно снижается из-за развития других проектов.</p>

<p><strong>Компетенция в сообществе.</strong> Исторически сложилось, что Emacs в большей степени подходит для разработки на Лиспе, чем другие редакторы. За долгие годы его адаптировали под разные диалекты — Common Lisp, Racket, Scheme и другие. Cider опирается на этот опыт: большая часть его функций — повтор удачных решений для других Лиспов.</p>

<p>Если вы пользуетесь другим редактором, не спешите пропускать раздел. Возможно, вы откроете подходы, о которых не знали раньше. Также вы заочно познакомитесь с Emacs: это сложный редактор, но он стоит потраченных сил.</p>

<h2 id="emacs-и-cider">Emacs и Cider</h2>

<p>Проект Cider состоит из двух частей. Первая — одноименный <a href="https://github.com/clojure-emacs/cider">модуль для Emacs</a>, чтобы подключаться к nREPL из редактора. Вторая часть — библиотека на Clojure под названием <a href="https://github.com/clojure-emacs/cider-nrepl">cider-nrepl</a>. Это набор middleware, которые дополняют nREPL: добавляют запуск тестов, отладку, переходы по коду, профилирование и многое другое.</p>

<p>Взаимодействие Emacs и сервера выглядит так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌────────────────────────────────────────────────────────────────┐
│                                                                │
│  ┌─────────────────┐   ┌────────────────────────────────────┐  │
│  │Client           │   │Server                              │  │
│  │                 │   │                                    │  │
│  │  ┌───────────┐  │   │  ┌───────────┐     ┌───────────┐   │  │
│  │  │           │  │   │  │   nREPL   │     │           │   │  │
│  │  │   Emacs   │  │   │  │  server   │◀═══▶│  Clojure  │   │  │
│  │  │           │  │   │  │           │     │           │   │  │
│  │  └───────────┘  │   │  └───────────┘     └───────────┘   │  │
│  │        ▲        │   │        ▲                 ▲         │  │
│  │        ║        │   │        ║                 ║         │  │
│  │        ║        │   │        ║                 ║         │  │
│  │        ▼        │   │        ▼                 ▼         │  │
│  │  ┌───────────┐  │   │  ┌───────────┐     ┌───────────┐   │  │
│  │  │           │  │   │  │Cider/nrepl│     │           │   │  │
│  │  │   CIDER   │◀═╬═══╬═▶│middleware │     │    JVM    │   │  │
│  │  │           │  │   │  │           │     │           │   │  │
│  │  └───────────┘  │   │  └───────────┘     └───────────┘   │  │
│  │                 │   │                                    │  │
│  │                 │   │                                    │  │
│  │                 │   │                                    │  │
│  └─────────────────┘   └────────────────────────────────────┘  │
│                                                                │
└────────────────────────────────────────────────────────────────┘
</code></pre></div></div>

<p>Cider-nrepl работает на сервере и не зависит от языка, на котором написан клиент. На него опирается не только Emacs, но и плагины для Vim и других редакторов.</p>

<p>Есть несколько способов начать работу над проектом в Emacs. <strong>Первый</strong> — поручить все шаги Cider. Откройте любой файл проекта и выполните:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x cider-jack-in
</code></pre></div></div>

<p>Произойдет следующее: Emacs начнет искать файл <code class="language-plaintext highlighter-rouge">project.clj</code> в текущей папке, а затем все выше и выше. Если он найден, Emacs запустит процесс <code class="language-plaintext highlighter-rouge">lein repl</code>. В параметрах окажутся библиотека <code class="language-plaintext highlighter-rouge">nrepl</code> и служебные плагины. Приведем итоговую команду в сокращении:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> /usr/local/bin/lein
  update-in :dependencies conj <span class="o">[</span>nrepl/nrepl <span class="s2">"0.9.0"</span><span class="o">]</span> <span class="se">\</span>
  update-in :plugins conj <span class="o">[</span>cider/cider-nrepl <span class="s2">"0.28.3"</span><span class="o">]</span> <span class="se">\</span>
  update-in :plugins conj <span class="o">[</span>mx.cider/enrich-classpath <span class="s2">"1.9.0"</span><span class="o">]</span> <span class="se">\</span>
  update-in :middleware conj cider.enrich-classpath/middleware <span class="se">\</span>
  repl :headless :host localhost
</code></pre></div></div>

<p>Cider различает системы управления проектом: lein, Clojure CLI и Boot. Для каждой из них он выполнит разные команды. Если найдены файлы нескольких утилит, Emacs спросит, что именно запустить.</p>

<p>После запуска nREPL редактор подключится к нему. Откроется буфер <code class="language-plaintext highlighter-rouge">*cider-repl &lt;project&gt;*</code> для ввода выражений. Еще один буфер <code class="language-plaintext highlighter-rouge">*nrepl-server &lt;project&gt;*</code> служит для вывода процесса <code class="language-plaintext highlighter-rouge">lein repl</code>.</p>

<p>Возможно, первый запуск <code class="language-plaintext highlighter-rouge">cider-jack-in</code> займет время. Его бóльшая часть уйдет на загрузку зависимостей.</p>

<p>При <strong>втором способе</strong> подключения шаги проделывают вручную: запускают nREPL в терминале и подключаются из редактора. Откройте глобальный профиль lein в файле <code class="language-plaintext highlighter-rouge">~/.lein/profiles.clj</code>. В вектор <code class="language-plaintext highlighter-rouge">:user</code> → <code class="language-plaintext highlighter-rouge">:plugins</code> добавьте плагин <code class="language-plaintext highlighter-rouge">cider/cider-nrepl</code>. Плагин зависит от модуля <code class="language-plaintext highlighter-rouge">nrepl/nrepl</code>, поэтому последний указывать не нужно — он загрузится как транзитивная зависимость.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:user</span><span class="w">
 </span><span class="p">{</span><span class="no">:plugins</span><span class="w">
  </span><span class="p">[[</span><span class="n">cider/cider-nrepl</span><span class="w"> </span><span class="s">"0.28.3"</span><span class="p">]]}}</span><span class="w">
</span></code></pre></div></div>

<p>Запустите в терминале процесс <code class="language-plaintext highlighter-rouge">lein repl</code>. Перейдите в Emacs и выполните <code class="language-plaintext highlighter-rouge">M-x cider-connect</code>. Редактор запросит у вас хост и порт сервера. В нашем случае хост будет <code class="language-plaintext highlighter-rouge">localhost</code> или <code class="language-plaintext highlighter-rouge">127.0.0.1</code>. Вводить порт вручную необязательно: Cider найдет его в файле <code class="language-plaintext highlighter-rouge">.nrep-port</code>. Для этого нажмите в минибуфере TAB — появится список с вариантами. Emacs покажет не только номера портов, но и названия проектов, с которыми они связаны.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Click on a completion to select it.
In this buffer, type RET to select the completion near point.

Possible completions are:
- etaoin:54446
- pact:64187
</code></pre></div></div>

<p>После соединения вы окажетесь в буфере <code class="language-plaintext highlighter-rouge">*cider-repl &lt;project&gt;*</code> с приглашением. Буфера <code class="language-plaintext highlighter-rouge">*nrepl-server &lt;project&gt;*</code> не будет, поскольку сервер запущен вне Emacs и между ними нет связи по каналам stdin/out.</p>

<p>Для Clojure CLI проект выглядит как в примере ниже. Запустите его командой <code class="language-plaintext highlighter-rouge">clojure -M:cider</code>. По аналогии с <code class="language-plaintext highlighter-rouge">lein</code>, поместите профиль <code class="language-plaintext highlighter-rouge">:cider</code> в файл <code class="language-plaintext highlighter-rouge">~/.clojure/deps.edn</code>, чтобы применить его к любому проекту.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:aliases</span><span class="w">
 </span><span class="p">{</span><span class="no">:cider</span><span class="w">
  </span><span class="p">{</span><span class="no">:extra-deps</span><span class="w">
   </span><span class="p">{</span><span class="n">cider/cider-nrepl</span><span class="w"> </span><span class="p">{</span><span class="no">:mvn/version</span><span class="w"> </span><span class="s">"0.25.9"</span><span class="p">}}</span><span class="w">
   </span><span class="no">:main-opts</span><span class="w">
   </span><span class="p">[</span><span class="s">"-m"</span><span class="w"> </span><span class="s">"nrepl.cmdline"</span><span class="w">
    </span><span class="s">"--bind"</span><span class="w"> </span><span class="s">"localhost"</span><span class="w">
    </span><span class="s">"--middleware"</span><span class="w"> </span><span class="s">"[cider.nrepl/cider-middleware]"</span><span class="p">]}}}</span><span class="w">
</span></code></pre></div></div>

<p>Возможно, у читателя возникнет вопрос: зачем нужно ручное подключение, если доступно автоматическое? Пока мы не ушли дальше, объясним разницу между подходами.</p>

<p>В автоматическом режиме (<code class="language-plaintext highlighter-rouge">cider-jack-in</code>) процесс <code class="language-plaintext highlighter-rouge">lein repl</code> запускается силами Emacs. Если редактор “упадет”, завершатся открытые им процессы. Те, кто работает с Clojure постоянно, держат несколько запущенных проектов одновременно. Восстанавливать их после перезапуска редактора утомительно.</p>

<p>Когда сеансы запущены вручную вне Emacs, сбой в редакторе не скажется на них. Более того — они сохранят изменения, которые вы внесли до этого. Достаточно включить редактор и подключится к запущенным проектам.</p>

<p>В редких случаях к проекту можно подключиться только в удаленном режиме. Например, если сервер nREPL запущен на другой машине или в виртуальном окружении (Docker, VirtualBox). Эти сценарии мы рассмотрим ближе к концу главы.</p>

<h3 id="первые-шаги">Первые шаги</h3>

<p>Итак, если подключение состоялось, откроется буфер <code class="language-plaintext highlighter-rouge">*cider-repl*</code> приглашением. Введите что-нибудь вроде <code class="language-plaintext highlighter-rouge">(+ 1 2)</code>, чтобы убедиться в его работе. Наверху буфера находится краткая справка. Если вы только знакомитесь с Cider, прочитайте ее. Опытные разработчики отключают справку, назначив <code class="language-plaintext highlighter-rouge">nil</code> специальной переменной Emacs:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">setq</span> <span class="nv">cider-repl-display-help-banner</span> <span class="no">nil</span><span class="p">)</span>
</code></pre></div></div>

<p>Дальнейшие шаги зависят от конфигурации проекта. Если не задано пространство по умолчанию (параметры <code class="language-plaintext highlighter-rouge">:main</code> или <code class="language-plaintext highlighter-rouge">:repl-options</code> → <code class="language-plaintext highlighter-rouge">:init-ns</code>), ничего не будет загружено, и вы окажетесь в пространстве <code class="language-plaintext highlighter-rouge">user</code>. Загрузить код в nREPL можно двумя способами: вручную и автоматически.</p>

<p>В первом случае откройте файл с главным модулем. Как правило, это пространства <code class="language-plaintext highlighter-rouge">&lt;project&gt;.core</code> или <code class="language-plaintext highlighter-rouge">&lt;project&gt;.main</code>. Выполните команду <code class="language-plaintext highlighter-rouge">M-x cider-load-buffer</code>. Ей пользуются часто, поэтому команде назначено сочетание клавиш <code class="language-plaintext highlighter-rouge">C-c C-k</code>. Пространство имен, включая его зависимости, будут загружены на сервере.</p>

<p>В боевых проектах создают модуль <code class="language-plaintext highlighter-rouge">dev</code> (он же <code class="language-plaintext highlighter-rouge">local</code>, <code class="language-plaintext highlighter-rouge">sandbox</code>), доступный только в разработке (профиль <code class="language-plaintext highlighter-rouge">uberjar</code> его игнорирует). Модуль указывают в опциях nREPL, чтобы загрузить его при запуске сервера. В свою очередь <code class="language-plaintext highlighter-rouge">dev</code> зависит от других модулей, и они загружаются транзитивно.</p>

<p>Кроме импортов, в <code class="language-plaintext highlighter-rouge">dev</code> размещают служебные функции, например:</p>

<ul>
  <li>прогон миграций;</li>
  <li>запуск системы компонентов (веб-сервер, база, кэш и другие) и ее остановка;</li>
  <li>вызов различных API.</li>
</ul>

<p>Вот как выглядят настройки REPL с модулем <code class="language-plaintext highlighter-rouge">dev</code> по умолчанию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:profiles</span><span class="w">
 </span><span class="p">{</span><span class="no">:dev</span><span class="w">
  </span><span class="p">{</span><span class="no">:repl-options</span><span class="w"> </span><span class="p">{</span><span class="no">:init-ns</span><span class="w"> </span><span class="n">dev</span><span class="p">}}}}</span><span class="w">
</span></code></pre></div></div>

<p>При ручной загрузке может случиться так, что какие-то модули пропущены. Особенно досадно, когда не загружен модуль, расширяющий протокол или мультиметод. Код скомпилируется, но при запуске получим исключение, что нет нужной реализации.</p>

<p>Чтобы этого избежать, Cider предлагает автоматическую загрузку командой <code class="language-plaintext highlighter-rouge">M-x cider-ns-refresh</code>. Она перебирает пути classpath и принудительно загружает все файлы Clojure. Как только вы подключились к nREPL, выполните эту команду, и проект готов к работе.</p>

<h3 id="выполнение-кода">Выполнение кода</h3>

<p>После загрузки кода его можно выполнить. Перейдите в буфер <code class="language-plaintext highlighter-rouge">*cider-repl*</code> и введите вызов любой функции:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">my.project.util/some-func</span><span class="w"> </span><span class="p">{</span><span class="no">:message</span><span class="w"> </span><span class="s">"hello"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Нажмите Enter. На сервер уйдет сообщение с этим кодом. Там он выполнится, и ниже появится результат.</p>

<p>Чтобы быстро перейти в буфер REPL, связанный с текущим проектом, наберите команду <code class="language-plaintext highlighter-rouge">M-x cider-switch-to-repl-buffer</code> и задайте ей комбинацию клавиш.</p>

<p>Частый переход в буфер <code class="language-plaintext highlighter-rouge">*cider-repl*</code> и набор кода в нем неудобен. Гораздо лучше выполнить код из файла, где вы его набираете. Команда <code class="language-plaintext highlighter-rouge">M-x cider-eval-last-sexp</code>, назначенная на <code class="language-plaintext highlighter-rouge">C-x C-e</code>, выполнит последнее перед курсором S-выражение. Предположим, вы написали следующий код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="s">"John"</span><span class="w">
      </span><span class="n">email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s &lt;%s&gt;"</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">email</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Поместите курсор за последнюю скобку и выполните <code class="language-plaintext highlighter-rouge">C-x C-e</code>. Справа от формы появится результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="s">"John"</span><span class="w">
      </span><span class="n">email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s &lt;%s&gt;"</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">email</span><span class="p">))</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="s">"John &lt;test@test.com&gt;"</span><span class="w">
</span></code></pre></div></div>

<p>По аналогии с <code class="language-plaintext highlighter-rouge">inferior-mode</code>, S-выражение может быть где угодно: не только на верхнем уровне модуля, но и внутри другой формы. В выражении:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="p">(</span><span class="nf">java.util.UUID/randomUUID</span><span class="p">)</span><span class="w"> </span><span class="err">|</span><span class="w">
      </span><span class="nb">name</span><span class="w"> </span><span class="s">"John"</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="n">id</span><span class="w">
   </span><span class="no">:name</span><span class="w"> </span><span class="nb">name</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>подведите курсор на место вертикальной черты и выполните форму <code class="language-plaintext highlighter-rouge">(java.util...)</code>. Вы получите случайный идентификатор, экземпляр класса <code class="language-plaintext highlighter-rouge">UUID</code>.</p>

<p>Команды <code class="language-plaintext highlighter-rouge">cider-eval-region</code>, <code class="language-plaintext highlighter-rouge">cider-eval-buffer</code> и другие выполняют код из разных областей. Как следует из названий, <code class="language-plaintext highlighter-rouge">-region</code> выполняет выделенный код, в котором может быть несколько форм. Команда <code class="language-plaintext highlighter-rouge">-buffer</code> охватывает буфер цели.</p>

<p>Команда <code class="language-plaintext highlighter-rouge">cider-eval-defun-at-point</code> выполняет определение — формы <code class="language-plaintext highlighter-rouge">def</code>, <code class="language-plaintext highlighter-rouge">defn</code>, <code class="language-plaintext highlighter-rouge">defmacro</code> и другие. Особенность в том, курсор может быть в любом месте формы, а не обязательно на конце. В примере ниже установите курсор на место черты и выполните команду. Результатом станет переменная <code class="language-plaintext highlighter-rouge">#'user-description</code> (объект <code class="language-plaintext highlighter-rouge">Var</code>).</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user-description</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="err">|</span><span class="w">
        </span><span class="n">email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s &lt;%s&gt;"</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">email</span><span class="p">)))</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="o">#</span><span class="ss">'user-description</span><span class="w">
</span></code></pre></div></div>

<p>Этот прием крайне полезен в работе. Бóльшую часть времени мы проводим, редактируя функции, и перемещать курсор в конец формы неудобно. С помощью <code class="language-plaintext highlighter-rouge">cider-eval-defun-at-point</code> функцию обновляют, находясь в любом месте ее кода.</p>

<p>Если результат вычислений велик (например, выборка из базы данных), Cider покажет усеченную версию. Чтобы исследовать данные, выполните <code class="language-plaintext highlighter-rouge">cider-inspect-last-result</code>. Откроется буфер <code class="language-plaintext highlighter-rouge">*cider-inspect*</code>, где данные напечатаны постранично с учетом вложенности. Для примера исследуем большой словарь:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ns-map 'clojure.core)

Class: clojure.lang.PersistentHashMap
Contents:
  sort-by = #'clojure.core/sort-by
  contains? = #'clojure.core/contains?
  every? = #'clojure.core/every?
  proxy-mappings = #'clojure.core/proxy-mappings
  keep-indexed = #'clojure.core/keep-indexed
  ...
  Page size: 32, showing page: 1 of 29
</code></pre></div></div>

<p>За навигацию по данным отвечают особые клавиши; приведем некоторые из них:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SPC</code> (пробел) — перейти на следующую страницу результата;</li>
  <li><code class="language-plaintext highlighter-rouge">M-SPC</code> — вернуться на предыдущую;</li>
  <li><code class="language-plaintext highlighter-rouge">RET</code> (Enter) — открыть вложенную структуру данных;</li>
  <li><code class="language-plaintext highlighter-rouge">l</code> — подняться на уровень ниже</li>
</ul>

<p>Команда <code class="language-plaintext highlighter-rouge">cider-inspect-last-sexp</code> (или <code class="language-plaintext highlighter-rouge">C-x TAB</code>) совмещает два шага: выполнить форму и открыть инспектор с результатом. С ней не понадобиться вызывать их по отдельности.</p>

<p>Полное описание инспектора, его команд и клавиш вы найдете на сайте Cider в <a href="https://docs.cider.mx/cider/debugging/inspector.html">одноименном разделе</a>.</p>

<h3 id="dev-секции">Dev-секции</h3>

<p>Опытные программисты оставляют в файлах так называемые dev sections — области разработки. Это код, который легко выполняют в REPL, чтобы проверить некоторые вычисления. Dev-секция помещается в макрос <code class="language-plaintext highlighter-rouge">comment</code>, чтобы не участвовать в компиляции.</p>

<p>Предположим, вы написали функцию <code class="language-plaintext highlighter-rouge">-&gt;fahr</code> для перевода температуры между шкалой Цельсия и Фаренгейта:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-&gt;fahr</span><span class="w"> </span><span class="p">[</span><span class="n">cel</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">cel</span><span class="w"> </span><span class="mf">1.8</span><span class="p">)</span><span class="w"> </span><span class="mi">32</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы ее проверить, добавьте в конец файла отладочный код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mf">36.6</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Поставьте курсор после закрывающей скобки в первой форме и выполните ее — получится 97.88, что совпадает с ожиданиями. Выполните и другие выражения, в том числе с <code class="language-plaintext highlighter-rouge">nil</code>, чтобы спровоцировать исключение. Если логика функции изменится, вы легко проверите ее работу.</p>

<p>Обратите внимание на следующие моменты. Отладочный код находятся в макросе <code class="language-plaintext highlighter-rouge">comment</code>, который игнорирует содержимое: при компиляции он вырождается в пустоту. Не путайте макрос <code class="language-plaintext highlighter-rouge">comment</code> и комментирование точкой с запятой. Во втором случае форму нельзя выполнить: команда <code class="language-plaintext highlighter-rouge">cider-eval-last-sexp</code> не сработает.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; cannot be evaluated</span><span class="w">
</span><span class="c1">;; (-&gt;fahr 36.6) |</span><span class="w">
</span></code></pre></div></div>

<p>Закрывающая скобка <code class="language-plaintext highlighter-rouge">comment</code> стоит отдельно, чтобы по ошибке не выполнить его вместо последней формы. Покажем это на примере. Предположим, скобка стоит по правилам Lisp-синтаксиса на той же строке:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы выполнить <code class="language-plaintext highlighter-rouge">(-&gt;fahr nil)</code>, курсор ставят между двумя последними скобками:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="err">|</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>На практике легко промахнуться и поставить курсор в конце:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w"> </span><span class="err">|</span><span class="w">
</span></code></pre></div></div>

<p>В этом случае команда <code class="language-plaintext highlighter-rouge">cider-eval</code> выполнит форму <code class="language-plaintext highlighter-rouge">comment</code>, которая вернет <code class="language-plaintext highlighter-rouge">nil</code> вне зависимости от содержимого. Сложится ощущение, что <code class="language-plaintext highlighter-rouge">(-&gt;fahr nil)</code> возвращает <code class="language-plaintext highlighter-rouge">nil</code>, что на самом деле не так. Чтобы этого не случилось, скобку <code class="language-plaintext highlighter-rouge">comment</code> переносят на новую строку.</p>

<p>Некоторые редакторы выделяют форму <code class="language-plaintext highlighter-rouge">comment</code> цветом, чтобы подчеркнуть — это не боевой код, а пример или справка. Если подсветка не работает, попробуйте список с тегом игнорирования <code class="language-plaintext highlighter-rouge">#_</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="n">_</span><span class="w">
</span><span class="p">((</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mf">36.6</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>В результате dev-секция будет окрашена в особый цвет, и вы легко отделите ее от кода.</p>

<p>Код dev-секции может быть с побочным эффектом, например когда вы тестируете HTTP-запросы или базу данных. Проследите, чтобы в коде не было паролей или ключей доступа. Если они необходимы, считайте их из файла или переменной среды:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">
  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">-api-key</span><span class="w">
    </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="s">"API_KEY"</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">-response</span><span class="w">
    </span><span class="p">(</span><span class="nf">make-http-request</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="n">-api-key</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Dev-секции встречаются во многих библиотеках, в том числе Clojure. Например, модуль clojure.zip <a href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L281">содержит блок</a> <code class="language-plaintext highlighter-rouge">comment</code> с набором шагов, где проверяется логика <a href="https://grishaev.me/clj-zippers-1/">зипперов</a>.</p>

<h3 id="сниппеты">Сниппеты</h3>

<p>Чем дольше вы работаете в проекте, тем больше у вас будет сниппетов. Так называют фрагменты кода, которые делают что-то полезное: меняют логирование, посылают HTTP-запросы, выводят служебные данные. У сниппетов особое положение: с одной стороны, им не место в боевом коде. С другой стороны, они полезны в разработке, поэтому их нужно где-то хранить.</p>

<p>Снипеттом может быть запрос к базе, например очистка таблиц или сложная выборка. В разработке сброс таблиц нужен часто, поэтому логично держать сниппет под рукой.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">clojure.java.jdbc/execute!</span><span class="w">
 </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgresql"</span><span class="w">
  </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"test"</span><span class="w">
  </span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
  </span><span class="n">...</span><span class="p">}</span><span class="w">
 </span><span class="p">[</span><span class="s">"truncate users, orders, ... cascade"</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Другой пример — обращение ко внешнему REST API. Это вызов функции <code class="language-plaintext highlighter-rouge">post</code> из библиотеки clj-http с параметрами и заголовками:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">clj-http.client/post</span><span class="w">
 </span><span class="s">"https://internal.api.com/api/v1"</span><span class="w">
 </span><span class="p">{</span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="w">
  </span><span class="no">:content-type</span><span class="w"> </span><span class="no">:json</span><span class="w">
  </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="s">"Authorization"</span><span class="w"> </span><span class="s">"Bearer ..."</span><span class="p">}</span><span class="w">
  </span><span class="no">:form-params</span><span class="w"> </span><span class="p">{</span><span class="no">:event</span><span class="w"> </span><span class="s">"user_created"</span><span class="w">
                </span><span class="no">:user_id</span><span class="w"> </span><span class="mi">10099</span><span class="p">}})</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что в сниппетах используют полные пространства имен. Это нужно для того, чтобы код сработал в любом пространстве, в том числе там, где нет импортов <code class="language-plaintext highlighter-rouge">clj-http.client</code> или <code class="language-plaintext highlighter-rouge">cheshire.core</code>. Сниппеты удобно хранить в отдельном .clj-файле, чтобы выполнять оттуда, не копируя в REPL. Так получается персональная среда разработки.</p>

<p>Cider предлагает особый буфер, чтобы выполнить код на Clojure. Когда вы подключены к nREPL, наберите команду <code class="language-plaintext highlighter-rouge">M-x cider-scratch</code>. Откроется буфер <code class="language-plaintext highlighter-rouge">*cider-scratch*</code>, связанный с текущим проектом. Скопируйте в него любой код. Поместите курсор за нужной формой и нажмите <code class="language-plaintext highlighter-rouge">C-j</code> — на следующей строке появится результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="c1">;; press C-j</span><span class="w">

</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre></div></div>

<p>Особенность <code class="language-plaintext highlighter-rouge">*cider-scratch*</code> в том, что результат не пропадает, а остается в файле для дальнейшей работы. Выполните более сложный пример, нажимая <code class="language-plaintext highlighter-rouge">C-j</code> после каждой формы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.walk</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">walk</span><span class="p">])</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="p">(</span><span class="nf">walk/stringify-keys</span><span class="w"> </span><span class="p">{</span><span class="no">:hello</span><span class="w"> </span><span class="p">{</span><span class="no">:test</span><span class="w"> </span><span class="mi">33</span><span class="p">}})</span><span class="w">
</span><span class="p">{</span><span class="s">"hello"</span><span class="w"> </span><span class="p">{</span><span class="s">"test"</span><span class="w"> </span><span class="mi">33</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Комбинация <code class="language-plaintext highlighter-rouge">C-u C-j</code> печатает результат при помощи <code class="language-plaintext highlighter-rouge">clojure.pprint</code>, то есть с отступами и переносами строк. Опробуйте ее на больших данных, например словаре переменных среды:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">))</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="c1">;; C-j</span><span class="w">
</span></code></pre></div></div>

<p>Пользователи Emacs догадались, что буфер <code class="language-plaintext highlighter-rouge">*cider-scratch*</code> — это аналог обычного <code class="language-plaintext highlighter-rouge">*scratch*</code>. Так называется <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Lisp-Interaction.html">встроенный буфер</a> Emacs, который выполняет код на ELisp. Разница в том, что <code class="language-plaintext highlighter-rouge">*cider-scratch*</code> ожидает код на Clojure и выполняет его в том проекте, в папке с которым находится.</p>

<p>Если сохранить <code class="language-plaintext highlighter-rouge">*cider-scratch*</code>, Emacs запросит путь на диске, потому что по умолчанию буфер не связан с файлом. Введите любое имя, например <code class="language-plaintext highlighter-rouge">scratch.clj</code>. Если открыть его в следующий раз, он будет вести себя как обычный текст: нажатие <code class="language-plaintext highlighter-rouge">C-j</code> перенесет каретку без выполнения кода. Так происходит потому, что при открытии буфер получит базовый режим (fundamental mode). Смените его командой <code class="language-plaintext highlighter-rouge">M-x cider-clojure-interaction-mode</code>, и выполнение кода заработает.</p>

<p>Чтобы не вводить команду каждый раз, воспользуйтесь одним из двух способов. Первый — поместите в начале файла строку:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>; -*- mode: cider-clojure-interaction -*-
</code></pre></div></div>

<p>При открытии файлов Emacs <a href="https://www.gnu.org/software/emacs/manual/html_node/efaq/Associating-modes-with-files.html">учитывает выражения</a>, заключенные в символы <code class="language-plaintext highlighter-rouge">-*-</code>, и выполняет их. Метка <code class="language-plaintext highlighter-rouge">mode</code> означает сменить главный режим буфера.</p>

<p>Второй, более универсальный способ — связать регулярное выражение файла с режимом. Выражение охватывает только имя файла и расширение (путь отбрасывается). В нашем случае правило выглядит так:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">add-to-list</span> <span class="ss">'auto-mode-alist</span> <span class="o">'</span><span class="p">(</span><span class="s">"scratch\.clj"</span> <span class="o">.</span> <span class="nv">cider-clojure-interaction-mode</span><span class="p">))</span>
</code></pre></div></div>

<p>Выполните это выражение в буфере <code class="language-plaintext highlighter-rouge">*scratch*</code>, и изменения вступят в силу немедленно (не забудьте добавить его в конфигурацию Emacs). Закройте и откройте файл <code class="language-plaintext highlighter-rouge">scratch.clj</code> — он перейдет в интерактивный режим.</p>

<p>Чтобы сниппеты не попали в историю git, добавьте имя файла в <code class="language-plaintext highlighter-rouge">.gitignore</code> проекта или глобальные настройки git (файл <code class="language-plaintext highlighter-rouge">~/.gitignore</code> в домашней директории).</p>

<p>Пользу сниппетов трудно переоценить: намного легче найти код по ключевым словам, чем набирать по памяти. Не ленитесь сохранять полезные выражения в файл — в будущем они пригодятся вам и коллегам.</p>

<h2>Все части</h2>

<ul>
  <li><a href="/clj-repl-part-1/">Первая часть</a></li>
  <li><a href="/clj-repl-part-2/">Вторая часть</a></li>
  <li><a href="/clj-repl-part-3/">Третья часть</a></li>
  <li><a href="/clj-repl-part-4/">Четвертая часть</a></li>
</ul>

<!--
Local Variables:
ispell-local-dictionary: "ru"
fill-column: 99999
truncate-lines: nil
End:
-->

    
<div class="prev-next">

    <div class="prev-next-left">
    
        <p><small><a href="/web-files/">&larr; Веб-файлы</a></small></p>
    
    </div>

    <div class="prev-next-mid">
    </div>

    <div class="prev-next-right">
    
        <p><small><a href="/deformation/">Деформация &rarr;</a></small></p>
    
    </div>

</div>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>





<center>
    
    Комментариев пока нет
    
    
</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-repl-part-2/">
    <input required name="captcha" type="hidden" value="2 &#215; 1">

    <div class="block">
        <span class="comment-form-label"><small>2 &#215; 1 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="https://t.me/igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
