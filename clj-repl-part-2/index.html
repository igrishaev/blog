<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>REPL, Cider, Emacs (часть 2/4)</title>
  <meta name="description" content="Все части  Первая часть  Вторая часть  Третья часть  Четвертая часть">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-repl-part-2/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">REPL, Cider, Emacs (часть 2/4)</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2022-08-20T00:00:00+00:00">
        Aug 20, 2022
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/repl/" rel="tag">repl</a>, <a href="/tag/emacs/" rel="tag">emacs</a>, <a href="/tag/cider/" rel="tag">cider</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<h2>Все части</h2>

<ul>
  <li><a href="/clj-repl-part-1/">Первая часть</a></li>
  <li><a href="/clj-repl-part-2/">Вторая часть</a></li>
  <li><a href="/clj-repl-part-3/">Третья часть</a></li>
  <li><a href="/clj-repl-part-4/">Четвертая часть</a></li>
</ul>

<h2>

    Оглавление

</h2>

<ul id="toc-item-clojure-repl-toc">
  <li><a href="#repl-в-редакторе" id="toc-item-clojure-repl-toc-repl-в-редакторе">REPL в редакторе</a>    <ul>
      <li><a href="#недостатки" id="toc-item-clojure-repl-toc-недостатки">Недостатки</a></li>
    </ul>
  </li>
  <li><a href="#знакомство-с-nrepl" id="toc-item-clojure-repl-toc-знакомство-с-nrepl">Знакомство с nREPL</a>    <ul>
      <li><a href="#запуск-nrepl" id="toc-item-clojure-repl-toc-запуск-nrepl">Запуск nREPL</a></li>
      <li><a href="#внутреннее-устройство" id="toc-item-clojure-repl-toc-внутреннее-устройство">Внутреннее устройство</a></li>
      <li><a href="#транспорт" id="toc-item-clojure-repl-toc-транспорт">Транспорт</a></li>
      <li><a href="#middleware" id="toc-item-clojure-repl-toc-middleware">Middleware</a></li>
    </ul>
  </li>
  <li><a href="#подключение-из-clojure" id="toc-item-clojure-repl-toc-подключение-из-clojure">Подключение из Clojure</a>    <ul>
      <li><a href="#коротко-о-bencode" id="toc-item-clojure-repl-toc-коротко-о-bencode">Коротко о Bencode</a></li>
    </ul>
  </li>
  <li><a href="#клиенты-nrepl-для-редакторов" id="toc-item-clojure-repl-toc-клиенты-nrepl-для-редакторов">Клиенты nREPL для редакторов</a></li>
  <li><a href="#emacs-и-cider" id="toc-item-clojure-repl-toc-emacs-и-cider">Emacs и Cider</a>    <ul>
      <li><a href="#первые-шаги" id="toc-item-clojure-repl-toc-первые-шаги">Первые шаги</a></li>
      <li><a href="#выполнение-кода" id="toc-item-clojure-repl-toc-выполнение-кода">Выполнение кода</a></li>
      <li><a href="#dev-секции" id="toc-item-clojure-repl-toc-dev-секции">Dev-секции</a></li>
      <li><a href="#сниппеты" id="toc-item-clojure-repl-toc-сниппеты">Сниппеты</a></li>
    </ul>
  </li>
</ul>

<h2 id="repl-в-редакторе">REPL в редакторе</h2>

<p>До сих пор мы набирали код в терминале, что не совсем удобно. Терминал подходит для коротких команд, но плохо справляется с многострочным кодом. Будет правильно набрать код в редакторе, а затем скопировать в терминал. Заодно сохраните код в файл, чтобы не набирать его в следующий раз.</p>

<p>Со временем вы заметите, что переключение между редактором и терминалом отнимает время. Было бы здорово связать редактор с REPL напрямую. Вы набираете код и с помощью комбинации клавиш выполняете его в REPL. В отдельной области редактор показывает результат. С таким подходом нам доступна мощь обеих сред: REPL и редактора.</p>

<!-- more -->

<p>Описанный способ предлагает <a href="https://www.gnu.org/software/emacs/">Emacs</a> — текстовый редактор с историей более сорока лет. Emacs может запустить любой Лисп, будь то Common Lisp, Scheme или Clojure, и управлять им из редактора. В терминах Emacs запущенный Лисп называется внешним (external) в противоположность встроенному диалекту ELisp. Режим, когда код вычисляется внешним Лиспом, назывыется <em>inferior lisp</em> mode (анг. inferior — низший). Название объясняется тем, что, поскольку режим нацелен на любой Лисп, он поддерживает только базовые операции.</p>

<p>Проведем короткий сеанс REPL из Emacs. Запустите редактор и выполните команду:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x inferior-lisp
</code></pre></div></div>

<p>Emacs запросит путь к программе, которая запускает Лисп. Введите <code class="language-plaintext highlighter-rouge">clojure</code> или <code class="language-plaintext highlighter-rouge">lein repl</code> в зависимости от того, какая утилита у вас установлена. Чтобы не указывать программу каждый раз, объявите в настройках переменную <code class="language-plaintext highlighter-rouge">inferior-lisp-program</code>. Того же эффекта можно добиться, выполнив одно из выражений в буфере <code class="language-plaintext highlighter-rouge">*scratch*</code>:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">setq</span> <span class="nv">inferior-lisp-program</span> <span class="s">"clojure"</span><span class="p">)</span> <span class="c1">;; C-j</span>
<span class="p">(</span><span class="k">setq</span> <span class="nv">inferior-lisp-program</span> <span class="s">"lein repl"</span><span class="p">)</span> <span class="c1">;; C-j</span>
</code></pre></div></div>

<p>Emacs запустит процесс соединится с его каналами ввода и вывода. В буфере <em>inferior-lisp</em> появится сеанс REPL. Он работает как в терминале: ожидает выражение, вычисляет, печатает и снова ожидает.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Clojure</span><span class="w"> </span><span class="mf">1.10</span><span class="n">.1</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">6</span><span class="w">
</span></code></pre></div></div>

<p>Но поскольку это не терминал, а буфер Emacs, нам доступно больше возможностей. Можно свободно перемещаться по всему буферу, копировать и вставлять код, искать в прямом и обратном направлении, сохранить буфер в файл и многое другое.</p>

<p>Особые команды передают код из редактора в REPL без ручного копирования. Переключитесь в буфер с кодом на Clojure и включите режим Lisp командой:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x lisp-mode
</code></pre></div></div>

<p>Установите курсор после закрывающей скобки любого выражения, например <code class="language-plaintext highlighter-rouge">(+ 1 2)</code>. Выполните команду</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x lisp-eval-last-sexp
</code></pre></div></div>

<p>, которая означает выполнить последнее S-выражение. В буфере <code class="language-plaintext highlighter-rouge">*inferior-lisp*</code> появится результат:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user=&gt; 3
</code></pre></div></div>

<p>Эффект аналогичен тому, как если бы вы скопировали код, вставили в REPL и нажали Enter. Заметим, что выражение не обязательно должно быть на верхнем уровне модуля. Легко выполнить форму, которая находится внутри другой формы. Предположим, в вашем файле следующий код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"inner form"</span><span class="p">)</span><span class="w"> </span><span class="err">|</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Подведите курсор за выражение <code class="language-plaintext highlighter-rouge">...form")</code> на место вертикальной черты. Выполните <code class="language-plaintext highlighter-rouge">lisp-eval-last-sexp</code>, и REPL вычислит форму <code class="language-plaintext highlighter-rouge">(println "inner form")</code>. Таким образом можно выполнить форму в любом месте кода, если она не зависит от внешних переменных.</p>

<p>Команды с приставкой <code class="language-plaintext highlighter-rouge">lisp-eval-...</code> отвечают за то, какую часть файла выполнить в REPL. Например, <code class="language-plaintext highlighter-rouge">lisp-eval-region</code> отправит только выделенную область, а <code class="language-plaintext highlighter-rouge">lisp-eval-defun</code> — функцию, на которой сейчас установлен курсор. Команды с окончанием <code class="language-plaintext highlighter-rouge">...-and-go</code> делают то же самое, но дополнительно переключат вас в REPL.</p>

<p>Проделайте упражнения из разделов выше. Подключите встроенные модули, объявите несколько функций, спровоцируйте исключение.</p>

<p>Обратите внимание, что команды <code class="language-plaintext highlighter-rouge">lisp-eval-...</code> вычисляют код без учета текущего пространства. Контроль за тем, в каком пространстве пребывает REPL, ложится на вас. Если вы работаете с двумя и более модулями, это станет проблемой. Легко объявить функцию в одном пространстве:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">test1</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>и вызвать в другом, что приведет к ошибке:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ns test2)

(add 1 2)

test2=&gt; Syntax error compiling at (REPL:1:1).
Unable to resolve symbol: add in this context
</code></pre></div></div>

<p>Эта проблема решена в более продвинутых системах. О них мы поговорим уже скоро.</p>

<p>Запуск REPL из Emacs может показаться примитивным подходом, но на самом деле это не так. Вам доступны все возможности Clojure и Emacs одновременно. Для эффективной работы с Clojure требуется не так уж много команд: выполнить s-выражение, регион или def-определение.</p>

<p><a href="https://batsov.com/articles/2014/12/04/introducing-inf-clojure-a-better-basic-clojure-repl-for-emacs/">По словам Рича Хикки</a>, автора Clojure, он работал над языком, используя Emacs и режим <code class="language-plaintext highlighter-rouge">inferior-lisp</code>. Это подтверждает: можно достичь значимых результатов малыми средствами. И хотя сегодня для Clojure созданы более мощные инструменты, полезно знать этот спартанский метод.</p>

<h3 id="недостатки">Недостатки</h3>

<p>Способ, когда Emacs запускает внешний Лисп, не лишен недостатков. Перечислим наиболее важные их них.</p>

<p>Обмен данными между средами происходит по стандартным каналам операционной системы (stdin, stdout и stderr). Скорость их передачи ниже, чем по сети, что особенно заметно на больших файлах.</p>

<p>Интерпретатор Лиспа, его библиотеки и окружение должны быть установлены локально. Без специальных ухищрений нельзя подключиться к Лиспу, запущенному на удаленной машине.</p>

<p>Данные, что передают друг другу Emacs и REPL, никак не структурированы — это текст. Из-за этого Emacs выводит ответы как есть без каких-либо улучшений. Это сделано намеренно, поскольку режим <code class="language-plaintext highlighter-rouge">inferior-lisp</code> рассчитан на любой REPL, будь то Common Lisp, Racket или Clojure.</p>

<p>Ради справедливости заметим, что в Clojure REPL поддерживает сетевой режим. Чтобы его включить, передайте следующие аргументы:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clojure <span class="nt">-J-Dclojure</span>.server.repl<span class="o">=</span><span class="s2">"{:port 5555 :accept clojure.core.server/repl}"</span>
</code></pre></div></div>

<p>Теперь REPL принимает данные не только с клавиатуры, но и с порта 5555. Чтобы это проверить, подключимся к локальному серверу через telnet:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; telnet 127.0.0.1 5555

Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
user=&gt; (defn add [a b]
         (+ a b))
#'user/add
</code></pre></div></div>

<p>В результате <code class="language-plaintext highlighter-rouge">telnet</code> работает как обычный REPL; разница в том, что данные передаются по сети. Подключитесь по <code class="language-plaintext highlighter-rouge">telnet</code> с другой машины, на которой нет Clojure. Введите несколько выражений: сумму чисел, объявление def и другие. Перейдите к машине, где запущен REPL и убедитесь, что изменения, проделанные удаленно, вступили в силу.</p>

<p>Хотя сетевой режим снимает одну из проблем, озвученных выше, особой популярности он не получил. Данные по-прежнему передаются плоским текстом, что мешает эффективному обмену. Со временем появился проект nREPL, который закрывает этот недостаток, а также многие другие.</p>

<h2 id="знакомство-с-nrepl">Знакомство с nREPL</h2>

<p>В названии <a href="https://nrepl.org">nREPL</a> буква n означает network, то есть сетевой REPL. Проект нацелен на то, чтобы обеспечить работу в REPL по сети. В отличие от терминала, nREPL обладает более сложной архитектурой; перечислим ее главные свойства.</p>

<p>Сервер nREPL принимает команды по сетевому протоколу TCP. С одним проектом могут работать несколько клиентов. Сервер может быть запущен на удаленной машине или в изолированном окружении (Docker, VirtualBox).</p>

<p>Сообщения nREPL обладают структурой. Каждое из них содержит номер сеанса, тип операции, ее аргументы и текущее пространство имен. Сообщение легко дополнить или изменить при помощи промежуточных слоев — middleware.</p>

<p>nREPL опирается на транспорт сообщений. Транспортом называют соглашение о том, как писать и читать сообщения. По умолчанию nREPL предлагает транспорты Bencode, EDN и TTY. Создать новый транспорт означает расширить протокол из библиотеки.</p>

<p>Обычный REPL работает синхронно: получив команду с клавиатуры, он не принимает текст до тех пор, пока не вычислит и напечатает результат. nREPL устроен асинхронно: в ответ на одну операцию он может прислать несколько сообщений. По специальному полю клиент определяет, последнее это сообщение или нет.</p>

<p>Технически nREPL — библиотека, доступная в Clojars. У нее нет зависимостей, что упрощает развитие и поддержку. Несмотря на свою роль в экосистеме Clojure, nREPL остается отдельным, а не встроенным модулем. С таким подходом он не зависит от цикла версий Clojure.</p>

<h3 id="запуск-nrepl">Запуск nREPL</h3>

<p>Чтобы запустить сеанс nREPL вместо обычного REPL, добавьте библиотеку в проект. Если вы пользуетесь lein, откройте файл <code class="language-plaintext highlighter-rouge">project.clj</code> и расширьте зависимости:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">...</span><span class="w">
 </span><span class="no">:dependencies</span><span class="w">
 </span><span class="p">[</span><span class="n">...</span><span class="w"> </span><span class="p">[</span><span class="n">nrepl/nrepl</span><span class="w"> </span><span class="s">"0.9.0"</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<p>Сохраните файл и выполните <code class="language-plaintext highlighter-rouge">lein repl</code>. Утилита <code class="language-plaintext highlighter-rouge">lein</code> устроена так, что если nREPL найден в зависимостях, предпочтение отдается ему. Убедиться, что вы запустили именно nREPL можно по фразе “nREPL server started”, которая появится в терминале:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; lein repl

nREPL server started on port 52002 on host 127.0.0.1 - nrepl://127.0.0.1:52002
REPL-y 0.4.4, nREPL 0.8.3
Clojure 1.10.1
OpenJDK 64-Bit Server VM 11.0.12+6-jvmci-21.2-b08
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&gt;
</code></pre></div></div>

<p>В случае с <code class="language-plaintext highlighter-rouge">deps.edn</code> укажите профиль <code class="language-plaintext highlighter-rouge">:nrepl</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:aliases</span><span class="w">
 </span><span class="p">{</span><span class="no">:nrepl</span><span class="w">
  </span><span class="p">{</span><span class="no">:extra-deps</span><span class="w">
   </span><span class="p">{</span><span class="n">nrepl/nrepl</span><span class="w"> </span><span class="p">{</span><span class="no">:mvn/version</span><span class="w"> </span><span class="s">"0.9.0"</span><span class="p">}}</span><span class="w">
   </span><span class="no">:main-opts</span><span class="w"> </span><span class="p">[</span><span class="s">"-m"</span><span class="w"> </span><span class="s">"nrepl.cmdline"</span><span class="w"> </span><span class="s">"-i"</span><span class="p">]}}}</span><span class="w">
</span></code></pre></div></div>

<p>Ключ <code class="language-plaintext highlighter-rouge">-i</code> в <code class="language-plaintext highlighter-rouge">:main-opts</code> означает интерактивный режим, то есть с вводом с клавиатуры. Без него nREPL работает в “безголовом” режиме, слушая только сетевой порт. Запустите утилиту <code class="language-plaintext highlighter-rouge">clj</code> с профилем <code class="language-plaintext highlighter-rouge">:nrepl</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; clj -M:nrepl

nREPL server started on port 55113 on host localhost - nrepl://localhost:55113
nREPL 0.9.0
Clojure 1.11.1
OpenJDK 64-Bit Server VM 11.0.12+6-jvmci-21.2-b08
Interrupt: Control+C
Exit:      Control+D or (exit) or (quit)
user=&gt;
</code></pre></div></div>

<p>На первый взгляд nREPL не отличается от обычного REPL. Он по-прежнему ожидает ввода с клавиатуры, вычисляет выражение и печатает результат. Истинная мощь nREPL проявляется в работе из редактора, и уже скоро мы дойдем до этого раздела.</p>

<p>После запуска nREPL вы обнаружите файл <code class="language-plaintext highlighter-rouge">.nrepl-port</code> в папке проекта. Если не указать порт явно, nREPL случайно выберет свободный порт для подключения. Дополнительно он запишет порт в файл, чтобы клиент прочитал его, не запрашивая у пользователя.</p>

<p>Выше мы указали nREPL в главных зависимостях проекта — векторе <code class="language-plaintext highlighter-rouge">:dependencies</code> формы <code class="language-plaintext highlighter-rouge">defproject</code>. Поскольку nREPL относится к разработке, поместим его в профиль <code class="language-plaintext highlighter-rouge">:dev</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:profiles</span><span class="w">
</span><span class="p">{</span><span class="no">:dev</span><span class="w"> </span><span class="p">{</span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">nrepl/nrepl</span><span class="w"> </span><span class="s">"0.9.0"</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<p>В этом случае nREPL доступен при запуске <code class="language-plaintext highlighter-rouge">lein repl</code>, потому что профиль <code class="language-plaintext highlighter-rouge">:dev</code> подключается по умолчанию. При сборке проекта его не окажется в зависимостях. Это легко проверить, вызвав команду <code class="language-plaintext highlighter-rouge">deps :tree</code> с профилем <code class="language-plaintext highlighter-rouge">uberjar</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lein with-profile uberjar deps :tree | <span class="nb">grep </span>nrepl
<span class="p">;;</span> nothing
</code></pre></div></div>

<p>Быстро окажется, что nREPL нужен во всех проектах.Чтобы не добавлять его в каждый <code class="language-plaintext highlighter-rouge">project.clj</code>, прибегают к пользовательскому профилю. Создайте файл <code class="language-plaintext highlighter-rouge">~/.lein/profiles.clj</code> со словарем внутри. В поле <code class="language-plaintext highlighter-rouge">:user</code> разместите вложенный словарь с зависимостями. Утилита <code class="language-plaintext highlighter-rouge">lein</code> объединит его с полем <code class="language-plaintext highlighter-rouge">:profiles</code> при запуске.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="p">{</span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">nrepl/nrepl</span><span class="w"> </span><span class="s">"0.9.0"</span><span class="p">]]}}</span><span class="w">
</span></code></pre></div></div>

<p>Теперь по команде <code class="language-plaintext highlighter-rouge">lein repl</code> запусится nREPL, неважно указан ли он в <code class="language-plaintext highlighter-rouge">project.clj</code> или нет. Это особенно полезно, когда с проектом работают несколько человек и их редакторы требуют разные версии nREPL (например, Cider и Calva). Каждый укажет свою версию в файле <code class="language-plaintext highlighter-rouge">~/.lein/profiles.clj</code>, избежав конфликта.</p>

<p>Если вы используете Clojure CLI, похожий файл называется <code class="language-plaintext highlighter-rouge">~/.clojure/deps.edn</code>. При запуске <code class="language-plaintext highlighter-rouge">clj</code> или <code class="language-plaintext highlighter-rouge">clojure</code> он дополняет текущий файл <code class="language-plaintext highlighter-rouge">deps.edn</code>. Перенесите профиль <code class="language-plaintext highlighter-rouge">:nrepl</code>, что мы создали выше, в этот файл. Чтобы подчеркнуть, что это локальный профиль, добавьте ему пространство <code class="language-plaintext highlighter-rouge">local</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:aliases</span><span class="w">
 </span><span class="p">{</span><span class="no">:local/nrepl</span><span class="w">
  </span><span class="p">{</span><span class="no">:extra-deps</span><span class="w"> </span><span class="p">{</span><span class="n">nrepl/nrepl</span><span class="w"> </span><span class="p">{</span><span class="no">:mvn/version</span><span class="w"> </span><span class="s">"0.9.0"</span><span class="p">}}</span><span class="w">
   </span><span class="no">:main-opts</span><span class="w"> </span><span class="p">[</span><span class="s">"-m"</span><span class="w"> </span><span class="s">"nrepl.cmdline"</span><span class="p">]}}}</span><span class="w">
</span></code></pre></div></div>

<p>Включите проект командой:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> clj <span class="nt">-M</span>:local/nrepl
</code></pre></div></div>

<p>Поведение nREPL меняют с помощью параметров проекта. В <code class="language-plaintext highlighter-rouge">lein</code> для этого служит ключ <code class="language-plaintext highlighter-rouge">:repl-options</code>. Перечислим опции, которые понадобятся чаще других.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:port</code> — сетевой порт, по которому nREPL принимает сообщения от клиентов. Если не задан, будет случайно выбран любой свободный порт. В редких случаях порт указывают явно, например когда nREPL запущен в Docker или на удаленной машине — эти случаи мы рассмотрим в конце главы).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:prompt</code> — функция приглашения. Принимает один аргумент — текущее пространство имен — и по умолчанию выводит его имя.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:init-ns</code> — символ пространства, которое nREPL загрузит при запуске. В разработке указывают пространства <code class="language-plaintext highlighter-rouge">dev</code>, <code class="language-plaintext highlighter-rouge">user</code> или <code class="language-plaintext highlighter-rouge">sandbox</code> — своего рода песочницу, в которой собраны служебные функции. Например, запуск системы, прогон миграций, ping-запросы к серверам и многое другое.</p>
  </li>
</ul>

<p>Конфигурация nREPL с нестандартными параметрами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">...</span><span class="w">
  </span><span class="no">:repl-options</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">9911</span><span class="w">
                 </span><span class="no">:init-ns</span><span class="w"> </span><span class="n">dev</span><span class="w">
                 </span><span class="no">:prompt</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">current-ns</span><span class="p">]</span><span class="w">
                           </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"[%s] &gt;&gt; "</span><span class="w"> </span><span class="n">current-ns</span><span class="p">))}}</span><span class="w">
</span></code></pre></div></div>

<p>Вот как с ними выглядит приглашение:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>dev] <span class="o">&gt;&gt;</span> <span class="o">(</span>+ 1 2 3<span class="o">)</span>
6
</code></pre></div></div>

<p>Остальные параметры вы найдете в документации проектов <a href="https://github.com/technomancy/leiningen/blob/master/sample.project.clj#L368">lein</a> и <a href="https://nrepl.org/nrepl/usage/server.html">nREPL</a>.</p>

<h3 id="внутреннее-устройство">Внутреннее устройство</h3>

<p>Архитектура nREPL состоит из нескольких частей: обработчика запроса, middleware и транспорта. В этом плане nREPL напоминает <a href="https://github.com/ring-clojure/ring">Ring</a>: большую роль в нем играет спецификация — соглашение о том, как устроена та или иная часть. При этом код относительно мал в сравнении со смысловой нагрузкой.</p>

<p>Коротко опишем каждый уровень nREPL. Обработчик (<code class="language-plaintext highlighter-rouge">handler</code>) — это функция одного аргумента, которая принимает словарь сообщения. В nREPL сообщения структурированы, то есть разбиты на поля. По полю <code class="language-plaintext highlighter-rouge">:op</code> (operation) функция понимает, что от нее требуется, и выполняет действие. Вот как выглядит сообщение с командой выполнить код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w"> </span><span class="no">:code</span><span class="w"> </span><span class="s">"(+ 1 2 3)"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>и ответ на него:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:session</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:value</span><span class="w"> </span><span class="mi">6</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Мы привели сообщения в формате EDN для читаемости. На уровне транспорта они кодируются и выглядят иначе. На месте многоточий должны быть длинные идентификаторы, которые мы сократили за ненадобностью.</p>

<p>Хотя nREPL сравнивают с Ring, обработчик в nREPL устроен сложнее. В Ring обработчик возвращает словарь ответа. Некоторые обработчики бывают чистыми функциями, то есть такими, чей результат зависит только от входных данных, например сумма параметров <code class="language-plaintext highlighter-rouge">a</code> и <code class="language-plaintext highlighter-rouge">b</code>. Логично ожидать, что обработчик nREPL возвращает словарь, который будет передан в транспорт, но практике это не так.</p>

<p>Сообщение, переданное обработчику, содержит поле :transport с текущим объектом транспорта. Чтобы отправить ответ клиенту, нужно вызвать метод send транспорта со словарем ответа:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="p">[{</span><span class="no">:as</span><span class="w"> </span><span class="n">message</span><span class="w">
                </span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">transport</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">code</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="n">...</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">t/send</span><span class="w"> </span><span class="n">transport</span><span class="w"> </span><span class="p">{</span><span class="no">:value</span><span class="w"> </span><span class="n">value</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Результат обработчика при этом отбрасывается; важно только то, что мы отправили в транспорт. При таком подходе обработчик теряет чистоту и усложняет тестирование. Это не ошибка дизайна, а вынужденные меры, связанные с архитектурой.</p>

<p>Напомним, что на одно сообщение nREPL может вернуть несколько ответов. Передача может быть асинхронной и с задержками между ответами. Простейший случай, когда ответов несколько — вычисление двух форм за раз. Для этого выделим в редакторе две формы и выполним <code class="language-plaintext highlighter-rouge">M-x cider-eval-region</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>На сервер уйдет сообщение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w"> </span><span class="no">:code</span><span class="w"> </span><span class="s">"(+ 1 2 3)(+ 1 2 3 4)"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>В ответ получим три сообщения: по одному на каждую форму плюс завершающее, которое означает, что задача окончена:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:session</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:value</span><span class="w"> </span><span class="s">"6"</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:session</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:value</span><span class="w"> </span><span class="s">"10"</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:session</span><span class="w"> </span><span class="s">"..."</span><span class="w"> </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"done"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>У всех трех сообщений одинаковый ID, чтобы понять, к какому запросу они относятся.</p>

<p>Очевидно, если бы обработчик был чистой функцией, он должен был вернуть список ответов. Но список нельзя отправить клиенту, пока не вычислен последний элемент. В этом случае мы вынудим клиента ждать до тех пор, пока не будут готовы все ответы. Это неоптимально: гораздо лучше отправлять сообщения по мере готовности.</p>

<h3 id="транспорт">Транспорт</h3>

<p>В терминах nREPL транспорт — это соглашение о том, в каком виде передавать сообщения. Чтобы клиент и сервер понимали друг друга, они должны использовать одинаковый транспорт. На уровне кода это объект, реализующий протокол <code class="language-plaintext highlighter-rouge">nrepl.transport.Transport</code>. В него входят методы recv и send, которые отвечают за прием и отправку сообщений.</p>

<p>nREPL предлагает три транспорта: Bencode, EDN и TTY. Мы перечислили их по убыванию важности. Большинство клиентов используют Bencode, поэтому он задан по умолчанию, если не указан иной транспорт. Bencode опирается на одноименный формат данных, популярный в сети BitTorrent. Мы рассмотрим его чуть позже.</p>

<p>Транспорт EDN передает данные в формате, принятом в Clojure. Его используют в ClojureScript, поскольку там возможностей Bencode не хватает, чтобы покрыть все типы данных. Транспорт TTY предназначен для подключения из терминала. Это наиболее скудный формат, которым пользуются в крайних случаях.</p>

<h3 id="middleware">Middleware</h3>

<p>По аналогии с Ring, middleware — это прослойка между запросом и обработчиком. Задача middleware в том, чтобы расширить логику сервера, не меняя обработчик.</p>

<p>Предположим, мы бы хотели, чтобы команда “classpath” вернула текущий список <a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">путей JVM</a>. Для этого напишем middleware с логикой: если поле <code class="language-plaintext highlighter-rouge">:op</code> сообщения равно “classpath”, отправить сообщение со списком строк. В противном случае вызвать обработчик по умолчанию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-classpath</span><span class="w"> </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[{</span><span class="no">:as</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">op</span><span class="w"> </span><span class="n">transport</span><span class="p">]}]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"classpath"</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">paths</span><span class="w"> </span><span class="p">(</span><span class="nf">get-classpath</span><span class="w"> </span><span class="n">...</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">t/send</span><span class="w"> </span><span class="n">transport</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="w"> </span><span class="no">:classpath</span><span class="w"> </span><span class="n">paths</span><span class="p">}))</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">msg</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Как и в Ring, цепочка middleware образует стек. В примере выше переменная handler не обязательно конечный обработчик nREPL. Скорей всего, он многократно обернут другими middleware, что идут ниже по стеку.</p>

<p>Проект Cider, о который мы скоро рассмотрим, предлагает <a href="https://github.com/clojure-emacs/cider-nrepl/tree/master/src/cider/nrepl/middleware">множество подобных middleware</a>. Вместе они радикально расширяют возможности nREPL.</p>

<h2 id="подключение-из-clojure">Подключение из Clojure</h2>

<p>Опробуем nREPL на практике: подключимся к серверу и выполним несколько выражений. Пока что мы не знаем, как подключиться из редактора, поэтому воспользуемся встроенным клиентом на Clojure. У нас будет два сеанса nREPL: первый в роли сервера, второй в качестве клиента.</p>

<p>Запустите оба сеанса командой <code class="language-plaintext highlighter-rouge">lein repl</code> или <code class="language-plaintext highlighter-rouge">clj -M:nrepl</code>. Напомним, библиотека <code class="language-plaintext highlighter-rouge">nrepl/nrepl</code> должна быть указана в профиле по умолчанию (файлы <code class="language-plaintext highlighter-rouge">~/.lein/profiles.clj</code> и <code class="language-plaintext highlighter-rouge">~/.clojure/deps.edn</code>). Запомните порт первого сеанса (в случае автора это 50411). Его можно увидеть в терминале при nREPL или в файле <code class="language-plaintext highlighter-rouge">.nrepl-port</code> той директории, где запущен сеанс.</p>

<p>Во втором сеансе выполните:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">nrepl.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">nrepl</span><span class="p">])</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/connect</span><span class="w"> </span><span class="no">:port</span><span class="w"> </span><span class="mi">50411</span><span class="p">))</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/client</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="mi">1000</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Код подключит вас к удаленному nREPL. Объект <code class="language-plaintext highlighter-rouge">client</code> отвечает за отправку и получение сообщений. Для начала сложим несколько чисел. Отправим сообщение с операцией <code class="language-plaintext highlighter-rouge">eval</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w"> </span><span class="no">:code</span><span class="w"> </span><span class="s">"(+ 1 2 3)"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Получим два ответа: первый с результатом, второй с признаком окончания:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">({</span><span class="no">:id</span><span class="w"> </span><span class="s">"1ac6cbc4-74d4-4b3a-bf3f-97dcf7ca07c2"</span><span class="w">
  </span><span class="no">:ns</span><span class="w"> </span><span class="s">"my-repl"</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"fec9d5a3-3c22-4640-b089-c1cecc041068"</span><span class="w">
  </span><span class="no">:value</span><span class="w"> </span><span class="s">"6"</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"1ac6cbc4-74d4-4b3a-bf3f-97dcf7ca07c2"</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"fec9d5a3-3c22-4640-b089-c1cecc041068"</span><span class="w">
  </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"done"</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Проверим, что случится, если возникнет исключение. Поделим число на ноль:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w"> </span><span class="no">:code</span><span class="w"> </span><span class="s">"(/ 0 0)"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Ответ:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">({</span><span class="no">:err</span><span class="w"> </span><span class="s">"Execution error (ArithmeticException) at my-repl/eval5984 (form-init9833672407535844907.clj:1).\nDivide by zero\n"</span><span class="w">
  </span><span class="no">:id</span><span class="w"> </span><span class="s">"a8444b3c-7b54-4e04-9b48-04b8bda170f4"</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"17d02cb6-45ff-464c-a01c-c87da89cdfa7"</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:ex</span><span class="w"> </span><span class="s">"class java.lang.ArithmeticException"</span><span class="w">
  </span><span class="no">:id</span><span class="w"> </span><span class="s">"a8444b3c-7b54-4e04-9b48-04b8bda170f4"</span><span class="w">
  </span><span class="no">:root-ex</span><span class="w"> </span><span class="s">"class java.lang.ArithmeticException"</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"17d02cb6-45ff-464c-a01c-c87da89cdfa7"</span><span class="w">
  </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"eval-error"</span><span class="p">]}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"a8444b3c-7b54-4e04-9b48-04b8bda170f4"</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"17d02cb6-45ff-464c-a01c-c87da89cdfa7"</span><span class="w"> </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"done"</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Мы получили краткие сведения об исключении: класс, текст и последний элемент стектрейса. Сбором этих данных занимается функция, которую можно переопределить параметром <code class="language-plaintext highlighter-rouge">:nrepl.middleware.caught/caught</code>. Функция должна быть объявлена на сервере, поэтому в сообщении передают путь к ней, а не объект функции:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:nrepl.middleware.caught/caught</span><span class="w"> </span><span class="ss">'project.util/caught-func</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Убедимся, что изменения доступны на сервере. С помощью клиента объявите функцию <code class="language-plaintext highlighter-rouge">add</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w"> </span><span class="no">:code</span><span class="w"> </span><span class="s">"
(defn add [a b]
  (+ a b))
"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Переключитесь в первый терминал с сервером. Выполните в терминале <code class="language-plaintext highlighter-rouge">(add 1 2)</code> — функция сработает без ошибок.</p>

<p>Другая полезная команда называется <code class="language-plaintext highlighter-rouge">lookup</code>. Она принимает символ и возвращает данные о переменной, связанной с ним. Данные содержат путь к исходному файлу, позиция в нем, документация и сигнатуры. На <code class="language-plaintext highlighter-rouge">lookup</code> завязаны важные функции редактора: переход к определению, вывод документации, всплывающее окно с сигнатурой вызова по мере набора. Запросим информацию о символе <code class="language-plaintext highlighter-rouge">+</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"lookup"</span><span class="w"> </span><span class="no">:sym</span><span class="w"> </span><span class="s">"+"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Символ может быть как с пространством, так и без него. Во втором случае поиск происходит в текущем пространстве имен. В ответ получим все необходимое для перехода к определению (файл, строка), вызова (список аргументов) и документации (поле <code class="language-plaintext highlighter-rouge">:doc</code>):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">({</span><span class="no">:id</span><span class="w"> </span><span class="s">"e66092b8-c6aa-49a9-9cff-cc3557e421c6"</span><span class="n">,</span><span class="w">
  </span><span class="no">:info</span><span class="w"> </span><span class="p">{</span><span class="no">:protocol</span><span class="w"> </span><span class="s">""</span><span class="n">,</span><span class="w">
         </span><span class="no">:added</span><span class="w"> </span><span class="s">"1.2"</span><span class="n">,</span><span class="w">
         </span><span class="no">:ns</span><span class="w"> </span><span class="s">"clojure.core"</span><span class="n">,</span><span class="w">
         </span><span class="no">:name</span><span class="w"> </span><span class="s">"+"</span><span class="n">,</span><span class="w">
         </span><span class="no">:file</span><span class="w"> </span><span class="s">"jar:file:/Users/ivan/.m2/repository/org/clojure/clojure/1.10.0/clojure-1.10.0.jar!/clojure/core.clj"</span><span class="n">,</span><span class="w">
         </span><span class="no">:arglists-str</span><span class="w"> </span><span class="s">"([] [x] [x y] [x y &amp; more])"</span><span class="n">,</span><span class="w">
         </span><span class="no">:column</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w">
         </span><span class="no">:line</span><span class="w"> </span><span class="mi">984</span><span class="n">,</span><span class="w">
         </span><span class="no">:arglists</span><span class="w"> </span><span class="s">"([] [x] [x y] [x y &amp; more])"</span><span class="n">,</span><span class="w">
         </span><span class="no">:doc</span><span class="w"> </span><span class="s">"Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'"</span><span class="p">}</span><span class="n">,</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"63a4ba3f-6a19-4597-919d-3136ebbfa1cb"</span><span class="n">,</span><span class="w">
  </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"done"</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Команда <code class="language-plaintext highlighter-rouge">completions</code> возвращает список определений по префиксу. Это полезно, когда пользователь ввел часть текста и ожидает выпадающее окно с вариантами. Например, функции семейства <code class="language-plaintext highlighter-rouge">ex-...</code> служат для работы с исключениями. Проверим, что найдет сервер по префиксу <code class="language-plaintext highlighter-rouge">ex-</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"completions"</span><span class="w"> </span><span class="no">:prefix</span><span class="w"> </span><span class="s">"ex-"</span><span class="p">})</span><span class="w">

</span><span class="p">({</span><span class="no">:completions</span><span class="w">
  </span><span class="p">[{</span><span class="no">:candidate</span><span class="w"> </span><span class="s">"ex-cause"</span><span class="n">,</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="s">"function"</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:candidate</span><span class="w"> </span><span class="s">"ex-data"</span><span class="n">,</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="s">"function"</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:candidate</span><span class="w"> </span><span class="s">"ex-info"</span><span class="n">,</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="s">"function"</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:candidate</span><span class="w"> </span><span class="s">"ex-message"</span><span class="n">,</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="s">"function"</span><span class="p">}]</span><span class="n">,</span><span class="w">
  </span><span class="no">:id</span><span class="w"> </span><span class="s">"e6f3b77b-5689-484e-8743-76f9682caaa7"</span><span class="n">,</span><span class="w">
  </span><span class="no">:session</span><span class="w"> </span><span class="s">"f15bb73c-e3f9-49c8-8aa5-0ebc592d038d"</span><span class="n">,</span><span class="w">
  </span><span class="no">:status</span><span class="w"> </span><span class="p">[</span><span class="s">"done"</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Получили четыре функции для работы с исключениями.</p>

<p>nREPL поддерживает другие полезные команды, например <code class="language-plaintext highlighter-rouge">:load-file</code> для загрузки кода из файла. При этом сообщение передает не путь к файлу на сервере, а его содержимое и метаданные. Создайте файл <code class="language-plaintext highlighter-rouge">src/sample.clj</code> с кодом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">sample</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">multiply</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>После чего отправьте его на сервер (функция <code class="language-plaintext highlighter-rouge">slurp</code> читает файл в строку):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"load-file"</span><span class="w">
                       </span><span class="no">:file</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="s">"src/sample.clj"</span><span class="p">)})</span><span class="w">
</span></code></pre></div></div>

<p>Код из файла будет скомпилируется на сервере. Появится новое пространство имен sample. Перейдите в терминал сервера и обратитесь к новой функции:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">sample/multiply</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="mi">12</span><span class="w">
</span></code></pre></div></div>

<p>При помощи <code class="language-plaintext highlighter-rouge">:load-file</code> редактор загружает код на сервер. По аналогии с <code class="language-plaintext highlighter-rouge">eval</code>, <code class="language-plaintext highlighter-rouge">load-file</code> принимает дополнительные параметры, которые вы найдете в документации.</p>

<p>Мы не будем досконально перечислять все команды nREPL. Любопытный читатель найдет их на <a href="https://nrepl.org/nrepl/ops.html">странице документации</a>. Завершим этот раздел тем, что вызовем команду <code class="language-plaintext highlighter-rouge">close</code>. Она принимает строго один параметр — номер сессии — и освобождает ресурсы, связанные с ней:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">nrepl/message</span><span class="w"> </span><span class="n">client</span><span class="w">
               </span><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"close"</span><span class="w">
                </span><span class="no">:session</span><span class="w"> </span><span class="s">"97ec6c4b-28ee-4402-87e3-43f3275a7430"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<h3 id="коротко-о-bencode">Коротко о Bencode</h3>

<p>Давайте исследуем трафик, которым обмениваются клиент и сервер nREPL. Пока открыты оба сеанса, запустите команду <code class="language-plaintext highlighter-rouge">tcpdump</code> для записи трафика в файл. В системах Linux и MacOS утилита доступна по умолчанию. <code class="language-plaintext highlighter-rouge">Tcpdump</code> требует привилегий суперпользователя, поэтому запускается через <code class="language-plaintext highlighter-rouge">sudo</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sudo</span><span class="w"> </span><span class="n">tcpdump</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="mi">50411</span><span class="w"> </span><span class="n">-i</span><span class="w"> </span><span class="n">lo0</span><span class="w"> </span><span class="n">-w</span><span class="w"> </span><span class="n">nrepl.log</span><span class="w">
</span></code></pre></div></div>

<p>Число 50411 — это порт сервера nREPL, а <code class="language-plaintext highlighter-rouge">nrepl.log</code> — файл, куда писать TCP-пакеты. После запуска <code class="language-plaintext highlighter-rouge">tcpdump</code> переключитесь в терминал клиента и выполните несколько действий. Завершите tcpdump нажатием <code class="language-plaintext highlighter-rouge">Ctrl+C</code>.</p>

<p>Изучите полученный файл в программе <a href="https://www.wireshark.org">Wireshark</a>. Это бесплатное приложение для анализа сетевого трафика. Содержимое файла в этой программе выглядит примерно так (переносы строк отделяют запрос и ответ):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d4:code9:(+ 1 2 3)2:id36:c88f2dcb-d502-4c90-9529-2dd843bc56d02:op4:evale
d2:id36:c88f2dcb-d502-4c90-9529-2dd843bc56d02:ns7:my-repl7:session36:1fdd9575-881e-4be1-80ca-dd8e64bdff185:value1:6e
</code></pre></div></div>

<p>Каждая строка — структура данных в <a href="https://en.wikipedia.org/wiki/Bencode">формате Bencode</a>. Формат пришел из протокола BitTorrent, и позже его переняли другие системы, в том числе nREPL. Bencode передает числа, строки, словари и списки. Несмотря на меньший по сравнению с JSON набор типов, у формат обладает решительным преимуществом — простотой.</p>

<p>Описание формата займет не больше страницы. Числа записываются в виде <code class="language-plaintext highlighter-rouge">i&lt;число&gt;e</code>, например <code class="language-plaintext highlighter-rouge">i2020e</code> означает <code class="language-plaintext highlighter-rouge">2020</code>. Цепочка байтов — в виде <code class="language-plaintext highlighter-rouge">&lt;длина&gt;:&lt;содержимое&gt;</code>; строка <code class="language-plaintext highlighter-rouge">"hello"</code> становится <code class="language-plaintext highlighter-rouge">"5:hello"</code>. Выражение <code class="language-plaintext highlighter-rouge">l&lt;...&gt;e</code> означает список. Значения, найденные между <code class="language-plaintext highlighter-rouge">l</code> и <code class="language-plaintext highlighter-rouge">e</code>, станут его содержимым. Например, в строке <code class="language-plaintext highlighter-rouge">"l5:helloi42ee"</code> записан список с элементами <code class="language-plaintext highlighter-rouge">"hello"</code> и <code class="language-plaintext highlighter-rouge">42</code>. Форма <code class="language-plaintext highlighter-rouge">d&lt;...&gt;e</code> служит для словаря. От списка он отличается тем, что перед каждым значением идет строка с именем ключа. Сообщение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"d5:title4:19844:yeari1948ee"
</code></pre></div></div>

<p>означает словарь</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:title</span><span class="w"> </span><span class="s">"1984"</span><span class="w"> </span><span class="no">:year</span><span class="w"> </span><span class="mi">1948</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Формат допускает вложенность одних коллекций в другие, например список словарей или словарь, значения которого списки. Упакуем в Bencode следующие данные:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:title</span><span class="w"> </span><span class="s">"1984"</span><span class="w">
 </span><span class="no">:year</span><span class="w"> </span><span class="mi">1948</span><span class="w">
 </span><span class="no">:tags</span><span class="w"> </span><span class="p">[</span><span class="s">"novel"</span><span class="w"> </span><span class="s">"fiction"</span><span class="w"> </span><span class="s">"dystopia"</span><span class="p">]</span><span class="w">
 </span><span class="no">:author</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"George"</span><span class="w"> </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Orwell"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"d6:authord5:fname6:George5:lname6:Orwelle4:tagsl5:novel7:fiction8:dystopiae5:title4:19844:yeari1948ee"</span><span class="w">
</span></code></pre></div></div>

<p>Всё, вы знаете Bencode!</p>

<p>Этих правил достаточно для передачи сообщений в nREPL. Конечно, при кодировании данных теряется их семантика: тип <code class="language-plaintext highlighter-rouge">Keyword</code> становится строкой, но обратной операции не предусмотрено — получив строку, нельзя определить, была ли она раньше кейвордом. По аналогии вектор, список и множество становятся в Bencode списком. Но чаще всего это неважно.</p>

<p>Почему бы не использовать более продвинутый формат, например JSON? Причина в том, что, в отличие от JSON, Bencode экстремально прост: код упаковки и чтения данных займет не более ста строк. Это важно для встроенных в редактор языков, которые не всегда поддерживают JSON по умолчанию. Разработка JSON-парсера потребует в разы больше кода и сил.</p>

<p>Транспорт Bencode назначен в nREPL по умолчанию. Когда nREPL работает с ClojureScript, используется EDN. Сообщения в ClojureScript требуют больше типов данных, и здесь Bencode уже недостаточно.</p>

<p>Ради эксперимента укажите серверу и клиенту транспорт EDN. Для сервера это делается ключом <code class="language-plaintext highlighter-rouge">:repl-options</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:repl-options</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="w">
               </span><span class="no">:transport</span><span class="w"> </span><span class="n">nrepl.transport/edn</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Если выполнить <code class="language-plaintext highlighter-rouge">lein repl</code>, вы увидите в консоли фразу <code class="language-plaintext highlighter-rouge">nrepl+edn://127.0.0.1:&lt;port&gt;</code>, при этом ввод с клавиатуры будет недоступен. Чтобы подключиться к серверу, измените параметры клиента:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">nrepl.transport</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">transport</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">nrepl/connect</span><span class="w">
           </span><span class="no">:port</span><span class="w"> </span><span class="mi">61093</span><span class="w">
           </span><span class="no">:transport-fn</span><span class="w"> </span><span class="n">transport/edn</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запишите трафик в файл и исследуйте в Wireshark. Вы увидите привычные данные в формате Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:op</span><span class="w"> </span><span class="s">"eval"</span><span class="w">
 </span><span class="no">:code</span><span class="w"> </span><span class="s">"(+ 1 2 3)"</span><span class="w">
 </span><span class="no">:id</span><span class="w"> </span><span class="s">"f4fcb617-74a7-4be8-978a-6f788787d360"</span><span class="p">}</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="s">"f4fcb617-74a7-4be8-978a-6f788787d360"</span><span class="w">
 </span><span class="no">:session</span><span class="w"> </span><span class="s">"29e04d1a-06b2-463b-8b5b-878424958780"</span><span class="w">
 </span><span class="no">:ns</span><span class="w"> </span><span class="s">"my-repl"</span><span class="w">
 </span><span class="no">:value</span><span class="w"> </span><span class="s">"6"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Bencode для Clojure доступен в двух вариантах: как часть nREPL и в виде отдельной библиотеки <a href="https://github.com/nrepl/bencode">nrepl/bencode</a>. Последняя является копией модуля из nREPL и обновляется параллельно с ним.</p>

<h2 id="клиенты-nrepl-для-редакторов">Клиенты nREPL для редакторов</h2>

<p>Мы провели достаточно опытов, чтобы понять, как устроен клиент для nREPL. Это код, который обменивается с сервером сообщениями. Подобный код выносят в плагины — программные модули для редактора. Плагин служит прослойкой между пользователем и средой исполнения: он прослушивает комбинации клавиш, изменяет текст, реагирует на события редактора.</p>

<p>Плагины пишут на разных языках. На GitHub вы найдете клиенты к nREPL, написанные на Clojure, Emacs Lisp, Java, Python, Lua, JavaScript, TypeScript, VimScript и других языках. Это многообразие объясняется тем, каждый редактор использует свой язык внутренних нужд. Например, плагины для Emacs пишут на старом диалекте Лиспа Elisp; редактор VS Code поддерживает JavaScript и TypeScript; модули к продуктам JetBrains создают на Java, и так далее.</p>

<p>В этом разделе мы не будем перебирать все клиенты. Наоборот, остановим выбор на модуле Cider для редактора Emacs. В его пользу говорят следующие факты.</p>

<p><strong>Долгая история.</strong> Первый коммит в репозиторий Cider <a href="https://github.com/clojure-emacs/cider/tree/v0.1.0">сделан в 2012 году</a>. На момент написания книги проекту полных десять лет. Cider давно вышел из стадии любительского решения. У него обширное сообщество и документация.</p>

<p><strong>Популярность.</strong> Согласно ежегодному опросу <a href="https://clojure.org/news/2022/06/02/state-of-clojure-2022">Clojure Survey</a>, связка Cider/Emacs держит первое место по популярности у разработчиков. Процент голосов в пользу Cider превышает 40% (хоть и плавно снижается из-за развития других проектов).</p>

<p><strong>Компетенция в сообществе.</strong> Исторически сложилось, что Emacs в большей степени подходит для разработки на Лиспе, чем другие редакторы. За долгие годы его адаптировали под разные диалекты — Common Lisp, Racket, Scheme и другие. Cider опирается на этот опыт: большая часть его функций — повтор удачных решений для других Лиспов.</p>

<p>Если вы пользуетесь другим редактором, не спешите пропускать раздел. Возможно, вы откроете подходы, о которых не знали раньше. Также вы заочно познакомитесь с Emacs. Это сложный редактор, но он стоит потраченных сил.</p>

<h2 id="emacs-и-cider">Emacs и Cider</h2>

<p>Проект Cider состоит из двух частей. Первая — одноименный <a href="https://github.com/clojure-emacs/cider">модуль для Emacs</a>, чтобы подключаться к nREPL из редактора. Вторая часть — библиотека на Clojure под названием <a href="https://github.com/clojure-emacs/cider-nrepl">cider-nrepl</a>. Это набор middleware, которые дополняют nREPL: добавляют запуск тестов, отладку, переходы по коду, профилирование и многое другое.</p>

<p>Взаимодействие Emacs и сервера выглядит так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌────────────────────────────────────────────────────────────────┐
│                                                                │
│  ┌─────────────────┐   ┌────────────────────────────────────┐  │
│  │Client           │   │Server                              │  │
│  │                 │   │                                    │  │
│  │  ┌───────────┐  │   │  ┌───────────┐     ┌───────────┐   │  │
│  │  │           │  │   │  │   nREPL   │     │           │   │  │
│  │  │   Emacs   │  │   │  │  server   │◀═══▶│  Clojure  │   │  │
│  │  │           │  │   │  │           │     │           │   │  │
│  │  └───────────┘  │   │  └───────────┘     └───────────┘   │  │
│  │        ▲        │   │        ▲                 ▲         │  │
│  │        ║        │   │        ║                 ║         │  │
│  │        ║        │   │        ║                 ║         │  │
│  │        ▼        │   │        ▼                 ▼         │  │
│  │  ┌───────────┐  │   │  ┌───────────┐     ┌───────────┐   │  │
│  │  │           │  │   │  │Cider/nrepl│     │           │   │  │
│  │  │   CIDER   │◀═╬═══╬═▶│middleware │     │    JVM    │   │  │
│  │  │           │  │   │  │           │     │           │   │  │
│  │  └───────────┘  │   │  └───────────┘     └───────────┘   │  │
│  │                 │   │                                    │  │
│  │                 │   │                                    │  │
│  │                 │   │                                    │  │
│  └─────────────────┘   └────────────────────────────────────┘  │
│                                                                │
└────────────────────────────────────────────────────────────────┘
</code></pre></div></div>

<p>Cider-nrepl работает на сервере и не зависит от языка, на котором написан клиент. Поэтому он используется не только вместе с Cider (модулем Emacs), но и в плагинах для Vim и других редакторов.</p>

<p>Есть несколько способов начать работу над проектом в Emacs. Первый — поручить запуск проекта и подключение модулю Cider. Для этого откройте любой файл и выполните:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x cider-jack-in
</code></pre></div></div>

<p>Произойдет следующее: Emacs начнет искать файл <code class="language-plaintext highlighter-rouge">project.clj</code> в текущей папке, а затем все выше и выше. Если он найден, Emacs запустит процесс <code class="language-plaintext highlighter-rouge">lein repl</code>. В зависимостях окажутся библиотека <code class="language-plaintext highlighter-rouge">nrepl</code> и служебные плагины. Приведем итоговую команду в сокращении:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> /usr/local/bin/lein
  update-in :dependencies conj <span class="o">[</span>nrepl/nrepl <span class="s2">"0.9.0"</span><span class="o">]</span> <span class="se">\</span>
  update-in :plugins conj <span class="o">[</span>cider/cider-nrepl <span class="s2">"0.28.3"</span><span class="o">]</span> <span class="se">\</span>
  update-in :plugins conj <span class="o">[</span>mx.cider/enrich-classpath <span class="s2">"1.9.0"</span><span class="o">]</span> <span class="se">\</span>
  update-in :middleware conj cider.enrich-classpath/middleware <span class="se">\</span>
  repl :headless :host localhost
</code></pre></div></div>

<p>Cider различает системы управления проектом: lein, Clojure CLI или Boot. Для каждой из них он выполнит разные команды. Если найдены файлы нескольких утилит, Emacs спросит у вас, что именно запустить.</p>

<p>После запуска nREPL редактор подключится к нему. Откроется буфер <code class="language-plaintext highlighter-rouge">*cider-repl &lt;project&gt;*</code> для ввода выражений. Еще один буфер <code class="language-plaintext highlighter-rouge">*nrepl-server &lt;project&gt;*</code> отображает вывод процесса <code class="language-plaintext highlighter-rouge">lein repl</code>.</p>

<p>Возможно, первый запуск проекта займет около тридцати секунд. Большая часть времени уйдет на то, чтобы скачать пакеты установить их локально.</p>

<p>Второй способ подключения в том, чтобы проделать шаги вручную: запустить nREPL в терминале и подключиться из редактора самостоятельно. Откройте глобальный профиль, расположенный в файле <code class="language-plaintext highlighter-rouge">~/.lein/profiles.clj</code>. В вектор <code class="language-plaintext highlighter-rouge">:user</code> → <code class="language-plaintext highlighter-rouge">:plugins</code> добавьте плагин <code class="language-plaintext highlighter-rouge">cider/cider-nrepl</code>. Плагин зависит от модуля <code class="language-plaintext highlighter-rouge">nrepl/nrepl</code>, поэтому последний указывать не нужно — он загрузится как транзитивная зависимость.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:user</span><span class="w">
 </span><span class="p">{</span><span class="no">:plugins</span><span class="w">
  </span><span class="p">[[</span><span class="n">cider/cider-nrepl</span><span class="w"> </span><span class="s">"0.28.3"</span><span class="p">]]}}</span><span class="w">
</span></code></pre></div></div>

<p>Запустите в терминале процесс <code class="language-plaintext highlighter-rouge">lein repl</code>. Перейдите в Emacs и выполните <code class="language-plaintext highlighter-rouge">M-x cider-connect</code>. Редактор запросит у вас хост и порт сервера. В нашем случае хост будет <code class="language-plaintext highlighter-rouge">localhost</code> или <code class="language-plaintext highlighter-rouge">127.0.0.1</code>. Вводить порт вручную необязательно: Cider найдет его в файле <code class="language-plaintext highlighter-rouge">.nrep-port</code>. Для этого нажмите в минибуфере TAB — появится список с вариантами:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Click on a completion to select it.
In this buffer, type RET to select the completion near point.

Possible completions are:
- etaoin:54446
- pact:64187
</code></pre></div></div>

<p>Emacs показывает не только номера портов, но и названия проектов, с которыми они связаны. После соединения появится буфер <code class="language-plaintext highlighter-rouge">*cider-repl &lt;project&gt;*</code> с приглашением. Буфера <code class="language-plaintext highlighter-rouge">*nrepl-server &lt;project&gt;*</code> не будет, поскольку сервер запущен вне Emacs и между ними нет связи по стандартным каналам.</p>

<p>Для Clojure CLI файл <code class="language-plaintext highlighter-rouge">deps.edn</code> будет как в примере ниже. Запустите проект командой <code class="language-plaintext highlighter-rouge">clojure -M:cider</code>. По аналогии с <code class="language-plaintext highlighter-rouge">lein</code>, поместите профиль <code class="language-plaintext highlighter-rouge">:cider</code> в локальный файл <code class="language-plaintext highlighter-rouge">~/.clojure/deps.edn</code>, чтобы применить его к любому проекту.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:aliases</span><span class="w">
 </span><span class="p">{</span><span class="no">:cider</span><span class="w">
  </span><span class="p">{</span><span class="no">:extra-deps</span><span class="w">
   </span><span class="p">{</span><span class="n">cider/cider-nrepl</span><span class="w"> </span><span class="p">{</span><span class="no">:mvn/version</span><span class="w"> </span><span class="s">"0.25.9"</span><span class="p">}}</span><span class="w">
   </span><span class="no">:main-opts</span><span class="w">
   </span><span class="p">[</span><span class="s">"-m"</span><span class="w"> </span><span class="s">"nrepl.cmdline"</span><span class="w">
    </span><span class="s">"--bind"</span><span class="w"> </span><span class="s">"localhost"</span><span class="w">
    </span><span class="s">"--middleware"</span><span class="w"> </span><span class="s">"[cider.nrepl/cider-middleware]"</span><span class="p">]}}}</span><span class="w">
</span></code></pre></div></div>

<p>Вопрос: зачем нужно ручное подключение, если доступно автоматическое? Пока мы не ушли дальше, объясним разницу между подходами.</p>

<p>В автоматическом режиме (<code class="language-plaintext highlighter-rouge">cider-jack-in</code>) процесс <code class="language-plaintext highlighter-rouge">lein repl</code> запускается силами Emacs. Если редактор “упадет”, завершатся открытые им процессы. Те, кто работает с Clojure постоянно, держат несколько запущенных проектов одновременно. Восстанавливать сеансы после перезапуска редактора утомительно.</p>

<p>Если же сеансы запущены вручную в терминале, выключение редактора не скажется на них. Более того — они сохранят изменения, которые вы внесли раньше. Достаточно включить редактор и подключится к запущенным проектам.</p>

<p>В редких случаях к проекту можно подключиться только в удаленном режиме. Например, если сервер nREPL запущен на другой машине или в виртуальном окружении (Docker, VirtualBox). Эти сценарии мы рассмотрим ближе к концу главы.</p>

<h3 id="первые-шаги">Первые шаги</h3>

<p>Итак, если подключение состоялось, откроется буфер <code class="language-plaintext highlighter-rouge">*cider-repl*</code> приглашением. Введите что-нибудь вроде <code class="language-plaintext highlighter-rouge">(+ 1 2)</code>, чтобы убедиться в его работе. В верхней части буфера приведена краткая справка. Если вы только знакомитесь с Cider, прочитайте ее. Опытные разработчики отключают справку, назначив <code class="language-plaintext highlighter-rouge">nil</code> специальной переменной Emacs:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">setq</span> <span class="nv">cider-repl-display-help-banner</span> <span class="no">nil</span><span class="p">)</span>
</code></pre></div></div>

<p>Дальнейшие шаги зависят от конфигурации проекта. Если не задано пространство по умолчанию (параметры <code class="language-plaintext highlighter-rouge">:main</code> или <code class="language-plaintext highlighter-rouge">:repl-options</code> → <code class="language-plaintext highlighter-rouge">:init-ns</code>), модули проекта не будут загружены, и вы окажетесь в пространстве <code class="language-plaintext highlighter-rouge">user</code>. Загрузить код в nREPL можно двумя способами: вручную и автоматически.</p>

<p>В первом случае откройте файл с главным модулем. Как правило, это пространства <code class="language-plaintext highlighter-rouge">&lt;project&gt;.core</code> или <code class="language-plaintext highlighter-rouge">&lt;project&gt;.main</code>. Выполните команду <code class="language-plaintext highlighter-rouge">M-x cider-load-buffer</code>. Ей пользуются часто, поэтому команде назначено сочетание клавиш <code class="language-plaintext highlighter-rouge">С-с С-k</code>. Пространство имен, включая его зависимости, будут загружены на сервере.</p>

<p>В боевых проектах создают модуль <code class="language-plaintext highlighter-rouge">dev</code> (он же <code class="language-plaintext highlighter-rouge">local</code>, <code class="language-plaintext highlighter-rouge">sandbox</code>), который доступен только в разработке (профиль <code class="language-plaintext highlighter-rouge">uberjar</code> его игнорирует). Модуль указывают в опциях nREPL, чтобы загрузить его при запуске сервера. В свою очередь <code class="language-plaintext highlighter-rouge">dev</code> зависит от других модулей проекта, и они загружаются транзитивно.</p>

<p>Кроме импортов, в <code class="language-plaintext highlighter-rouge">dev</code> размещают служебные функции, например:</p>

<ul>
  <li>прогон миграций;</li>
  <li>запуск системы компонентов (веб-сервер, база, кэш и другие) и ее остановка;</li>
  <li>выгрузку данных с боевых сервисов.</li>
</ul>

<p>Вот как выглядят настройки REPL с модулем <code class="language-plaintext highlighter-rouge">dev</code> по умолчанию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:profiles</span><span class="w">
 </span><span class="p">{</span><span class="no">:dev</span><span class="w">
  </span><span class="p">{</span><span class="no">:repl-options</span><span class="w"> </span><span class="p">{</span><span class="no">:init-ns</span><span class="w"> </span><span class="n">dev</span><span class="p">}}}}</span><span class="w">
</span></code></pre></div></div>

<p>При ручной загрузке может случиться так, что не все модули загрузились. Особенно досадно, когда пропущен модуль, расширяющий протокол или мультиметод. Ошибки компиляции не произойдет, но при выполнении кода получим исключение, что нет нужной реализации.</p>

<p>Чтобы этого избежать, Cider предлагает автоматическую загрузку командой <code class="language-plaintext highlighter-rouge">M-x cider-ns-refresh</code>. Она перебирает пути classpath и принудительно загружает все файлы Clojure. Как только вы подключились к nREPL, выполните <code class="language-plaintext highlighter-rouge">M-x cider-ns-refresh</code>, и проект готов к работе.</p>

<h3 id="выполнение-кода">Выполнение кода</h3>

<p>После загрузки кода его можно выполнить. Перейдите в буфер <code class="language-plaintext highlighter-rouge">*cider-repl*</code> и вызовите любую функцию проекта:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">my.project.util/some-func</span><span class="w"> </span><span class="p">{</span><span class="no">:message</span><span class="w"> </span><span class="s">"hello"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Нажмите Enter. На сервер уйдет сообщение с этим кодом. Там он выполнится, и вам придет ответ. Чтобы быстро перейти в буфер REPL, связанный с текущим проектом, наберите команду <code class="language-plaintext highlighter-rouge">cider-switch-to-repl-buffer</code> и по возможности задайте ей комбинацию клавиш.</p>

<p>Частый переход в буфер <code class="language-plaintext highlighter-rouge">*cider-repl*</code> и набор кода в нем неудобен. Гораздо лучше выполнить код из файла, где вы его набираете. Команда <code class="language-plaintext highlighter-rouge">cider-eval-last-sexp</code>, назначенная на комбинацию <code class="language-plaintext highlighter-rouge">C-x C-e</code>, выполняет последнее перед курсором S-выражение. Предположим, вы написали следующий код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="s">"John"</span><span class="w">
      </span><span class="n">email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s &lt;%s&gt;"</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">email</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Поместите курсор за последнюю скобку или ниже и выполните <code class="language-plaintext highlighter-rouge">C-x C-e</code>. Справа от формы появится результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="s">"John"</span><span class="w">
      </span><span class="n">email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s &lt;%s&gt;"</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">email</span><span class="p">))</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="s">"John &lt;test@test.com&gt;"</span><span class="w">
</span></code></pre></div></div>

<p>По аналогии с <code class="language-plaintext highlighter-rouge">inferior-mode</code>, S-выражение может быть где угодно: не только на верхнем уровне модуля, но и внутри другой формы. В выражении:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="p">(</span><span class="nf">java.util.UUID/randomUUID</span><span class="p">)</span><span class="w"> </span><span class="err">|</span><span class="w">
      </span><span class="nb">name</span><span class="w"> </span><span class="s">"John"</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="n">id</span><span class="w">
   </span><span class="no">:name</span><span class="w"> </span><span class="nb">name</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>подведите курсор на место вертикальной черты и выполните форму <code class="language-plaintext highlighter-rouge">(java.util...)</code>. Вы получите случайный идентификатор, экземпляр класса <code class="language-plaintext highlighter-rouge">UUID</code>.</p>

<p>Команды <code class="language-plaintext highlighter-rouge">cider-eval-region</code>, <code class="language-plaintext highlighter-rouge">cider-eval-buffer</code> и другие выполняют код из разных областей. Как следует из названий, <code class="language-plaintext highlighter-rouge">-region</code> выполняет выделенный код, в котором может быть несколько форм. Команда <code class="language-plaintext highlighter-rouge">-buffer</code> выполняет содержимое буфера.</p>

<p>Команда <code class="language-plaintext highlighter-rouge">cider-eval-defun-at-point</code> выполняет определение — формы <code class="language-plaintext highlighter-rouge">def</code>, <code class="language-plaintext highlighter-rouge">defn</code>, <code class="language-plaintext highlighter-rouge">defmacro</code> и другие. Ее особенность в том, курсор может быть в любом месте формы, а не обязательно на конце. В примере ниже установите курсор на место черты и выполните команду. Результатом станет переменная <code class="language-plaintext highlighter-rouge">#'user-description</code> (объект <code class="language-plaintext highlighter-rouge">Var</code>).</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user-description</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="err">|</span><span class="w">
        </span><span class="n">email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s &lt;%s&gt;"</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">email</span><span class="p">)))</span><span class="w">

</span><span class="n">=&gt;</span><span class="w"> </span><span class="o">#</span><span class="ss">'user-description</span><span class="w">
</span></code></pre></div></div>

<p>Этот прием крайне полезен в работе. Большую часть времени мы проводим в функциях, и перемещать курсор в конец формы неудобно. С помощью <code class="language-plaintext highlighter-rouge">cider-eval-defun-at-point</code> легко обновить определение, находясь в любом месте его кода.</p>

<p>Если результат вычислений велик (например, выборка из базы данных), Cider покажет усеченную версию. Чтобы исследовать данные, выполните <code class="language-plaintext highlighter-rouge">cider-inspect-last-result</code>. Откроется буфер, где данные напечатаны постранично с учетом вложенности. Для примера исследуем большой словарь:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ns-map 'clojure.core)

Class: clojure.lang.PersistentHashMap
Contents:
  sort-by = #'clojure.core/sort-by
  contains? = #'clojure.core/contains?
  every? = #'clojure.core/every?
  proxy-mappings = #'clojure.core/proxy-mappings
  keep-indexed = #'clojure.core/keep-indexed
  ...
  Page size: 32, showing page: 1 of 29
</code></pre></div></div>

<p>Буфер <code class="language-plaintext highlighter-rouge">*cider-inspect*</code> нельзя редактировать. За навигацию по данным отвечают особые клавиши; приведем некоторые из них:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SPC</code> (пробел) — перейти на следующую страницу результата;</li>
  <li><code class="language-plaintext highlighter-rouge">M-SPC</code> — вернуться на предыдущую;</li>
  <li><code class="language-plaintext highlighter-rouge">RET</code> (Enter) — открыть вложенную структуру данных;</li>
  <li><code class="language-plaintext highlighter-rouge">l</code> — подняться на уровень ниже</li>
</ul>

<p>Команда <code class="language-plaintext highlighter-rouge">cider-inspect-last-sexp</code> <code class="language-plaintext highlighter-rouge">(C-x TAB)</code> совмещает два шага: выполнить форму и открыть инспектор с результатом. С ней не понадобиться вызывать их по отдельности.</p>

<p>Полное описание инспектора, его команд и клавиш вы найдете на сайте Cider в <a href="https://docs.cider.mx/cider/debugging/inspector.html">одноименном разделе</a>.</p>

<h3 id="dev-секции">Dev-секции</h3>

<p>Опытные программисты оставляют в файлах так называемые <em>dev sections</em> — области разработки. Это код, который легко выполнить в REPL, чтобы проверить результат. Dev-секция помещается в макрос <code class="language-plaintext highlighter-rouge">comment</code>, чтобы не влиять на компиляцию.</p>

<p>Предположим, вы написали функцию <code class="language-plaintext highlighter-rouge">-&gt;fahr</code> для перевода температуры между шкалой Цельсия и Фаренгейта:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-&gt;fahr</span><span class="w"> </span><span class="p">[</span><span class="n">cel</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">cel</span><span class="w"> </span><span class="mf">1.8</span><span class="p">)</span><span class="w"> </span><span class="mi">32</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы ее проверить, добавьте в конец файла отладочный код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mf">36.6</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Поставьте курсор после закрывающей скобки в первой форме и выполните ее — получите результат 97.88, что совпадает с ожиданиями. Выполните и другие выражения, в том числе для <code class="language-plaintext highlighter-rouge">nil</code>, чтобы спровоцировать исключение. Если логика функции изменится, вы легко проверите ее работу.</p>

<p>Обратите внимание на следующие моменты. Отладочный код находятся в макросе <code class="language-plaintext highlighter-rouge">comment</code>, который игнорирует содержимое: при компиляции он вырождается в пустоту. Не путайте макрос <code class="language-plaintext highlighter-rouge">comment</code> и комментирование строки точкой с запятой. Во втором случае форму нельзя выполнить: команда <code class="language-plaintext highlighter-rouge">cider-eval-last-sexp</code> не сработает.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; cannot be evaluated</span><span class="w">
</span><span class="c1">;; (-&gt;fahr 36.6) |</span><span class="w">
</span></code></pre></div></div>

<p>Закрывающая скобка <code class="language-plaintext highlighter-rouge">comment</code> стоит отдельно, чтобы по ошибке не выполнить его вместо последней формы. Покажем это на примере. Предположим, скобка стоит по правилам Lisp-синтаксиса на той же строке:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы выполнить <code class="language-plaintext highlighter-rouge">(-&gt;fahr nil)</code>, поставим курсор между двумя последними скобками:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="err">|</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>На практике легко промахнуться и поставить курсор в конце:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w"> </span><span class="err">|</span><span class="w">
</span></code></pre></div></div>

<p>В этом случае команда <code class="language-plaintext highlighter-rouge">cider-eval</code> выполнит форму <code class="language-plaintext highlighter-rouge">comment</code>, которая вернет <code class="language-plaintext highlighter-rouge">nil</code> вне зависимости от содержимого. Сложится ложное ощущение, что <code class="language-plaintext highlighter-rouge">(-&gt;fahr nil)</code> возвращает <code class="language-plaintext highlighter-rouge">nil</code>, что на самом деле не так. Чтобы этого не случилось, идут на легкое нарушение правил.</p>

<p>Некоторые редакторы выделяют блок <code class="language-plaintext highlighter-rouge">comment</code> цветом, чтобы подчеркнуть — это не боевой код, а пример или справка. Если у вас это не работает, попробуйте список с тегом игнорирования <code class="language-plaintext highlighter-rouge">#_</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="n">_</span><span class="w">
</span><span class="p">((</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mf">36.6</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>В результате dev-секция будет окрашена в нейтральный цвет. Так вы легко отделите ее от кода.</p>

<p>Код dev-секции может быть с побочным эффектом, например когда вы тестируете HTTP-запросы или базу данных. Проследите, чтобы в коде не было паролей или ключей доступа. Если они необходимы, считайте их в переменную из файла или переменной среды:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">
  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">-api-key</span><span class="w">
    </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="s">"API_KEY"</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">-response</span><span class="w">
    </span><span class="p">(</span><span class="nf">make-http-request</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="n">-api-key</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Dev-секции встречаются во многих библиотеках, в том числе Clojure. Например, модуль clojure.zip <a href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L281">содержит блок</a> <code class="language-plaintext highlighter-rouge">comment</code> с набором шагов, где проверяется логика <a href="https://grishaev.me/clj-zippers-1/">зипперов</a>.</p>

<h3 id="сниппеты">Сниппеты</h3>

<p>Чем дольше вы работаете с Clojure, тем больше у вас будет сниппетов. Так называют фрагменты кода, которые делают что-то полезное: меняют логирование, посылают HTTP-запросы, выводят служебные данные. У сниппетов особое положение: с одной стороны, им не место в боевом коде. С другой стороны, они полезны в разработке, поэтому их нужно где-то хранить.</p>

<p>На роль сниппета подойдет сброс данных в json-файл с отступами. Набирать этот код утомительно, поэтому полезно держать его под рукой.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">data</span><span class="w">
    </span><span class="p">(</span><span class="nf">cheshire.core/generate-string</span><span class="w"> </span><span class="p">{</span><span class="no">:pretty</span><span class="w"> </span><span class="n">true</span><span class="p">})</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="s">"output.json"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Другой пример — обращение к сервису по протоколу HTTP. Это вызов функции post из библиотеки Clj-HTTP с нужными параметрами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">clj-http.client/post</span><span class="w">
 </span><span class="s">"https://internal.site.com/api/v1"</span><span class="w">
 </span><span class="p">{</span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="w">
  </span><span class="no">:content-type</span><span class="w"> </span><span class="no">:json</span><span class="w">
  </span><span class="no">:form-params</span><span class="w"> </span><span class="p">{</span><span class="no">:event</span><span class="w"> </span><span class="s">"user-created"</span><span class="w">
                </span><span class="no">:user_id</span><span class="w"> </span><span class="mi">10099</span><span class="p">}})</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что в сниппетах используют полные пространства имен. Такой код сработает даже в модуле, где нет импортов <code class="language-plaintext highlighter-rouge">clj-http.client</code> или <code class="language-plaintext highlighter-rouge">cheshire.core</code>. Достаточно, чтобы библиотеки были загружены в другом месте.</p>

<p>Чем опытней разработчик, тем больше у него сниппетов на разные случаи. Удобно хранить их в отдельном .clj-файле, чтобы выполнять оттуда, не копируя в REPL. С таким подходом получается личная среда разработки.</p>

<p>Cider предлагает особый буфер, чтобы выполнять код на Clojure. Когда вы подключены к nREPL, наберите команду <code class="language-plaintext highlighter-rouge">M-x cider-scratch</code>. Откроется буфер <code class="language-plaintext highlighter-rouge">*cider-scratch*</code>, связанный с текущим проектом. Скопируйте в него любой код. Поместите курсор за нужной формой и нажмите <code class="language-plaintext highlighter-rouge">C-j</code> — на следующей строке появится ее результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="c1">;; press C-j</span><span class="w">

</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre></div></div>

<p>Преимущество <code class="language-plaintext highlighter-rouge">*cider-scratch*</code> в том, что результат не пропадает, а остается в файле для дальнейшей работы. Выполните более сложный пример, нажимая <code class="language-plaintext highlighter-rouge">C-j</code> после каждой формы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.walk</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">walk</span><span class="p">])</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="p">(</span><span class="nf">walk/stringify-keys</span><span class="w"> </span><span class="p">{</span><span class="no">:hello</span><span class="w"> </span><span class="p">{</span><span class="no">:test</span><span class="w"> </span><span class="mi">33</span><span class="p">}})</span><span class="w">
</span><span class="p">{</span><span class="s">"hello"</span><span class="w"> </span><span class="p">{</span><span class="s">"test"</span><span class="w"> </span><span class="mi">33</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Комбинация <code class="language-plaintext highlighter-rouge">C-u C-j</code> печатает результат при помощи <code class="language-plaintext highlighter-rouge">clojure.pprint</code>, то есть с отступами и переносами строк. Опробуйте ее на больших данных, например словаре переменных среды:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">))</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="c1">;; C-j</span><span class="w">
</span></code></pre></div></div>

<p>Пользователи Emacs догадались, что буфер <code class="language-plaintext highlighter-rouge">*cider-scratch*</code> —  это аналог обычного <em>scratch</em>. Так называется <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Lisp-Interaction.html">встроенный буфер</a> Emacs, который выполняет код на ELisp. Разница в том, что вместо ELisp <code class="language-plaintext highlighter-rouge">*cider-scratch*</code> принимает код на Clojure. Режим, в котором он работает, называется <code class="language-plaintext highlighter-rouge">cider-clojure-interaction-mode</code>.</p>

<p>Если сохранить <code class="language-plaintext highlighter-rouge">*cider-scratch*</code>, Emacs запросит путь на диске, потому что по умолчанию буфер не связан с файлом. Введите любое имя; автор предпочитает такое же, что и у буфера, то есть <code class="language-plaintext highlighter-rouge">*cider-scratch*</code> без расширения со звездочками.</p>

<p>Когда вы откроете буфер <code class="language-plaintext highlighter-rouge">*cider-scratch*</code> с диска, он будет вести себя как обычный текст: нажатие <code class="language-plaintext highlighter-rouge">C-j</code> перенесет каретку без выполнения кода. Так происходит потому, что при открытии буфер получит базовый режим (fundamental mode). Чтобы вернуть интерактивность, смените режим командой <code class="language-plaintext highlighter-rouge">M-x cider-clojure-interaction-mode</code>, и выполнение кода заработает.</p>

<p>Чтобы не вводить команду каждый раз, воспользуйтесь одним из двух способов. Первый — поместите в начале файла строку:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>; -*- mode: cider-clojure-interaction -*-
</code></pre></div></div>

<p>При открытии файлов Emacs <a href="https://www.gnu.org/software/emacs/manual/html_node/efaq/Associating-modes-with-files.html">учитывает выражения</a>, заключенные в <code class="language-plaintext highlighter-rouge">-*-</code>, и выполняет их. Метка <code class="language-plaintext highlighter-rouge">mode</code> означает сменить главный режим буфера.</p>

<p>Второй, более универсальный способ — связать регулярное выражение файла с режимом. Выражение описывает только имя файла — при сопоставлении путь к нему отбрасывается. В нашем случае правило выглядит так:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">add-to-list</span> <span class="ss">'auto-mode-alist</span> <span class="o">'</span><span class="p">(</span><span class="s">"\*cider-scratch\*"</span> <span class="o">.</span> <span class="nv">cider-clojure-interaction-mode</span><span class="p">))</span>
</code></pre></div></div>

<p>У звездочки особая роль в регулярных выражениях. Чтобы задать символ звездочки, ее экранируют обратной чертой. Выполните форму выше в буфере <code class="language-plaintext highlighter-rouge">*scratch*</code>, и изменения вступят в силу немедленно (не забудьте добавить ее в конфигурацию Emacs). Закройте и откройте файл <code class="language-plaintext highlighter-rouge">*cider-scratch*</code> — он сразу перейдет в интерактивный режим.</p>

<p>Сниппеты удобно хранить в личном репозитории. Чтобы они были доступны в разных проектах, расставьте мягкие ссылки (symlink). Ниже мы полагаем, что в папке <code class="language-plaintext highlighter-rouge">~/dotfiles</code> находится ваш личный репозиторий настроек, а в <code class="language-plaintext highlighter-rouge">~/work/acme/backend</code> — серверный код заказчика. Команда <code class="language-plaintext highlighter-rouge">ln -s</code> добавит ссылку в папку проекта:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~/dotfiles
<span class="nb">ln</span> <span class="nt">-s</span> ~/dotfiles/scratch.clj ~/work/acme/backend/scratch.clj
</code></pre></div></div>

<p>С ростом файла разбейте его по признаку проекта или заказчика. Пользу сниппетов трудно переоценить: легче найти код по ключевым словам, чем набирать по памяти. Не ленитесь сохранять полезные выражения в файл — в будущем они пригодятся вам и коллегам.</p>

<h2>Все части</h2>

<ul>
  <li><a href="/clj-repl-part-1/">Первая часть</a></li>
  <li><a href="/clj-repl-part-2/">Вторая часть</a></li>
  <li><a href="/clj-repl-part-3/">Третья часть</a></li>
  <li><a href="/clj-repl-part-4/">Четвертая часть</a></li>
</ul>


  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-repl-part-2/">
    <input required name="captcha" type="hidden" value="7 &#215; 5">

    <div class="block">
        <span class="comment-form-label"><small>7 &#215; 5 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
