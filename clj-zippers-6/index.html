<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Зипперы в Clojure (часть 6). Виртуальные деревья. Обмен валют</title>
  <meta name="description" content="Оглавление  Зипперы (часть 1). Азы навигации  Зипперы (часть 2). Автонавигация  Зипперы (часть 3). XML-зипперы  Зипперы (часть 4). Поиск в XML  Зипперы (част...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-zippers-6/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Зипперы в Clojure (часть 6). Виртуальные деревья. Обмен валют</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2020-08-12T00:00:00+00:00">
        Aug 12, 2020
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/zippers/" rel="tag">zippers</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="оглавление">Оглавление</h2>

<ul>
  <li><a href="/clj-zippers-1/">Зипперы (часть 1). Азы навигации</a></li>
  <li><a href="/clj-zippers-2/">Зипперы (часть 2). Автонавигация</a></li>
  <li><a href="/clj-zippers-3/">Зипперы (часть 3). XML-зипперы</a></li>
  <li><a href="/clj-zippers-4/">Зипперы (часть 4). Поиск в XML</a></li>
  <li><a href="/clj-zippers-5/">Зипперы (часть 5). Редактирование</a></li>
  <li><a href="/clj-zippers-6/">Зипперы (часть 6). Виртуальные деревья. Обмен валют</a></li>
  <li><a href="/clj-zippers-7/">Зипперы (часть 7). Обход в ширину. Улучшенный обмен валют</a></li>
  <li><a href="/clj-zippers-8/">Зипперы (часть 8). Заключение</a></li>
</ul>

<p>Предыдущих занятий было достаточно, чтобы перейти к экспериментам над
зипперами. Предлагаем читателю подумать над необычным примером.</p>

<p>До сих пор вторая функция, которую мы передавали в зиппер, возвращала потомков
из ветки. Для вектора это была просто <code class="language-plaintext highlighter-rouge">seq</code>, для XML — более сложная комбинация
<code class="language-plaintext highlighter-rouge">(comp seq :content)</code>. Оба варианта отталкиваются от родительского узла, и если
потомков нет, функция вернёт <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>Но что если функция вернёт постоянный набор потомков:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Как поведёт себя такой зиппер? Напишем его:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">zip-123</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w"> </span><span class="n">any?</span><span class="w">
              </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
              </span><span class="n">nil</span><span class="w">
              </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<!-- more -->

<p>Из-за того, что у каждого элемента три потомка, зиппер станет бесконечным. Обойти
его с помощью <code class="language-plaintext highlighter-rouge">iter-zip</code> не получится — <code class="language-plaintext highlighter-rouge">zip/next</code> будет всё глубже погружаться
в зиппер, но не достигнет его конца.</p>

<p>Ради интереса сделаем несколько шагов по новому зипперу. Спустимся вниз и
вправо. Мы окажемся на двойке в середине вектора <code class="language-plaintext highlighter-rouge">[1 2 3]</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">zip-123</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc-2</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">
</span></code></pre></div></div>

<p>Покажем наше положение не схеме. Шаги влево и право сдвинут нас на единицу и
тройку:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │     1     │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │[1 2 3]│
                └───────┘
</code></pre></div></div>

<p>С шагом вниз мы провалимся в очередной вектор <code class="language-plaintext highlighter-rouge">[1 2 3]</code> и так далее. Ради
интереса спустимся вниз и вправо пять раз, и всё равно окажемся в двойке:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">down-right</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">zip/right</span><span class="w"> </span><span class="n">zip/down</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">
</span></code></pre></div></div>

<p>Зиппер можно назвать виртуальным, потому что данных, по которым мы путешествуем,
на самом деле не существует — они появляются в полёте.</p>

<p>Пока что неясно, в чём польза от этого зиппера. Но он подтверждает важный тезис
— можно получать потомков в процессе обхода дерева. Это не нарушает правила
зипперов и даёт новые возможности.</p>

<p>Явно заданный вектор <code class="language-plaintext highlighter-rouge">[1 2 3]</code> не раскрывает их. Если потомки известны заранее,
нужда в зиппере отпадает — коллекцию можно обойти более простым
способом. Интересен случай, когда потомки зависят от каких-то внешних факторов,
например, приходят из сторонних источников. В терминах функционального
программирования зиппер становится “грязным”: поскольку мы не контролируем
внешний источник, повторный обход может дать разный результат. Однако это не
значит, что грязный зиппер не имеет права на жизнь. Рассматривайте его как
абстракцию над источником, которая делает его удобней.</p>

<p>На роль примера отлично подходит файловая система. Ее элементы – файлы и
директории – отвечают всем условиям зиппера. Директория – это узел, который
содержит ссылки на другие элементы. Когда вы просматриваете файлы в любом
менеджере, курсор ведет себя как локация. Он знает текущий файл, его соседей по
директории и пути вверх и вглубь (если текущий файл – директория). Если
правильно подобрать функции <code class="language-plaintext highlighter-rouge">branch?</code> и <code class="language-plaintext highlighter-rouge">children</code>, обычный файл становится
зиппером.</p>

<p>Код оказывается на удивление коротким. Добавьте в пространство модуль
<code class="language-plaintext highlighter-rouge">clojure.zip</code> и класс <code class="language-plaintext highlighter-rouge">java.io.File</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">zipper-demo</span><span class="w">
  </span><span class="p">(</span><span class="no">:import</span><span class="w"> </span><span class="n">java.io.File</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.zip</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">zip</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">file-zip</code> принимает строковый путь и возвращает зиппер. Проверка
<code class="language-plaintext highlighter-rouge">branch?</code> сводится к вызову метода <code class="language-plaintext highlighter-rouge">.isDirectory</code> файла. Очевидно, если это
обычный файл, а не папка, двигаться ниже нельзя. Функция <code class="language-plaintext highlighter-rouge">children</code> опирается на
метод <code class="language-plaintext highlighter-rouge">.listFiles</code>, который вернет массив файлов в директории. Обертка в <code class="language-plaintext highlighter-rouge">seq</code>
необходима, чтобы привести пустой массив к <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">file-zip</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">File</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">.isDirectory</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">File</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nf">.listFiles</span><span class="w"> </span><span class="n">f</span><span class="p">)))</span><span class="w">
   </span><span class="n">nil</span><span class="w">
   </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="nb">path</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Получим зиппер проведем с ним эксперименты. Первая локация указывает на
корневую папку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">fz</span><span class="w">
  </span><span class="p">(</span><span class="nf">file-zip</span><span class="w"> </span><span class="s">"/Users/ivan"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">fz</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; #object[java.io.File 0xe413375 "/Users/ivan"]</span><span class="w">
</span></code></pre></div></div>

<p>Вызов <code class="language-plaintext highlighter-rouge">zip/next</code> сдвигает указатель на вложенные папки и файлы. В случае автора
это скрытая папка <code class="language-plaintext highlighter-rouge">.eclipse</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">fz</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; #object[java.io.File 0x23e1b67 "/Users/ivan/.eclipse"]</span><span class="w">
</span></code></pre></div></div>

<p>Через три сдвига получим файл <code class="language-plaintext highlighter-rouge">secure_storage</code> в ее недрах:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">fz</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; #object[java.io.File 0x138b3172 "/Users/ivan/.eclipse/org.eclipse.equinox.security/secure_storage"]</span><span class="w">
</span></code></pre></div></div>

<p>Сохраним локацию в переменную и вызовем <code class="language-plaintext highlighter-rouge">zip/path</code>. Получим вектор папок,
ведущих к файлу из локации:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">file-loc</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">fz</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/next</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">zip/path</span><span class="w"> </span><span class="n">file-loc</span><span class="p">)</span><span class="w">

</span><span class="p">[</span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">java.io.File</span><span class="w"> </span><span class="mi">0</span><span class="n">xe413375</span><span class="w"> </span><span class="s">"/Users/ivan"</span><span class="p">]</span><span class="w">
 </span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">java.io.File</span><span class="w"> </span><span class="mi">0</span><span class="n">x2067c8ff</span><span class="w"> </span><span class="s">"/Users/ivan/.eclipse"</span><span class="p">]</span><span class="w">
 </span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">java.io.File</span><span class="w"> </span><span class="mi">0</span><span class="n">x69304325</span><span class="w"> </span><span class="s">"/Users/ivan/.eclipse/org.eclipse.equinox.security"</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>Файловый зиппер поддерживает <code class="language-plaintext highlighter-rouge">iter-zip</code>, поиск, переходы и прочие техники, что
мы рассмотрели. Признаем, в случае с файлами это не самое оптимальное решение:
за долгие годы для них созданы инструменты намного быстрее. Но пример
подтверждает, что зиппером может выступить объект, который на первый взгляд не
подходит на эту роль.</p>

<p>Наверное, каждый программист сталкивался с неуклюжим API, который возвращает
сущности и ее потомков по одной. Например, древняя CRM по запросу <code class="language-plaintext highlighter-rouge">GET
/api/entity/&lt;id&gt;</code> вернет JSON вида:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Gizmo"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Does something"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"children"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Если у сущности нет потомков, в поле <code class="language-plaintext highlighter-rouge">children</code> пустой массив или оно
отсутствует.</p>

<p>Чтобы обойти сущности, построим зиппер, замкнутый на API. Предположим, функция
<code class="language-plaintext highlighter-rouge">entity-by-id</code> принимает HTTP-клиент с активным соединением и номер сущности и
возвращает прочитанный JSON из тела ответа.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">entity-by-id</span><span class="w"> </span><span class="p">[</span><span class="n">http-client</span><span class="w"> </span><span class="n">entity-id</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>В этом случае зиппер выглядит как в примере ниже. Он принимает HTTP-клиент и
номер корневой сущности. Функция <code class="language-plaintext highlighter-rouge">branch?</code> проверяет, что поле <code class="language-plaintext highlighter-rouge">children</code> не
пустое. Функция потомков извлекает их в цикле <code class="language-plaintext highlighter-rouge">for</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">entity-zip</span><span class="w"> </span><span class="p">[</span><span class="n">http-client</span><span class="w"> </span><span class="n">entity-id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="nb">children</span><span class="p">]}]</span><span class="w">
                </span><span class="p">(</span><span class="nb">pos?</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="nb">children</span><span class="p">)))</span><span class="w">
              </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="nb">children</span><span class="p">]}]</span><span class="w">
                </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">child</span><span class="w"> </span><span class="nb">children</span><span class="p">]</span><span class="w">
                  </span><span class="p">(</span><span class="nf">entity-by-id</span><span class="w"> </span><span class="n">http-client</span><span class="w"> </span><span class="n">child</span><span class="p">)))</span><span class="w">
              </span><span class="n">nil</span><span class="w">
              </span><span class="p">(</span><span class="nf">entity-by-id</span><span class="w"> </span><span class="n">http-client</span><span class="w"> </span><span class="n">entity-id</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Вызывая <code class="language-plaintext highlighter-rouge">zip/next</code>, мы будем шагать по сущностям, извлекая их по сети по мере
необходимости. Ради оптимизации можно заменить цикл <code class="language-plaintext highlighter-rouge">for</code> на частично
параллельный <code class="language-plaintext highlighter-rouge">pmap</code> или применить библиотеки Aleph и Manifold для удобной
многопоточности.</p>

<p>Когда сведения о потомках приходят по сети, важно оценить частоту запросов и
нагрузку на источник данных. Если это CRM в банковской системе, ее замедление
скажется на других частях компании. В этом случае данные полезно кэшировать в
памяти или в key-value хранилищах типа Memcached или Redis. Зиппер, построенный
на базе подобного хранилища, выглядит похоже за исключением функции
<code class="language-plaintext highlighter-rouge">entity-by-id</code>. Изменится только его конструктор, но не принцип работы.</p>

<p>Еще один интересный пример – когда функции <code class="language-plaintext highlighter-rouge">branch?</code> и <code class="language-plaintext highlighter-rouge">children</code> замкнуты на
некоторых данных. Это тоже обход, но по другим правилам.</p>

<p>Рассмотрим следующую задачу. Банк разменивает валюты, например доллары на евро,
рубли на лиры и так далее. Для краткости обозначим их парами: <code class="language-plaintext highlighter-rouge">(usd, eur)</code>,
<code class="language-plaintext highlighter-rouge">(rub, lir)</code>. Размен действует в одном направлении: чтобы поменять евро на
доллары или лиры на рубли, у банка должны быть отдельные правила <code class="language-plaintext highlighter-rouge">(eur, usd)</code> и
<code class="language-plaintext highlighter-rouge">(lir, rub)</code>.</p>

<p>В банк обращается клиент, чтобы разменять валюту <code class="language-plaintext highlighter-rouge">X</code> на <code class="language-plaintext highlighter-rouge">Y</code>. Если в правилах
есть пара <code class="language-plaintext highlighter-rouge">(X, Y)</code>, проблемы не возникает. Но если пары нет, банк строит цепочку
обменов. Например, клиент хочет поменять доллары на лиры, но в банке нет прямой
пары <code class="language-plaintext highlighter-rouge">(usd, lir)</code>. Однако есть пары <code class="language-plaintext highlighter-rouge">(usd, eur)</code> и <code class="language-plaintext highlighter-rouge">(eur, lir)</code>. В этом случае
клиенту предложат обмен <code class="language-plaintext highlighter-rouge">usd</code> → <code class="language-plaintext highlighter-rouge">eur</code> → <code class="language-plaintext highlighter-rouge">lir</code>.</p>

<p>Ваша задача — написать программу, которая принимает правила обмена, входную и
выходную валюты. Вы должны найти цепочки обмена. Чем короче цепочка, тем
лучше. Если возможны несколько цепочек одинаковой длины, вернуть их все, чтобы
клиент мог выбирать. Учесть, что решений может не быть и адекватно реагировать
на этот случай: не уйти в вечный цикл, не занимать все ресурсы компьютера.</p>

<p>Опишем входные данные в терминах Clojure. Каждое правило будет парой кейвордов —
с какой валюты на какую происходит обмен. Вектор правил назовем <code class="language-plaintext highlighter-rouge">rules</code>. Кроме
правил, мы принимаем параметры <code class="language-plaintext highlighter-rouge">from</code> и <code class="language-plaintext highlighter-rouge">to</code> с какой и на какую валюту менять.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; rules</span><span class="w">
</span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="p">]]</span><span class="w">

</span><span class="no">:usd</span><span class="w"> </span><span class="c1">;; from</span><span class="w">
</span><span class="no">:rub</span><span class="w"> </span><span class="c1">;; to</span><span class="w">
</span></code></pre></div></div>

<p>На выходе ожидаем набор цепочек от <code class="language-plaintext highlighter-rouge">from</code> к <code class="language-plaintext highlighter-rouge">to</code> или <code class="language-plaintext highlighter-rouge">nil</code>. Для случая выше
цепочка от доллара к евро выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Всё вместе даёт функцию <code class="language-plaintext highlighter-rouge">exchanges</code>, тело которой нам предстоит заполнить:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">exchanges</span><span class="w"> </span><span class="p">[</span><span class="n">rules</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">to</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Для начала напишем несколько тестов. Они помогут размяться, и заодно мы лучше
поймем задачу. Первый тест — простой обмен, который есть среди правил:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-simple</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Обмен в обратную сторону невозможен, если нет отдельного правила:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-reverse-err</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:usd</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Случай, когда цепочки обмена не существует:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-no-solution</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:usd</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:eur</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Наиболее важный сценарий: множественный обмен. От долларов к рублям ведут два
пути с евро и лирами в середине:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-two-ways</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
          </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Ещё один тест проверяет, что вы вернём только самые короткие цепочки. Обмен с
четырьмя валютами (в данном случае <code class="language-plaintext highlighter-rouge">[:usd :yen :eur :rub]</code>) не попадёт в
результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-short-ways-only</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
          </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:yen</span><span class="w"> </span><span class="no">:eur</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>В терминах олимпиадного программирования можно сказать, что задача содержит
отдельные рёбра графа. Требуется проверить, можно ли составить из рёбер маршрут
от вершины А к B. Поскольку эта глава о зипперах, мы не будем использовать
термины “граф” и “рёбра”. Мы не гарантируем, что решение будет оптимальным, и
возможно, алгоритм на графах справится лучше. Однако надеемся, что пример ещё
больше раскроет мощь зипперов.</p>

<p>Как вы помните, зипперы удобны там, где встречается иерархия. На первый взгляд у
валют нет иерархии, но ее легко построить. Представим, что на вершине дерева
стоит валюта <code class="language-plaintext highlighter-rouge">from</code>, которую мы хотим разменять. Пусть это будет
доллар. Очевидно, что потомки этой валюты — все те, что размениваются на
доллар. Для этого выберем второй элемент из каждой пары, где первый элемент
равен <code class="language-plaintext highlighter-rouge">from</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">rules</span><span class="w">
  </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:tug</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="no">:usd</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">usd-children</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">]</span><span class="w"> </span><span class="n">rules</span><span class="w">
        </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">from</span><span class="p">)]</span><span class="w">
    </span><span class="n">v2</span><span class="p">))</span><span class="w">
</span><span class="c1">;; (:rub :lir)</span><span class="w">
</span></code></pre></div></div>

<p>Таким образом, потомки доллара – рубль и лира. Изобразим мнимое дерево и
обозначим уровни:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                  ┌───────┐
     1            │  usd  │
                  └───────┘
                      │
          ┌───────┐   │   ┌───────┐
     2    │  rub  │◀──┴──▶│  lir  │
          └───────┘       └───────┘
</code></pre></div></div>

<p>Для каждой валюты второго уровня найдём потомков по такому же правилу. Для
удобства напишем функцию <code class="language-plaintext highlighter-rouge">get-children</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-children</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">]</span><span class="w"> </span><span class="n">rules</span><span class="w">
        </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">value</span><span class="p">)]</span><span class="w">
    </span><span class="n">v2</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">get-children</span><span class="w"> </span><span class="no">:rub</span><span class="p">)</span><span class="w">
</span><span class="c1">;; (:eur :yen)</span><span class="w">
</span></code></pre></div></div>

<p>Новое дерево:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      ┌───────┐
    1                 │  usd  │
                      └───────┘
                          │
              ┌───────┐   │   ┌───────┐
    2         │  rub  │◀──┴──▶│  lir  │
              └───────┘       └───────┘
                  │               │
       ┌───────┐  │  ┌───────┐    │  ┌───────┐
    3  │  eur  │◀─┴─▶│  yen  │    └─▶│  tug  │
       └───────┘     └───────┘       └───────┘
</code></pre></div></div>

<p>Заметим, что это виртуальное дерево, о котором мы говорили недавно. У нас нет
этого дерева на руках – оно получается в процессе. Функция <code class="language-plaintext highlighter-rouge">make-children</code>
замкнута на исходных парах обмена. Это пример того, как обходить данные, которые
получаем в полёте из других данных.</p>

<p>Структура дерева валют известна, и его можно обойти. Вопрос, до каких пор его
обходить? Очевидно, мы остановимся, как только встретим локацию, чей узел равен
валюте <code class="language-plaintext highlighter-rouge">to</code>. Пусть это будут йены. Это значит, мы соединили <code class="language-plaintext highlighter-rouge">from</code> и <code class="language-plaintext highlighter-rouge">to</code> с
помощью других валют. Обозначим решение на схеме:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      ┌───────┐
    1                 │  usd  │
                      └───────┘
                          │
              ┌───────┐   │   ┌ ─ ─ ─ ┐
    2         │  rub  │◀──┘
              └───────┘       └ ─ ─ ─ ┘
                  │
       ┌ ─ ─ ─ ┐  │  ┌───────┐       ┌ ─ ─ ─ ┐
    3             └─▶│  yen  │
       └ ─ ─ ─ ┘     └───────┘       └ ─ ─ ─ ┘

</code></pre></div></div>

<p>Чтобы получить цепочку обмена, локацию <code class="language-plaintext highlighter-rouge">to</code> передают в функцию <code class="language-plaintext highlighter-rouge">zip/path</code>. Она
вернёт вектор родителей локации, не включая ее саму. Путь к локации и её узел
образуют цепочку обмена.</p>

<p>На базе этих рассуждений напишем код. Подготовим зиппер:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">zip-val</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w"> </span><span class="nb">keyword?</span><span class="w">      </span><span class="c1">;; это валюта?</span><span class="w">
              </span><span class="n">get-children</span><span class="w">  </span><span class="c1">;; на что её можно разменять?</span><span class="w">
              </span><span class="n">nil</span><span class="w">
              </span><span class="n">from</span><span class="p">))</span><span class="w">        </span><span class="c1">;; исходная валюта</span><span class="w">
</span></code></pre></div></div>

<p>Ищем в зиппере локацию с целевой валютой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-to?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">to</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-to</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">zip-val</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nf">find-first</span><span class="w"> </span><span class="n">loc-to?</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Если нашли, получим из неё цепочку обмена. Для этого к пути присоединим значение
<code class="language-plaintext highlighter-rouge">to</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/path</span><span class="w"> </span><span class="n">loc-to</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc-to</span><span class="p">))</span><span class="w">
</span><span class="c1">;; [:usd :rub :yen]</span><span class="w">
</span></code></pre></div></div>

<p>Задача решена, но с недостатком: для любых данных мы получим только одну
цепочку, даже если их несколько. Чтобы исправиться, ищем не только первую
локацию с валютой <code class="language-plaintext highlighter-rouge">to</code>, а их все с помощью <code class="language-plaintext highlighter-rouge">filter</code>.</p>

<p>Расширим исходные данные:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">rules</span><span class="w">
  </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:tug</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="no">:usd</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="no">:yen</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>и найдём цепочки. Для этого заменим <code class="language-plaintext highlighter-rouge">find-first</code> на <code class="language-plaintext highlighter-rouge">filter</code>, который вернёт все
элементы, подходящие предикату, а не только первый.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">locs-to</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">zip-val</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-to?</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Для каждой найденной локации постоим путь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">locs-to</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/path</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)))</span><span class="w">

</span><span class="p">([</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Теперь мы нашли цепочки всех длин, что может быть избыточно. По условию задачи
нам не нужен обмен из четырёх операций, если найден с двумя. Напишем функцию,
которая вернёт самые короткие списки из результата выше. Она группирует обмены
по длине, находит меньшую длину и выбирает из словаря.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-shortest-chains</span><span class="w">
  </span><span class="p">[</span><span class="n">chains</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">chains</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">count-&gt;chains</span><span class="w"> </span><span class="p">(</span><span class="nf">group-by</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="n">chains</span><span class="p">)</span><span class="w">
          </span><span class="n">min-count</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">min</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">count-&gt;chains</span><span class="p">))]</span><span class="w">
      </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">count-&gt;chains</span><span class="w"> </span><span class="n">min-count</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Для последнего результата получим два вектора по три валюты в каждом. Этот
случай покрывает последний тест <code class="language-plaintext highlighter-rouge">test-short-ways-only</code>, где длинные цепочки
отбрасываются:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>Составьте функцию <code class="language-plaintext highlighter-rouge">exchanges</code> из фрагментов кода. Убедитесь, что тесты
проходят. Добавьте в них больше случаев.</p>

<p>Кажется, что задача решена, однако её можно улучшить. Дело в том, что при особых
входных данных дерево станет бесконечным. Программа либо уйдёт в вечный цикл,
либо, если число шагов ограничить, не найдет решения. Не заглядывая вперед,
подумайте, что может быть тому причиной и как это исправить. На эти вопросы мы
ответим в следующем разделе.</p>

<p>(Продолжение следует)</p>

<h2 id="оглавление-1">Оглавление</h2>

<ul>
  <li><a href="/clj-zippers-1/">Зипперы (часть 1). Азы навигации</a></li>
  <li><a href="/clj-zippers-2/">Зипперы (часть 2). Автонавигация</a></li>
  <li><a href="/clj-zippers-3/">Зипперы (часть 3). XML-зипперы</a></li>
  <li><a href="/clj-zippers-4/">Зипперы (часть 4). Поиск в XML</a></li>
  <li><a href="/clj-zippers-5/">Зипперы (часть 5). Редактирование</a></li>
  <li><a href="/clj-zippers-6/">Зипперы (часть 6). Виртуальные деревья. Обмен валют</a></li>
  <li><a href="/clj-zippers-7/">Зипперы (часть 7). Обход в ширину. Улучшенный обмен валют</a></li>
  <li><a href="/clj-zippers-8/">Зипперы (часть 8). Заключение</a></li>
</ul>


  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-zippers-6/">
    <input required name="captcha" type="hidden" value="3 &#215; 7">

    <div class="block">
        <span class="comment-form-label"><small>3 &#215; 7 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
