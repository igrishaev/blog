---
comment_id: 1751890061860
is_spam: false
is_deleted: false
post: /sql-hate/
date: 2025-07-07 12:07:42 +0000
author_fullname: 'Роман'
---

Ненависть к SQL вполне объяснима. Требования растут и ограничения становятся проблемой. 

В начале нулевых работал в одном региональном телекоме. Там была ситуация - чтоб запустить один отчет из программы человек бегал и всех в здании предупреждал. Иначе на 15-20 минут работа вставала.

Я потом этот ужос оптимизировал. SQL запрос на 4 страницы мелким шрифтом. Любви это вовсе не прибавило. А это было время как раз безраздельного доминирования SQL-а. Это не проблема SQL как такового, но он таки ограничен и выстрелить в ногу - элементарно. 

> Когда я стал работать в крупной фирме, поразился тому, что почти каждый знает SQL. Менеджеров и аналитиков этому учат на курсах. 

Насколько я помню он изначально и создавался именно для них. Простое средство выборки данных для аналитиков и способ сэкономить на программистах. 

> Кончилось тем, что Postgres сделал jsonb 

Но вот только это уже не SQL - то есть просто прогнулись под общий тренд. И обращаю внимание - фича-то востребованная. То есть не хватает уже SQL-а. 

> Сюда же относится OpenSearch ... На практике его развертка настолько сложна — нужно минимум три узла в кубере

Работаю с эластиком - это вроде как тоже самое. Никакие три узла в кубере не нужны (не обязательны). Запускается не сложнее любой СУБД.

> Апишку OpenSearch вы видели? Казалось бы, HTTP и REST, шли джейсоны и живи спокойно. Я с ней работал и скажу — неудобно. 

Да - неудобно. Ублюдочный вложенный JSON. Напрямую его никогда не генерю - есть обертки, которые позволяют делать это композицией. Но спасает несильно. Кроме вложенности нестабильный и неконсистентный синтаксис просто раздражает.

> Нельзя выбрать больше 10 тысяч записей за раз 

Можно. Это всего лишь умолчание.

> (Посгрес выплюнет миллион за долю секунды)

Никогда этого аргумента не понимал. Зачем вам выплевывать миллионы? Куда? 
Вы на экран пользователю эти миллионы вывалите? Ну нет же - один хрен вы все будете пагинировать. Или аггрегировать. 

И на клиента вы потащите ограниченный набор, а не "эти ваши миллионы"

И именно отсюда это умолчание в OpenSearch/Elastic 

> Пагинация ужасная и состоит их двух апишек, а не одной.

Не совсем понял в чем ужос-ужос. Пагинация там как раз правильная, а не offset/limit       который используется повсеместно. В PG кстати offset/limit был традиционной болью ибо работал медленно (может уже починили - давно это не тестил)

Ну и вот сейчас графану глянул на живом проекте. Elastic + MariaDB.
Среднее время выборки 

- elastic - 1.5ms
- mysql - 33ms

Максимальное

- elastic 9 ms
- mysql - 1.24s

И это при том, что в эластике очень много выборок с аггрегированнием и в целом данных сильно больше. 
 
Это конечно пальцем в небо - грубо без учета специфики использования. Но тут разница в скорости колоссальная - она слишком велика, чтоб ее игнорировать. Поэтому оно и живо и популярно.

Итого - пусть растут все цветы. SQL никуда не денется - для своих целей он близок к идеалу - взрослая стабильная технология. Весь этот noSQL просто занимает ниши где SQL не очень хорош. Проблемы они в крайностях и фанатиках с "эффектом утенка".




