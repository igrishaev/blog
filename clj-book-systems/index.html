<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Системы в Clojure</title>
  <meta name="description" content="В этой главе мы поговорим о системах. Рассмотрим, как составить проект изотдельных частей и заставить их работать вместе.">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-book-systems/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Системы в Clojure</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2019-08-25T00:00:00+00:00">
        Aug 25, 2019
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/systems/" rel="tag">systems</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>В этой главе мы поговорим о системах. Рассмотрим, как составить проект из
отдельных частей и заставить их работать вместе.</em></p>

<h2>

    Содержание

</h2>

<ul id="toc-item-clj-book-systems">
  <li><a href="#подробнее-о-системе" id="toc-item-clj-book-systems-подробнее-о-системе">Подробнее о системе</a></li>
  <li><a href="#зависимости" id="toc-item-clj-book-systems-зависимости">Зависимости</a></li>
  <li><a href="#преимущества" id="toc-item-clj-book-systems-преимущества">Преимущества</a></li>
  <li><a href="#подготовка-к-обзору" id="toc-item-clj-book-systems-подготовка-к-обзору">Подготовка к обзору</a></li>
  <li><a href="#база-данных" id="toc-item-clj-book-systems-база-данных">База данных</a></li>
  <li><a href="#docker" id="toc-item-clj-book-systems-docker">Docker</a></li>
  <li><a href="#mount" id="toc-item-clj-book-systems-mount">Mount</a>    <ul>
      <li><a href="#первая-сущность" id="toc-item-clj-book-systems-первая-сущность">Первая сущность</a></li>
      <li><a href="#связь-с-конфигурацией" id="toc-item-clj-book-systems-связь-с-конфигурацией">Связь с конфигурацией</a></li>
      <li><a href="#база-данных-1" id="toc-item-clj-book-systems-база-данных-1">База данных</a></li>
      <li><a href="#фоновая-задача" id="toc-item-clj-book-systems-фоновая-задача">Фоновая задача</a></li>
      <li><a href="#все-вместе" id="toc-item-clj-book-systems-все-вместе">Все вместе</a></li>
      <li><a href="#зависимости-1" id="toc-item-clj-book-systems-зависимости-1">Зависимости</a></li>
      <li><a href="#внутреннее-устройство" id="toc-item-clj-book-systems-внутреннее-устройство">Внутреннее устройство</a></li>
      <li><a href="#состояние" id="toc-item-clj-book-systems-состояние">Состояние</a></li>
      <li><a href="#выборочный-запуск" id="toc-item-clj-book-systems-выборочный-запуск">Выборочный запуск</a></li>
      <li><a href="#проблема-перезагрузки" id="toc-item-clj-book-systems-проблема-перезагрузки">Проблема перезагрузки</a></li>
      <li><a href="#самостоятельная-работа" id="toc-item-clj-book-systems-самостоятельная-работа">Самостоятельная работа</a></li>
    </ul>
  </li>
  <li><a href="#component" id="toc-item-clj-book-systems-component">Component</a>    <ul>
      <li><a href="#устройство" id="toc-item-clj-book-systems-устройство">Устройство</a></li>
      <li><a href="#первый-компонент" id="toc-item-clj-book-systems-первый-компонент">Первый компонент</a></li>
      <li><a href="#конструктор" id="toc-item-clj-book-systems-конструктор">Конструктор</a></li>
      <li><a href="#особенность-слотов" id="toc-item-clj-book-systems-особенность-слотов">Особенность слотов</a></li>
      <li><a href="#компонент-базы" id="toc-item-clj-book-systems-компонент-базы">Компонент базы</a></li>
      <li><a href="#транзакционный-компонент" id="toc-item-clj-book-systems-транзакционный-компонент">Транзакционный компонент</a></li>
      <li><a href="#воркер" id="toc-item-clj-book-systems-воркер">Воркер</a></li>
      <li><a href="#ручные-зависимости" id="toc-item-clj-book-systems-ручные-зависимости">Ручные зависимости</a></li>
      <li><a href="#промышленная-система" id="toc-item-clj-book-systems-промышленная-система">Промышленная система</a></li>
      <li><a href="#хранение-системы" id="toc-item-clj-book-systems-хранение-системы">Хранение системы</a></li>
      <li><a href="#корректное-завершение" id="toc-item-clj-book-systems-корректное-завершение">Корректное завершение</a></li>
      <li><a href="#ожидание-системы" id="toc-item-clj-book-systems-ожидание-системы">Ожидание системы</a></li>
      <li><a href="#улучшаем-зависимости" id="toc-item-clj-book-systems-улучшаем-зависимости">Улучшаем зависимости</a></li>
      <li><a href="#группировка-слотов" id="toc-item-clj-book-systems-группировка-слотов">Группировка слотов</a></li>
      <li><a href="#условная-система" id="toc-item-clj-book-systems-условная-система">Условная система</a></li>
      <li><a href="#спуск-системы" id="toc-item-clj-book-systems-спуск-системы">Спуск системы</a></li>
      <li><a href="#идемпотентность" id="toc-item-clj-book-systems-идемпотентность">Идемпотентность</a></li>
    </ul>
  </li>
  <li><a href="#integrant" id="toc-item-clj-book-systems-integrant">Integrant</a>    <ul>
      <li><a href="#базовое-устройство" id="toc-item-clj-book-systems-базовое-устройство">Базовое устройство</a></li>
      <li><a href="#первые-компоненты" id="toc-item-clj-book-systems-первые-компоненты">Первые компоненты</a></li>
      <li><a href="#зависимости-2" id="toc-item-clj-book-systems-зависимости-2">Зависимости</a></li>
      <li><a href="#параллели-с-component" id="toc-item-clj-book-systems-параллели-с-component">Параллели с Component</a></li>
      <li><a href="#проблема-потери-ключей" id="toc-item-clj-book-systems-проблема-потери-ключей">Проблема потери ключей</a></li>
      <li><a href="#система-в-файле" id="toc-item-clj-book-systems-система-в-файле">Система в файле</a></li>
      <li><a href="#наследование-ключей" id="toc-item-clj-book-systems-наследование-ключей">Наследование ключей</a></li>
      <li><a href="#другие-стадии-компонента" id="toc-item-clj-book-systems-другие-стадии-компонента">Другие стадии компонента</a></li>
      <li><a href="#подготовка" id="toc-item-clj-book-systems-подготовка">Подготовка</a></li>
      <li><a href="#спека" id="toc-item-clj-book-systems-спека">Спека</a></li>
      <li><a href="#приостановка" id="toc-item-clj-book-systems-приостановка">Приостановка</a></li>
    </ul>
  </li>
  <li><a href="#заключение" id="toc-item-clj-book-systems-заключение">Заключение</a></li>
</ul>

<p>Понятие системы тесно связано с конфигурацией, которую мы подробно рассмотрели
недавно. На этапе черновика конфигурация и системы составляли одну главу, но со
временем стало ясно, что это отдельные темы. Причина кроется не столько в объеме
материала, сколько в семантике. Конфигурация и система это не одно и то же.</p>

<p class="draft-warn">Внимание! Вы читаете черновик к книге <a href="/clojure-in-prod/">“Clojure на производстве”</a>. Для
книги я переписывал его много раз, но в блоге осталась старая версия. Здесь она
для истории, а вам я рекомендую купить книжку.</p>

<p>Конфигурация учит тому, как получить параметры из внешнего мира. Как выстроить
этот процесс согласно производству и пожеланиям команды. Система означает
внутреннее устройство программы. Это набор компонентов с логическими связями и
иерархией.</p>

<p>Система зависит от конфигурации, но не строго один к одному. Для одной и той же
конфигурации бывают разные системы и наоборот. Главное отличие в следующем:
конфигурация отвечает на вопрос как получить параметры, а система знает, как ими
распорядиться.</p>

<!-- more -->

<h2 id="подробнее-о-системе">Подробнее о системе</h2>

<p>Понятие системы появилось в момент, когда возник спрос на долгоиграющие
приложения. При разработке скриптов или утилит этот вопрос не стоял остро. Время
работы скрипта обычно коротко, и его состояние тоже живет недолго. При
завершении программы занятые ресурсы освобождаются, поэтому нет нужды в особом
контроле за ними.</p>

<p>Это не так при работе с серверными приложениями. Они рассчитаны на постоянную
работу и потому устроены иначе, чем разовые скрипты. Приложение состоит из
компонентов, которые работают в фоне. Каждый компонент выполняет какую-то узкую
задачу. При запуске приложение включает компоненты в правильном порядке и строит
между ними связи.</p>

<p>Компонент это любой объект, который несет состояние. На него действуют две
операции: включить и выключить. Как правило, включить компонент означает
установить соединение с каким-либо ресурсом, а выключить — закрыть его.</p>

<p>Типичные компоненты веб-приложения это HTTP-сервер, база данных и кэш. Так,
чтобы не открывать новое TCP-соединение на каждый запрос к базе, понадобится пул
соединений. Но создавать его вручную и передавать в функции это слишком рутинная
задача. Должен быть компонент, который при включении открывает пул соединений и
хранит его внутри. Для сторонних потребителей компонент предлагает функции для
работы с БД. Внутри эти функции опираются на открытый пул.</p>

<p>На первый взгляд схема напоминает концепцию ООП и ее принцип инкапсуляции. Но в
мире Clojure компоненты работают иначе. Пусть читатель не торопится с
выводами. Ниже мы рассмотрим техническую разницу между объектами и компонентами.</p>

<h2 id="зависимости">Зависимости</h2>

<p>Центральная проблема систем это зависимость компонентов друг от друга. В примере
выше все компоненты — сервер, база и кэш — работают обособленно. Например,
подключение к базе требуется только для отдельных страниц, а кэширование
устроено так, что неработающий кэш не ломает приложение. Говорят, что это
базовые компоненты системы.</p>

<p>Компоненты высокого уровня опираются на базовые. Примером такого компонента
может быть фоновый поток, который читает данные из базы и отправляет
письма. Будет неправильно, если компонент откроет собственные подключения к
обоим ресурсам. Вместо этого он принимает уже запущенные компоненты базы и почты
и работает с ними как с черным ящиком.</p>

<p>Важно, что компонент не пытается управлять жизненным циклом его зависимостей. В
момент старта дочерние компоненты части уже запущены. Порядок запуска и
остановки компонентов в правильном порядке остается на откуп системы.</p>

<p>Система это комбинация компонентов с учетом их зависимостей. Ключевая
обязанность системы — запустить и остановить дерево компонентов в правильном
порядке. Например, если компонент A зависит от B и C, то к моменту запуска A
последние два уже должны быть запущены. При завершении программы компонент C
нельзя тушить до тех пор, пока работает A.</p>

<p>Технически задача сводится к построению графа зависимостей между
компонентами. При запуске и выключении нужно обойти этот граф так, чтобы
удовлетворить запросы каждого компонента.</p>

<p>К продвинутым системам предъявляют дополнительные требования. Например, не
допустить ситуацию, когда система запущена частично. Такое возможно, когда один
из компонентов выбросил исключение. Включился сервер, почта, а база данных
недоступна.</p>

<p>Это досадная ситуация, потому что мы застряли в пограничном состоянии. С точки
зрения программы запуск системы не удался. Если починить БД и включить систему
во второй раз, мы получим другую ошибку. Система попытается включить компоненты,
которые уже работают, что приведет к конфликту в сетевых подключениях.</p>

<p>Будет правильно, если дойдя до проблемного компонента, загрузчик системы не
вывалится с исключением, а поместит его в переменную. Затем пойдет в обратном
направлении и выключит все компоненты, что уже успел включить. И только потом
выбросит исключение, которое поймал.</p>

<p>Система должна быть устроена так, чтобы было легко добавить в нее новый
компонент. Чтобы достичь этого, система должна быть описана декларативно. В
идеальном случае система это структура данных — комбинация словарей и
списков. Код загрузки пробегает по этой структуре и включает
компоненты. Расширить систему означает добавить новый узел в коллекцию.</p>

<p>Когда система знает о зависимостях компонентов, появляется приятная возможность
запустить ее подмножество. Например, нужно отладить работу фонового обработчика
почты. Это компонент, который зависит от базы и SMTP-сервера. Веб-сервер и кэш в
данном случае не нужны, и запуск всей системы будет излишним. Продвинутые
системы предлагают функцию с семантикой “запусти это компонент и все его
зависимости”.</p>

<h2 id="преимущества">Преимущества</h2>

<p>На первый взгляд кажется, что система — лишнее усложнение в проекте. Это
дополнительная библиотека, новые соглашения в команде, рефакторинг кода и
ограничения. Но первичные неудобства окупаются со временем.</p>

<p>Система приводит проект в порядок. С ростом кодовой базы становится критически
важным, чтобы разные части проекта были выполнены в одном стиле. Это особенно
удобно, когда продукт состоит из отдельных сервисов. В таких случаях
разработчиков выручает повторное использование кода, в том числе банальная
“копипаста”.</p>

<p>Системы полезны на стадиях производства, особенно тестировании. Для тестов
запускают измененную версию системы, где отдельные компоненты работают
по-другому. Предположим, для отправки смс в систему подкладывают компонент,
который пишет сообщения в файл.</p>

<p>Подобно конфигурации, у системы свой жизненный цикл. Понимая этот цикл, мы можем
вмешиваться в работу системы и вносить корректировки. Например, на стадии
определения системы внедрить операторы <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">when</code>, <code class="language-plaintext highlighter-rouge">cond-&gt;</code>, чтобы добавить
или убрать компоненты в зависимости от конфигурации.</p>

<h2 id="подготовка-к-обзору">Подготовка к обзору</h2>

<p>В <a href="/clj-book-mutability/">главе об изменяемых данных</a> мы впервые заговорили о
системах. Это был раздел про <code class="language-plaintext highlighter-rouge">alter-var-root</code>, и мы только что узнали, как
менять глобальные переменные. Идея в том, чтобы вынести каждый компонент в
модуль и снабдить его функциями <code class="language-plaintext highlighter-rouge">start!</code> и <code class="language-plaintext highlighter-rouge">stop!</code>. Функции включают и выключают
состояние модуля: веб-сервер, базу данных и так далее. Запуск системы сводится к
вызову функций в правильном порядке.</p>

<p>Это слабое, любительское решение. Такая система не знает о зависимостях между
компонентами. Она хрупкая, работает в ручном режиме, и любое ее изменение
требует проверок.</p>

<p>В оставшейся части главы мы не будем писать свою систему. В этом нет смысла,
потому что при разработке системы важна ее семантика, идеологическая
часть. Когда семантика найдена, написать код становится тривиальным занятием.</p>

<p>В мире Clojure существует несколько библиотек для работы с системами. Мы
рассмотрим проекты mount, component и integrant. Их кодовые базы невелики,
каждая по нескольку сотен строк кода. Библиотеки различаются принципами,
идеологией при построении систем. Они исповедуют разный подход для описания
компонентов и связей между ними. Тем интересней будет взглянуть на проблему с
разных сторон.</p>

<p>Библиотеки специально расставлены в таком порядке. Mount следует первым, потому
что с него легче начать. Он будет удачным выбором для начинающих. Component стал
промышленным стандартом. Мы уделим ему больше внимания и поэтому поставим в
середину. Integrant замыкает обзор, потому что его рассматривают как
альтернативу Component, с котором читатель уже должен быть знаком.</p>

<p>В практических примерах нам бы хотелось избежать банальности. Вместо наивных
<code class="language-plaintext highlighter-rouge">foo</code> и <code class="language-plaintext highlighter-rouge">bar</code> мы построим настоящую систему, похожую на промышленные
аналоги. Система состоит из веб-сервера, базы данных и фонового процесса,
который дополняет базу из внешнего источника.</p>

<p>Схема специально устроена так, чтобы в ней встречались зависимые
компоненты. Например, фоновый процесс нуждается в компоненте базы данных. Так мы
научимся работать с зависимостями. Топологию системы можно изобразить так:</p>

<div class="language-plaintext code_chart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>           ┌────────────┐
           │   Config   │┼──────────────────┐
           └────────────┘                   │
                  ┼                         │
          ┌───────┴──────┐                  │
          │              │                  │
   ┌────────────┐  ┌────────────┐    ┌────────────┐
   │   Server   │  │  Database  │┼───│   Worker   │
   └────────────┘  └────────────┘    └────────────┘
</code></pre></div></div>

<p>Стрелки на схеме означают зависимости. Выражение A → B означает “А зависит
от В”. В нашей системе все компоненты зависят от конфигурации. Дополнительно
фоновый обработчик зависит от базы данных. Над этой топологией мы и будем
работать до конца главы.</p>

<h2 id="база-данных">База данных</h2>

<p>Отдельно рассмотрим компонент базы данных. В прошлых главах мы упоминали, что
открывать новое соединение на каждый запрос неоптимально. В настоящих проектах с
базой работают через пул соединений. Пул это сущность с внутренним состоянием,
поэтому его тоже “включают и выключают”.</p>

<p>Другие обучающие материалы приводят примеры с in-memory базами данных: SQLite,
H2. Это базы, которые хранят данные в оперативной памяти без доступа к
диску. Преимущество в том, что такие базы не нужно устанавливать в систему и
запускать в отдельном процессе. Как правило, исходный код этой базы слинкован с
библиотекой для вашего языка. Достаточно подключить зависимость в проект и
работать с базой как с модулем.</p>

<p>Вариант с базой в памяти удобен для быстрого старта, но не отражает реалии
производства — то, к чему мы стремимся в этой книге. Для in-memory-баз не
используют пулы соединений. В этом нет смысла, потому что данные лежат в памяти
процесса, а не в сети. Поэтому мы используем настоящую реляционную БД PostgreSQL
в связке с пулом HikariCP.</p>

<p>В нашей системе работает фоновый процесс, воркер. Это отдельный поток, который
выбирает из базы не до конца заполненные записи и извлекает нужную информацию из
сети. В главе про изменяемость мы рассматривали случай с
гео-координатами. Мобильное приложение отправляет текущие широту и долготу, и мы
записываем их в базу. Поскольку вывод данных о локации может быть долгим, мы
делаем это в фоне.</p>

<p>Для этой главы мы подобрали другой пример. Предположим, фирма ведет свою
аналитику посещений. Каждый раз, когда кто-то открывает страницу, приложение
записывает в базу ее адрес и базовые поля запроса: заголовок User-Agent,
IP-адрес клиента. Чтобы строить отчеты в разрезе стран и городов, нужно извлечь
эти данные из тех, что у нас на руках. Чаще всего это дорогая операция, поэтому
записи присваивают статус “ждет обработки” и выносят логику в фон.</p>

<h2 id="docker">Docker</h2>

<p>Возможно, у вас уже установлен PostgreSQL. Тогда вам останется только создать
новую базу и таблицу в ней. Если нет, самое время попробовать Docker. Это
система для запуска приложений из образов. Под образом понимают специальный
файл, внутри которого спрятано приложение со всем необходимым для
запуска. Запущенный образ называют контейнером.</p>

<p>У контейнеров несколько преимуществ. Приложение запускается в изолированной
среде и тем самым отделено от основной системы. Кроме безопасности, это решает
проблему чистоты — по завершении контейнер не оставляет следов работы, если это
не настроено специально.</p>

<p>Существует публичный репозиторий образов, откуда Docker их
скачивает. Производители ПО выкладывают образы программ в различных версиях и
комплектации. Например, если приложению нужна БД версии 9.3 с определенными
расширениями, просто скачайте этот образ. Локальная установка, скорее всего,
вступит в конфликт с уже имеющейся БД.</p>

<p>Некоторые образы подготовлены так, что их удобно настроить переменными среды или
файлами. Когда вы запускаете базу, то, скорее всего, ожидаете определенные
таблицы и данные. Образ postgres устроен так, что при старте он загружает все
<code class="language-plaintext highlighter-rouge">*.sql</code> файлы из папки <code class="language-plaintext highlighter-rouge">/docker-entrypoint-initdb.d</code>. Если сопоставить этой
папке локальный том с sql-схемой и миграциями, получится готовая база без
строчки кода.</p>

<p>В комплекте с Docker идет утилита docker-compose. Она запускает контейнеры на
базе файла конфигурации. Стандартное имя этого файла <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code>. Это
YAML-документ , где перечислены образы и параметры их запуска. В примере ниже
указан один контейнер, postgres с определенными портами, томами и переменными
среды.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">2'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">postgres</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./initdb.d:/docker-entrypoint-initdb.d</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">5432:5432</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">POSTGRES_DB</span><span class="pi">:</span> <span class="s">book</span>
      <span class="na">POSTGRES_USER</span><span class="pi">:</span> <span class="s">book</span>
      <span class="na">POSTGRES_PASSWORD</span><span class="pi">:</span> <span class="s">book</span>
</code></pre></div></div>

<p>В папке <code class="language-plaintext highlighter-rouge">initdb.d</code> лежат sql-файлы для старта базы. Нам достаточно файла
<code class="language-plaintext highlighter-rouge">01.init.sql</code> с одной таблицей:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">drop</span> <span class="k">table</span> <span class="n">if</span> <span class="k">exists</span> <span class="n">requests</span><span class="p">;</span>
<span class="k">create</span> <span class="k">table</span> <span class="n">requests</span> <span class="p">(</span>
    <span class="n">id</span>            <span class="nb">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">created_at</span>    <span class="nb">timestamp</span> <span class="k">with</span> <span class="nb">time</span> <span class="k">zone</span>
                    <span class="k">not</span> <span class="k">null</span> <span class="k">default</span> <span class="n">now</span><span class="p">(),</span>
    <span class="n">path</span>          <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">ip</span>            <span class="n">inet</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">is_processed</span>  <span class="nb">boolean</span> <span class="k">not</span> <span class="k">null</span> <span class="k">default</span> <span class="k">false</span><span class="p">,</span>
    <span class="n">zip</span>           <span class="nb">text</span><span class="p">,</span>
    <span class="n">country</span>       <span class="nb">text</span><span class="p">,</span>
    <span class="n">city</span>          <span class="nb">text</span><span class="p">,</span>
    <span class="n">lat</span>           <span class="nb">float</span><span class="p">,</span>
    <span class="n">lon</span>           <span class="nb">float</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Если запустить <code class="language-plaintext highlighter-rouge">docker-compose up</code>, то через некоторое время в системе
заработает сервер PostgreSQL на 5432 порту и готовой базой book.</p>

<p>Мы не будем уделять внимание установке Docker и тонкостям его настройки,
поскольку эта тема заслуживает отдельной книги. Всю необходимую информацию вы
найдете на официальном сайте проекта — <a href="https://docker.com">docker.com</a>.</p>

<h2 id="mount">Mount</h2>

<p>Библиотека <a href="https://github.com/tolitius/mount">Mount</a> описывает сущности с двумя состояниями: запущено и
остановлено. По команде сущность “включается” и принимает значение, которое
вернул код из фазы старта. При выключении срабатывает код из фазы останова.</p>

<p>Mount использует некоторые трюки, чтобы максимально упростить работу
программисту. Ее сущности напоминают глобальные переменные, которые меняют
значения по команде. С точки зрения потребителя mount устроен просто, и потому
удобен для начинающих.</p>

<p>Центральная точка библиотеки это макрос <code class="language-plaintext highlighter-rouge">defstate</code>, который объявляет новую
сущность. Макрос похож на форму <code class="language-plaintext highlighter-rouge">def</code>: он тоже объявляет переменную в текущем
пространстве. Разница в том, что вместо значения defstate принимает два
выражения: первое для старта, второе для остановки.</p>

<p>Пока сущность не включена, в переменной хранится особое значение
<code class="language-plaintext highlighter-rouge">DerefableState</code>. Когда ее включили, переменная принимает значение, которое
вернуло выражение старта. Выключение работает слегка по-другому. Выполняется код
останова, и переменная становится особым значением <code class="language-plaintext highlighter-rouge">NotStartedState</code>.</p>

<h3 id="первая-сущность">Первая сущность</h3>

<p>Опишем с помощью Mount компонент веб-сервера. Поместим его в отдельный модуль в
файле <code class="language-plaintext highlighter-rouge">src/book/systems/mount/server.clj</code>. Приложение app это функция, которая
возвращает одинаковый ответ для любого запроса.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.systems.mount.server</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">mount.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">mount</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">defstate</span><span class="p">]]</span><span class="w">
   </span><span class="p">[</span><span class="n">ring.adapter.jetty</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">run-jetty</span><span class="p">]]))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="nf">defstate</span><span class="w"> </span><span class="n">server</span><span class="w">
  </span><span class="no">:start</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="p">})</span><span class="w">
  </span><span class="no">:stop</span><span class="w"> </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>В макросе <code class="language-plaintext highlighter-rouge">defstate</code> фазы отделены ключами <code class="language-plaintext highlighter-rouge">:start</code> и <code class="language-plaintext highlighter-rouge">:stop</code>. Пока что мы
только объявили состояние, но ничего не включили. Если выполнить выражение
server, увидим примерно следующее:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="n">mount.core.DerefableState</span><span class="p">[{</span><span class="no">:status</span><span class="w"> </span><span class="no">:pending,</span><span class="w"> </span><span class="no">:val</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w"> </span><span class="mi">0</span><span class="n">x358e34df</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы запустить компонент, выполните <code class="language-plaintext highlighter-rouge">(mount/start)</code>. Функция пробегает по всем
объявленным сущностями и включает их. Выражение <code class="language-plaintext highlighter-rouge">(run-jetty ...)</code> под ключом
<code class="language-plaintext highlighter-rouge">:start</code> возвращает объект сервера, который работает в фоне. После запуска
проверьте, что сервер работает: по адресу http://127.0.0.1:8080 браузер покажет
приветствие. Переменная <code class="language-plaintext highlighter-rouge">server</code> станет объектом класса <code class="language-plaintext highlighter-rouge">Server</code> из пакета
jetty:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="n">server</span><span class="p">)</span><span class="w">
</span><span class="n">org.eclipse.jetty.server.Server</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы выключить систему, выполните <code class="language-plaintext highlighter-rouge">(mount/stop)</code>. Обратите внимание, что в
выражении <code class="language-plaintext highlighter-rouge">(.stop server)</code> сущность обращается к самой себе. Это нормально,
потому что на этапе выключения переменная server будет именно тем, что мы
ожидаем. После остановки server станет особым значением, которое означает
завершение.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="n">server</span><span class="p">)</span><span class="w">
</span><span class="n">mount.core.NotStartedState</span><span class="w">
</span></code></pre></div></div>

<p>По такому принципу строят систему. Сперва находят сущности, которые работают в
течение всего жизненного цикла программы. Как правило, это сетевые подключения
или фоновые задачи. Затем выносят их в отдельные модули, где описывают логику
включения и завершения.</p>

<h3 id="связь-с-конфигурацией">Связь с конфигурацией</h3>

<p>В примере выше мы допускаем ту же ошибку, что и в прошлой главе. Параметры
сервера “захардкожены” на месте его запуска. Это затрудняет работу с
проектом. Параметры каждой сущности должны приходить из конфигурации.</p>

<p>Мы уже научились работать с конфигурацией и знакомы с cprop, yummy и
аналогами. В прошлый раз мы запускали ее вручную функцией
<code class="language-plaintext highlighter-rouge">(load-config!)</code>. Поскольку мы строим систему, логично вынести конфигурацию в
отдельный компонент. При его запуске срабатывают все шаги, что мы рассмотрели
ранее: чтение файла и переменных среды, вывод типов и валидация.</p>

<p>Поместим конфигурацию в модуль <code class="language-plaintext highlighter-rouge">src/book/systems/mount/config.clj</code>. Для
краткости опустим описание спеки <code class="language-plaintext highlighter-rouge">::config</code>: пусть это будет только проверка на
словарь. Фаза <code class="language-plaintext highlighter-rouge">:start</code> читает edn-файл, проверяет спекой и возвращает
данные. Замените <code class="language-plaintext highlighter-rouge">:start</code> на вызов библиотеки Yummy, Aero или свое решение.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.systems.mount.config</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">mount.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">mount</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">defstate</span><span class="p">]]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.spec.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.edn</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">edn</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::config</span><span class="w"> </span><span class="nb">map?</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defstate</span><span class="w"> </span><span class="n">config</span><span class="w">
  </span><span class="no">:start</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"system.config.edn"</span><span class="w">
      </span><span class="nb">slurp</span><span class="w">
      </span><span class="n">edn/read-string</span><span class="w">
      </span><span class="p">(</span><span class="nf">as-&gt;</span><span class="w"> </span><span class="n">config</span><span class="w">
          </span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::config</span><span class="w"> </span><span class="n">config</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Для компонента выше не нужна фаза <code class="language-plaintext highlighter-rouge">:stop</code>. Конфигурация не содержит открытых
ресурсов, поэтому дополнительная логика останова не требуется.</p>

<p>Улучшим компонент сервера так, чтобы он зависел от конфигурации. Технически это
сводится к тому, чтобы импортировать в модуль сервера объект конфигурации и
работать с ним как с обычным словарем.</p>

<p>Пусть файл <code class="language-plaintext highlighter-rouge">system.config.edn</code> содержит словарь, где ключ это имя компонента, а
значение — словарь его параметров. Поместим параметры сервера под ключ <code class="language-plaintext highlighter-rouge">:jetty</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:jetty</span><span class="w"> </span><span class="p">{</span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="no">:port</span><span class="w"> </span><span class="mi">8088</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Обновим модуль сервера. В список <code class="language-plaintext highlighter-rouge">:require</code> добавим импорт конфигурации:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">book.systems.mount.config</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>Перепишем компонент так, чтобы параметры приходили из словаря:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defstate</span><span class="w">
  </span><span class="n">server</span><span class="w">
  </span><span class="no">:start</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="n">jetty-opt</span><span class="w"> </span><span class="no">:jetty</span><span class="p">}</span><span class="w"> </span><span class="n">config</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="n">jetty-opt</span><span class="p">))</span><span class="w">
  </span><span class="no">:stop</span><span class="w"> </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>На этом этапе у нас уже получилась система из двух компонентов, где один зависит
от другого. Убедитесь, что после вызова <code class="language-plaintext highlighter-rouge">(mount/start)</code> сервер работает как
ожидалось.</p>

<h3 id="база-данных-1">База данных</h3>

<p>Подготовим компонент для работы с базой данных. Понадобяться две библиотеки:
<code class="language-plaintext highlighter-rouge">clojure.java.jdbc</code> и <code class="language-plaintext highlighter-rouge">hikari-cp</code>. Первая предлагает универсальный доступ к
реляционным базам данных. Это набор функций, которые работают одинаково для
разных типов баз. Например, выражения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/get-by-id</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"ivan@test.com"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>прочитают и запишут нового пользователя в PostgreSQL, MySQL или Oracle. Для
каждого бекенда JDBC построит правильный SQL-запрос.</p>

<p>Каждая jdbc-функция принимает первым параметром то, что называется
JDBC-спекой. В простом случае это словарь с параметрами подключения к базе:
адрес и порт сервера, имя базы, пользователь и пароль. На каждый запрос JDBC
создает новый источник данных с этими параметрами, открывает соединение,
обменивается данными и закрывает его.</p>

<p>Спека может содержать необязательный ключ :datasource с уже подготовленным
источником. Тогда JDBC игнорирует другие ключи и работает напрямую с
<code class="language-plaintext highlighter-rouge">:datasource</code>. Библиотека hikari-cp предлагает функцию, чтобы построить источник
данных с пулом соединений. Каждый раз, когда мы запрашиваем соединение у
источника, мы не открываем новое, а получаем одно из созданных ранее.</p>

<p>Поскольку пул это объект с жизненным циклом, его выносят в компонент. Подготовим
модуль <code class="language-plaintext highlighter-rouge">src/book/systems/mount/db.clj</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.systems.mount.db</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">mount.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">mount</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">defstate</span><span class="p">]]</span><span class="w">
   </span><span class="p">[</span><span class="n">hikari-cp.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">cp</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">book.systems.mount.config</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]))</span><span class="w">

</span><span class="p">(</span><span class="nf">defstate</span><span class="w"> </span><span class="n">db</span><span class="w">
  </span><span class="no">:start</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="n">pool-opt</span><span class="w"> </span><span class="no">:pool</span><span class="p">}</span><span class="w"> </span><span class="n">config</span><span class="w">
        </span><span class="n">store</span><span class="w"> </span><span class="p">(</span><span class="nf">cp/make-datasource</span><span class="w"> </span><span class="n">pool-opt</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:datasource</span><span class="w"> </span><span class="n">store</span><span class="p">})</span><span class="w">
  </span><span class="no">:stop</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:datasource</span><span class="w"> </span><span class="n">cp/close-datasource</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>На этапе старта мы возвращаем JDBC-спеку — словарь с одним ключом
<code class="language-plaintext highlighter-rouge">:datasource</code>. На стадии выключения функция <code class="language-plaintext highlighter-rouge">close-datasource</code> закрывает пул и
все открытые соединения.</p>

<p>В файл конфигурации добавим настройки пула:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:pool</span><span class="w"> </span><span class="p">{</span><span class="no">:minimum-idle</span><span class="w">       </span><span class="mi">10</span><span class="w">
        </span><span class="no">:maximum-pool-size</span><span class="w">  </span><span class="mi">10</span><span class="w">
        </span><span class="no">:pool-name</span><span class="w">          </span><span class="s">"book-pool"</span><span class="w">
        </span><span class="no">:adapter</span><span class="w">            </span><span class="s">"postgresql"</span><span class="w">
        </span><span class="no">:username</span><span class="w">           </span><span class="s">"book"</span><span class="w">
        </span><span class="no">:password</span><span class="w">           </span><span class="s">"book"</span><span class="w">
        </span><span class="no">:database-name</span><span class="w">      </span><span class="s">"book"</span><span class="w">
        </span><span class="no">:server-name</span><span class="w">        </span><span class="s">"127.0.0.1"</span><span class="w">
        </span><span class="no">:port-number</span><span class="w">        </span><span class="mi">5432</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Для экономии места обозначим только самые важные параметры. Это свойства
подключения (адрес и имя базы, пользователь, пароль) и размерность
пула. Дополнительно можно задать тайминг для каждой стадии работы с БД. Полный
список параметров с их описанием перечислен на странице GitHub-проекта.</p>

<p>Запустите систему и выполните простой запрос:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">mount/start</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.java.jdbc</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select 42 as answer"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; ({:answer 42})</span><span class="w">
</span></code></pre></div></div>

<h3 id="фоновая-задача">Фоновая задача</h3>

<p>Все готово для последнего и самого сложного компонента системы. Это фоновый
процесс, воркер, который работает в отдельном потоке. Процесс выбирает из базы
не обработанные записи и дополняет пустые поля данными из стороннего сервиса.</p>

<p>Напомним, что в таблице requests мы храним дату, адрес страницы и IP-адрес
клиента. Поле <code class="language-plaintext highlighter-rouge">is_processed</code> это признак того, была ли уже обработана
запись. Искомые поля <code class="language-plaintext highlighter-rouge">city</code>, <code class="language-plaintext highlighter-rouge">country</code> и другие по умолчанию не заполняются и
равны <code class="language-plaintext highlighter-rouge">null</code>.</p>

<p>Задача воркера сводится к тому, чтобы каждый интервал времени запрашивать одну
запись с флагом <code class="language-plaintext highlighter-rouge">NOT is_processed</code>. Затем сделать запрос к сервису, который
вернет гео-данные по IP. Обновить поля записи и сохранить изменения в базе. Все
описанное делать в транзакции.</p>

<p>Подумаем, как выразить воркер в терминах Mount. Поскольку задача работает в
отдельном потоке, очевидно это будет тред или футура с бесконечным циклом. Но мы
бы хотели остановить воркер по запросу. Значит, цикл должен быть не бесконечным,
а с каким-то условием. Например, с проверкой состояния на каждом шаге. Это
состояние должно быть доступно и воркеру, и стороннему наблюдателю.</p>

<p>В Clojure эта задача решается парой атом и футура. В атоме хранят логический
флаг — признак продолжения цикла. На каждом шаге футура проверяет флаг, и если
он истина, то в очередной раз выполняет задачу. Чтобы корректно завершить
футуру, мы совершаем два действия. Первое — устанавливаем флаг в ложь. Второе —
ждем до тех пор, пока футура не станет <code class="language-plaintext highlighter-rouge">realized</code>. В терминах Clojure это
значит, что футура завершила работу с некоторым результатом.</p>

<p>Подготовим модуль воркера. Понадобится импорт конфигурации, компонента базы,
логирование и HTTP-клиент:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.systems.mount.worker</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">mount.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">mount</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">defstate</span><span class="p">]]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.java.jdbc</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clj-http.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">client</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.tools.logging</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">log</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">book.systems.mount.db</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="p">]]</span><span class="w">
   </span><span class="p">[</span><span class="n">book.systems.mount.config</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]))</span><span class="w">
</span></code></pre></div></div>

<p>Технически компонент сводится к словарю с полями <code class="language-plaintext highlighter-rouge">:flag</code> и <code class="language-plaintext highlighter-rouge">:task</code>. Первое поле
хранит атом состояния, а второе футуру.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defstate</span><span class="w"> </span><span class="n">worker</span><span class="w">
  </span><span class="no">:start</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="n">task-opt</span><span class="w"> </span><span class="no">:worker</span><span class="p">}</span><span class="w"> </span><span class="n">config</span><span class="w">
        </span><span class="n">flag</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
        </span><span class="n">task</span><span class="w"> </span><span class="p">(</span><span class="nf">make-task</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">task-opt</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:flag</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="no">:task</span><span class="w"> </span><span class="n">task</span><span class="p">})</span><span class="w">
  </span><span class="no">:stop</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">flag</span><span class="w"> </span><span class="n">task</span><span class="p">]}</span><span class="w"> </span><span class="n">worker</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">while</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">realized?</span><span class="w"> </span><span class="n">task</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"Waiting for the task to complete"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">300</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>В фазе <code class="language-plaintext highlighter-rouge">:start</code> мы создали состояние и футуру и вернули их композицию в виде
словаря. Функции <code class="language-plaintext highlighter-rouge">make-task</code> пока что не существует, но мы считаем, что она
вернет футуру. В фазе <code class="language-plaintext highlighter-rouge">:stop</code> мы возводим состояние в ложь и бесконечно ждем до
тех пор, пока футура не завершится. Идея в том, что <code class="language-plaintext highlighter-rouge">flag</code> доступен внутри
футуры, и на очередном шаге она должна проверить его статус и завершиться.</p>

<p>Код выше учит хорошей практике, о которой следует сказать явно. Код компонента
не должен быть большим. В компоненте должна быть только его логика, набор
шагов. Технически возможно описать футуру прямо внутри <code class="language-plaintext highlighter-rouge">defstate</code>. Но это займет
лишних десять строк, и жизненный цикл компонента станет читаться хуже.</p>

<p>Добавим в EDN-файл параметры воркера. Достаточно одного поля — сколько
миллисекунд ждать на каждом шаге цикла.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:worker</span><span class="w"> </span><span class="p">{</span><span class="no">:sleep</span><span class="w"> </span><span class="mi">1000</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Опишем функцию <code class="language-plaintext highlighter-rouge">make-task</code>. Она принимает состояние и словарь параметров.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-task</span><span class="w">
  </span><span class="p">[</span><span class="n">flag</span><span class="w"> </span><span class="n">opt</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">sleep</span><span class="p">]}</span><span class="w"> </span><span class="n">opt</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">future</span><span class="w">
      </span><span class="p">(</span><span class="nf">while</span><span class="w"> </span><span class="o">@</span><span class="n">flag</span><span class="w">
        </span><span class="p">(</span><span class="nf">try</span><span class="w">
          </span><span class="p">(</span><span class="nf">task-fn</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
            </span><span class="p">(</span><span class="nf">log/error</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="nf">finally</span><span class="w">
            </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="n">sleep</span><span class="p">)))))))</span><span class="w">
</span></code></pre></div></div>

<p>В примере <code class="language-plaintext highlighter-rouge">(task-fn)</code> это целевая функция, в которой заключена бизнес-логика
приложения. Недостаточно просто вызвать эту функцию; нужно обернуть ее в цикл с
условием и перехватом ошибок, чтобы футура не завершилась аварийно. Даже если
произошло исключение, мы пишем его в лог и переходим на следующую итерацию.</p>

<p>Тем временем кто-то мог установить <code class="language-plaintext highlighter-rouge">flag</code> в ложь. Если это произошло, мы выходим
из цикла <code class="language-plaintext highlighter-rouge">while</code> и логика футуры завершается.</p>

<p>Теперь опишем <code class="language-plaintext highlighter-rouge">task-fn</code>. Функция читает из базы записи, которые еще не были
обработаны. Для каждой записи ищем гео-данные по IP с помощью <code class="language-plaintext highlighter-rouge">get-ip-info</code>. Мы
пока что не знаем, как работает эта функция, но уверены, что это словарь с
полями <code class="language-plaintext highlighter-rouge">:city</code>, <code class="language-plaintext highlighter-rouge">:country</code> и так далее. В конце мы обновляем запись этими
полями.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">task-fn</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/with-db-transaction</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">requests</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="n">requests-query</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="n">requests</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="n">ip</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
              </span><span class="n">info</span><span class="w"> </span><span class="p">(</span><span class="nf">get-ip-info</span><span class="w"> </span><span class="n">ip</span><span class="p">)</span><span class="w">
              </span><span class="n">fields</span><span class="w"> </span><span class="p">{</span><span class="no">:is_processed</span><span class="w"> </span><span class="n">true</span><span class="w">
                      </span><span class="no">:zip</span><span class="w"> </span><span class="p">(</span><span class="no">:postal_code</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w">
                      </span><span class="no">:country</span><span class="w"> </span><span class="p">(</span><span class="no">:country_name</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w">
                      </span><span class="no">:city</span><span class="w"> </span><span class="p">(</span><span class="no">:city</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w">
                      </span><span class="no">:lat</span><span class="w"> </span><span class="p">(</span><span class="no">:lat</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w">
                      </span><span class="no">:lon</span><span class="w"> </span><span class="p">(</span><span class="no">:lng</span><span class="w"> </span><span class="n">info</span><span class="p">)}]</span><span class="w">
          </span><span class="p">(</span><span class="nf">jdbc/update!</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="no">:requests</span><span class="w">
                        </span><span class="n">fields</span><span class="w">
                        </span><span class="p">[</span><span class="s">"id = ?"</span><span class="w"> </span><span class="n">id</span><span class="p">]))))))</span><span class="w">
</span></code></pre></div></div>

<p>Запрос на чтение мы вынесли в переменную requests-query, чтобы не отвлекаться на
него в коде <code class="language-plaintext highlighter-rouge">task-fn</code>. Это SQL-выражение с оператором <code class="language-plaintext highlighter-rouge">FOR UPDATE</code>. Оператор
означает, что выбранная запись блокируется на изменение другими клиентами.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">requests-query</span><span class="w">
  </span><span class="s">"SELECT * FROM requests
   WHERE NOT is_processed
   LIMIT 1 FOR UPDATE;"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Эффект <code class="language-plaintext highlighter-rouge">FOR UPDATE</code> работает только в транзакции, поэтому тело функции обернуто
в <code class="language-plaintext highlighter-rouge">(jdbc/with-db-transaction)</code>. Это макрос, внутри которого доступна
транзакционная версия соединения с базой. Символ <code class="language-plaintext highlighter-rouge">tx</code> связан с транзакционным
соединением, полученным на основе db. Внутри макроса мы передаем в jdbc-функции
<code class="language-plaintext highlighter-rouge">tx</code>, а не <code class="language-plaintext highlighter-rouge">db</code>.</p>

<p>Осталось написать <code class="language-plaintext highlighter-rouge">get-ip-info</code>. Это функция, которая обращается стороннему HTTP
API. В нашем случае это один из многочисленных сервисов, который принимает POST
запрос с полем ip и возвращает JSON-документ. В промышленных системах это могут
быть службы Google или собственная база адресов.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-ip-info</span><span class="w">
  </span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="no">:body</span><span class="w">
   </span><span class="p">(</span><span class="nf">client/post</span><span class="w"> </span><span class="s">"https://iplocation.com"</span><span class="w">
                </span><span class="p">{</span><span class="no">:form-params</span><span class="w"> </span><span class="p">{</span><span class="no">:ip</span><span class="w"> </span><span class="n">ip</span><span class="p">}</span><span class="w">
                 </span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Если вызвать <code class="language-plaintext highlighter-rouge">get-ip-info</code> с адресом из диапазона сетей Берлина, получим
следующий словарь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">get-ip-info</span><span class="w"> </span><span class="s">"85.214.132.117"</span><span class="p">)</span><span class="w">

</span><span class="p">{</span><span class="no">:postal_code</span><span class="w"> </span><span class="s">"12529"</span><span class="w">
 </span><span class="no">:continent_code</span><span class="w"> </span><span class="s">"EU"</span><span class="w">
 </span><span class="no">:region_name</span><span class="w"> </span><span class="s">"Land Berlin"</span><span class="w">
 </span><span class="no">:city</span><span class="w"> </span><span class="s">"Berlin"</span><span class="w">
 </span><span class="no">:isp</span><span class="w"> </span><span class="s">"Strato AG"</span><span class="w">
 </span><span class="no">:region</span><span class="w"> </span><span class="s">"BE"</span><span class="w">
 </span><span class="no">:country_code</span><span class="w"> </span><span class="s">"DE"</span><span class="w">
 </span><span class="no">:country_name</span><span class="w"> </span><span class="s">"Germany"</span><span class="w">
 </span><span class="no">:time_zone</span><span class="w"> </span><span class="s">"Europe/Berlin"</span><span class="w">
 </span><span class="no">:lat</span><span class="w"> </span><span class="mf">52.5167</span><span class="w">
 </span><span class="no">:company</span><span class="w"> </span><span class="s">"Strato AG"</span><span class="w">
 </span><span class="no">:lng</span><span class="w"> </span><span class="mf">13.4</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Тем самым мы описали последний неизвестный элемент воркера, и он готов к
работе. Проверим его: запишем в базу несколько записей, запустим воркер и через
некоторое время прочитаем их снова.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:requests</span><span class="w"> </span><span class="p">{</span><span class="no">:path</span><span class="w"> </span><span class="s">"/help"</span><span class="w"> </span><span class="no">:ip</span><span class="w"> </span><span class="s">"31.148.198.0"</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">mount/start</span><span class="p">)</span><span class="w">
</span><span class="c1">;; wait for a while</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from requests"</span><span class="p">)</span><span class="w">
</span><span class="p">({</span><span class="no">:path</span><span class="w"> </span><span class="s">"/help"</span><span class="w"> </span><span class="no">:ip</span><span class="w"> </span><span class="s">"31.148.198.0"</span><span class="w"> </span><span class="no">:is_processed</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="no">:city</span><span class="w"> </span><span class="s">"Pinsk"</span><span class="w"> </span><span class="no">:zip</span><span class="w"> </span><span class="s">"225710"</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="no">:lon</span><span class="w"> </span><span class="mf">26.0728</span><span class="w"> </span><span class="no">:lat</span><span class="w"> </span><span class="mf">52.1214</span><span class="w"> </span><span class="no">:country</span><span class="w"> </span><span class="s">"Belarus"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Поля заполнены верно, и мы переходим к последнему этапу.</p>

<h3 id="все-вместе">Все вместе</h3>

<p>Когда все компоненты готовы и работают по отдельности, осталось собрать их в
единую композицию. Это модуль, который импортирует все компоненты системы. Вызов
<code class="language-plaintext highlighter-rouge">(mount/start)</code> из этого модуля запустит их все.</p>

<p>Единый модуль решает проблему потерянного компонента. Выше мы упоминали, что
функции <code class="language-plaintext highlighter-rouge">start</code> и <code class="language-plaintext highlighter-rouge">stop</code> работают только с теми компонентами, которые известны
Mount. Например, если загрузить модуль воркера, то Mount будет знать о
компонентах <code class="language-plaintext highlighter-rouge">worker</code>, <code class="language-plaintext highlighter-rouge">db</code> и <code class="language-plaintext highlighter-rouge">config</code>. Модуль <code class="language-plaintext highlighter-rouge">book.systems.mount.server</code> не
будет загружен, и система не узнает про компонент веб-сервера.</p>

<p>Объявим модуль <code class="language-plaintext highlighter-rouge">book.systems.mount.core</code>. Предоставим функцию <code class="language-plaintext highlighter-rouge">start</code> для
запуска системы целиком.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.systems.mount.core</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">mount.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">mount</span><span class="p">]</span><span class="w">
   </span><span class="n">book.systems.mount.server</span><span class="w">
   </span><span class="n">book.systems.mount.worker</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">mount/start</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>В списке импорта мы не указали модули <code class="language-plaintext highlighter-rouge">db</code> и <code class="language-plaintext highlighter-rouge">config</code>. В нашем случае это не
обязательно. Модули <code class="language-plaintext highlighter-rouge">server</code> и <code class="language-plaintext highlighter-rouge">worker</code> зависят от них, поэтому компилятор
загрузит db и config автоматически.</p>

<h3 id="зависимости-1">Зависимости</h3>

<p>В начале главы мы говорили о центральной проблеме систем. Это зависимости между
компонентами, их разрешение и порядок обхода. Mount предлагает интересный способ
решить эти задачи, и ниже мы рассмотрим его техническое устройство.</p>

<p>Наверное, читатель заметил, что при объявлении компонента мы не указываем его
зависимости. Так, worker нуждается в config и db, но об этом нигде не сказано
явно. Когда мы вызываем <code class="language-plaintext highlighter-rouge">(mount/start)</code>, система каким-то образом угадывает
порядок запуска компонентов: <code class="language-plaintext highlighter-rouge">config</code>, <code class="language-plaintext highlighter-rouge">db</code>, <code class="language-plaintext highlighter-rouge">worker</code>. Если переставить любые
два элемента в этом списке, система не запустится. Как это устроено?</p>

<p>Чтобы определить порядок компонентов, Mount полагается на компилятор
Clojure. Пространства имен в Clojure работают примерно так же, как и система
компонентов. При загрузке имен компилятор ищет зависимости в теле ns и загружает
их первыми. Вспомним, как выглядит ns воркера:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.systems.mount.worker</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">book.systems.mount.db</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="p">]]</span><span class="w">
   </span><span class="p">[</span><span class="n">book.systems.mount.config</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]))</span><span class="w">
</span></code></pre></div></div>

<p>С точки зрения компилятора граф зависимостей выглядит так:</p>

<div class="language-plaintext code_chart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    ┌──────────────┐
    │ mount.worker │
    └──────────────┘
            │  ┌────────────┐
            ├─┼│  mount.db  │
            │  └────────────┘
            │  ┌───────────────┐
            └─┼│ mount.config  │
               └───────────────┘
</code></pre></div></div>

<p>Компилятор не загрузит <code class="language-plaintext highlighter-rouge">mount.worker</code> до тех пор, пока не разрешит
зависимости. Он начнет с модуля <code class="language-plaintext highlighter-rouge">mount.db</code>. Его упрощенное определение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.systems.mount.db</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">book.systems.mount.config</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]))</span><span class="w">
</span></code></pre></div></div>

<p>Что с точки зрения компилятора:</p>

<div class="language-plaintext code_chart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ┌──────────────┐
    │   mount.db   │
    └──────────────┘
            │  ┌───────────────┐
            └─┼│ mount.config  │
               └───────────────┘
</code></pre></div></div>

<p>Теперь прежде чем загрузить <code class="language-plaintext highlighter-rouge">db</code>, компилятор займется <code class="language-plaintext highlighter-rouge">config</code>. Будем считать,
что <code class="language-plaintext highlighter-rouge">config</code> не зависит других модулей, и поэтому будет загружен первым. Затем
компилятор загрузит <code class="language-plaintext highlighter-rouge">db</code>. Дальше он поднимется обратно на уровень
<code class="language-plaintext highlighter-rouge">mount.worker</code>. Модуль <code class="language-plaintext highlighter-rouge">mount.db</code> загружен, следующий по списку
<code class="language-plaintext highlighter-rouge">mount.config</code>. Но конфигурация уже была загружена на этапе <code class="language-plaintext highlighter-rouge">mount.db</code>. В
Clojure модуль не может быть загружен больше одного раза, поэтому компилятор
пропустит <code class="language-plaintext highlighter-rouge">mount.config</code>. И на последнем шаге загрузит <code class="language-plaintext highlighter-rouge">mount.worker</code>.</p>

<p>Мы вывели порядок загрузки модулей: <code class="language-plaintext highlighter-rouge">config</code>, <code class="language-plaintext highlighter-rouge">db</code>, <code class="language-plaintext highlighter-rouge">worker</code>. Это значит, что
каждая форма <code class="language-plaintext highlighter-rouge">defstate</code> выполняется в такой же последовательности. В этом и
заключается трюк: каждый вызов <code class="language-plaintext highlighter-rouge">defstate</code> увеличивает внутренний счетчик
Mount. В момент создания компонент запоминает это число. Сущности <code class="language-plaintext highlighter-rouge">config</code>, <code class="language-plaintext highlighter-rouge">db</code>
и <code class="language-plaintext highlighter-rouge">worker</code> получат номера 1, 2 и 3. Чтобы запустить систему, Mount сортирует
компоненты по возрастанию номера, а чтобы остановить — по убыванию.</p>

<h3 id="внутреннее-устройство">Внутреннее устройство</h3>

<p>Mount хранит сведения о компонентах в приватных атомах. Они недоступны сторонним
модулям, но Clojure оставляет техническую возможность добраться до них. Когда
компоненты загружены, выполните выражение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">_state</span><span class="w"> </span><span class="o">@@</span><span class="p">(</span><span class="nb">resolve</span><span class="w"> </span><span class="ss">'mount.core/meta-state</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>В переменной <code class="language-plaintext highlighter-rouge">_state</code> окажется словарь компонентов. Двойной оператор <code class="language-plaintext highlighter-rouge">@</code> играет
следующую роль. Функция <code class="language-plaintext highlighter-rouge">resolve</code> по символу возвращает объект <code class="language-plaintext highlighter-rouge">Var</code>. Из прошлых
глав мы помним, что это контейнер, который хранит внутри значение. Первый <code class="language-plaintext highlighter-rouge">@</code>
извлекает значение из <code class="language-plaintext highlighter-rouge">Var</code>. Это атом со словарем. Второй <code class="language-plaintext highlighter-rouge">@</code> извлекает словарь
из атома.</p>

<p>Ключ словаря это текстовая ссылка на компонент, например
<code class="language-plaintext highlighter-rouge">#'book.systems.mount.config/config</code>. Ей сопоставлен другой словарь с полной
информацией о текущем состоянии компонента. Нас интересует поле <code class="language-plaintext highlighter-rouge">:order</code> — тот
самый счетчик, по возрастанию которого нужно включать компоненты.</p>

<p>Расставим компоненты вручную. Видим, что порядок их загрузки верный:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">_state</span><span class="w">
     </span><span class="nb">vals</span><span class="w">
     </span><span class="p">(</span><span class="nb">sort-by</span><span class="w"> </span><span class="no">:order</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="no">:var</span><span class="w"> </span><span class="nb">meta</span><span class="w"> </span><span class="no">:name</span><span class="p">)))</span><span class="w">
</span><span class="c1">;; (config server db worker)</span><span class="w">
</span></code></pre></div></div>

<p>Выражение</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@@</span><span class="p">(</span><span class="nb">resolve</span><span class="w"> </span><span class="ss">'mount.core/running</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>вернет словарь запущенных компонентов с похожей структурой. Атом <code class="language-plaintext highlighter-rouge">state-seq</code>
хранит глобальный счетчик компонентов. Чтобы прочитать его, выполните:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@@</span><span class="p">(</span><span class="nb">resolve</span><span class="w"> </span><span class="ss">'mount.core/state-seq</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Результатом будет число 4, что верно. Значения от 0 до 3 уже заняты нашими
компонентами.</p>

<p>Заметим, что при работе с Mount мы не должны изменять его внутренние
атомы. Примеры выше нужны для того, чтобы читатель лучше понял устройство
библиотеки.</p>

<h3 id="состояние">Состояние</h3>

<p>Легкость, с которой компонент изменяется при вызове <code class="language-plaintext highlighter-rouge">start</code> и <code class="language-plaintext highlighter-rouge">stop</code> напоминает
магию. Макрос <code class="language-plaintext highlighter-rouge">defstate</code> изящно скрывает технические шаги, которые срабатывают в
момент его работы. На нижнем уровне состояние работает на функции
<code class="language-plaintext highlighter-rouge">alter-var-root</code>, которую мы рассмотрели в главе про изменяемость.</p>

<p>Вспомним, как мы описали компонент сервера:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defstate</span><span class="w"> </span><span class="n">server</span><span class="w">
  </span><span class="no">:start</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="n">jetty-opt</span><span class="w"> </span><span class="no">:jetty</span><span class="p">}</span><span class="w"> </span><span class="n">config</span><span class="p">]</span><span class="w">
           </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="n">jetty-opt</span><span class="p">))</span><span class="w">
  </span><span class="no">:stop</span><span class="w"> </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="o">^</span><span class="n">Server</span><span class="w"> </span><span class="n">server</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>В общих словах, <code class="language-plaintext highlighter-rouge">defstate</code> разворачивается в несколько определений. Это
глобальная переменная без значения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">server</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>и две анонимные функции старта и останова. Тела функций это формы <code class="language-plaintext highlighter-rouge">:start</code> и
<code class="language-plaintext highlighter-rouge">:stop</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-var-root</span><span class="w"> </span><span class="o">#</span><span class="ss">'server</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="n">jetty-opt</span><span class="w"> </span><span class="no">:jetty</span><span class="p">}</span><span class="w"> </span><span class="n">config</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="n">jetty-opt</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="n">stop</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-var-root</span><span class="w"> </span><span class="o">#</span><span class="ss">'server</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="o">^</span><span class="n">Server</span><span class="w"> </span><span class="n">server</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Mount помещает анонимные функции и прочую информацию в атом <code class="language-plaintext highlighter-rouge">meta-state</code>. Чтобы
включить компонент, достаточно найти в словаре функцию включения и вызвать
ее. Эта функция назначит переменной <code class="language-plaintext highlighter-rouge">#'server</code> новое значение. Остановка
компонента работает аналогично.</p>

<h3 id="выборочный-запуск">Выборочный запуск</h3>

<p>До сих пор мы запускали систему целиком. Вызов <code class="language-plaintext highlighter-rouge">(mount/start)</code> без аргументов
пробегает по meta-state и стартует все компоненты. Но это не всегда
удобно. Предположим, мы работаем над воркером и хотели бы запустить только его и
зависимые компоненты. В этом случае веб-сервер не нужен.</p>

<p>Чтобы запустить только нужные компоненты, их явно передают в функцию. Компонент
должен быть не значением, а объектом <code class="language-plaintext highlighter-rouge">Var</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">mount/start</span><span class="w"> </span><span class="o">#</span><span class="ss">'book.systems.mount.config/config</span><span class="w">
             </span><span class="o">#</span><span class="ss">'book.systems.mount.db/db</span><span class="w">
             </span><span class="o">#</span><span class="ss">'book.systems.mount.worker/worker</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Если передать значение, Mount не запустит компонент. В примере ниже не будет
ошибки или сообщения, просто ничего не произойдет:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; does nothing</span><span class="w">
</span><span class="p">(</span><span class="nf">mount/start</span><span class="w"> </span><span class="n">book.systems.mount.config/config</span><span class="w">
             </span><span class="n">book.systems.mount.db/db</span><span class="w">
             </span><span class="n">book.systems.mount.worker/worker</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Тот факт, что функция ожидает именно <code class="language-plaintext highlighter-rouge">Var</code>, а не значение, сбивает с толку
новичков. Это не очевидно, поскольку в Clojure мы редко прибегаем к переменным.</p>

<p>Недостаток ручного запуска в том, что он не контролирует зависимости. Вспомним,
что mount не хранит зависимости явно. Библиотека знает только как упорядочить
компоненты, но не как они связаны. Предположим, мы забыли, что базе и воркеру
требуется конфигурация:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">mount/start</span><span class="w"> </span><span class="o">#</span><span class="ss">'book.systems.mount.db/db</span><span class="w">
             </span><span class="o">#</span><span class="ss">'book.systems.mount.worker/worker</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Такой вызов выбросит странное исключение. Оно возникнет в компоненте <code class="language-plaintext highlighter-rouge">db</code>, где
мы попытаемся создать пул из конфигурации. Объект <code class="language-plaintext highlighter-rouge">config</code> не запущен, и
выражение <code class="language-plaintext highlighter-rouge">(:pool config)</code> вернет <code class="language-plaintext highlighter-rouge">nil</code>. При попытке создать пул из <code class="language-plaintext highlighter-rouge">nil</code>
получим исключение.</p>

<p>С ростом системы становится сложнее отслеживать зависимости. Это слабое место
Mount — запуск подсистемы сводится к ручному перечислению компонентов. Чтобы
облегчить этот сценарий, библиотека предлагает вспомогательные функции-селекторы
компонентов: <code class="language-plaintext highlighter-rouge">only</code>, <code class="language-plaintext highlighter-rouge">except</code> и другие.</p>

<p>Например, <code class="language-plaintext highlighter-rouge">except</code> вернет имена всех компонентов кроме перечисленных. Если если
передать результат в start, получим систему без указанных компонентов. Пример
ниже запустит подмножество системы без веб-сервера:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="ss">'book.systems.mount.server/server</span><span class="p">]</span><span class="w">
    </span><span class="n">mount/except</span><span class="w">
    </span><span class="n">mount/start</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Эти функции и их комбинации описаны на странице GitHub проекта.</p>

<h3 id="проблема-перезагрузки">Проблема перезагрузки</h3>

<p>В режиме разработки наш редактор соединен с REPL-сессией. Когда мы меняем код,
редактор отправляет изменения на сервер. Возникает вопрос: что случится, если
внести правки в уже написанный компонент? Как mount отреагирует на повторную
загрузку модуля?</p>

<p>Если вы работаете в Emacs и Cider, подключитесь к проекту через <code class="language-plaintext highlighter-rouge">M-x
cider-connect</code>. Из модуля <code class="language-plaintext highlighter-rouge">book.systems.mount.core</code> запустите систему, как мы
делали это выше. Теперь откройте модуль сервера. Выполните команду <code class="language-plaintext highlighter-rouge">M-x
cider-eval-buffer</code> (или с клавиатуры через <code class="language-plaintext highlighter-rouge">C-c C-k</code>). Команда исполнит
содержимое файла сервера. Это значит, что все определения, включая <code class="language-plaintext highlighter-rouge">ns</code>, <code class="language-plaintext highlighter-rouge">def</code>,
<code class="language-plaintext highlighter-rouge">defstate</code> будут выполнены повторно.</p>

<p>В сеансе REPL вы увидете логи с текстом, что сервер был остановлен и снова
запущен. Mount достаточно умен и учитывает этот сценарий. Макрос <code class="language-plaintext highlighter-rouge">defstate</code>
проверяет, что такой компонент уже объявлен, и перезагружает его.</p>

<p>Перезагрузка компонента это не всегда желаемое поведение. Во время интенсивных
изменений может случиться т.н. “рассинхрон”. Это ситуация, когда компонент
считается выключенным, но ресурс все еще работает. Например, мы допустили ошибку
в фазе <code class="language-plaintext highlighter-rouge">:stop</code> и не вызвали у сервера метод <code class="language-plaintext highlighter-rouge">(.stop)</code>. Если выключить такой
компонент и снова включить, мы получим ошибку с семантикой “порт уже занят”.</p>

<p>Поведение компонента при перезагрузке задают в его метаданных. Это поле
<code class="language-plaintext highlighter-rouge">:on-reload</code>, которое по умолчанию равно <code class="language-plaintext highlighter-rouge">:restart</code>. С этим значением компонент
перезагружает себя при повторном вызове <code class="language-plaintext highlighter-rouge">defstate</code>. Если задать <code class="language-plaintext highlighter-rouge">:stop</code>,
компонент будет остановлен. Наиболее удобно значение <code class="language-plaintext highlighter-rouge">:noop</code>, что значит не
делать ничего.</p>

<p>Компонент с метаданными выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defstate</span><span class="w"> </span><span class="o">^</span><span class="p">{</span><span class="no">:on-reload</span><span class="w"> </span><span class="no">:noop</span><span class="p">}</span><span class="w"> </span><span class="n">server</span><span class="w">
  </span><span class="no">:start</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="p">})</span><span class="w">
  </span><span class="no">:stop</span><span class="w"> </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Считается хорошей практикой указывать <code class="language-plaintext highlighter-rouge">:on-reload</code> для всех
компонентов. Поведение <code class="language-plaintext highlighter-rouge">:noop</code> удобно тем, что освобождает от побочных
эффектов. Возможно, вы изменили не компонент, а исправили опечатку в соседней
строке. Перезагружать компонент в таком случае не требуется. Но даже если
изменения относятся к компоненту, лучше перезагрузить его вручную.</p>

<h3 id="самостоятельная-работа">Самостоятельная работа</h3>

<p>Вспомним, как устроена функция <code class="language-plaintext highlighter-rouge">get-ip-info</code> из модуля воркера. Для каждого
IP-адреса она выполняет HTTP-запрос к серверу. На низком уровне мы каждый раз
открываем TCP-соединение, работаем с ним и закрываем. Это не оптимально, и
проблему решают так же, как и с базами данных — пулом постоянных соединений.</p>

<p>Минимальный пример с жизненным циклом пула</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; create a new pool</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">cm</span><span class="w"> </span><span class="p">(</span><span class="nf">clj-http.conn-mgr/make-reusable-conn-manager</span><span class="w">
         </span><span class="p">{</span><span class="no">:timeout</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:threads</span><span class="w"> </span><span class="mi">3</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; make a request within the pool</span><span class="w">
</span><span class="p">(</span><span class="nf">client/get</span><span class="w"> </span><span class="s">"http://example.org/"</span><span class="w">
            </span><span class="p">{</span><span class="no">:connection-manager</span><span class="w"> </span><span class="n">cm</span><span class="p">})</span><span class="w">

</span><span class="c1">;; shut down the pool</span><span class="w">
</span><span class="p">(</span><span class="nf">clj-http.conn-mgr/shutdown-manager</span><span class="w"> </span><span class="n">cm</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Найдите <a href="https://github.com/dakrone/clj-http">в документации к clj-http</a> более подробные примеры. Напишите
компонент HTTP-клиента, который выполняет запросы через пул. Параметры
компонента (тайминг, число тредов) приходят из конфигурации. На старте компонент
запускает пул, при остановке закрывает его. Перепишите воркер так, чтобы он
зависел от нового компонента.</p>

<h2 id="component">Component</h2>

<p>Библиотека <a href="https://github.com/stuartsierra/component">Component</a> тоже служит для описания компонентов и
систем. Это небольшой фремворк, в котором главную роль играет не объем кода, а
идея. Дизайн Component в корне отличаются от техники mount, которую мы
рассмотрели выше.</p>

<p>Разница в том, что сущности Component это не глобальные переменные, а обычные
объекты. В библиотеке нет скрытых атомов, которые хранят информацию о
компонентах. Программист выстраивает систему явно, подобно тому как мы описываем
структуру данных.</p>

<p>Как и в Mount, на компонент действуют две операции: <code class="language-plaintext highlighter-rouge">start</code> и <code class="language-plaintext highlighter-rouge">stop</code>. Каждая их
них возвращает копию компонента в другом состоянии. Функции не меняют исходный
компонент. Можно сказать, что компоненты неизменяемы. Это отсекает целый пласт
ошибок, связанных с состоянием.</p>

<p>Система это комбинация компонентов с указанием зависимостей. Каждый компонент в
системе носит машинное имя. На первом этапе программист составляет систему в
состоянии покоя. Она состоит из компонентов, которые еще не были запущены.</p>

<p>В момент запуска специальный код обходит компоненты и запускает их. В результате
получится запущенная копия системы. Она аналогична исходной, но каждый компонент
в ней заменен на включенную копию себя. Остановка работает аналогично: вы
получите выключенную копию системы.</p>

<p>Идеи Component не терпят глобального состояния. Один компонент может работать с
другим только если это указано в зависимостях. Компонент не должен хранить
внутреннее состояние в атоме или другой изменяемой сущности. На каждое действие
он возвращает новую копию себя.</p>

<h3 id="устройство">Устройство</h3>

<p>Технически компонент это объект, который реализует протокол
<code class="language-plaintext highlighter-rouge">Lifecycle</code>. Протокол несет две операции: <code class="language-plaintext highlighter-rouge">start</code> и <code class="language-plaintext highlighter-rouge">stop</code>. Компоненты удобно
описывать типизированными словарями. Это сущности, которые объявляют формой
<code class="language-plaintext highlighter-rouge">defrecord</code>. По-другому их называют типизированными записями или “рекорды” с
ударением на первый слог.</p>

<p>Обычный словарь может содержать любые поля. Запись перечисляет возможные поля в
момент объявления. Эти поля называют слотами записи. Доступ к ним работает
быстрее, чем у обычного словаря. Компонент резервирует несколько слотов для
входных и внутренних параметров.</p>

<p>Форма <code class="language-plaintext highlighter-rouge">defrecord</code> работает в паре с протоколом. При объявлении записи можно
сразу расширить ее протоколом. Преимущество этого подхода в том, что слоты
записи доступны протоколу как локальные переменные. Это уменьшает код и держит
наше внимание на главном.</p>

<p>Компонент таит в себе состояние, и только он знает, как им управлять. Будет
грубой ошибкой “вынимать” из него отдельные поля и передавать их функции. Для
внешних потребителей компонент реализует еще один протокол, в котором
перечислены операции над компонентом.</p>

<p>Программирование на Component отдаленно напоминает ООП. Компонент это объект с
данными и фиксированным набором операций над ним. Как и классы, компонент
инициируют, запускают и останавливают. Разница в том, что, во-первых, компоненты
неизменяемы. Переход к новому состоянию не изменяет слоты объекта, в то время
как в промышленных ОО-языках мы их перезаписываем.</p>

<p>Во-вторых, принцип <code class="language-plaintext highlighter-rouge">SOLID</code> и классическая тройка инкапсуляция, наследование,
полиморфизм не имеют той же силы в Clojure. Большая часть этих принципов
отпадает за ненадобностью. Программируя на Clojure, мы не волнуемся о том, что
нарушили правила ООП. Код исходит из здравого смысла.</p>

<h3 id="первый-компонент">Первый компонент</h3>

<p>Перейдем к практике: перепишем систему из прошлого раздела на Component. Начнем
с веб-сервера. Поместим его в файл <code class="language-plaintext highlighter-rouge">src/book/systems/comp/server.clj</code>. Объявим
пространство имен:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.systems.comp.server</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">com.stuartsierra.component</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">component</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">ring.adapter.jetty</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">run-jetty</span><span class="p">]]))</span><span class="w">
</span></code></pre></div></div>

<p>Компонент это запись с двумя слотами: <code class="language-plaintext highlighter-rouge">options</code> и <code class="language-plaintext highlighter-rouge">server</code>. В опциях записаны
параметры Jetty-сервера, в server — его экземпляр. Строка <code class="language-plaintext highlighter-rouge">component/Lifecycle</code>
означает протокол, который реализует запись. Ниже следует реализация протокола.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Server</span><span class="w">
    </span><span class="p">[</span><span class="n">options</span><span class="w"> </span><span class="n">server</span><span class="p">]</span><span class="w">
  </span><span class="n">component/Lifecycle</span><span class="w">
  </span><span class="p">(</span><span class="nf">start</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">server</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="n">options</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:server</span><span class="w"> </span><span class="n">server</span><span class="p">)))</span><span class="w">
  </span><span class="p">(</span><span class="nf">stop</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:server</span><span class="w"> </span><span class="n">nil</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Метод <code class="language-plaintext highlighter-rouge">start</code> вернет ту же запись, но с непустым слотом <code class="language-plaintext highlighter-rouge">:server</code>. В него
записан объект сервера. Метод <code class="language-plaintext highlighter-rouge">stop</code> принимает запущенный компонент. Он
выключает сервер и возвращает новый компонент, где слот <code class="language-plaintext highlighter-rouge">:server</code> установлен в
nil.</p>

<p>Обратите внимание: внутри методов мы свободно обращаемся к слотам записи, словно
это локальные переменные. Это работает только в тех случаях, когда методы
расположены внутри <code class="language-plaintext highlighter-rouge">defrecord</code>. Если мы расширяем запись в отдельной форме,
например через extend, доступ к слотам теряется. Приходится извлекать слоты из
переменной <code class="language-plaintext highlighter-rouge">this</code>.</p>

<p>Запустим компонент вручную. Сущность <code class="language-plaintext highlighter-rouge">Server</code> это еще не компонент, а его
абстрактное описание. На первом шаге его инициируют, то есть получают экземпляр
записи. Чтобы создать экземпляр, вызывают функцию <code class="language-plaintext highlighter-rouge">map-&gt;&lt;Record&gt;</code>, где
<code class="language-plaintext highlighter-rouge">&lt;Record&gt;</code> это имя записи. Макрос <code class="language-plaintext highlighter-rouge">defrecord</code> автоматически порождает эту
функцию. В нашем случае это <code class="language-plaintext highlighter-rouge">map-&gt;Server</code>. Функция принимает обычный словарь и
возвращает его типизированную версию. Ключи словаря должны совпадать со слотами
записи. Если ключ не найден, слот равен nil.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">s-created</span><span class="w">
  </span><span class="p">(</span><span class="nf">map-&gt;Server</span><span class="w">
   </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}}))</span><span class="w">
</span></code></pre></div></div>

<p>Переменная <code class="language-plaintext highlighter-rouge">s-created</code> это экземпляр записи <code class="language-plaintext highlighter-rouge">Server</code>. При инициализации мы
указали слот options, но не server. В этом нет смысла, потому что server будет
заполнен автоматически в процессе жизненного цикла.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">s-started</span><span class="w"> </span><span class="p">(</span><span class="nf">component/start</span><span class="w"> </span><span class="n">s-created</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Эта строка вернет запущенную версию компонента. Откройте браузер по адресу
http://127.0.0.1:8080/ и проверьте, что сервер работает. На этот раз у записи
<code class="language-plaintext highlighter-rouge">s-started</code> слот <code class="language-plaintext highlighter-rouge">:server</code> заполнен:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">s-started</span><span class="w"> </span><span class="no">:server</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w">
</span><span class="n">org.eclipse.jetty.server.Server</span><span class="w">
</span></code></pre></div></div>

<p>Остановите компонент. Проверьте браузер и слоты <code class="language-plaintext highlighter-rouge">s-stopped</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">s-stopped</span><span class="w"> </span><span class="p">(</span><span class="nf">component/stop</span><span class="w"> </span><span class="n">s-started</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Мы прошли жизненный цикл одного компонента. Это инициирование, запуск и
остановка. Переход на каждую стадию возвращает новую копию. В промышленных
системах вам не придется управлять компонентами поштучно. Этим занимается
система.</p>

<h3 id="конструктор">Конструктор</h3>

<p>Вспомним, как мы создали экземпляр <code class="language-plaintext highlighter-rouge">Server</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">s-created</span><span class="w">
  </span><span class="p">(</span><span class="nf">map-&gt;Server</span><span class="w">
   </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}}))</span><span class="w">
</span></code></pre></div></div>

<p>У такой записи есть недостаток. Мы вынуждены помнить, какие слоты нужны для
инициализации, а какие для внутреннего использования. Для простых записей это не
критично, но в боевых системах встречаются компоненты с десятью и более
слотами. Чтобы программист не запутался, объявляют функцию-конструктор.</p>

<p>Конструктор принимает только те аргументы, которые нужны для инициализации
компонента. В нашем случае это options, поэтому функция выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-server</span><span class="w">
  </span><span class="p">[</span><span class="n">options</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">map-&gt;Server</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="n">options</span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">s-created</span><span class="w"> </span><span class="p">(</span><span class="nf">make-server</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Конструктор упрощает создание сервера. С таким подходом невозможно передать в
<code class="language-plaintext highlighter-rouge">map-&gt;Server</code> что-то лишнее. Дополняйте каждый компонент системы конструктором
даже в тривиальных случаях.</p>

<h3 id="особенность-слотов">Особенность слотов</h3>

<p>При остановке компонента мы совершаем два действия: физически выключаем сервер и
замещаем его слот значением nil. Читатель заметит, почему бы не заменить <code class="language-plaintext highlighter-rouge">assoc</code>
на <code class="language-plaintext highlighter-rouge">dissoc?</code> Зачем хранить nil, когда можно отсоединить поле?</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:server</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">;; should have become</span><span class="w">
</span><span class="p">(</span><span class="nb">dissoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:server</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Причина в том, как устроены записи и слоты. Запись сохраняет свои уникальные
свойства до тех пор, пока все ее слоты на месте. Если забрать у записи слот
через <code class="language-plaintext highlighter-rouge">dissoc</code>, получим обычный словарь. Покажем это на примере:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">s-stopped</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="no">:server</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w">
</span><span class="n">book.systems.comp.server.Server</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">s-stopped</span><span class="w"> </span><span class="p">(</span><span class="nb">dissoc</span><span class="w"> </span><span class="no">:server</span><span class="p">)</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w">
</span><span class="n">clojure.lang.PersistentArrayMap</span><span class="w">
</span></code></pre></div></div>

<p>Если один компонентов вызывает <code class="language-plaintext highlighter-rouge">dissoc</code> на самом себе, при переходе на новую
стадию мы получим не компонент, а словарь. Это досадная ошибка, которая ведет к
странному поведению системы. Например, при попытке выключить компонент он
продолжает работу.</p>

<p>Когда запись расширяют протоколом, тем самым устанавливают связь между типом
первого аргумента и логикой. Для аргумента с типом <code class="language-plaintext highlighter-rouge">Server</code> методы <code class="language-plaintext highlighter-rouge">start</code> и
<code class="language-plaintext highlighter-rouge">stop</code> выполнят одно, для типов <code class="language-plaintext highlighter-rouge">DB</code> или <code class="language-plaintext highlighter-rouge">Worker</code> — другое. На другие типы
действует реализация по умолчанию, которая возвращает this. Это значит, что если
метод start вернул не компонент, а словарь, мы не сможем вызвать правильный stop
для этого словаря.</p>

<p>Приведем неудачный пример компонента. Его метод <code class="language-plaintext highlighter-rouge">start</code> Возвращает словарь с
одноименным полем <code class="language-plaintext highlighter-rouge">server</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">BadServer</span><span class="w">
  </span><span class="p">[</span><span class="n">options</span><span class="w"> </span><span class="n">server</span><span class="p">]</span><span class="w">
  </span><span class="n">component/Lifecycle</span><span class="w">
  </span><span class="p">(</span><span class="nf">start</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">{</span><span class="no">:server</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="n">options</span><span class="p">)})</span><span class="w">
  </span><span class="p">(</span><span class="nf">stop</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">)</span><span class="w">
    </span><span class="n">nil</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запуск такого компонента сработает без ошибок. Выполнив два выражения ниже,
переключитесь браузер и проверьте сервер:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">bs-created</span><span class="w"> </span><span class="p">(</span><span class="nf">map-&gt;BadServer</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}}))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">bs-started</span><span class="w"> </span><span class="p">(</span><span class="nf">component/start</span><span class="w"> </span><span class="n">bs-created</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Но переменная <code class="language-plaintext highlighter-rouge">bs-started</code> уже не запись, а словарь. Реализация <code class="language-plaintext highlighter-rouge">stop</code> для
словаря вернет его же без каких либо действий. Можно сколько угодно вызывать
<code class="language-plaintext highlighter-rouge">component/stop</code>, но сервер не будет остановлен.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="n">bs-started</span><span class="p">)</span><span class="w">
</span><span class="n">clojure.lang.PersistentArrayMap</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">bs-stopped</span><span class="w"> </span><span class="p">(</span><span class="nf">component/stop</span><span class="w"> </span><span class="n">bs-started</span><span class="p">))</span><span class="w">
</span><span class="c1">;; does nothing, the server still works</span><span class="w">
</span></code></pre></div></div>

<p>Похожие трудности возникнут, если исправить <code class="language-plaintext highlighter-rouge">start</code> без учета <code class="language-plaintext highlighter-rouge">stop</code>. При
остановке плохой компонент выключит сервер, но вернет nil. При запуске nil
получим исключение, что тип не реализует протокол <code class="language-plaintext highlighter-rouge">Lifecycle</code>.</p>

<p>Следите за тем, чтобы компонент менял только значения слотов, но не их состав.</p>

<h3 id="компонент-базы">Компонент базы</h3>

<p>Напишем компонент для работы с базой данных. Концепция пула соединений уже
известна читателю из прошлых разделов. Компонент содержит два слота: <code class="language-plaintext highlighter-rouge">options</code> и
<code class="language-plaintext highlighter-rouge">db-spec</code>. Первый это словарь опций будущего пула. Слот <code class="language-plaintext highlighter-rouge">db-spec</code> предназначен
для внутреннего использования. Он хранит JDBC-спеку с открытым пулом.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">DB</span><span class="w">
    </span><span class="p">[</span><span class="n">options</span><span class="w"> </span><span class="n">db-spec</span><span class="p">]</span><span class="w">

  </span><span class="n">component/Lifecycle</span><span class="w">

  </span><span class="p">(</span><span class="nf">start</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pool</span><span class="w"> </span><span class="p">(</span><span class="nf">cp/make-datasource</span><span class="w"> </span><span class="n">options</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:db-spec</span><span class="w"> </span><span class="p">{</span><span class="no">:datasource</span><span class="w"> </span><span class="n">pool</span><span class="p">})))</span><span class="w">

  </span><span class="p">(</span><span class="nf">stop</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">db-spec</span><span class="w"> </span><span class="no">:datasource</span><span class="w"> </span><span class="n">cp/close-datasource</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:db-spec</span><span class="w"> </span><span class="n">nil</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Добавим функцию-конструктор:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-db</span><span class="w"> </span><span class="p">[</span><span class="n">options</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">map-&gt;DB</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="n">options</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Компонент готов к запуску, и его можно прогнать через функции <code class="language-plaintext highlighter-rouge">make-db</code> →
<code class="language-plaintext highlighter-rouge">component/start</code> → <code class="language-plaintext highlighter-rouge">component/stop</code>.</p>

<p>Пока что неясно, как выполнять запросы через этот компонент. Нас интересует слот
<code class="language-plaintext highlighter-rouge">db-spec</code>, который хранит спеку. Технически возможно вычленить его и передать в
jdbc-функцию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">db-spec</span><span class="p">]}</span><span class="w"> </span><span class="n">db-started</span><span class="w">
      </span><span class="n">users</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db-spec</span><span class="w"> </span><span class="s">"select * from users"</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">process-users</span><span class="w"> </span><span class="n">users</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Но это варварский подход. Мы не должны вторгаться во внутренности компонента,
даже если язык предлагает такую возможность. Этим мы нарушаем концепцию
компонента, который неделим с точки зрения стороннего наблюдателя. В этом плане
компоненты близки к объектам в современных языках.</p>

<p>Дополним DB методами для работы с базой. Сначала определим протокол с методами
запроса и обновления. Сигнатуры аналогичны их jdbc-версиям с той разницей, что
первый параметр это не <code class="language-plaintext highlighter-rouge">db-спека</code>, а <code class="language-plaintext highlighter-rouge">this</code>, компонент:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defprotocol</span><span class="w"> </span><span class="n">IDB</span><span class="w">
  </span><span class="p">(</span><span class="nf">query</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">sql-params</span><span class="p">])</span><span class="w">
  </span><span class="p">(</span><span class="nf">update!</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">set-map</span><span class="w"> </span><span class="n">where-clause</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>В теле <code class="language-plaintext highlighter-rouge">defrecord</code>, сразу после <code class="language-plaintext highlighter-rouge">stop</code>, поместим реализацию этого
протокола. Реализация сводится к jdbc-функциям, в которые мы передаем слот
<code class="language-plaintext highlighter-rouge">:db-spec</code> и аргументы метода.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="c1">;; ........</span><span class="w">

  </span><span class="p">(</span><span class="nf">stop</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">db-spec</span><span class="w"> </span><span class="no">:datasource</span><span class="w"> </span><span class="n">cp/close-datasource</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:db-spec</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">

  </span><span class="n">IDB</span><span class="w">

  </span><span class="p">(</span><span class="nf">query</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">sql-params</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db-spec</span><span class="w"> </span><span class="n">sql-params</span><span class="p">))</span><span class="w">

  </span><span class="p">(</span><span class="nf">update!</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">set-map</span><span class="w"> </span><span class="n">where-clause</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/update!</span><span class="w"> </span><span class="n">db-spec</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">set-map</span><span class="w"> </span><span class="n">where-clause</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>На этом этапе компонент уже готов к запросам. Обратите внимание, что мы вызываем
не jdbc-функции, а методы протокола. Тем самым мы изолируем зависимость от JDBC
внутри компонента.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-created</span><span class="w"> </span><span class="p">(</span><span class="nf">make-db</span><span class="w"> </span><span class="n">options</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-started</span><span class="w"> </span><span class="p">(</span><span class="nf">component/start</span><span class="w"> </span><span class="n">db-created</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">query</span><span class="w"> </span><span class="n">db-started</span><span class="w"> </span><span class="s">"select * from requests"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">update!</span><span class="w"> </span><span class="n">db-started</span><span class="w"> </span><span class="no">:requests</span><span class="w"> </span><span class="p">{</span><span class="no">:is_processed</span><span class="w"> </span><span class="n">false</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="s">"id = ?"</span><span class="w"> </span><span class="mi">42</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-stopped</span><span class="w"> </span><span class="p">(</span><span class="nf">component/stop</span><span class="w"> </span><span class="n">db-started</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h3 id="транзакционный-компонент">Транзакционный компонент</h3>

<p>Из прошлого раздела мы помним, что для согласованных изменений в базе нужны
транзакции. Раньше мы пользовались <code class="language-plaintext highlighter-rouge">jdbc/with-db-transaction</code>. Он связывает
символ с транзакционным соединением, полученным из обычного.</p>

<p>Напишем одноименный макрос с такой же сигнатурой. В отличии от JDBC-версии, наш
макрос работает с компонентами. Он принимает обычный компонент БД и связывает с
символом его транзакционную версию. Технически макрос сводится к следующим
шагам:</p>

<ul>
  <li>получить из компонента текущее соединение;</li>
  <li>обернуть тело в макрос jdbc, получить транзакционное соединение;</li>
  <li>связать с символом <code class="language-plaintext highlighter-rouge">comp-tx</code> компонент, у которого слот :db-spec заменен на
транзакционное соединение.</li>
</ul>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-db-transaction</span><span class="w">
  </span><span class="p">[[</span><span class="n">comp-tx</span><span class="w"> </span><span class="n">comp-db</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">trx-opt</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="n">db-spec</span><span class="o">#</span><span class="w"> </span><span class="no">:db-spec</span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="n">comp-db</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">jdbc/with-db-transaction</span><span class="w">
       </span><span class="p">[</span><span class="n">t-conn</span><span class="o">#</span><span class="w"> </span><span class="n">db-spec</span><span class="o">#</span><span class="w"> </span><span class="o">~@</span><span class="n">trx-opt</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="o">~</span><span class="n">comp-tx</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="o">~</span><span class="n">comp-db</span><span class="w"> </span><span class="no">:db-spec</span><span class="w"> </span><span class="n">t-conn</span><span class="o">#</span><span class="p">)]</span><span class="w">
         </span><span class="o">~@</span><span class="n">body</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Читатель заметит, что в макросе мы нарушаем принцип закрытости
компонента. Например, мы вручную читаем и заменяем его приватный слот. В случае
с макросом это нормально. Подобно компоненту, макрос изолирует низкоуровневые
действия, поэтому сторонний потребитель не заметит манипуляций со слотами.</p>

<p>Пример работы макроса:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-db-transaction</span><span class="w">
  </span><span class="p">[</span><span class="n">db-tx</span><span class="w"> </span><span class="n">db-started</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">requests</span><span class="w"> </span><span class="p">(</span><span class="nf">query</span><span class="w"> </span><span class="n">db-tx</span><span class="w"> </span><span class="s">"select * from requests limit 1 for update"</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">requests</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">update!</span><span class="w"> </span><span class="n">db-tx</span><span class="w"> </span><span class="no">:requests</span><span class="w"> </span><span class="p">{</span><span class="no">:is_processed</span><span class="w"> </span><span class="n">false</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="s">"id = ?"</span><span class="w"> </span><span class="p">(</span><span class="no">:id</span><span class="w"> </span><span class="n">request</span><span class="p">)]))))</span><span class="w">
</span></code></pre></div></div>

<p>В логах PostgreSQL мы увидим следующие записи:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">requests</span> <span class="k">limit</span> <span class="mi">1</span> <span class="k">for</span> <span class="k">update</span>
<span class="k">UPDATE</span> <span class="n">requests</span> <span class="k">SET</span> <span class="n">is_processed</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="err">$</span><span class="mi">2</span>
<span class="n">DETAIL</span><span class="p">:</span>  <span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'f'</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="s1">'3'</span>
<span class="k">COMMIT</span>
</code></pre></div></div>

<p>Выражения <code class="language-plaintext highlighter-rouge">select</code> и <code class="language-plaintext highlighter-rouge">update</code> действительно выполнены в транзакции.</p>

<h3 id="воркер">Воркер</h3>

<p>Напишем компонент воркера. Для этого объявим новый модуль и подключим
зависимости:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.systems.comp.worker</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">com.stuartsierra.component</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">component</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">book.systems.comp.db</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clj-http.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">client</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.tools.logging</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">log</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Воркер это запись, которая реализует два протокола: <code class="language-plaintext highlighter-rouge">Lifecycle</code> и
<code class="language-plaintext highlighter-rouge">IWorker</code>. Протокол <code class="language-plaintext highlighter-rouge">Lifecycle</code> уже знаком читателю: это функции <code class="language-plaintext highlighter-rouge">start</code> и
<code class="language-plaintext highlighter-rouge">stop</code>. Они опираются на методы <code class="language-plaintext highlighter-rouge">IWorker</code>, который выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defprotocol</span><span class="w"> </span><span class="n">IWorker</span><span class="w">
  </span><span class="p">(</span><span class="nf">make-task</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">])</span><span class="w">
  </span><span class="p">(</span><span class="nf">task-fn</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Мы ожидаем, что <code class="language-plaintext highlighter-rouge">task-fn</code> это функция, которую воркер вызывает на каждом шаге
цикла. Метод <code class="language-plaintext highlighter-rouge">make-task</code> оборачивает ее в цикл и <code class="language-plaintext highlighter-rouge">try/catch</code>.</p>

<p>Запись хранит четыре слота: входные опции, флаг продолжения цикла, футура с
циклом и база данных. Это зависимый компонент, который мы описали на предыдущем
шаге. Для начала реализуем <code class="language-plaintext highlighter-rouge">Lifecycle</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Worker</span><span class="w">
    </span><span class="p">[</span><span class="n">options</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">

  </span><span class="n">component/Lifecycle</span><span class="w">

  </span><span class="p">(</span><span class="nf">start</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">flag</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
          </span><span class="n">this</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:flag</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="c1">;; note</span><span class="w">
          </span><span class="n">task</span><span class="w"> </span><span class="p">(</span><span class="nf">make-task</span><span class="w"> </span><span class="n">this</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:task</span><span class="w"> </span><span class="n">task</span><span class="p">)))</span><span class="w">

  </span><span class="p">(</span><span class="nf">stop</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">while</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">realized?</span><span class="w"> </span><span class="n">task</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"Waiting for the task to complete"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">300</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:flag</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:task</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">

  </span><span class="c1">;; to be continued</span><span class="w">
  </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Отдельно прокомментируем строку с меткой <code class="language-plaintext highlighter-rouge">;; note</code>. Мы заменяем <code class="language-plaintext highlighter-rouge">this</code> на его же
версию с флагом состояния. Это нужно для того, чтобы <code class="language-plaintext highlighter-rouge">make-task</code> смог прочитать
флаг из переданного <code class="language-plaintext highlighter-rouge">this</code>. Если строку убрать, <code class="language-plaintext highlighter-rouge">make-task</code> получит запись с
флагом nil, что приведет к ошибке.</p>

<p>Опишем протокол <code class="language-plaintext highlighter-rouge">IWorker</code>. Код <code class="language-plaintext highlighter-rouge">make-task</code> и <code class="language-plaintext highlighter-rouge">task-fn</code> уже знаком читателю из
прошлого раздела про Mount. Разница в том, что теперь мы работаем не с
функциями, а методами. Поскольку метод имеет прямой доступ к слотам, нет смысла
передавать <code class="language-plaintext highlighter-rouge">db</code>, <code class="language-plaintext highlighter-rouge">flag</code> и другие параметры, как мы делали это с
функциями. Каждый метод принимает только <code class="language-plaintext highlighter-rouge">this</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Worker</span><span class="w">
  </span><span class="c1">;; skipped</span><span class="w">
  </span><span class="n">IWorker</span><span class="w">

  </span><span class="p">(</span><span class="nf">make-task</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">future</span><span class="w">
      </span><span class="p">(</span><span class="nf">while</span><span class="w"> </span><span class="o">@</span><span class="n">flag</span><span class="w">
        </span><span class="p">(</span><span class="nf">try</span><span class="w"> </span><span class="p">(</span><span class="nf">task-fn</span><span class="w"> </span><span class="n">this</span><span class="p">)</span><span class="w">
             </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
               </span><span class="p">(</span><span class="nf">log/error</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
             </span><span class="p">(</span><span class="nf">finally</span><span class="w">
               </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="p">(</span><span class="no">:sleep</span><span class="w"> </span><span class="n">options</span><span class="p">)))))))</span><span class="w">

  </span><span class="p">(</span><span class="nf">task-fn</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">db/with-db-transaction</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">db/query</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="n">requests-query</span><span class="p">))]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="n">ip</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
              </span><span class="n">info</span><span class="w"> </span><span class="p">(</span><span class="nf">get-ip-info</span><span class="w"> </span><span class="n">ip</span><span class="p">)</span><span class="w">
              </span><span class="n">fields</span><span class="w"> </span><span class="p">{</span><span class="no">:is_processed</span><span class="w"> </span><span class="n">true</span><span class="w">
                      </span><span class="no">:zip</span><span class="w"> </span><span class="p">(</span><span class="no">:postal_code</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w">
                      </span><span class="no">:lat</span><span class="w"> </span><span class="p">(</span><span class="no">:lat</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w">
                      </span><span class="no">:lon</span><span class="w"> </span><span class="p">(</span><span class="no">:lng</span><span class="w"> </span><span class="n">info</span><span class="p">)}]</span><span class="w">
          </span><span class="p">(</span><span class="nf">db/update!</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="no">:requests</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="p">[</span><span class="s">"id = ?"</span><span class="w"> </span><span class="n">id</span><span class="p">]))))))</span><span class="w">
</span></code></pre></div></div>

<p>Добавим конструктор, и компонент готов:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-worker</span><span class="w">
  </span><span class="p">[</span><span class="n">options</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">map-&gt;Worker</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="n">options</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<h3 id="ручные-зависимости">Ручные зависимости</h3>

<p>Воркер отличается от других компонентов тем, что имеет зависимости. Пока что не
ясно, как воркер узнает о базе данных, потому что его конструктор принимает
только опции. Забегая вперед скажем, что эту проблему решает система, а не
разработчик. Мы не должны передавать компоненты друг другу в момент их создания.</p>

<p>Хотелось бы проверить воркер до того, как мы двинемся дальше. Во время
разработки это правило можно нарушить. Мы вручную соберем мини-систему из двух
компонентов. Так мы проверим код, который написали и поймем, как работает
система.</p>

<p>Проведем эксперимент с системой в отдельном модуле core. Импортируйте в него
конструкторы и библиотеку Component:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.systems.comp.core</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">com.stuartsierra.component</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">component</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">book.systems.comp.server</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">make-server</span><span class="p">]]</span><span class="w">
   </span><span class="p">[</span><span class="n">book.systems.comp.worker</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">make-worker</span><span class="p">]]</span><span class="w">
   </span><span class="p">[</span><span class="n">book.systems.comp.db</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">make-db</span><span class="p">]]))</span><span class="w">
</span></code></pre></div></div>

<p>Наивная система приведена ниже. Это функция, которая принимает конфигурацию. Мы
вручную запускаем базу и воркер и возвращаем словарь компонентов. В строке с
комментарием вы передаем воркеру слот с компонентом базы. Важен момент, в
который мы это делаем. Компонент базы уже должен быть включен, а воркер еще нет.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-system-start</span><span class="w">
  </span><span class="p">[</span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="n">db-opt</span><span class="w"> </span><span class="no">:pool</span><span class="w">
         </span><span class="n">worker-opt</span><span class="w"> </span><span class="no">:worker</span><span class="p">}</span><span class="w"> </span><span class="n">config</span><span class="w">
        </span><span class="n">db</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">db-opt</span><span class="w">
               </span><span class="n">make-db</span><span class="w">
               </span><span class="n">component/start</span><span class="p">)</span><span class="w">
        </span><span class="n">worker</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">worker-opt</span><span class="w">
                   </span><span class="n">make-worker</span><span class="w">
                   </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="n">db</span><span class="p">)</span><span class="w"> </span><span class="c1">;; note</span><span class="w">
                   </span><span class="n">component/start</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:worker</span><span class="w"> </span><span class="n">worker</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы запустить систему, передайте в функцию словарь с параметрами пула и
воркера. Сохраните систему в переменной, чтобы выключить ее позже.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">_sys</span><span class="w"> </span><span class="p">(</span><span class="nf">my-system-start</span><span class="w"> </span><span class="p">{</span><span class="no">:pool</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">}</span><span class="w"> </span><span class="no">:worker</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">}}))</span><span class="w">
</span></code></pre></div></div>

<p>Пока система работает, проверьте ее, как мы делали это в прошлом
разделе. Добавьте несколько записей в таблицу <code class="language-plaintext highlighter-rouge">requests</code> и убедитесь, что воркер
дополняет поля.</p>

<p>Функция выключения останавливает компоненты в верном порядке.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-system-stop</span><span class="w">
  </span><span class="p">[</span><span class="n">system</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">system</span><span class="w">
      </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:worker</span><span class="w"> </span><span class="n">component/stop</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="n">component/stop</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">my-system-stop</span><span class="w"> </span><span class="n">_sys</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h3 id="промышленная-система">Промышленная система</h3>

<p>Рассмотрим, как работает настоящая, промышленная система. Функция <code class="language-plaintext highlighter-rouge">system-map</code>
принимает цепочку значений, где каждый нечетный элемент это ключ, машинное имя
компонента в системе. Четные элементы это инициированные компоненты (т.е. вызовы
их конструкторов). Функция возвращает систему в состоянии покоя.</p>

<p>Построение системы не должно носить побочных эффектов. Технически вызов
<code class="language-plaintext highlighter-rouge">system-map</code> аналогичен объявлению структуры данных. Конструкторы компонентов
только возвращают экземпляры записей с заполненными слотами. Если конструктор
обращается к консоли, диску и глобальному состоянию, это грубая ошибка.</p>

<p>Поскольку система зависит от конфигурации, ее построение оборачивают в отдельную
функцию <code class="language-plaintext highlighter-rouge">make-system</code>. Эта функция принимает словарь конфигурации и разделяет
его на составные части. Каждый конструктор вызывается со своей
под-конфигурацией. Удобно, когда конфигурация повторяет топологию системы: на
верхнем уровне ключи компонентов, а под ними словари опций.</p>

<p>Чтобы сообщить компоненту зависимости, его оборачивают в функцию
<code class="language-plaintext highlighter-rouge">component/using</code>. Вторым аргументом передают ключи компонентов, которые
необходимо сообщить целевому компоненту до его старта. Ключи могут быть вектором
или словарем. Если имя слота совпадает с именем компонента в системе, это
вектор. Если имена отличаются, передают словарь вида <code class="language-plaintext highlighter-rouge">{:slot-name
:system-name}</code>.</p>

<p>В примере ниже функция <code class="language-plaintext highlighter-rouge">make-system</code> строит систему, о которой мы договаривались
в начале главы. Компонент <code class="language-plaintext highlighter-rouge">worker</code>, который зависит от базы данных, обернут в
<code class="language-plaintext highlighter-rouge">component/using</code>. Поскольку имя слота <code class="language-plaintext highlighter-rouge">:db</code> совпадает с именем компонента в
системе, мы передали вектор <code class="language-plaintext highlighter-rouge">[:db]</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-system</span><span class="w">
  </span><span class="p">[</span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">jetty</span><span class="w"> </span><span class="n">pool</span><span class="w"> </span><span class="n">worker</span><span class="p">]}</span><span class="w"> </span><span class="n">config</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">component/system-map</span><span class="w">
     </span><span class="no">:server</span><span class="w"> </span><span class="p">(</span><span class="nf">make-server</span><span class="w"> </span><span class="n">jetty</span><span class="p">)</span><span class="w">
     </span><span class="no">:db</span><span class="w">     </span><span class="p">(</span><span class="nf">make-db</span><span class="w"> </span><span class="n">pool</span><span class="p">)</span><span class="w">
     </span><span class="no">:worker</span><span class="w"> </span><span class="p">(</span><span class="nf">component/using</span><span class="w">
              </span><span class="p">(</span><span class="nf">make-worker</span><span class="w"> </span><span class="n">worker</span><span class="p">)</span><span class="w">
              </span><span class="p">[</span><span class="no">:db</span><span class="p">]))))</span><span class="w">
</span></code></pre></div></div>

<p>Если бы имя компонента в системе было <code class="language-plaintext highlighter-rouge">:storage</code>, мы бы передали словарь
соответствия имен:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">component/system-map</span><span class="w">
 </span><span class="no">:server</span><span class="w">  </span><span class="p">(</span><span class="nf">make-server</span><span class="w"> </span><span class="n">jetty</span><span class="p">)</span><span class="w">
 </span><span class="no">:storage</span><span class="w"> </span><span class="p">(</span><span class="nf">make-db</span><span class="w"> </span><span class="n">pool</span><span class="p">)</span><span class="w">
 </span><span class="no">:worker</span><span class="w">  </span><span class="p">(</span><span class="nf">component/using</span><span class="w">
           </span><span class="p">(</span><span class="nf">make-worker</span><span class="w"> </span><span class="n">worker</span><span class="p">)</span><span class="w">
           </span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="no">:storage</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Вариант со словарем полезен, когда вы подключаете сторонние компоненты. Их
разработчики не знают наверняка, как именуют сущности в вашем проекте. Например,
чужой компонент зависит от некого <code class="language-plaintext highlighter-rouge">:storage</code>. Это слишком абстрактное имя: в
системе бывает несколько хранилищ данных: <code class="language-plaintext highlighter-rouge">:postgres</code>, <code class="language-plaintext highlighter-rouge">:cassandra</code>,
<code class="language-plaintext highlighter-rouge">:redis</code>. Система маппинга снимает проблему расхождения имен.</p>

<p>Чтобы запустить систему, ее передают в <code class="language-plaintext highlighter-rouge">component/start</code>. Система реализует
протокол <code class="language-plaintext highlighter-rouge">Lifecycle</code> и с технической точки зрения ведет себя как
компонент. Разница в том, что система аккумулирует другие компоненты и управляет
их жизненным циклом.</p>

<p>В момент запуска алгоритм обходит компоненты и строит граф зависимостей. Из
этого графа система выводит порядок обхода. Перед тем как запустить компонент с
зависимостями, система сообщает их компоненту через assoc, как мы делали это
выше. Аналогично работает выключение системы.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">sys-init</span><span class="w"> </span><span class="p">(</span><span class="nf">make-system</span><span class="w"> </span><span class="n">config</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">sys-started</span><span class="w"> </span><span class="p">(</span><span class="nf">component/start</span><span class="w"> </span><span class="n">sys-init</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">sys-stopped</span><span class="w"> </span><span class="p">(</span><span class="nf">component/stop</span><span class="w"> </span><span class="n">sys-started</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h3 id="хранение-системы">Хранение системы</h3>

<p>Выше мы определили систему через <code class="language-plaintext highlighter-rouge">def</code>, что не совсем правильно. Система это
сущность, которая включается по требованию. Считается грубой ошибкой, если форма
def срабатывает в функции, а не на верхнем уровне модуля. Поэтому с системой
обращаются как глобальной переменной, которая меняет значение. С технической
стороны для этого подходит <code class="language-plaintext highlighter-rouge">alter-var-root</code>.</p>

<p>В главном модуле приложения выделяют переменную для глобальной системы. Ее
объявляют через defonce, чтобы случайно не переопределить ее при перезагрузке
модуля. Функция alter-system это сокращенная версия <code class="language-plaintext highlighter-rouge">(alter-var-root #'system
...)</code>. Код с ней получается короче.</p>

<p>Как мы выяснили, компонент может находиться в трех состояниях: покой, запуск и
остановка. То же самое применимо к системе. Функции <code class="language-plaintext highlighter-rouge">system-init</code>,
<code class="language-plaintext highlighter-rouge">system-start</code> и <code class="language-plaintext highlighter-rouge">system-stop</code> устанавливают глобальную систему в нужное
состояние. Первая функция принимает словарь конфигурации.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defonce</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">alter-system</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">alter-var-root</span><span class="w"> </span><span class="o">#</span><span class="ss">'system</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">system-init</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-system</span><span class="w"> </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="p">(</span><span class="nf">make-system</span><span class="w"> </span><span class="n">config</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">system-start</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-system</span><span class="w"> </span><span class="n">component/start</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">system-stop</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-system</span><span class="w"> </span><span class="n">component/stop</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Этот простой код дает все необходимое, чтобы управлять приложением. Функция
<code class="language-plaintext highlighter-rouge">-main</code> приложения сводится к трем шагам: чтению конфигурации, подготовке
системы и ее запуску.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-main</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="w"> </span><span class="p">(</span><span class="nf">load-config</span><span class="w"> </span><span class="s">"config.edn"</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">system-init</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">system-start</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что хотя система и глобальна, к ней нельзя обращаться напрямую. Если
один компонент извлекает другой из недр системы, это провал разработчика. Такой
подход сводит на нет саму идею системы и компонентов. Обращаться к системе
напрямую можно только в режиме разработки или тестов.</p>

<p>Для большей надежности переменную системы делают приватной:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defonce</span><span class="w"> </span><span class="o">^</span><span class="no">:private</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Этим мы обезопасим систему от обращения извне. В режиме разработки нам все еще
доступен трюк с resolve и символом переменной, чтобы сослаться на нее.</p>

<h3 id="корректное-завершение">Корректное завершение</h3>

<p>Подход с глобальной переменной идет вразрез с тем, что пишет автор
библиотеки. На странице проекта в его описании встречается следующая фраза:</p>

<blockquote>
  <p>In production, the system map is ephemeral. It is used to start all the
components running, then it is discarded.</p>
</blockquote>

<p>Что в переводе:</p>

<blockquote>
  <p>В промышленном запуске система эфемерна. Она запускает все компоненты и затем
исчезает.</p>
</blockquote>

<p>Это редкий случай, когда мы не согласимся с автором. Даже в боевом режиме вам
нужна ссылка на систему. Без ссылки невозможно выполнить т.н. “graceful
shutdown”, что значит корректно завершить программу. Под корректностью понимают
факт того, что все ресурсы были закрыты.</p>

<p>Система управляет состоянием приложения. Некоторые его части бывают очень
сложны: это очереди задач, каналы данных, транзакции. При завершении программы
мы не можем полагаться на стандартные средства JVM. Например, если вынужденно
заверить компонент очереди, мы потеряем сообщение или обработаем его дважды. Мы
обязаны закрыть ресурсы правильно, даже если придется подождать.</p>

<p>В боевом режиме приложение перехватывает <code class="language-plaintext highlighter-rouge">POSIX</code>-сигналы и реагирует на них
должным образом. Например, если поступил <code class="language-plaintext highlighter-rouge">SIGTERM</code>, приложение останавливает
систему, дожидается ее остановки и только потом завершается.</p>

<p>Библиотека <code class="language-plaintext highlighter-rouge">spootnik/signal</code> предлагает изящный макрос, чтобы связать сигнал с
реакцией на него. Подключите библиотеку в проект и модуль core:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; project.clj</span><span class="w">
</span><span class="p">[</span><span class="n">spootnik/signal</span><span class="w"> </span><span class="s">"0.2.2"</span><span class="p">]</span><span class="w">

</span><span class="c1">;; src/book/systems/comp/core.clj</span><span class="w">
</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">signal.handler</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">with-handler</span><span class="p">]]))</span><span class="w">
</span></code></pre></div></div>

<p>Расширьте функцию <code class="language-plaintext highlighter-rouge">-main</code>: сразу после запуска системы добавьте обработчики
сигналов <code class="language-plaintext highlighter-rouge">SIGTERM</code>, <code class="language-plaintext highlighter-rouge">SIGINT</code> и <code class="language-plaintext highlighter-rouge">SIGHUP</code>. На первые два мы завершаем систему и
выходим из программы. Сигнал <code class="language-plaintext highlighter-rouge">SIGHUP</code> мы расцениваем как сигнал к перезагрузке
системы. В примере ниже функция <code class="language-plaintext highlighter-rouge">(exit)</code> это аналог <code class="language-plaintext highlighter-rouge">(System/exit)</code> с
дополнительной логикой.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-handler</span><span class="w"> </span><span class="no">:term</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"caught SIGTERM, quitting"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">system-stop</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"all components shut down"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">exit</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">with-handler</span><span class="w"> </span><span class="no">:int</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"caught SIGINT, quitting"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">system-stop</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"all components shut down"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">exit</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">with-handler</span><span class="w"> </span><span class="no">:hup</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"caught SIGHUP, reloading"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">system-stop</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">system-start</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"system reloaded"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что обработка сигналов не работает, когда проект запущен через <code class="language-plaintext highlighter-rouge">lein
run</code> или вручную в REPL-сеансе. Чтобы проверить сигналы, скомпилируйте uberjar и
запустите его как java-приложение.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein uberjar
java <span class="nt">-jar</span> target/myproject.jar
</code></pre></div></div>

<p>После запуска нажмите <code class="language-plaintext highlighter-rouge">Ctrl-C</code>. Приложение завершится не сразу, и вы увидите
логи о том, что система остановлена.</p>

<p>При работе с системой позаботьтесь о том, чтобы безопасно остановить ее даже в
аварийном случае.</p>

<h3 id="ожидание-системы">Ожидание системы</h3>

<p>Вспомним функцию <code class="language-plaintext highlighter-rouge">-main</code> приложения. Это входная точка старта Java-программы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-main</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="w"> </span><span class="p">(</span><span class="nf">load-config</span><span class="w"> </span><span class="s">"config.edn"</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">system-init</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">system-start</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>У читателя, не знакомого с тонкостями JVM, возникнет вопрос. Что помешает
программе завершиться после вызова <code class="language-plaintext highlighter-rouge">(system-start)</code>? Ниже этой формы нет
какого-то бесконечного цикла, хука или события. Почему платформа продолжит
работу?</p>

<p>Это стандартное поведение JVM. Если программа завершается не аварийно, главный
тред ожидает, пока не остановятся остальные. Запуск системы порождает состояние
в новых потоках (сервер, пул соединений). Поэтому после <code class="language-plaintext highlighter-rouge">(system-start)</code>
основной поток повиснет в ожидании их завершения. Он будет ждать до тех пор,
пока систему не выключит кто-то другой и параллельного треда или не придет
<code class="language-plaintext highlighter-rouge">POSIX</code>-сигнал. Как приложению реагировать на сигналы мы рассмотрели выше.</p>

<h3 id="улучшаем-зависимости">Улучшаем зависимости</h3>

<p>Когда мы объявили систему, то сообщили компоненту <code class="language-plaintext highlighter-rouge">:worker</code> о его
зависимостях. В примере ниже мы буквально говорим компоненту: ты зависишь от
базы данных.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">component/system-map</span><span class="w">
 </span><span class="c1">;; ...</span><span class="w">
 </span><span class="no">:worker</span><span class="w"> </span><span class="p">(</span><span class="nf">component/using</span><span class="w">
          </span><span class="p">(</span><span class="nf">make-worker</span><span class="w"> </span><span class="n">worker</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="no">:db</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Когда компонентов много, перечисление их зависимостей занимает место и зашумляет
код. Помогает следующий трюк: зависимости компонента выносят в конструктор.</p>

<p>В примере выше <code class="language-plaintext highlighter-rouge">(make-worker {...})</code> возвращает наивную версию компонента,
которая не знает о зависимостях. Наивная версия попадает в <code class="language-plaintext highlighter-rouge">component/using</code>,
которая сообщает их. Мы могли бы втянуть <code class="language-plaintext highlighter-rouge">component/using</code> в конструктор, чтобы
новый компонент был сразу “заряжен” зависимостями. Тогда на уровне системы шаг
<code class="language-plaintext highlighter-rouge">component/using</code> станет не нужен.</p>

<p>Перепишем конструктор воркера:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-worker</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">config</span><span class="w">
      </span><span class="n">map-&gt;Worker</span><span class="w">
      </span><span class="p">(</span><span class="nf">component/using</span><span class="w"> </span><span class="p">[</span><span class="no">:db</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь система выглядит чище:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">component/system-map</span><span class="w">
 </span><span class="no">:server</span><span class="w"> </span><span class="p">(</span><span class="nf">make-server</span><span class="w"> </span><span class="n">jetty</span><span class="p">)</span><span class="w">
 </span><span class="no">:db</span><span class="w">     </span><span class="p">(</span><span class="nf">make-db</span><span class="w"> </span><span class="n">pool</span><span class="p">)</span><span class="w">
 </span><span class="no">:worker</span><span class="w"> </span><span class="p">(</span><span class="nf">make-worker</span><span class="w"> </span><span class="n">worker</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Такой подход требует, чтобы имена в системе совпадали с зависимыми слотами. Если
это ваши компоненты, достаточно один раз договориться с командой об
именовании. Для сторонних компонентов легко написать свой конструктор.</p>

<p>Коротко рассмотрим, как хранятся данные о зависимостях. Очевидно, что вызов
<code class="language-plaintext highlighter-rouge">component/using</code> сообщает компоненту новые сведения, однако сам компонент от
этого не меняется. У него не появляется нового поля <code class="language-plaintext highlighter-rouge">:deps</code> или что-то в этом
роде. Компонент хранит зависимости в метаданных.</p>

<p>Метаданные это словарь дополнительных сведений об объекте. Метаданные работают с
коллекциями и некоторым другим типам Clojure, например, символом или
переменной. К метаданным прибегают, когда нужно сообщить добавочные сведения об
объекте, не изменяя его. Зависимости компонента подходят на роль таких сведений.</p>

<p>Функция meta возвращает словарь метаданных объекта. Пример ниже показывает, что
конструктор порождает компонент с заполненными зависимостями:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">}</span><span class="w"> </span><span class="n">make-worker</span><span class="w"> </span><span class="nb">meta</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="no">:com.stuartsierra.component</span><span class="p">{</span><span class="no">:dependencies</span><span class="w"> </span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="no">:db</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы увидеть метаданные другим способом, установите глобальную переменную
<em>print-meta</em> в истину. Тогда при выводе объекта в REPL он будет дополнен
метаданными:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*print-meta*</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">make-worker</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">})</span><span class="w">
</span><span class="o">^#</span><span class="no">:com.stuartsierra.component</span><span class="p">{</span><span class="no">:dependencies</span><span class="w"> </span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="no">:db</span><span class="p">}}</span><span class="w">
</span><span class="o">#</span><span class="n">book.systems.comp.worker.Worker</span><span class="p">{</span><span class="n">...</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="группировка-слотов">Группировка слотов</h3>

<p>Слоты компонента делятся на три группы. Это параметры инициализации, поля
внутреннего состояния и зависимости. Вспомним, как мы объявили компонент
воркера:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Worker</span><span class="w">
    </span><span class="p">[</span><span class="n">options</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">db</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>В этом примере слот <code class="language-plaintext highlighter-rouge">options</code> относится к инициализации, <code class="language-plaintext highlighter-rouge">flag</code> и <code class="language-plaintext highlighter-rouge">task</code> к
состоянию, <code class="language-plaintext highlighter-rouge">db</code> — зависимость. Чем сложнее компонент, тем больше у него слотов в
каждой группе. Когда слоты перечислены беспорядочно, трудно понять их
семантику. Поэтому хорошей практикой считается группировать слоты вручную и
разделять их комментарием:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Worker</span><span class="w">
    </span><span class="p">[</span><span class="c1">;; init</span><span class="w">
     </span><span class="n">options</span><span class="w">
     </span><span class="c1">;; runtime</span><span class="w">
     </span><span class="n">flag</span><span class="w"> </span><span class="n">task</span><span class="w">
     </span><span class="c1">;; deps</span><span class="w">
     </span><span class="n">db</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Первой идет группа <code class="language-plaintext highlighter-rouge">init</code>, входящие параметры. Это слоты, необходимые для нового
компонента. Ожидается, что конструктор принимает такие же параметры. Группа
<code class="language-plaintext highlighter-rouge">runtime</code> перечисляет слоты, которые компонент заполнит сам в момент старта. В
<code class="language-plaintext highlighter-rouge">deps</code> указаны зависимости. Вектор этих зависимостей передают в
<code class="language-plaintext highlighter-rouge">component/using</code> в конструкторе.</p>

<p>Сортировка слотов облегчает работу с кодом. Договоритесь с членами команды,
чтобы внедрить эту практику. Но когда слотов слишком много, это говорит о том,
что компонент излишне сложен. Тогда часть слотов и логики выносят в отдельный
компонент и подключают его как зависимость.</p>

<p>В последующих примерах мы не группируем слоты, потому что иначе код займет
слишком много места. В вашем коде слоты должны быть сгруппированы.</p>

<h3 id="условная-система">Условная система</h3>

<p>В главе про конфигурацию мы писали про т.н. feature flags. Это логические
параметры, которые включают или отключают целые пласты логики. Флаги удобны тем,
что быстро отключают функциональность без пересборки приложения. Достаточно
поменять конфигурацию и перезагрузить сервис.</p>

<p>Система компонентов может быть построена не линейно, а по условиям. Вспомним,
что технически задача сводится к тому, чтобы передать ключи и компоненты в
функцию <code class="language-plaintext highlighter-rouge">system-map</code>. Если список аргументов предварительно обработать, получим
нужную функциональность.</p>

<p>Предположим, компонент воркера все еще в испытательном режиме. Пусть в
конфигурации будет поле, которое означает “включить воркер”. Если оно ложь,
система должна запуститься без этого компонента.</p>

<p>Выделим в конфигурации группу <code class="language-plaintext highlighter-rouge">:features</code>. Это словарь флагов для “фич”, которые
под вопросом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:features</span><span class="w"> </span><span class="p">{</span><span class="no">:worker</span><span class="w"> </span><span class="n">true</span><span class="p">}</span><span class="w">
 </span><span class="no">:jetty</span><span class="w"> </span><span class="p">{</span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="no">:port</span><span class="w"> </span><span class="mi">8088</span><span class="p">}</span><span class="w">
 </span><span class="c1">;; etc</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Перепишем функцию <code class="language-plaintext highlighter-rouge">make-system</code>. Теперь компоненты, перед тем как попасть в
system-map проходят предварительный просев. Макрос <code class="language-plaintext highlighter-rouge">cond-&gt;</code> “пробрасывает”
вектор базовых компонентов через цепочку условий и форм. Если выражение
<code class="language-plaintext highlighter-rouge">(:worker features)</code> вернет истину, следующая за ней форма добавит в вектор
значения <code class="language-plaintext highlighter-rouge">:worker</code> и <code class="language-plaintext highlighter-rouge">(make-worker {...})</code>. Ниже могут располагаться другие
флаги или проверки.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-system</span><span class="w">
  </span><span class="p">[</span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">features</span><span class="w"> </span><span class="n">jetty</span><span class="w"> </span><span class="n">pool</span><span class="w"> </span><span class="n">worker</span><span class="p">]}</span><span class="w"> </span><span class="n">config</span><span class="w">

        </span><span class="n">components</span><span class="w">
        </span><span class="p">(</span><span class="nf">cond-&gt;</span><span class="w"> </span><span class="p">[</span><span class="no">:server</span><span class="w"> </span><span class="p">(</span><span class="nf">make-server</span><span class="w"> </span><span class="n">jetty</span><span class="p">)</span><span class="w">
                 </span><span class="no">:db</span><span class="w">     </span><span class="p">(</span><span class="nf">make-db</span><span class="w"> </span><span class="n">pool</span><span class="p">)]</span><span class="w">

          </span><span class="p">(</span><span class="no">:worker</span><span class="w"> </span><span class="n">features</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="no">:worker</span><span class="w"> </span><span class="p">(</span><span class="nf">make-worker</span><span class="w"> </span><span class="n">worker</span><span class="p">)))]</span><span class="w">

    </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">component/system-map</span><span class="w"> </span><span class="n">components</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Убедимся, что механизм флагов работает. Поскольку система это запись, функция
keys вернет список ее слотов. В примерах ниже видно, что слот <code class="language-plaintext highlighter-rouge">:worker</code>
появляется в зависимости от конфигурации:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="p">(</span><span class="nf">make-system</span><span class="w"> </span><span class="p">{</span><span class="no">:features</span><span class="w"> </span><span class="p">{</span><span class="no">:worker</span><span class="w"> </span><span class="n">false</span><span class="p">}}))</span><span class="w">
</span><span class="p">(</span><span class="no">:server</span><span class="w"> </span><span class="no">:db</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="p">(</span><span class="nf">make-system</span><span class="w"> </span><span class="p">{</span><span class="no">:features</span><span class="w"> </span><span class="p">{</span><span class="no">:worker</span><span class="w"> </span><span class="n">true</span><span class="p">}}))</span><span class="w">
</span><span class="p">(</span><span class="no">:server</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="no">:worker</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Система флагов облегчает работу с проектом. Некоторые компоненты очень сложны и
требуют специального окружения. Если такой компонент нельзя отключить, это
станет проблемой для ваших коллег. И наоборот, если компонент регулируется
галочкой, вы сэкономите их время и нервы.</p>

<h3 id="спуск-системы">Спуск системы</h3>

<p>Пока сущности приложения это компоненты, они свободно общаются друг с
другом. Если одному компоненту понадобился другой, мы указываем зависимость и
добавляем слот. Проблемы начинаются, когда к системе обращается не компонент, а
другая сущность.</p>

<p>Чаще всего это функция-обработчик HTTP-запроса. Мы подробно говорили о них в
первой главе. По своей природе функция не ложится на концепцию
компонента. Компонент хранит состояние, а функция, напротив, избегает
его. Запуск и остановка функции это бессмысленная операция. Это не хорошо и не
плохо, просто функция и компонент противоположны друг другу.</p>

<p>Рассмотрим случай, когда обработчик HTTP-запроса нуждается в компоненте базы
данных. Возникает вопрос: как спустить отдельные части системы в функции, не
нарушив принципы библиотеки? Обращение к системе как глобальной переменной мы не
рассматриваем, потому что это плохая практика. В промышленных решениях прибегают
к двум способам: пробросу и замыканию.</p>

<p>Проброс означает, что отдельные компоненты передают в объекте запроса. Этот
вариант имеет право на жизнь, потому что запрос это часть сервера, а сервер это
компонент. Поэтому сервер имеет право сообщать дополнительные поля запросу.</p>

<p>Чтобы компонент базы стал доступен серверу, подключим его в
зависимостях. Добавим слот в запись сервера и зависимости в конструктор:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Server</span><span class="w">
    </span><span class="p">[</span><span class="n">options</span><span class="w"> </span><span class="n">server</span><span class="w"> </span><span class="n">db</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-server</span><span class="w">
  </span><span class="p">[</span><span class="n">options</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">map-&gt;Server</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="n">options</span><span class="p">})</span><span class="w">
      </span><span class="p">(</span><span class="nf">component/using</span><span class="w"> </span><span class="p">[</span><span class="no">:db</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>Расширим метод сервера <code class="language-plaintext highlighter-rouge">start</code>. Если раньше мы передавали app напрямую в
<code class="language-plaintext highlighter-rouge">run-jetty</code>, то теперь мы вводим дополнительный шаг. Функция <code class="language-plaintext highlighter-rouge">make-handler</code>
оборачивает app таким образом, что каждый запрос в app дополнен компонентом
базы.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-handler</span><span class="w"> </span><span class="p">[</span><span class="n">app</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">app</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="n">db</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">start</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">handler</span><span class="w"> </span><span class="p">(</span><span class="nf">make-handler</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="n">db</span><span class="p">)</span><span class="w">
        </span><span class="n">server</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="n">options</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:server</span><span class="w"> </span><span class="n">server</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Представим, что главная страница приложения выводит данные из базы. Пример ниже
показывает, как выполнить запрос к базе из обработчика HTTP-запроса. Чтобы не
усложнять пример версткой HTML, мы возвращаем данные в виде текста.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">db/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from requests"</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w">
             </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="n">data</span><span class="p">))}))</span><span class="w">
</span></code></pre></div></div>

<p>Со временем приложению могут понадобиться другие компоненты, например очередь
задач или кэш. Их добавляют аналогично: сперва вводят новый компонент в систему,
указывают зависимости в сервере и пробрасывают в <code class="language-plaintext highlighter-rouge">make-handler</code>.</p>

<p>Когда компонентов все больше, хранить их на верхнем уровне запроса становится
неудобно: возникает риск конфликта ключей. Будет логично записывать их во
вложенный словарь <code class="language-plaintext highlighter-rouge">:system</code> или <code class="language-plaintext highlighter-rouge">:engine</code>. Важно понимать, что <code class="language-plaintext highlighter-rouge">:system</code>
содержит не глобальную систему, а ее минимальное подмножество, необходимое для
веб-части приложения.</p>

<p>Замыкание отличается от проброса способом передачи аргументов. В случае с
замыканием компоненты передают отдельным аргументом. С таким подходом
функция-HTTP обработчик принимает не один, а два аргумента: подмножество системы
и текущий запрос.</p>

<p>Чтобы собрать нужные компоненты в одну структуру, в систему вводят особый
группировочный компонент. Он ничего не делает при запуске и остановке, а только
аккумулирует зависимости. Компонент сервера зависит от этого группировочного
компонента. На базе него мы строим дерево маршрутов (роутер), где каждый
обработчик принимает компонент первым аргументом.</p>

<p>Введем группировочный компонент <code class="language-plaintext highlighter-rouge">:web</code>. Пока что он зависит в только от базы
данных, но в будущем, возможно, потребует и другие компоненты:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Web</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-web</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">map-&gt;Web</span><span class="w"> </span><span class="p">{})</span><span class="w">
      </span><span class="p">(</span><span class="nf">component/using</span><span class="w"> </span><span class="p">[</span><span class="no">:db</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>В функции make-system подключим его в систему:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">component/system-map</span><span class="w">
 </span><span class="no">:web</span><span class="w">    </span><span class="p">(</span><span class="nf">make-web</span><span class="p">)</span><span class="w">
 </span><span class="no">:server</span><span class="w"> </span><span class="p">(</span><span class="nf">make-server</span><span class="w"> </span><span class="n">jetty</span><span class="p">)</span><span class="w">
 </span><span class="no">:db</span><span class="w">     </span><span class="p">(</span><span class="nf">make-db</span><span class="w"> </span><span class="n">pool</span><span class="p">)</span><span class="w">
 </span><span class="no">:worker</span><span class="w"> </span><span class="p">(</span><span class="nf">make-worker</span><span class="w"> </span><span class="n">worker</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Переключим зависимости сервера: теперь он зависит не от базы данных, а от
группировочного <code class="language-plaintext highlighter-rouge">web</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Server</span><span class="w">
    </span><span class="p">[</span><span class="n">options</span><span class="w"> </span><span class="n">server</span><span class="w"> </span><span class="n">web</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-server</span><span class="w">
  </span><span class="p">[</span><span class="n">options</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">map-&gt;Server</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="n">options</span><span class="p">})</span><span class="w">
      </span><span class="p">(</span><span class="nf">component/using</span><span class="w"> </span><span class="p">[</span><span class="no">:web</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>Из первой главы про веб-разработку вспомним, как мы строили роуты. Проще всего
это сделать макросом <code class="language-plaintext highlighter-rouge">defroutes</code> из пакета Compojure. Макрос возвращает функцию,
которая принимает запрос и возвращает ответ.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defroutes</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/"</span><span class="w">      </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-index</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/hello"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-hello</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="n">page-404</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Но теперь дерево маршрутов не статично, а строится по запросу. Функция
make-routes принимает группировочный компонент и возвращает маршруты, замкнутые
на нем. В функции <code class="language-plaintext highlighter-rouge">page-index</code> и другие приходят два аргумента: компонент и
текущий запрос. Компонент будет постоянным, в том состоянии, что он пришел в
make-routes:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-routes</span><span class="w"> </span><span class="p">[</span><span class="n">web</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">routes</span><span class="w">
   </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/"</span><span class="w">      </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-index</span><span class="w"> </span><span class="n">web</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
   </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/hello"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-hello</span><span class="w"> </span><span class="n">web</span><span class="w"> </span><span class="n">request</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Метод <code class="language-plaintext highlighter-rouge">start</code> сервера строит маршруты и передает в <code class="language-plaintext highlighter-rouge">run-jetty</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">start</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">routes</span><span class="w"> </span><span class="p">(</span><span class="nf">make-routes</span><span class="w"> </span><span class="n">web</span><span class="p">)</span><span class="w">
        </span><span class="n">server</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">routes</span><span class="w"> </span><span class="n">options</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:server</span><span class="w"> </span><span class="n">server</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Рассмотрим, как может выглядеть обработчик <code class="language-plaintext highlighter-rouge">page-index</code>, который обращается к
базе данных. Поскольку первый аргумент интересует нас только как хранилище
компонентов, мы распакуем его на уровне сигнатуры.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-index</span><span class="w">
  </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">db/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from requests"</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w">
             </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="n">data</span><span class="p">))}))</span><span class="w">
</span></code></pre></div></div>

<p>Проброс и замыкание в целом похожи: они решают одну и ту же задачу. Разница в
том, как технически передать аргументы в функцию. Вариант с пробросом удобен
тем, что обычно HTTP-функции принимают один аргумент, и нам не придется менять
все сигнатуры.</p>

<p>С другой стороны, передача данных через запрос не всегда очевидна. Когда в
запросе слишком много полей, становится трудно его конструировать при разработке
или в тестах. При записи запроса в лог или на экран возникает риск получить
слишком большой выхлоп. Вариант с замыканием и двумя аргументами в целом
выглядит понятнее. Сигнатура функции прямо говорит о том, какие данные ожидают
на входе.</p>

<p>Выбор конкретного способа зависит от соглашений в команде.</p>

<h3 id="идемпотентность">Идемпотентность</h3>

<p>До сих пор мы писали компоненты так, что их повторный запуск или остановка
приводили к ошибке. Покажем это на примере веб-сервера:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8088</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}</span><span class="w">
           </span><span class="n">make-server</span><span class="w">
           </span><span class="n">component/start</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">component/start</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w">

</span><span class="n">Execution</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">(</span><span class="nf">BindException</span><span class="p">)</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="n">Address</span><span class="w"> </span><span class="n">already</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">use</span><span class="w">
</span></code></pre></div></div>

<p>В теле <code class="language-plaintext highlighter-rouge">start</code> мы не проверяем, что сервер уже работает. При попытке включить
уже запущенный компонент получим исключение о том, что порт уже занят. Это
правильное поведение системы: мы бы не хотели, чтобы запустилось два сервера. Но
для других компонентов исключения может и не быть. Например, если повторно
запустить базу данных, получим новый пул соединений. Старый пул останется где-то
в памяти и будет работать и писать логи. Так происходит утечка ресурсов.</p>

<p>Свойство, когда повторная операция над объектом возвращает тот же результат, что
и в начале, называется идемпотентность. Чтобы избежать утечки ресурсов,
компонент должен быть идемпотентен. Повторный вызов start или stop срабатывают
только один раз для данного состояния.</p>

<p>На уровне кода это сводится к проверке слотов перед тем, как открывать
ресурс. Например, если слот сервера nil, мы порождаем новый сервер и записываем
его в слот. Если не nil, это значит, что сервер уже запущен, и возвращают
<code class="language-plaintext highlighter-rouge">this</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">start</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">server</span><span class="w">
    </span><span class="n">this</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">server</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="n">options</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:server</span><span class="w"> </span><span class="n">server</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Аналогично работает <code class="language-plaintext highlighter-rouge">stop</code>: перед тем, как закрыть ресурс, слот проверяют на
заполненность:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">stop</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">server</span><span class="w">
    </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:server</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Вариант с макросом or выглядит декларативнее. При запуске мы всегда записываем
слот, но значение это либо новый сервер, либо текущий.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">start</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">server</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">server</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="n">options</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:server</span><span class="w"> </span><span class="n">server</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h2 id="integrant">Integrant</h2>

<p>Библиотека <a href="https://github.com/weavejester/integrant">Integrant</a> это следующий виток мысли о том, как строить
системы. Мы поместили ее последней в обзоре по нескольким причинам. Integrant
отталкивается от идей Component, которые мы только что рассмотрели. Библиотека
устроена гибче и в целом более продвинута, чем Component. Читатель должен
подойти к ней с некоторым практическим опытом.</p>

<p>Как и в случае с Component, основная задача библиотеки — избежать глобального
состояния. Вместе с тем Integrant исправляет слабые моменты Component. Кратко
перечислим тезисы, которые предложил автор Integrant.</p>

<p>Сущности Component напоминают классы и ООП. В мире Clojure, где в основном
работают с данными и функциями, это выглядит усложнением. Пусть компоненты будут
функциями. Функция проще объекта, потому что над ней определена только одна
операция — вызов.</p>

<p>Component выделяет только два состояния компонента — запущен и
остановлен. Integrant предлагает дополнительные стадии, например, приостановка и
возобновление, валидация спекой, подготовка параметров. По умолчанию эти стадии
пустые, но любой компонент может подписаться на них. С этим подходом система
становится гибче и удобней в поддержке.</p>

<p>Integrant делает ставку на декларативность системы. Технически возможно описать
систему в edn-файле и считать одной функцией. Это выгодно отличает Integrant от
Component с ручным вызовом конструкторов.</p>

<p>Integrant лоялен к зависимостям. Если в Component зависимость требует два
действия — добавить слот и метаданные, — то в Integrant это один шаг. В
Component зависимость может быть только другим компонентом. Иногда объект
оборачивают в компонент только чтобы выполнить это требование. В Integrant
зависимостью может быть что угодно: словарь, объект, функция.</p>

<p>В целом Integrant выглядит легче и удобнее Component. Он решает задачи простым
способом, как это принято в мире Clojure.</p>

<h3 id="базовое-устройство">Базовое устройство</h3>

<p>Работу с Integrant начинают с описания будущей системы. Это структура данных,
каркас, за который цепляется дальнейшая логика. На уровне кода система это
словарь. Вот так мы бы описали систему из веб-сервера и пула для базы данных:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">config</span><span class="w">
  </span><span class="p">{</span><span class="no">::server</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}</span><span class="w">
   </span><span class="no">::db</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w">      </span><span class="s">"book"</span><span class="w">
         </span><span class="no">:password</span><span class="w">      </span><span class="s">"book"</span><span class="w">
         </span><span class="no">:database-name</span><span class="w"> </span><span class="s">"book"</span><span class="w">
         </span><span class="no">:server-name</span><span class="w">   </span><span class="s">"127.0.0.1"</span><span class="w">
         </span><span class="no">:port-number</span><span class="w">   </span><span class="mi">5432</span><span class="p">}})</span><span class="w">
</span></code></pre></div></div>

<p>Ключ словаря это машинное имя компонента, а значение — параметры запуска. Уже на
этом этапе видно одно из преимуществ Integrant — его декларативность. Эту
структуру можно скопировать или считать из файла.</p>

<p>Система и компоненты связаны через мультиметоды. Чтобы добавить реакцию на
определенное событие, мы расширяем нужный мультиметод по ключу
компонента. Например, при старте система вызывает метод <code class="language-plaintext highlighter-rouge">init-key</code> для каждого
ключа. Чтобы объяснить системе, как запускать сервер, метод предварительно
расширяют ключом <code class="language-plaintext highlighter-rouge">::server</code>.</p>

<p>Integrant ожидает, что ключ реализует минимум два метода: запуск и
остановка. Это ключевые операции для работы с системой, поэтому для них не
предусмотрены действия по умолчанию. Другие события опциональны и остаются на
усмотрение разработчика.</p>

<h3 id="первые-компоненты">Первые компоненты</h3>

<p>Как и в прошлых разделах, мы начнем практику с описания компонентов сервера и
базы. Они просты и не имеют зависимостей. Подготовьте модуль
<code class="language-plaintext highlighter-rouge">src/book/integrant.clj</code> со следующей шапкой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.integrant</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">integrant.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">ig</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Для краткости мы опустим импорты Jetty, HikariCP и других библиотек. Они
аналогичны тем, что мы писали в упражнениях с Mount и Component.</p>

<p>Начнем с сервера. Метод init-key принимает два параметра: ключ и словарь его
опций. Для конфигурации выше это значения <code class="language-plaintext highlighter-rouge">::server</code> и <code class="language-plaintext highlighter-rouge">{:port 8080 :join?
false}</code>. Метод должен вернуть объект-состояние компонента. Достаточно передать в
функцию <code class="language-plaintext highlighter-rouge">run-jetty</code> обработчик запроса, объявленный где-то выше, и словарь
опций.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/init-key</span><span class="w"> </span><span class="no">::server</span><span class="w">
  </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">options</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="n">options</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Поскольку ключ известен из определения метода, первый параметр затеняют символом
подчеркивания. По аналогии опишем базу данных. Состояние компонента это
JDBC-спека, которую передают в функции из пакета clojure.java.jdbc.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/init-key</span><span class="w"> </span><span class="no">::db</span><span class="w">
  </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">options</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:datasource</span><span class="w"> </span><span class="p">(</span><span class="nf">cp/make-datasource</span><span class="w"> </span><span class="n">options</span><span class="p">)})</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">init</code> пробегает по каркасу системы и вызывает для каждого ключа
мультиметод <code class="language-plaintext highlighter-rouge">init-key</code>. В результате получим словарь-систему, где ключ это имя
компонента, а значение — его состояние:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">_sys</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/init</span><span class="w"> </span><span class="n">config</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">_sys</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="no">:book.integrant/db</span><span class="w"> </span><span class="no">:book.integrant/server</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>В терминах Integrant остановка системы называется <code class="language-plaintext highlighter-rouge">halt</code>. Метод <code class="language-plaintext highlighter-rouge">halt-key!</code>
определяет, как выключить определенный ключ. Он принимает два параметра: ключ и
состояние, которые мы вернули из метода <code class="language-plaintext highlighter-rouge">init-key</code>. Определим эти события для
сервера и базы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/halt-key!</span><span class="w"> </span><span class="no">::server</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">server</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/halt-key!</span><span class="w"> </span><span class="no">::db</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">db-spec</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">db-spec</span><span class="w"> </span><span class="no">:datasource</span><span class="w"> </span><span class="n">cp/close-datasource</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Функция halt! останавливает систему целиком:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ig/halt!</span><span class="w"> </span><span class="n">_sys</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h3 id="зависимости-2">Зависимости</h3>

<p>Чтобы указать ключу зависимости, в его опции добавляют специальный ссылочный
параметр. При запуске Integrant просматривает каркас системы на наличие таких
параметров и строит по ним граф зависимостей. Ссылочный параметр задают функцией
<code class="language-plaintext highlighter-rouge">ig/ref</code>. Она принимает ключ, на который следует сослаться.</p>

<p>Рассмотрим зависимость на примере воркера. Добавьте в конфигурацию новый ключ:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">::worker</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:sleep</span><span class="w"> </span><span class="mi">1000</span><span class="p">}</span><span class="w">
           </span><span class="no">:db</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/ref</span><span class="w"> </span><span class="no">::db</span><span class="p">)}}</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы <code class="language-plaintext highlighter-rouge">:db</code> не слиплось с общими настройками воркера, мы вынесли их в отдельное
поле <code class="language-plaintext highlighter-rouge">:options</code>.</p>

<p>Теперь когда метод <code class="language-plaintext highlighter-rouge">init-key</code> дойдет до ключа <code class="language-plaintext highlighter-rouge">::worker</code>, в поле <code class="language-plaintext highlighter-rouge">:db</code> будет
значение, которое <code class="language-plaintext highlighter-rouge">init-key</code> вернул для этого ключа. В нашем случае это
JDBC-спека с пулом соединений.</p>

<p>Код запуска и остановки воркера аналогичен тому, что мы писали для Mount и
Component. Для экономии места приведем только реализации <code class="language-plaintext highlighter-rouge">init-key</code> и
<code class="language-plaintext highlighter-rouge">halt-key!</code>. Если вдруг вы забыли, как устроен воркер, обратитесь к прошлым
разделам главы.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/init-key</span><span class="w"> </span><span class="no">::worker</span><span class="w">
  </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">options</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">flag</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
        </span><span class="n">task</span><span class="w"> </span><span class="p">(</span><span class="nf">make-task</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">options</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:flag</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="no">:task</span><span class="w"> </span><span class="n">task</span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/halt-key!</span><span class="w"> </span><span class="no">::worker</span><span class="w">
  </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">flag</span><span class="w"> </span><span class="n">task</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">while</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">realized?</span><span class="w"> </span><span class="n">task</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">300</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h3 id="параллели-с-component">Параллели с Component</h3>

<p>Многие из приемов, которые мы рассмотрели для Component, работают и в Integrant
Вспомним некоторые их них.</p>

<p><strong>Глобальное хранилище.</strong> Чтобы управлять системой, нужно где-то ее
хранить. Проще всего добавить глобальную переменную и вспомогательные функции
для запуска и остановки.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defonce</span><span class="w"> </span><span class="o">^</span><span class="no">:private</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">alter-system</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">alter-var-root</span><span class="w"> </span><span class="o">#</span><span class="ss">'system</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">system-start</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-system</span><span class="w"> </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/init</span><span class="w"> </span><span class="n">config</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">system-stop</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-system</span><span class="w"> </span><span class="n">ig/halt!</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Как и в Component, система должна быть приватной. Недопустимо, чтобы компоненты
свободно обращались к ней.</p>

<p><strong>Ожидание и сигналы.</strong> Перед тем как закончить работу, приложение ожидает, пока
все компоненты корректно остановятся. Пример с макросом <code class="language-plaintext highlighter-rouge">with-handler</code> и
перехватом сигналов работает аналогично для Integrant:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-handler</span><span class="w"> </span><span class="no">:term</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"caught SIGTERM, quitting"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">system-stop</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"all components shut down"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">exit</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p><strong>Спуск системы и маршруты.</strong> В Integrant легче решить проблему доступа к
системе из HTTP-обработчика. Достаточно выразить обработчик в виде компонента с
нужными зависимостями. Представим, что главная страница веб-сервера выводит
число записей в базе. Добавим в систему новый ключ, который зависит от базы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">::handler</span><span class="w"> </span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/ref</span><span class="w"> </span><span class="no">::db</span><span class="p">)}}</span><span class="w">
</span></code></pre></div></div>

<p>При запуске ключа вернем функцию-обработчик, замкнутую на <code class="language-plaintext highlighter-rouge">db</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/init-key</span><span class="w"> </span><span class="no">::handler</span><span class="w">
  </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">query</span><span class="w"> </span><span class="s">"select count(*) as total from requests"</span><span class="w">
          </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">query</span><span class="p">)</span><span class="w">
          </span><span class="n">total</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="no">:total</span><span class="p">)]</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"You've got %s requests."</span><span class="w"> </span><span class="n">total</span><span class="p">)})))</span><span class="w">
</span></code></pre></div></div>

<p>Доработаем сервер так, чтобы он зависел от обработчика:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">::server</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}</span><span class="w">
           </span><span class="no">:handler</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/ref</span><span class="w"> </span><span class="no">::handler</span><span class="p">)}}</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/init-key</span><span class="w"> </span><span class="no">::server</span><span class="w">
  </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">handler</span><span class="w"> </span><span class="n">options</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="n">options</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь браузер покажет фразу “You’ve got N requests.”, где N — число записей в
базе. Как и в примере с Component, <code class="language-plaintext highlighter-rouge">::handler</code> может вернуть дерево маршрутов,
построенное с помощью Compojure.</p>

<p><strong>Условное построение.</strong> Конфигурация системы это словарь, поэтому в него можно
добавить или удалить ключи по каким-либо условиям, как мы делали это в
Component. Например, специальная функция определяет, будет ли запущен воркер или
нет. Если будет, мы добавляем в систему ключ и его настройки.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">cond-&gt;</span><span class="w"> </span><span class="n">sys-config</span><span class="w">
  </span><span class="p">(</span><span class="nf">is-worker-supported?</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="no">::worker</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:sleep</span><span class="w"> </span><span class="mi">1000</span><span class="p">}</span><span class="w">
                   </span><span class="no">:db</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/ref</span><span class="w"> </span><span class="no">::db</span><span class="p">)}))</span><span class="w">
</span></code></pre></div></div>

<p>Есть и другой способ запустить подмножество системы, аналогичный Mount. Функция
<code class="language-plaintext highlighter-rouge">init</code> принимает необязательный список ключей. Этот список, а еще лучше
множество, можно подготовить заранее на базе определенной логики.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">components</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="nb">keys</span><span class="w"> </span><span class="nb">set</span><span class="p">)</span><span class="w">
      </span><span class="n">components</span><span class="w"> </span><span class="p">(</span><span class="nf">cond-&gt;</span><span class="w"> </span><span class="n">components</span><span class="w">
                   </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">is-worker-supported?</span><span class="p">))</span><span class="w">
                   </span><span class="p">(</span><span class="nb">disj</span><span class="w"> </span><span class="no">::worker</span><span class="p">))]</span><span class="w">
  </span><span class="p">(</span><span class="nf">ig/init</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="n">components</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h3 id="проблема-потери-ключей">Проблема потери ключей</h3>

<p>Обратите внимание, что мы указываем полные (квалифицированные) ключи для
компонентов, например <code class="language-plaintext highlighter-rouge">::server</code> или <code class="language-plaintext highlighter-rouge">::db</code>. Двойное двоеточие означает текущее
пространство имен, в котором объявлен ключ. Запись <code class="language-plaintext highlighter-rouge">::db</code> это краткий вариант
<code class="language-plaintext highlighter-rouge">:book.integrant/db</code>.</p>

<p>Когда ключ полный, то есть с пространством, легко определить, в каком модуле он
объявлен. В промышленных системах бывает несколько десятков
компонентов. Представьте, что возникла проблема с ключом <code class="language-plaintext highlighter-rouge">:queue</code>. Как понять, в
каком месте мы расширили мультиметод этим ключом? Наоборот, ключ
<code class="language-plaintext highlighter-rouge">:my-project.utils.queue/queue</code> несет эту информацию. Всегда используйте полные
ключи.</p>

<p>Возможна ситуация, когда вы забыли импортировать модуль, в котором расширяете
мультиметод. Иногда трудно понять, почему возникла ошибка: вы точно помните, что
писали этот код. Чтобы избежать ошибки, добавьте эти модули в заголовок <code class="language-plaintext highlighter-rouge">ns</code>
главного модуля, который загружается всегда. Пусть это будет модуль, в котором
вы собираете систему.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">project.system</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="n">project.db</span><span class="w">
            </span><span class="n">project.server</span><span class="w">
            </span><span class="n">project.worker</span><span class="w">
            </span><span class="n">project.utils.queue</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Возможно, утилиты для проверки синтаксиса (линтеры) будут выдавать
предупреждение для этих модулей. С их точки зрения утилиты вы добавили модуль,
но не используете его, потому что в коде нет ни одного выражения
<code class="language-plaintext highlighter-rouge">project.db/&lt;something&gt;</code>. Чтобы подавить эти предупреждения, добавьте модули в
конфигурацию линтера в секцию “known namespaces” или аналогичную.</p>

<p>Integrant предлагает функцию <code class="language-plaintext highlighter-rouge">load-namespaces</code> для автоматической загрузки
модулей. На вход подают конфигурацию системы. Для каждого ключа функция
вычисляет его пространство и загружает его. Вот как выглядит промышленная
система с ключами из разных модулей:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">config</span><span class="w">
  </span><span class="p">{</span><span class="no">:project.server/server</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}</span><span class="w">
                           </span><span class="no">:handler</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/ref</span><span class="w"> </span><span class="no">:project.handlers/index</span><span class="p">)}</span><span class="w">
   </span><span class="no">:project.db/db</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">}</span><span class="w">
   </span><span class="no">:project.worker/worker</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:sleep</span><span class="w"> </span><span class="mi">1000</span><span class="p">}</span><span class="w">
                           </span><span class="no">:db</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/ref</span><span class="w"> </span><span class="no">:project.db/db</span><span class="p">)}</span><span class="w">
   </span><span class="no">:project.handlers/index</span><span class="w"> </span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/ref</span><span class="w"> </span><span class="no">:project.db/db</span><span class="p">)}})</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы загрузить все модули, которые участвуют в этой системе, добавьте
выражение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ig/load-namespaces</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что явная загрузка модулей все же предпочтительнее. Мы советуем
начинающим воздержаться от автоматических импортов. Размещайте их явно в блоке
<code class="language-plaintext highlighter-rouge">ns</code>: этот вариант хоть и многословен, но зато очевиден. Прибегайте к помощи
<code class="language-plaintext highlighter-rouge">load-namespaces</code> только если точно знаете, как работает система пространств в
Clojure.</p>

<h3 id="система-в-файле">Система в файле</h3>

<p>Выше мы упоминали, что Integrant делает ставку на декларативность. В идеале
конфигурация системы это статичная структура данных, словарь. Для экономии места
систему можно вынести в EDN-файл и прочитать функцией из модуля <code class="language-plaintext highlighter-rouge">clojure.edn</code>.</p>

<p>Читатель заметит, что мы указываем зависимости через функцию <code class="language-plaintext highlighter-rouge">ig/ref</code>, и не
совсем ясно, как поместить это выражение в файл. Вспомним систему тегов: при
чтении EDN-данных мы указываем связь между тегом и функцией, которая обработает
следующее за тегом значение. Для зависимостей Integrant предлагает тег
<code class="language-plaintext highlighter-rouge">#ig/ref</code>. В примере ниже мы выразили зависимость тегом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:project.worker/worker</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:sleep</span><span class="w"> </span><span class="mi">1000</span><span class="p">}</span><span class="w">
                         </span><span class="no">:db</span><span class="w"> </span><span class="o">#</span><span class="n">ig/ref</span><span class="w"> </span><span class="no">:project.db/db</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Integrant предлагает функцию <code class="language-plaintext highlighter-rouge">read-string</code> что чтения EDN-данных. Это обертка
вокруг <code class="language-plaintext highlighter-rouge">clojure.edn/read-string</code>, заряженная дополнительными тегами. Чтобы
прочитать систему из файла, выполните:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">config</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"config.edn"</span><span class="w"> </span><span class="nb">slurp</span><span class="w"> </span><span class="n">ig/read-string</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Из главы про конфигурацию мы помним, что нежелательно хранить в файле пароли и
ключи доступа. Этот принцип нарушает компонент <code class="language-plaintext highlighter-rouge">:project.db/db</code>: пароль к базе
данных записан открыто. Сделаем так, чтобы парсер читал пароль из переменной
среды.</p>

<p>Вынесем конфигурацию в файл <code class="language-plaintext highlighter-rouge">integrant.test.edn</code> (ниже ее фрагмент):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:project.db/db</span><span class="w"> </span><span class="p">{</span><span class="no">:password</span><span class="w"> </span><span class="o">#</span><span class="n">env</span><span class="w"> </span><span class="n">DB_PASSWORD</span><span class="p">}</span><span class="w">
 </span><span class="no">:project.worker/worker</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:sleep</span><span class="w"> </span><span class="mi">1000</span><span class="p">}</span><span class="w">
                         </span><span class="no">:db</span><span class="w"> </span><span class="o">#</span><span class="n">ig/ref</span><span class="w"> </span><span class="no">:project.db/db</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Обернем чтение конфигурации в функцию. Первым аргументом в <code class="language-plaintext highlighter-rouge">ig/read-string</code>
укажем словарь с тегами. Функцию <code class="language-plaintext highlighter-rouge">tag-env</code> для тега <code class="language-plaintext highlighter-rouge">#env</code> мы перенесли из
прошлой главы. На нижнем уровне Integrant дополнит наш словарь тегов
собственными, поэтому оба <code class="language-plaintext highlighter-rouge">#ig/ref</code> и <code class="language-plaintext highlighter-rouge">#env</code> будут работать.</p>

<p>Теперь система хранится в файле, а теги описывают ее точнее и гибче.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">load-config</span><span class="w">
  </span><span class="p">[</span><span class="n">filename</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">ig/read-string</span><span class="w"> </span><span class="p">{</span><span class="no">:readers</span><span class="w"> </span><span class="p">{</span><span class="ss">'env</span><span class="w"> </span><span class="n">tag-env</span><span class="p">}}</span><span class="w">
                  </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="n">filename</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">load-config</span><span class="w"> </span><span class="s">"integrant.test.edn"</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:project.db/db</span><span class="w"> </span><span class="p">{</span><span class="no">:password</span><span class="w"> </span><span class="s">"c8497b517da25"</span><span class="p">}</span><span class="w">
 </span><span class="no">:project.worker/worker</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:sleep</span><span class="w"> </span><span class="mi">1000</span><span class="p">}</span><span class="w">
                         </span><span class="no">:db</span><span class="w"> </span><span class="o">#</span><span class="n">integrant.core.Ref</span><span class="p">{</span><span class="no">:key</span><span class="w"> </span><span class="no">:project.db/db</span><span class="p">}}}</span><span class="w">
</span></code></pre></div></div>

<h3 id="наследование-ключей">Наследование ключей</h3>

<p>В Clojure ключи могут выстраиваться в иерархию. Функция <code class="language-plaintext highlighter-rouge">derive</code> принимает два
ключа и задает превосходство первого над вторым.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">derive</span><span class="w"> </span><span class="no">::postgresql</span><span class="w"> </span><span class="no">::database</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Когда мультиметод разрешает действие по ключу, он учитывает его
иерархию. Например, если мультиметод реализован для <code class="language-plaintext highlighter-rouge">::database</code>, вызов с
<code class="language-plaintext highlighter-rouge">::postgresql</code> не приведет к ошибке: сработает реализация <code class="language-plaintext highlighter-rouge">::database</code>.</p>

<p>Поскольку Integrant устроен на мультиметодах, из наследования ключей можно
извлечь пользу. Например, нагруженные проекты работают с двумя базами данных:
мастер для записи и реплика для чтения. Пусть это будут компоненты <code class="language-plaintext highlighter-rouge">::db-master</code>
и <code class="language-plaintext highlighter-rouge">::db-replica</code>. Технически они одинаковы и отличаются только входными
параметрами.</p>

<p>Если бы мы не знали про наследование, то расширили бы <code class="language-plaintext highlighter-rouge">ig/init-key</code> и
<code class="language-plaintext highlighter-rouge">ig/halt-key!</code> каждым ключом. Пришлось бы копировать код каждой реализации, что
не гибко и считается плохой практикой. Вспомним, что мы уже описали поведение
базы компонентом <code class="language-plaintext highlighter-rouge">::db</code>. Унаследуем от него две других базы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">derive</span><span class="w"> </span><span class="no">::db-master</span><span class="w"> </span><span class="no">::db</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">derive</span><span class="w"> </span><span class="no">::db-replica</span><span class="w"> </span><span class="no">::db</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Изменим конфигурацию так, что в ней две базы данных: мастер и реплика. Для
реплики мы выставили флаг <code class="language-plaintext highlighter-rouge">:read-only</code> true, чтобы обезопасить себя от записи не
в тот источник. Обратите внимание от какой базы зависит каждый
компонент. Поскольку воркер пишет данные в базу, он зависит от
<code class="language-plaintext highlighter-rouge">::db-master</code>. Компонент <code class="language-plaintext highlighter-rouge">::hander</code> только читает данные, поэтому зависит от
<code class="language-plaintext highlighter-rouge">::db-replica</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">config</span><span class="w">
  </span><span class="p">{</span><span class="no">::server</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}</span><span class="w">
             </span><span class="no">:handler</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/ref</span><span class="w"> </span><span class="no">::handler</span><span class="p">)}</span><span class="w">
   </span><span class="no">::db-master</span><span class="w"> </span><span class="p">{</span><span class="c1">;; other fields</span><span class="w">
                </span><span class="no">:read-only</span><span class="w"> </span><span class="n">false</span><span class="p">}</span><span class="w">
   </span><span class="no">::db-replica</span><span class="w"> </span><span class="p">{</span><span class="c1">;; other fields</span><span class="w">
                 </span><span class="no">:read-only</span><span class="w"> </span><span class="n">true</span><span class="p">}</span><span class="w">
   </span><span class="no">::worker</span><span class="w"> </span><span class="p">{</span><span class="no">:options</span><span class="w"> </span><span class="p">{</span><span class="no">:sleep</span><span class="w"> </span><span class="mi">1000</span><span class="p">}</span><span class="w">
             </span><span class="no">:db</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/ref</span><span class="w"> </span><span class="no">::db-master</span><span class="p">)}</span><span class="w">
   </span><span class="no">::handler</span><span class="w"> </span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/ref</span><span class="w"> </span><span class="no">::db-replica</span><span class="p">)}})</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">ig/refset</code> и одноименный тег вернут множество зависимостей с учетом
иерархии. Предположим, что один из компонентов ожидает все базы данных для
какой-то ручной синхронизации. Чтобы не ссылаться на каждую базу вручную, укажем
ее корневой ключ.</p>

<p>Добавим в конфигурацию компонент <code class="language-plaintext highlighter-rouge">::sync</code> с зависимостью через <code class="language-plaintext highlighter-rouge">refset</code>. Объявим
пустой <code class="language-plaintext highlighter-rouge">init-key</code> для этого компонента: он ничего не делает, а только возвращает
параметры. При запуске компонент получит множество баз в поле <code class="language-plaintext highlighter-rouge">:dbs</code></p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">::sync</span><span class="w"> </span><span class="p">{</span><span class="no">:dbs</span><span class="w"> </span><span class="p">(</span><span class="nf">ig/refset</span><span class="w"> </span><span class="no">::db</span><span class="p">)}}</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/init-key</span><span class="w"> </span><span class="no">::sync</span><span class="w">
  </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">opt</span><span class="p">]</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">system-start</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="no">::sync</span><span class="w"> </span><span class="no">:dbs</span><span class="w"> </span><span class="nb">count</span><span class="p">)</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span></code></pre></div></div>

<h3 id="другие-стадии-компонента">Другие стадии компонента</h3>

<p>Кроме запуска и остановки, Integrant выделяет дополнительные стадии, которые
проходит компонент. В отличии от запуска, они не обязательны к
реализации. Дополнительные стадии устроены как мультиметоды, которым задано
действие по умолчанию (вернуть nil или исходный объект). Чтобы подписать
компонент на событие, расширите мультиметод его ключом. Ниже мы рассмотрим
несколько полезных стадий.</p>

<h3 id="подготовка">Подготовка</h3>

<p>Метод <code class="language-plaintext highlighter-rouge">ig/prep-key</code> служит для предварительной подготовки параметров. Чаще всего
это объединение параметров по умолчанию с теми, что мы получили из
конфигурации. Например, мы выяснили, что для нашей инфраструктуры важны именно
такие метрики пула БД. Чтобы не указывать в конфигурации все поля, вынесем их
фиксированную часть в словарь опций по умолчанию.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-defaults</span><span class="w">
  </span><span class="p">{</span><span class="no">:auto-commit</span><span class="w">        </span><span class="n">false</span><span class="w">
   </span><span class="no">:read-only</span><span class="w">          </span><span class="n">false</span><span class="w">
   </span><span class="no">:connection-timeout</span><span class="w"> </span><span class="mi">30000</span><span class="w">
   </span><span class="no">:validation-timeout</span><span class="w"> </span><span class="mi">5000</span><span class="w">
   </span><span class="no">:idle-timeout</span><span class="w">       </span><span class="mi">600000</span><span class="w">
   </span><span class="no">:max-lifetime</span><span class="w">       </span><span class="mi">1800000</span><span class="w">
   </span><span class="no">:minimum-idle</span><span class="w">       </span><span class="mi">10</span><span class="w">
   </span><span class="no">:maximum-pool-size</span><span class="w">  </span><span class="mi">10</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/prep-key</span><span class="w"> </span><span class="no">::db</span><span class="w">
  </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">options</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">merge</span><span class="w"> </span><span class="n">db-defaults</span><span class="w"> </span><span class="n">options</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Метод <code class="language-plaintext highlighter-rouge">prep-key</code> объединяет этот словарь с параметрами. Теперь в конфигурации
достаточно указать только параметры подключения и, если требуется,
переопределения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">::db</span><span class="w"> </span><span class="p">{</span><span class="no">:auto-commit</span><span class="w">   </span><span class="n">true</span><span class="w"> </span><span class="c1">;; override the default</span><span class="w">
       </span><span class="no">:adapter</span><span class="w">       </span><span class="s">"postgresql"</span><span class="w">
       </span><span class="no">:username</span><span class="w">      </span><span class="s">"book"</span><span class="w">
       </span><span class="no">:password</span><span class="w">      </span><span class="s">"book"</span><span class="w">
       </span><span class="no">:database-name</span><span class="w"> </span><span class="s">"book"</span><span class="w">
       </span><span class="no">:server-name</span><span class="w">   </span><span class="s">"127.0.0.1"</span><span class="w">
       </span><span class="no">:port-number</span><span class="w">   </span><span class="mi">5432</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">ig/prep</code> принимает конфигурацию и запускает метод для каждого
ключа. Чтобы не забыть этот шаг, сделайте его частью функции <code class="language-plaintext highlighter-rouge">load-config</code>,
которую мы описали выше.</p>

<h3 id="спека">Спека</h3>

<p>Метод <code class="language-plaintext highlighter-rouge">ig/pre-init-spec</code> связывает параметры компонента со спекой. Если метод
вернул спеку для определенного ключа, параметры проходят проверку. Например, для
базы данных обязательны параметры подключения. Проверим их перед запуском пула:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.spec.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:db/username</span><span class="w"> </span><span class="nb">string?</span><span class="p">)</span><span class="w">
</span><span class="c1">;; other db fields</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">ig/pre-init-spec</span><span class="w"> </span><span class="no">::db</span><span class="w">
  </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:db/username</span><span class="w">
                   </span><span class="no">:db/password</span><span class="w">
                   </span><span class="no">:db/database-name</span><span class="w">
                   </span><span class="no">:db/server-name</span><span class="w">
                   </span><span class="no">:db/port-number</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Если запустить систему с неверными параметрами, получим ошибку spec:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Execution error (ExceptionInfo) at integrant.core/spec-exception (core.cljc:385).
Spec failed on key :book.integrant/db when building system
"book" - failed: string? in: [:username] at: [:username] spec: :db/username
</code></pre></div></div>

<h3 id="приостановка">Приостановка</h3>

<p>Кроме <code class="language-plaintext highlighter-rouge">init</code> и <code class="language-plaintext highlighter-rouge">halt</code>, Integrant выделяет третье состояние системы —
<code class="language-plaintext highlighter-rouge">suspended</code>. Приостановленный компонент не теряет состояние, а только ставит на
паузу внутренние процессы. Например, если это потребитель сообщений из очереди
<code class="language-plaintext highlighter-rouge">(KafkaConsumer)</code>, он не закрывает соединение с очередью, а временно перестает
читать сообщения (вызывать метод <code class="language-plaintext highlighter-rouge">poll</code>). Обратная операция называется
resume. При возобновлении компонент, не порождая новых тредов или соединений,
продолжает работу.</p>

<p>По умолчанию приостановка и возобновление работают как <code class="language-plaintext highlighter-rouge">halt</code> и <code class="language-plaintext highlighter-rouge">init</code>. Это
значит, что если компонент не реализует эти события, он останавливается и
запускается заново. Чтобы задать верную реакцию на suspend и resume, реализуйте
методы <code class="language-plaintext highlighter-rouge">ig/suspend-key!</code> и <code class="language-plaintext highlighter-rouge">ig/resume-key</code>. Это потребует углубленного внимания
и чтения документации. Мы оставим этот раздел читателю на самостоятельное
изучение.</p>

<h2 id="заключение">Заключение</h2>

<p>Подобно тому, как машина складывается из деталей, программа состоит из
компонентов. Система управляет компонентами. Это соглашение о том, как они
устроены и связаны друг с другом.</p>

<p>Любой проект нуждается в системе, и чем дальше он развивается, тем сильнее
потребность. Если в проекте нет соглашения о том, как проектировать составные
части, он начинает буксовать. Поддержка проекта становится слишком затратной.</p>

<p>Clojure предлагает разные подходы для систем. Наиболее популярные из них —
Mount, Component и Integrant — мы рассмотрели в этой главе. Библиотеки
исповедуют разный подход, и скорее всего разработчик найдет то, что ему по душе.</p>

<p>Проект Mount отталкивается от глобальных переменных. Если проект написан в таком
стиле:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">server</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>, то портировать его на Mount будет легко. Переменная server станет сущностью,
которая меняет значение по команде. Mount подойдет тем, кто только начал
знакомство с Clojure.</p>

<p>Библиотека Component это шаг в сторону настоящих компонентов. Такие компоненты
это отдельные сущности, которые изолируют состояние. Компоненты и протоколы
напоминают классы и объекты и из современных языков программирования. По этой
причине некоторые разработчики недолюбливают Component и обвиняют его в излишней
раздутости, “энтерпрайзности”.</p>

<p>Действительно, иногда решение на компонентах занимает больше места, чем на
атомах и функциях. С другой стороны, именно Component дает понимание того, как
строить устойчивые системы. Читатель заметит, что большую часть вопросов мы
обсудили в разделе именно про Component.</p>

<p>Проект Integrant ставит цель исправить некоторые недостатки Component. Он лишен
ООП-тяжести и целом более “кложурный”. Integrant опирается на идиомы и техники,
принятые в Clojure, и тем самым подкупает опытных разработчиков.</p>

<p>Эта глава не ставит цель выяснить, какая из библиотек лучше. Не бросайтесь
переписывать проект с условного Mount на Component. Архитектура библиотек
слишком отличается друг от друга. Это изнуряющий труд, и вы не поймете, каких
преимуществ достигли, пока не ощутите в них потребность.</p>

<p>Вопрос о том, какая система лучше ниже рангом другого, более важного вопроса:
зачем система нужна проекту. Когда вы понимаете важность системного подхода,
технические решения найдутся сами.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментарии</center>

<div id="comments">
  
    <div id="comment-4604821603" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            anonymous,
            5th Sep 2019,
            <a href="#comment-4604821603">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Очень круто, спасибо!</p>
</div>
    </div>
  
    <div id="comment-5011318036" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Roman Dronov,
            30th Jul 2020,
            <a href="#comment-5011318036">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Привет. Очень интересно. Заметил на мой взгляд неточность</p>
<p></p>
<blockquote>Clojure предлагает разные подходы для систем. Наиболее популярные из них — Mount, Compojure и Integrant — мы рассмотрели в этой главе.</blockquote>
<p></p>
<p>Тут наверно Component имелся в виду а не Compojure?<br />С уважением и ожиданием книги, Роман</p>
</div>
    </div>
  
    <div id="comment-5011323005" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            30th Jul 2020,
            <a href="#comment-5011323005">link</a>
            , <a href="#comment-5011318036">parent</a>
          </em>
        </small>
      </p>
      <div><p>Точно, должен быть Component, спасибо.</p>
</div>
    </div>
  
</div>








<form class="#comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input requred name="path" type="hidden" value="/clj-book-systems/">
    <input requred name="captcha" type="hidden" value="5 &#43; 4">

    <div class="block">
        <span class="comment-form-label"><small>5 &#43; 4 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
