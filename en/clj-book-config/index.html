<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Configuration in Clojure</title>
  <meta name="description" content="Clojure in Production  Chapter 1. Web development  Chapter 2. Clojure.spec  Chapter 3. Exceptions  Chapter 4. Mutability  Chapter 5. Configuration  Chapter 6...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/en/clj-book-config/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Configuration in Clojure</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2021-05-06T00:00:00+00:00">
        May 6, 2021
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/configuration/" rel="tag">configuration</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p><strong>Clojure in Production</strong></p>

<ul>
  <li>Chapter 1. Web development</li>
  <li>Chapter 2. Clojure.spec</li>
  <li><a href="/en/clj-book-exceptions/">Chapter 3. Exceptions</a></li>
  <li>Chapter 4. Mutability</li>
  <li><a href="/en/clj-book-config/">Chapter 5. Configuration</a></li>
  <li><a href="/en/clj-book-systems/">Chapter 6. Systems in Clojure</a></li>
  <li>Chapter 7. Tests</li>
</ul>

<h2>

    In This Chapter

</h2>

<ul id="toc-item-clj-book-exceptions-en">
  <li><a href="#configuration" id="toc-item-clj-book-exceptions-en-configuration">Configuration</a>    <ul>
      <li><a href="#formulation-of-the-problem" id="toc-item-clj-book-exceptions-en-formulation-of-the-problem">Formulation of the Problem</a></li>
      <li><a href="#semantics" id="toc-item-clj-book-exceptions-en-semantics">Semantics</a></li>
      <li><a href="#configuration-cycle" id="toc-item-clj-book-exceptions-en-configuration-cycle">Configuration Cycle</a></li>
      <li><a href="#config-errors" id="toc-item-clj-book-exceptions-en-config-errors">Config Errors</a></li>
      <li><a href="#configuration-loader" id="toc-item-clj-book-exceptions-en-configuration-loader">Configuration Loader</a>        <ul>
          <li><a href="#improvements" id="toc-item-clj-book-exceptions-en-improvements">Improvements</a></li>
        </ul>
      </li>
      <li><a href="#more-on-environment-variables" id="toc-item-clj-book-exceptions-en-more-on-environment-variables">More on Environment Variables</a>        <ul>
          <li><a href="#local-and-global-variables" id="toc-item-clj-book-exceptions-en-local-and-global-variables">Local and Global Variables</a></li>
        </ul>
      </li>
      <li><a href="#config-in-the-environment" id="toc-item-clj-book-exceptions-en-config-in-the-environment">Config in the Environment</a></li>
      <li><a href="#disadvantages-of-the-environment" id="toc-item-clj-book-exceptions-en-disadvantages-of-the-environment">Disadvantages of the Environment</a>        <ul>
          <li><a href="#env-files" id="toc-item-clj-book-exceptions-en-env-files">Env Files</a></li>
        </ul>
      </li>
      <li><a href="#environment-variables-in-clojure" id="toc-item-clj-book-exceptions-en-environment-variables-in-clojure">Environment Variables in Clojure</a>        <ul>
          <li><a href="#extra-keys-problem" id="toc-item-clj-book-exceptions-en-extra-keys-problem">Extra Keys Problem</a></li>
          <li><a href="#environment-loader" id="toc-item-clj-book-exceptions-en-environment-loader">Environment Loader</a></li>
          <li><a href="#inference-of-structure" id="toc-item-clj-book-exceptions-en-inference-of-structure">Inference of Structure</a></li>
        </ul>
      </li>
      <li><a href="#simple-configuration-manager" id="toc-item-clj-book-exceptions-en-simple-configuration-manager">Simple configuration manager</a></li>
      <li><a href="#reading-the-environment-from-config" id="toc-item-clj-book-exceptions-en-reading-the-environment-from-config">Reading the Environment from Config</a></li>
      <li><a href="#overview-of-formats" id="toc-item-clj-book-exceptions-en-overview-of-formats">Overview of Formats</a>        <ul>
          <li><a href="#json" id="toc-item-clj-book-exceptions-en-json">JSON</a></li>
          <li><a href="#yaml" id="toc-item-clj-book-exceptions-en-yaml">YAML</a></li>
          <li><a href="#edn" id="toc-item-clj-book-exceptions-en-edn">EDN</a></li>
        </ul>
      </li>
      <li><a href="#industrial-solutions" id="toc-item-clj-book-exceptions-en-industrial-solutions">Industrial Solutions</a>        <ul>
          <li><a href="#cprop" id="toc-item-clj-book-exceptions-en-cprop">Cprop</a></li>
          <li><a href="#aero" id="toc-item-clj-book-exceptions-en-aero">Aero</a></li>
          <li><a href="#yummy" id="toc-item-clj-book-exceptions-en-yummy">Yummy</a></li>
        </ul>
      </li>
      <li><a href="#summary" id="toc-item-clj-book-exceptions-en-summary">Summary</a></li>
    </ul>
  </li>
</ul>

<h1 id="configuration">Configuration</h1>

<p><em>In this chapter, we will discuss how to make a Clojure project easy to configure. We’ll take a look at the basics of config: file formats, environment variables, libraries, and their pros and cons.</em></p>

<h2 id="formulation-of-the-problem">Formulation of the Problem</h2>

<p>In materials on Clojure, there are such examples:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">server</span><span class="w">
  </span><span class="p">(</span><span class="nf">jetty/run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w">   </span><span class="s">"postgres"</span><span class="w">
         </span><span class="no">:dbname</span><span class="w">   </span><span class="s">"test"</span><span class="w">
         </span><span class="no">:user</span><span class="w">     </span><span class="s">"ivan"</span><span class="w">
         </span><span class="no">:password</span><span class="w"> </span><span class="s">"test"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>These are the server on port 8080 and the parameters for connecting to the database. The examples are useful because you can execute them in the REPL and check their result: open a page in a browser or perform a SQL query.</p>

<p>In practice, we should write code so that it does not carry concrete numbers and strings. Explicitly setting a port number to a server is considered bad practice. That is fine for documentation and examples, but not for the production launch.</p>

<p>Port 8080 and other combinations of zeros and eights are popular with programmers. There is a good chance that the port is occupied by another server. This happens when instead of running one service, you start a bunch of them at once during development or testing.</p>

<p>The code written by a programmer goes through several stages. These stages may differ between companies, but in general, they are development, testing, staging/pre-production, and production.</p>

<p>At each stage, the application runs alongside other projects. The assumption that port 8080 is free anytime is fanciful. In developer slang, the situation is called “hardcode” or “nailed down.” If there are nailed-down values in the code, they introduce problems into its life cycle. You cannot run two projects in parallel which declare port 8080 in their code.</p>

<p>The application does not need to know the server port – information about this comes from the outside. In a simple case, this source is the config file. The program reads the port from it and starts the server exactly as it needs to do on a specific machine.</p>

<p>In more complex scenarios, the file is not compiled by a person but a special program – a configuration manager. The manager stores information about network topology, machine addresses, and database access parameters. On request, it generate a config file for a specific machine or network segment.</p>

<p>The process of passing parameters to an application and accepting them is called configuration. This step in software development deserves close attention. When it is done well, the project easily goes through all the stages of production.</p>

<!-- more -->

<h2 id="semantics">Semantics</h2>

<p>The purpose of a config is to control the program without changing the code. The need for it arises with the growth of the code base and infrastructure. If you have a small Python script, there is nothing wrong with opening it in notepad and changing a constant. At enterprises, such scripts have been working for years.</p>

<p>But the more complex a company’s infrastructure, the more constraints it has. Today’s software development practices negate spontaneous changes in a project. You can’t <code class="language-plaintext highlighter-rouge">git push</code> directly to the master branch; <code class="language-plaintext highlighter-rouge">git merge</code> is prohibited until at least two colleagues approve your work; an application will not reach the server until tests pass.</p>

<p>This leads to the fact that even a slight change in the code will take hours to get in production. Editing in configuration is cheaper than releasing a new version of the product. The rule follows from this: if you can make something a configurable option, do it right now.</p>

<p>Large companies practice what is called a feature flag. It is a boolean field that enables a vast layer of the application logic. For example, a new interface, a ticket processing system, or an improved chat. Of course, updates are tested before releasing them, but there is always a risk of something going wrong in production. In this case, we set the flag to false and restart the service. Thus, the company will not only save time but also preserve its reputation.</p>

<h2 id="configuration-cycle">Configuration Cycle</h2>

<p>The better an application is designed, the more of its parts rely on parameters. That’s why, on startup, the program immediately looks for configuration. Processing of configuration is a collection of steps, not a monolithic task. Let’s list the most important of them.</p>

<p>At the first stage, the program <strong>reads the configuration</strong>. Most often, they are environment variables or a file. Data in a file is stored in JSON, YAML, and other formats. An app contains code to parse a format and get the data. We’ll look at the pros and cons of the well-known formats below.</p>

<p>Environment variables are part of an operating system. Think of them as a global map in memory. Every application inherits it when starting. Languages and frameworks offer functions to read variables into strings and maps.</p>

<p>Files and environment variables complement each other. For example, an application reads data from a file but looks for its path in environment variables. There might be an opposite approach. Sensitive data such as passwords and API keys are omitted in the file. So, other programs, including spyware, won’t see them. The application reads normal parameters from a file, but the secret information comes from variables.</p>

<p>Advanced configurations use tags. In the file, the tag is placed before the value: <code class="language-plaintext highlighter-rouge">:password #env DB_PASSWORD</code>. A tag is a short string meaning that the next value is processed specially. In our example, the <code class="language-plaintext highlighter-rouge">password</code> field contains not the <code class="language-plaintext highlighter-rouge">DB_PASSWORD</code> string but the value of the same name variable.</p>

<p>The first stage ends when we have received the data. It doesn’t matter if it was a file, environment variables, or something else. The application moves on to the second stage, <strong>type inference</strong>.</p>

<p>JSON and YAML have basic types: strings, numbers, booleans, and <code class="language-plaintext highlighter-rouge">null</code>. It is easy to see that there is no date among them. We use dates to define promotions or calendar events. In files, dates are specified either as an ISO string or as the number of seconds since January 1, 1970 (<a href="https://en.wikipedia.org/wiki/Unix\_time">UNIX era</a>). Specially designed code runs through the data and converts dates to the type accepted in the language.</p>

<p>Type inference applies to collections as well. Sometimes maps and arrays are not enough to work comfortably. For example, possible types of something are stored as a set because it cuts off duplicates and quickly validates if a value belongs to it. It’s easier to describe some complex types with plain values (strings, numbers) and coerce them later. A string <code class="language-plaintext highlighter-rouge">http://test.com</code> will become an instance of <code class="language-plaintext highlighter-rouge">java.net.URL</code>, and a sequence of 36 hexadecimal characters will be a <code class="language-plaintext highlighter-rouge">UUID</code>.</p>

<p>Environment variables are less flexible than modern formats. JSON provides scalars and collections, while variables contain nothing but text. Type inference is not only desirable, but necessary for them. You cannot pass a port as a string to where a number is expected.</p>

<p><strong>Data validation</strong> starts after type inference. In the chapter on Spec, we found out that a proper type does not promise a correct value. Validation is needed to make it impossible to specify port 0, -1, or 80 in the configuration.</p>

<p>From the same chapter, we remember that sometimes the values are correct individually but cannot be paired. Suppose we specified the promotion period in the configuration. It is an array of two dates: start and end ones. These dates may be be easily confused, and then checking of any date against an interval will return false.</p>

<p>After validation, proceed to the last stage. The application decides where <strong>to store the configuration</strong>, for example, in a global variable or a system component. Other parts of the program will read parameters from there, not from the file.</p>

<h2 id="config-errors">Config Errors</h2>

<p>At each stage, an error may occur, e.g., file not found, syntax violations, invalid field. In this case, the program displays a message and exits. The text should explicitly answer the question of what happened. Too often, programmers keep in mind only the positive path and forget about errors. When running their programs, you see a stack trace that is difficult to understand.</p>

<p>If an error occurred during the verification stage, explain which field was a culprit. In the chapter on Spec, we looked at how to improve a spec report. It takes effort but pays off over time.</p>

<p>In the IT industry, some people write code, and others manage it. Your DevOps colleagues don’t know Clojure and won’t understand the raw <code class="language-plaintext highlighter-rouge">s/explain</code>. Sooner or later, they will ask you to improve the configuration messages. Do this in advance out of respect for your colleagues.</p>

<p>If there is something wrong with the config, then the program should terminate immediately rather than work, hoping that everything will settle somehow. Sometimes one of the parameters is specified incorrectly, but the program does not use it for the time being. Avoid this: the error will appear at the most inopportune moment.</p>

<p>If one of the configuration steps fails, the program should exit with nonzero code. The message is sent to the <code class="language-plaintext highlighter-rouge">stderr</code> channel to signal an abnormal condition. Advanced terminals print text from <code class="language-plaintext highlighter-rouge">stderr</code> in red to catch your attention.</p>

<h2 id="configuration-loader">Configuration Loader</h2>

<p>To reinforce theory with practice, let’s write our configuration system. It will be a separate module of about one hundred lines. Before opening the editor, let’s think over the main points.</p>

<p>Let’s store the configuration in a JSON file. We’ll assume that the company has recently switched to Clojure, and DevOps has already written Python scripts to manage configuration settings. Of course, EDN would be the best choice for Clojure programs, but it will complicate work for our colleagues, so we’ll not use it for now.</p>

<p>The path to the config file is specified by the <code class="language-plaintext highlighter-rouge">CONFIG PATH</code> environment variable. From the file, we expect to get a server port, database parameters, and promotion date range. Dates should become <code class="language-plaintext highlighter-rouge">java.util.Date</code> objects. The start date is strictly less than the end date.</p>

<p>We will put the final map into the global variable <code class="language-plaintext highlighter-rouge">CONFIG</code>. If an error occurs at one of the steps, we will show a message and exit the program.</p>

<p>Let’s start with the <code class="language-plaintext highlighter-rouge">exit</code> helper function. It takes a completion code, a text, and formatting options. If the code is equal to zero, write the message to <code class="language-plaintext highlighter-rouge">stdout</code>, otherwise – to <code class="language-plaintext highlighter-rouge">stderr</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">exit</span><span class="w">
  </span><span class="p">[</span><span class="n">code</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">zero?</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="n">*out*</span><span class="w"> </span><span class="n">*err*</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*out*</span><span class="w"> </span><span class="n">out</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="n">args</span><span class="p">))))</span><span class="w">
  </span><span class="p">(</span><span class="nf">System/exit</span><span class="w"> </span><span class="n">code</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Now let’s move on to the loader. It is a set of steps, where each one takes the result of the previous one. The logic of the steps is easy to understand from their name. Namely, there are four actions: finding the path to the config, reading a file, infer data types, and setting a global variable. Type coercion and validation were combined into <code class="language-plaintext highlighter-rouge">coerce-config</code> since, technically, this is the <code class="language-plaintext highlighter-rouge">s/conform</code> call.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">load-config!</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">get-config-path</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">read-config-file</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">coerce-config</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">set-config!</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Now we will describe each step. The <code class="language-plaintext highlighter-rouge">get-config-path</code> function reads an environment variable and checks if such a file exists on disk. If everything is okay, the function will return the file path; otherwise, it will call <code class="language-plaintext highlighter-rouge">exit</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="ss">'java.io.File</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-config-path</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">filepath</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"CONFIG_PATH"</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">filepath</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">File</span><span class="p">)</span><span class="w"> </span><span class="n">.exists</span><span class="p">)</span><span class="w">
      </span><span class="n">filepath</span><span class="w">
      </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"File %s does not exist"</span><span class="w"> </span><span class="n">filepath</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"File path is not set"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">read-config-file</code> step reads the file by its path. The Cheshire library parses JSON. Its <code class="language-plaintext highlighter-rouge">parse-string</code> function returns data from a document string.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">cheshire.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">json</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">read-config-file</span><span class="w">
  </span><span class="p">[</span><span class="n">filepath</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">filepath</span><span class="w"> </span><span class="nb">slurp</span><span class="w"> </span><span class="p">(</span><span class="nf">json/parse-string</span><span class="w"> </span><span class="n">true</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"Malformed config, file: %s, error: %s"</span><span class="w">
            </span><span class="n">filepath</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Type inference and validation are the most important steps. The application must not receive invalid parameters. The <code class="language-plaintext highlighter-rouge">coerce-config</code> step passes data from the file through <code class="language-plaintext highlighter-rouge">s/conform</code>. There is a chance of getting an exception when calling it, so wrap it in <code class="language-plaintext highlighter-rouge">pcall</code> – a safe call that will return an error and the result.</p>

<p>If there was an exception, we print its message and terminate the program. The same applied to the case when we got <code class="language-plaintext highlighter-rouge">::s/invalid</code> keyword. The only difference is, we compose the message with the Expound library. We have to consider both cases because a failure and an incorrect result are different things.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.spec.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">expound.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">expound</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">coerce-config</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">e</span><span class="w"> </span><span class="n">result</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">pcall</span><span class="w"> </span><span class="n">s/conform</span><span class="w"> </span><span class="no">::config</span><span class="w"> </span><span class="n">config</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">cond</span><span class="w">
      </span><span class="p">(</span><span class="nf">some?</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"Wrong config values: %s"</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">

      </span><span class="p">(</span><span class="nf">s/invalid?</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">report</span><span class="w"> </span><span class="p">(</span><span class="nf">expound/expound-str</span><span class="w"> </span><span class="no">::config</span><span class="w"> </span><span class="n">config</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">exit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"Invalid config values: %s %s"</span><span class="w">
              </span><span class="sc">\n</span><span class="n">ewline</span><span class="w"> </span><span class="n">report</span><span class="p">))</span><span class="w">

      </span><span class="no">:else</span><span class="w"> </span><span class="n">result</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Now, only a spec is missing. Let’s open the configuration and examine its structure:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"server_port"</span><span class="p">:</span><span class="w"> </span><span class="mi">8080</span><span class="p">,</span><span class="w">
    </span><span class="nl">"db"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"dbtype"</span><span class="p">:</span><span class="w">   </span><span class="s2">"mysql"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"dbname"</span><span class="p">:</span><span class="w">   </span><span class="s2">"book"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"user"</span><span class="p">:</span><span class="w">     </span><span class="s2">"ivan"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"password"</span><span class="p">:</span><span class="w"> </span><span class="s2">"****"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"event"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"2019-07-05T12:00:00"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"2019-07-12T23:59:59"</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Describe the spec from top to bottom. It is a map with the keys:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::config</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">::server_port</span><span class="w"> </span><span class="no">::db</span><span class="w"> </span><span class="no">::event</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>The server port is a combination of two predicates: a number check and a range check. Checking for a number is needed so that <code class="language-plaintext highlighter-rouge">nil</code> and a string do not get into the second predicate. Otherwise, this will throw an exception where you least expect it.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::server_port</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w"> </span><span class="n">int?</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">65535</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>We meet number and range checks frequently, so Spec offers the <code class="language-plaintext highlighter-rouge">s/int-in</code> macro for this case. Please note that the right border is exclusive, meaning that it belongs to the interval. The mathematical notation for such an interval is written like <code class="language-plaintext highlighter-rouge">[1024, 65535)</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::server_port</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/int-in</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">65535</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Now let’s describe the database connection. There won’t be any problems with it, because all its fields are strings. For more rigor we use <code class="language-plaintext highlighter-rouge">::ne-string</code> to prevent empty lines. The database engine is specified as a enumeration of strings with the only item «mysql». This will eliminate extraneous values.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:db/dbtype</span><span class="w">   </span><span class="o">#</span><span class="p">{</span><span class="s">"mysql"</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:db/dbname</span><span class="w">   </span><span class="no">::ne-string</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:db/user</span><span class="w">     </span><span class="no">::ne-string</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:db/password</span><span class="w"> </span><span class="no">::ne-string</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::db</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:db/dbtype</span><span class="w">
                   </span><span class="no">:db/dbname</span><span class="w">
                   </span><span class="no">:db/user</span><span class="w">
                   </span><span class="no">:db/password</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">event</code> field is the most challenging one. It consists of a tuple of dates and an interval check:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::event</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w"> </span><span class="p">(</span><span class="nf">s/tuple</span><span class="w"> </span><span class="no">::-&gt;date</span><span class="w"> </span><span class="no">::-&gt;date</span><span class="p">)</span><span class="w">
         </span><span class="no">::date-range</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">s/tuple</code> spec validates if a collection has exact number of items. In our case, a vector of one or three dates won’t pass it. The <code class="language-plaintext highlighter-rouge">::-&gt;date</code> spec converts a string to a date. In order not to parse it manually, let’s take the <code class="language-plaintext highlighter-rouge">read-instant-date</code> function from the <code class="language-plaintext highlighter-rouge">clojure.instant</code> package. This function is format-tolerant and reads incomplete dates, for example, only a year. Let’s wrap it in <code class="language-plaintext highlighter-rouge">s/conformer</code>. We put <code class="language-plaintext highlighter-rouge">::ne-string</code> in front to cut off the non-date garbage.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.instant</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">inst</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;date</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w"> </span><span class="no">::ne-string</span><span class="w"> </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">read-instant-date</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Let’s describe range checking. It takes a couple of <code class="language-plaintext highlighter-rouge">Date</code> objects and compares them. Dates cannot be compared using “greater than” or “less than” signs. Instead, use the <code class="language-plaintext highlighter-rouge">compare</code> function, which will return -1, 0, and 1 for the less than, equal or greater than cases, respectively. We are interested in the first case when the result is negative.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::date-range</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[[</span><span class="n">date1</span><span class="w"> </span><span class="n">date2</span><span class="p">]]</span><span class="w">
    </span><span class="p">(</span><span class="nb">neg?</span><span class="w"> </span><span class="p">(</span><span class="nf">compare</span><span class="w"> </span><span class="n">date1</span><span class="w"> </span><span class="n">date2</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>The last step is <code class="language-plaintext highlighter-rouge">set-config!</code> that writes the map to the global <code class="language-plaintext highlighter-rouge">CONFIG</code> variable. We chose an uppercase name to avoid shadowing it with the local one <code class="language-plaintext highlighter-rouge">config</code>. To change a global variable, use <code class="language-plaintext highlighter-rouge">alter-var-root</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">CONFIG</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">set-config!</span><span class="w">
  </span><span class="p">[</span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alter-var-root</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">CONFIG</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="n">config</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>At the start of the program, execute <code class="language-plaintext highlighter-rouge">(load-config!)</code> so that the configuration appears in the variable. Other modules import <code class="language-plaintext highlighter-rouge">CONFIG</code> and read the keys they need. Below is how to start a server or execute a request based on configuration:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">project.config</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">CONFIG</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">jetty/run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="p">(</span><span class="no">:server_port</span><span class="w"> </span><span class="n">CONFIG</span><span class="p">)</span><span class="w">
                      </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="p">(</span><span class="no">:db</span><span class="w"> </span><span class="n">CONFIG</span><span class="p">)</span><span class="w"> </span><span class="s">"select * from users"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>If there is something wrong with your configuration, the program will terminate with a clear message.</p>

<h3 id="improvements">Improvements</h3>

<p>We have written a configuration loader. It is simple to maintain: every step is a function that is easy to modify. Our code does not pretend to be an industrial solution, but it is suitable for small projects.</p>

<p>Its advantage is that the configuration can be re-read at any time. This is handy for development: modify the file and run <code class="language-plaintext highlighter-rouge">load-config!</code> in the REPL. A new configuration appears in the <code class="language-plaintext highlighter-rouge">CONFIG</code> variable.</p>

<p>The downside of the loader is that the code is bound to the <code class="language-plaintext highlighter-rouge">exit</code> function, which terminates a JVM. In production, this is the right approach: you cannot continue if the parameters are misconfigured. In development, a termination is more of a problem than a benefit: any error kills the REPL, and you need to start it again.</p>

<p>The termination of a JVM is too drastic. We should separate an error and reaction to it. The naive way is to call <code class="language-plaintext highlighter-rouge">load-config!</code> while the <code class="language-plaintext highlighter-rouge">exit</code> is being redefined with a function that only throws an exception. Let’s name it <code class="language-plaintext highlighter-rouge">fake-exit</code>. The code below will not terminate the JVM; it will only throw an exception with the text that we passed to <code class="language-plaintext highlighter-rouge">exit</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fake-exit</span><span class="w">
  </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">message</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="n">message</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">load-config-repl!</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-redefs</span><span class="w"> </span><span class="p">[</span><span class="n">exit</span><span class="w"> </span><span class="n">fake-exit</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">load-config!</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>A better solution is to pass additional parameters to <code class="language-plaintext highlighter-rouge">load-config!</code>. Let’s call one of them <code class="language-plaintext highlighter-rouge">die-fn</code> (the “death function”) that takes an exception. In production, it terminates the JVM, and in development, it writes a message to the REPL. Modify the loader to support the <code class="language-plaintext highlighter-rouge">:die-fn</code> parameter. Consider default behavior if the parameter is not specified.</p>

<p>Another point that addresses the issue of inferring types. The loader relies on the <code class="language-plaintext highlighter-rouge">s/conform</code> function for type inference. In the chapter on Spec, we looked at the case when <code class="language-plaintext highlighter-rouge">s/conform</code> adds logical tags and changes the data structure. If we replace our custom <code class="language-plaintext highlighter-rouge">::db</code> spec with the <code class="language-plaintext highlighter-rouge">::jdbc/db-spec</code> one, we will get the same case. We have set our database spec without <code class="language-plaintext highlighter-rouge">s/or</code> macros in order not to distort the data.</p>

<p>In another way, you can coerce types using tags. We will discuss this technique in the following sections of this chapter.</p>

<h2 id="more-on-environment-variables">More on Environment Variables</h2>

<p>A loader reads data from a file, taking only a small part – the file path – from environment variables. Let’s modify the loader: now it reads all data from the environment without using files. To know better the advantages of the new approach, let’s discuss it first in isolation from any specific language.</p>

<p>Environment variables are sometimes called ENV for short, for example, when reading a file of the same name or working with them in the code. This is a fundamental property of the operating system. Think of variables as a global map that is populated at a computer startup. The map contains the main system parameters: locale, home directory, a list of paths where the system looks for programs, and much more.</p>

<p>To see the current variables, run <code class="language-plaintext highlighter-rouge">env</code> or <code class="language-plaintext highlighter-rouge">printenv</code> in a terminal. The pairs <code class="language-plaintext highlighter-rouge">NAME=value</code> will appear on the screen. Variable names are in uppercase to make them stand out and emphasize their priority. Most systems are case sensitive, so <code class="language-plaintext highlighter-rouge">home</code> and <code class="language-plaintext highlighter-rouge">HOME</code> are different variables. Spaces and hyphens are not allowed; lexemes are separated by underscores. Here’s a snippet of <code class="language-plaintext highlighter-rouge">printenv</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">USER</span><span class="o">=</span>ivan
<span class="nv">PWD</span><span class="o">=</span>/Users/ivan
<span class="nv">SHELL</span><span class="o">=</span>/bin/zsh
<span class="nv">TERM_PROGRAM</span><span class="o">=</span>iTerm.app
</code></pre></div></div>

<p>Each process receives a copy of this map. A process can add or remove a variable, but the changes are visible only to it and its descendants. A child process inherits the variables from its parent.</p>

<h3 id="local-and-global-variables">Local and Global Variables</h3>

<p>Distinguish between environment and shell variables; they are also called global and local variables. Newbies often confuse them. Run the command in the terminal:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ FOO</span><span class="o">=</span>42
</code></pre></div></div>

<p>You have set a shell variable. To refer to a value by name, precede it with a dollar sign. The example below will print 42:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$FOO</span>
42
</code></pre></div></div>

<p>If we execute <code class="language-plaintext highlighter-rouge">printenv</code>, we won’t see <code class="language-plaintext highlighter-rouge">FOO</code> in the output. The <code class="language-plaintext highlighter-rouge">FOO=42</code> instruction sets a shell variable, not an environment variable. These variables are only visible to the shell, and its descendants do not inherit them. Let’s check it: start a new one from the current shell and repeat printing.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$FOO</span>
</code></pre></div></div>

<p>We get an empty string because the child does not have such a variable. Run <code class="language-plaintext highlighter-rouge">exit</code> to return to the parent shell.</p>

<p>The <code class="language-plaintext highlighter-rouge">export</code> command puts a variable into the environment. Printenv sees the variable set this way:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">export </span><span class="nv">FOO</span><span class="o">=</span>42
<span class="nv">$ </span><span class="nb">printenv</span> | <span class="nb">grep </span>FOO
<span class="nv">FOO</span><span class="o">=</span>42
</code></pre></div></div>

<p>The child processes also see it:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$FOO</span>
42
</code></pre></div></div>

<p>Sometimes you need to start a process with a variable but so as not to affect the current state. In such a situation, you should place the expression <code class="language-plaintext highlighter-rouge">NAME=value</code> before the basic command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ BAR</span><span class="o">=</span>99 <span class="nb">printenv</span> | <span class="nb">grep </span>BAR
<span class="nv">BAR</span><span class="o">=</span>99
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Printenv</code> generates a new process that has access to the <code class="language-plaintext highlighter-rouge">BAR</code> variable. If we print <code class="language-plaintext highlighter-rouge">$BAR</code> once again, we’ll get an empty string.</p>

<p>Programs often read parameters from environment variables. A PostgreSQL client distinguishes between two dozen variables: <code class="language-plaintext highlighter-rouge">PGHOST</code>, <code class="language-plaintext highlighter-rouge">PGDATABASE</code>, <code class="language-plaintext highlighter-rouge">PGUSER</code>, and others. Environment variables take precedence over <code class="language-plaintext highlighter-rouge">--host</code>, <code class="language-plaintext highlighter-rouge">--user</code>, and similar parameters. If you execute the following in the current shell:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">export </span><span class="nv">PGHOST</span><span class="o">=</span>host.com <span class="nv">PGDATABASE</span><span class="o">=</span>project
</code></pre></div></div>

<p>then each PostgreSQL utility will run on the specified server and database. This is convenient for a series of commands: you don’t have to specify <code class="language-plaintext highlighter-rouge">--host</code> and other arguments every time.</p>

<p>Pay attention to the <code class="language-plaintext highlighter-rouge">PG</code> prefix. It prevents overwriting someone else’s <code class="language-plaintext highlighter-rouge">HOST</code> variable. There are no namespaces in the environment, so the prefix is the only way to separate your variables from others.</p>

<h2 id="config-in-the-environment">Config in the Environment</h2>

<p>Each language provides functions to read a single variable to a string or get all of them as a map. It means we can set config with environment variables. Let’s look at the pros and cons of this approach.</p>

<p>The application does not access the disk while reading the environment since it is located in memory. We’re not aiming at the performance benefits, though. Yes, memory is much faster than disk, but you will never notice the difference between 0.01sec and 0.001sec. Our main point is that an application that does not depend on files is more autonomous and easier to maintain.</p>

<p>Sometimes a configuration file is unexpectedly located in a different folder, and an application cannot find it, or worse, the app starts up with an old file version. This makes things slower and more confusing.</p>

<p>Storing passwords and keys in variables is safer than in files. These data can be read in files by other programs, including malware. By mistake, a file can get into the repository and remain in history. Some scripts search open repositories for keys to cloud platforms and wallets (and sometimes find them, unfortunately).</p>

<p>Even if a file belongs to a user, others can get read access. Environment variables are ephemeral: they live only in operating system memory. One user cannot read another’s variables – this is a strict limitation at the operating system level.</p>

<p>The industry is moving from files to virtualisation. If earlier we copied files via FTP, today applications are running from images. They are archives that contain the code and its environment. Unlike a regular archive, we cannot change an image. To update a file in the image, you need to rebuild it, which complicates the process.</p>

<p>On the contrary, virtualisation is loyal to the environment variables. They are specified in the parameters when you start the image. The same image is used with different variables, so a new build is not required. The more options you can set with variables, the more convenient it is to work with the image. In the example below, the PostgreSQL server starts with a ready-to-use database and a user:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="se">\</span>
  <span class="nt">-e</span> <span class="nv">POSTGRES_DB</span><span class="o">=</span>book <span class="se">\</span>
  <span class="nt">-e</span> <span class="nv">POSTGRES_USER</span><span class="o">=</span>ivan <span class="se">\</span>
  <span class="nt">-e</span> <span class="nv">POSTGRES_PASSWORD</span><span class="o">=</span><span class="k">****</span> <span class="se">\</span>
  <span class="nt">-d</span> postgres
</code></pre></div></div>

<p>The <a href="https://12factor.net">Twelve-Factor App</a> is a famous set of rules for developing robust applications. It also prescribes storing configuration in the environment. The author mentions the same advantages of variables that we have looked at – file independence, security, and support on all platforms.</p>

<h2 id="disadvantages-of-the-environment">Disadvantages of the Environment</h2>

<p>Variables do not support types: any value is text. Type inference is up to you. Do it declaratively, not manually. Here’s a bad example in Python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">db_port</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">[</span><span class="s">"DB_PORT"</span><span class="p">])</span>
</code></pre></div></div>

<p>When there are more than two variables, the code becomes ugly. Specify a map where a key is a variable name and value is a function to transform a text value. The special code traverses the map and fills up the result. For the sake of shortness, let’s skip error handling:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="n">env_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s">"DB_PORT"</span><span class="p">:</span> <span class="nb">int</span><span class="p">}</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span> <span class="ow">in</span> <span class="n">env_mapping</span><span class="p">.</span><span class="n">iteritems</span><span class="p">():</span>
    <span class="n">result</span><span class="p">[</span><span class="n">env</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">[</span><span class="n">env</span><span class="p">])</span>
</code></pre></div></div>

<p>The approach is also valid for other languages: less code, more of the declarative part. In Clojure, we usually transform the data with spec.</p>

<p>Environment variables do not work with hierarchy. They are a flat set of keys and values that is not always suitable for config. The more parameters the configuration has, the more often they are grouped by meaning. Let’s say ten parameters define the connection to the database. We’ll take them out to the child map in order not to put a prefix in front of each.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; so-so</span><span class="w">
</span><span class="p">{</span><span class="no">:db-name</span><span class="w"> </span><span class="s">"book"</span><span class="w">
 </span><span class="no">:db-user</span><span class="w"> </span><span class="s">"ivan"</span><span class="w">
 </span><span class="no">:db-pass</span><span class="w"> </span><span class="s">"****"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>vs</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; better</span><span class="w">
</span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"book"</span><span class="w">
      </span><span class="no">:user</span><span class="w"> </span><span class="s">"ivan"</span><span class="w">
      </span><span class="no">:pass</span><span class="w"> </span><span class="s">"****"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Nested variables are read differently on different systems. For example, a single underscore separates lexemes but does not change the structure. Double underscore stands for nesting:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DB_NAME=book</span><span class="w">
</span><span class="n">DB_PASS=pass</span><span class="w">

</span><span class="p">{</span><span class="no">:db-name</span><span class="w"> </span><span class="s">"book"</span><span class="w">
 </span><span class="no">:db-pass</span><span class="w"> </span><span class="s">"pass"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>and</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DB__NAME=book</span><span class="w">
</span><span class="n">DB__PASS=pass</span><span class="w">

</span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"book"</span><span class="w">
      </span><span class="no">:pass</span><span class="w"> </span><span class="s">"pass"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>An array is specified in square brackets or separated by commas. When parsing one, there is a risk of false splitting. This happens when the comma or a bracket refers to a word, not syntax.</p>

<p>The JSON and YAML formats set a clear standard for how to describe collections. But there is no single convention for environment variables. The situation gets more complicated when a highly nested parameter is expected, such as a list of dictionaries. Environment variables do not fit well with such a structure.</p>

<p>The development reveals one more trade-off of these variables: they are read-only on some systems. That is ideologically true, but it forces you to re-enable the REPL for every configuration change, whereas the file only needs to be changed and read again.</p>

<h3 id="env-files">Env Files</h3>

<p>When there are many variables, entering them manually via <code class="language-plaintext highlighter-rouge">export</code> is tiresome. In such situations, we move the variables to a file called the env-configuration. Technically, it is a shell script, but the less scripting capabilities it has, the better. Ideally, such a file holds only <code class="language-plaintext highlighter-rouge">NAME=value</code> pairs, one for each line. Let’s just call it <code class="language-plaintext highlighter-rouge">ENV</code> without extension.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">DB_NAME</span><span class="o">=</span>book
<span class="nv">DB_USER</span><span class="o">=</span>ivan
<span class="nv">DB_PASS</span><span class="o">=</span><span class="k">****</span>
</code></pre></div></div>

<p>To read the variables into the shell, call <code class="language-plaintext highlighter-rouge">source &lt;file&gt;</code>. It is a <code class="language-plaintext highlighter-rouge">bash</code> command that will execute the script in the current session. The shorthand for this often-used command is a dot: <code class="language-plaintext highlighter-rouge">. &lt;file&gt;</code>. The script will add variables to the shell, and you will see them after <code class="language-plaintext highlighter-rouge">source</code>. This is an important difference from <code class="language-plaintext highlighter-rouge">bash &lt;file&gt;</code> command, which will execute the script in a new shell, and you won’t see any changes in the current one.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">source </span>ENV
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$DB_NAME</span>
book
</code></pre></div></div>

<p>If you run the application from the current shell, the app still won’t get the variables from the file. Recall that the expression <code class="language-plaintext highlighter-rouge">VAR=value</code> defines a local variable. <code class="language-plaintext highlighter-rouge">DB_NAME</code> and other variables will not get into the environment, and the program will not inherit them. Let’s check this with <code class="language-plaintext highlighter-rouge">printenv</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">source </span>ENV
<span class="nv">$ </span><span class="nb">printenv</span> | <span class="nb">grep </span>DB
<span class="c"># exit 1</span>
</code></pre></div></div>

<p>You can solve the problem in two ways. The first is to open the file and place the <code class="language-plaintext highlighter-rouge">export</code> expression before each pair. Then the <code class="language-plaintext highlighter-rouge">source</code> command of this file will add variables to the environment:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>ENV
<span class="nb">export </span><span class="nv">DB_NAME</span><span class="o">=</span>book
<span class="nb">export </span><span class="nv">DB_USER</span><span class="o">=</span>ivan
<span class="nb">export </span><span class="nv">DB_PASS</span><span class="o">=</span><span class="k">****</span>

<span class="nv">$ </span><span class="nb">source </span>ENV
<span class="nv">$ </span><span class="nb">printenv</span> | <span class="nb">grep </span>DB
<span class="nv">DB_NAME</span><span class="o">=</span>book
<span class="nv">DB_USER</span><span class="o">=</span>ivan
<span class="nv">DB_PASS</span><span class="o">=</span><span class="k">****</span>
</code></pre></div></div>

<p>The disadvantage of this method is that now the file has become a script. If you do not put <code class="language-plaintext highlighter-rouge">export</code> before a variable, the application will not read it.</p>

<p>The second way is based on the <code class="language-plaintext highlighter-rouge">-a</code> (<strong>a</strong>llexport) parameter of the current shell. When it is set, the local variable is sent to the environment as well. Before reading variables from a file, set the flag to “true” and then to “false” again.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">set</span> <span class="nt">-a</span>
<span class="nv">$ </span><span class="nb">source </span>ENV
<span class="nv">$ </span><span class="nb">printenv</span> | <span class="nb">grep </span>DB
<span class="c"># prints all the vars</span>
<span class="nv">$ </span><span class="nb">set</span> +a
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">set</code> statement is counterintuitive: the parameter is enabled with a minus and disabled with a plus. This is an exception to remember.</p>

<p>If you read a variable that is already in the environment, it will replace the previous value. This way, files with overrides appear. If you need particular settings for your tests, you don’t have to copy the entire file. Create a file with the fields to be replaced and execute it after the main one.</p>

<p>Let the test settings of our program differ by the base name. The <code class="language-plaintext highlighter-rouge">ENV</code> file contains the main parameters, and in <code class="language-plaintext highlighter-rouge">ENV_TEST</code> we put a single pair <code class="language-plaintext highlighter-rouge">DB_NAME=test</code>. Let’s read both files and see how it turned out:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">set</span> <span class="nt">-a</span>
<span class="nv">$ </span><span class="nb">source </span>ENV
<span class="nv">$ </span><span class="nb">source </span>ENV_TEST
<span class="nv">$ </span><span class="nb">set</span> +a

<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$DB_NAME</span>
<span class="nb">test</span>
</code></pre></div></div>

<p>You can notice that using ENV files is contrary to the statement above. We said that variables remove the dependency on files, but in the end, we put them in a file. Why?</p>

<p>The difference between JSON and ENV files is what reads them. In the first case, an application does it, and in the second case, an operating system. A file is located in a strictly defined directory, whereas environment variables are available from everywhere. We will free the application from the code that looks for and reads the file. At the same time, we will make it easier for our DevOps colleagues: they set variables differently depending on the tool (shell, Docker, Kubernetes). This makes the environment the main exchange point of all settings.</p>

<h2 id="environment-variables-in-clojure">Environment Variables in Clojure</h2>

<p>Clojure is a hosted platform, so the language does not provide access to system resources. There is no function for reading environment variables in its core module. Let’s get them from the <code class="language-plaintext highlighter-rouge">java.lang.System</code> class. You don’t need to import the class: it is available in any namespace.</p>

<p>The static <code class="language-plaintext highlighter-rouge">getenv</code> method will return either one variable by name or the entire map if no name is specified.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; a single variable</span><span class="w">
</span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"HOME"</span><span class="p">)</span><span class="w">
</span><span class="s">"/Users/ivan"</span><span class="w">

</span><span class="c1">;; all variables</span><span class="w">
</span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="s">"JAVA_ARCH"</span><span class="w"> </span><span class="s">"x86_64"</span><span class="n">,</span><span class="w"> </span><span class="s">"LANG"</span><span class="w"> </span><span class="s">"en_US.UTF-8"</span><span class="p">}</span><span class="w"> </span><span class="c1">;; truncated</span><span class="w">
</span></code></pre></div></div>

<p>In the second case, we got not a Clojure collection but a Java one. It is an instance of <code class="language-plaintext highlighter-rouge">UnmodifiableMap</code> class, so the variables cannot be changed after the JVM has started.</p>

<p>Let’s cast the map to the Clojure type to make it easier to work with it. At the same time, we will fix the keys: at the moment, these are uppercase strings with underscores. Clojure uses keywords and kebab-case: lowercase with hyphens.</p>

<p>Let’s write a function to convert a single key:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-key</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="nb">key</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">key</span><span class="w">
      </span><span class="n">str/lower-case</span><span class="w">
      </span><span class="p">(</span><span class="nf">str/replace</span><span class="w"> </span><span class="o">#</span><span class="s">"_"</span><span class="w"> </span><span class="s">"-"</span><span class="p">)</span><span class="w">
      </span><span class="nb">keyword</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>and make sure that it works correctly:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">remap-key</span><span class="w"> </span><span class="s">"DB_PORT"</span><span class="p">)</span><span class="w">
</span><span class="no">:db-port</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">remap-env</code> function traverses the Java map and returns its Clojure version with keywords for keys:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-env</span><span class="w"> </span><span class="p">[</span><span class="n">env</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">acc</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]]</span><span class="w">
     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">key</span><span class="w"> </span><span class="p">(</span><span class="nf">remap-key</span><span class="w"> </span><span class="n">k</span><span class="p">)]</span><span class="w">
       </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="n">v</span><span class="p">)))</span><span class="w">
   </span><span class="p">{}</span><span class="w">
   </span><span class="n">env</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Here is a small part of the map:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">remap-env</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:home</span><span class="w"> </span><span class="s">"/Users/ivan"</span><span class="w">
 </span><span class="no">:lang</span><span class="w"> </span><span class="s">"en_US.UTF-8"</span><span class="w">
 </span><span class="no">:term</span><span class="w"> </span><span class="s">"xterm-256color"</span><span class="w">
 </span><span class="no">:java-arch</span><span class="w"> </span><span class="s">"x86_64"</span><span class="w">
 </span><span class="no">:term-program</span><span class="w"> </span><span class="s">"iTerm.app"</span><span class="w">
 </span><span class="no">:shell</span><span class="w"> </span><span class="s">"/bin/zsh"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Now that we have a map of variables, it follows the same pipeline: type inference, validation with a spec. Since all values are strings, the spec needs to be modified so that it converts strings to proper types. Previously, there was no need for this because the numbers came from JSON. Let’s make a better spec that considers both number and string types for numeric values. A smart number parser looks like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="k">cond</span><span class="w">
       </span><span class="p">(</span><span class="nf">int?</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="n">value</span><span class="w">
       </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">try</span><span class="w"> </span><span class="p">(</span><span class="nf">Integer/parseInt</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
              </span><span class="no">::s/invalid</span><span class="p">))</span><span class="w">
       </span><span class="no">:else</span><span class="w"> </span><span class="no">::s/invalid</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>With this spec, you can change the data source without editing the code.</p>

<h3 id="extra-keys-problem">Extra Keys Problem</h3>

<p>The variable map has the disadvantage of many extraneous fields. The application doesn’t need to know the terminal version or the path to Python. These fields introduce noise during printing and logging. If the spec fails, we’ll see excessive data in <code class="language-plaintext highlighter-rouge">explain</code>.</p>

<p>In the last step of <code class="language-plaintext highlighter-rouge">s/conform</code>, you need to select only the useful data part from the map. The <code class="language-plaintext highlighter-rouge">select-keys</code> function will return a subset of another map with only the keys passed to the second argument. But where to get the keys? It takes a long time to list them manually, and besides, we duplicate the code. We have already specified the keys in the <code class="language-plaintext highlighter-rouge">::config</code> spec, and we don’t want to do this a second time. We’ll use a trick to get the keys out of the spec.</p>

<p>The <code class="language-plaintext highlighter-rouge">s/form</code> function takes a spec key and returns the frozen form of whatever was passed to <code class="language-plaintext highlighter-rouge">s/def</code>. We will get a list where each item is a primitive or a collection of primitives (number, string, symbol, and others). For the <code class="language-plaintext highlighter-rouge">::config</code> spec, we’ll get the following form:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/form</span><span class="w"> </span><span class="no">::config</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">clojure.spec.alpha/keys</span><span class="w">
 </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:book.config/server_port</span><span class="w">
          </span><span class="no">:book.config/db</span><span class="w">
          </span><span class="no">:book.config/event</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Please note: this is a list indeed, not a code. The keys you need are in the third item after the <code class="language-plaintext highlighter-rouge">:req-un</code> keyword. We should consider other types of keys, for example, <code class="language-plaintext highlighter-rouge">:opt-un</code>. Let’s write a universal function that will return all keys from the <code class="language-plaintext highlighter-rouge">s/keys</code> spec.</p>

<p>We’ll drop the first symbol of the form. That leaves a list, where the odd items are the type of keys, and the even ones are their vector. Let’s rebuild the list into a map and combine the values. For <code class="language-plaintext highlighter-rouge">-un</code> keys, discard the namespace. As a result of these actions, we get the function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">spec-&gt;keys</span><span class="w">
  </span><span class="p">[</span><span class="n">spec-keys</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">form</span><span class="w"> </span><span class="p">(</span><span class="nf">s/form</span><span class="w"> </span><span class="n">spec-keys</span><span class="p">)</span><span class="w">
        </span><span class="n">params</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">hash-map</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">form</span><span class="p">))</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">req</span><span class="w"> </span><span class="n">opt</span><span class="w"> </span><span class="n">req-un</span><span class="w"> </span><span class="n">opt-un</span><span class="p">]}</span><span class="w"> </span><span class="n">params</span><span class="w">
        </span><span class="n">-&gt;unqualify</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="nb">keyword</span><span class="w"> </span><span class="nb">name</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="n">req</span><span class="w">
            </span><span class="n">opt</span><span class="w">
            </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">-&gt;unqualify</span><span class="w"> </span><span class="n">opt-un</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">-&gt;unqualify</span><span class="w"> </span><span class="n">req-un</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Let’s check the spec of our loader. Indeed, we get three keys:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">spec-&gt;keys</span><span class="w"> </span><span class="no">::config</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="no">:server_port</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="no">:event</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Let’s rewrite reading variables into the map. In the last step, we select only those keys that we declared in our spec.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">read-env-vars</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">cfg-keys</span><span class="w"> </span><span class="p">(</span><span class="nf">spec-&gt;keys</span><span class="w"> </span><span class="no">::config</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">remap-env</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nb">select-keys</span><span class="w"> </span><span class="n">cfg-keys</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>The advantage is that we managed to avoid repetitions. If a new field appears in <code class="language-plaintext highlighter-rouge">::config</code>, the <code class="language-plaintext highlighter-rouge">spec-&gt;keys</code> function will automatically pick it up.</p>

<h3 id="environment-loader">Environment Loader</h3>

<p>Let’s modify the loader to work with environment variables. Replace the first two steps with <code class="language-plaintext highlighter-rouge">read-env-vars</code>. Now the program does not depend on the config file.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">load-config!</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">read-env-vars</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">coerce-config</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">set-config!</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Make it so the data source can be specified using a parameter. For example, <code class="language-plaintext highlighter-rouge">:source "/path/to/config.json"</code> means read the file, and <code class="language-plaintext highlighter-rouge">:source :env</code> means environment variables.</p>

<p>An even more difficult problem is how to read both sources and combine them? Is the order important, and how to ensure it? How to combine maps asymmetrically, that is, when the second map only replaces the fields of the first one but does not add new fields?</p>

<h3 id="inference-of-structure">Inference of Structure</h3>

<p>It rarely happens that a configuration is a flat dictionary. Parameters related by their meaning are placed in nested dictionaries; for example, server and database fields are separate. When the settings are in a group, they are easier to maintain. A good example is splitting config into pieces using <code class="language-plaintext highlighter-rouge">{:keys [db server]}</code> syntax. Each component of the system accepts the part of the same name as a mini config.</p>

<p>Let’s improve our loader: we will teach it to read nested variables. Let’s agree that double underscore means a level change. We’ll put the following variables
in the <code class="language-plaintext highlighter-rouge">ENV_NEST</code> file:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">DB__NAME</span><span class="o">=</span>book
<span class="nv">DB__USER</span><span class="o">=</span>ivan
<span class="nv">DB__PASS</span><span class="o">=</span><span class="k">****</span>
<span class="nv">HTTP__PORT</span><span class="o">=</span>8080
<span class="nv">HTTP__HOST</span><span class="o">=</span>api.random.com
</code></pre></div></div>

<p>Now read it and start the REPL with the new environment:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">set</span> <span class="nt">-a</span>
<span class="nv">$ </span><span class="nb">source </span>ENV_NEST
<span class="nv">$ </span>lein repl
</code></pre></div></div>

<p>Let’s change the parsing of the environment. The <code class="language-plaintext highlighter-rouge">remap--key--nest</code> function takes a string key and returns a vector of its constituent parts (lexemes):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-key-nest</span><span class="w">
  </span><span class="p">[</span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="nb">key</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">key</span><span class="w">
      </span><span class="n">str/lower-case</span><span class="w">
      </span><span class="p">(</span><span class="nf">str/replace</span><span class="w"> </span><span class="o">#</span><span class="s">"_"</span><span class="w"> </span><span class="s">"-"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="o">#</span><span class="s">"--"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">keyword</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">remap-key-nest</span><span class="w"> </span><span class="s">"DB__PORT"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; (:db :port)</span><span class="w">
</span></code></pre></div></div>

<p>Now we change the function that builds a map. For each name, we will get a vector of lexemes. Let’s add a value with <code class="language-plaintext highlighter-rouge">assoc-in</code> that produces a nested structure.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-env-nest</span><span class="w">
  </span><span class="p">[</span><span class="n">env</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">acc</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]]</span><span class="w">
     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">key-path</span><span class="w"> </span><span class="p">(</span><span class="nf">remap-key-nest</span><span class="w"> </span><span class="n">k</span><span class="p">)]</span><span class="w">
       </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="n">key-path</span><span class="w"> </span><span class="n">v</span><span class="p">)))</span><span class="w">
   </span><span class="p">{}</span><span class="w">
   </span><span class="n">env</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The code below will return the parameters grouped as expected. Here is a subset of them:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">remap-env-nest</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">select-keys</span><span class="w"> </span><span class="p">[</span><span class="no">:db</span><span class="w"> </span><span class="no">:http</span><span class="p">]))</span><span class="w">

</span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="s">"ivan"</span><span class="n">,</span><span class="w"> </span><span class="no">:pass</span><span class="w"> </span><span class="s">"****"</span><span class="n">,</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"book"</span><span class="p">}</span><span class="n">,</span><span class="w">
 </span><span class="no">:http</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="s">"8080"</span><span class="n">,</span><span class="w"> </span><span class="no">:host</span><span class="w"> </span><span class="s">"api.random.com"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Then we act as usual: write a spec, infer types from strings, and so on.</p>

<p>Think about setting an array in a variable. How to separate array elements? When is false splitting possible, and how to prevent it?</p>

<h2 id="simple-configuration-manager">Simple configuration manager</h2>

<p>At this point, you might decide that config in a file is a bad idea. However, don’t rush to rewrite your code with environment variables. In practice, <em>hybrid</em> models are used combining both approaches. The application reads basic parameters from a file, but passwords and API keys from the environment.</p>

<p>Let’s look at how to use both files and environments. A naive solution doesn’t require you to write any code: it runs on command-line utilities. The <code class="language-plaintext highlighter-rouge">envsubst</code> program from the “GNU gettext” package provides a simple templating system. To install <code class="language-plaintext highlighter-rouge">gettext</code>, run the command in a terminal:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>&lt;manager&gt; <span class="nb">install </span>gettext,
</code></pre></div></div>

<p>, where <code class="language-plaintext highlighter-rouge">&lt;manager&gt;</code> is your system’s package utility (<code class="language-plaintext highlighter-rouge">brew</code>, <code class="language-plaintext highlighter-rouge">apt</code>, <code class="language-plaintext highlighter-rouge">yum</code>, and others).</p>

<p>The template text comes from <code class="language-plaintext highlighter-rouge">stdin</code>, and the environment variables are the context. The utility replaces the <code class="language-plaintext highlighter-rouge">$VAR_NAME</code> expressions with the values of the same name variable. Let’s put the template into the <code class="language-plaintext highlighter-rouge">config.tpl.json</code> file. The “tpl” part means a template.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"server_port"</span><span class="p">:</span><span class="w"> </span><span class="err">$HTTP_PORT</span><span class="p">,</span><span class="w">
    </span><span class="nl">"db"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"dbtype"</span><span class="p">:</span><span class="w">   </span><span class="s2">"mysql"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"dbname"</span><span class="p">:</span><span class="w">   </span><span class="s2">"$DB_NAME"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"user"</span><span class="p">:</span><span class="w">     </span><span class="s2">"$DB_USER"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"password"</span><span class="p">:</span><span class="w"> </span><span class="s2">"$DB_PASS"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"event"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"$EVENT_START"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"$EVENT_END"</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Note that the server port is not quoted because it is a number (line 2). Now we create an env <code class="language-plaintext highlighter-rouge">ENV_VARS</code> file with the following content:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>ENV_VARS
<span class="nv">DB_NAME</span><span class="o">=</span>book
<span class="nv">DB_USER</span><span class="o">=</span>ivan
<span class="nv">DB_PASS</span><span class="o">=</span><span class="s1">'secret123'</span>
<span class="nv">HTTP_PORT</span><span class="o">=</span>8080
<span class="nv">EVENT_START</span><span class="o">=</span><span class="s1">'2019-07-05T12:00:00'</span>
<span class="nv">EVENT_END</span><span class="o">=</span><span class="s1">'2019-07-12T23:59:59'</span>
</code></pre></div></div>

<p>Let’s read them and render the template:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">source </span>ENV_VARS
<span class="nv">$ </span><span class="nb">cat </span>config.tpl.json | envsubst
</code></pre></div></div>

<p>The substitution was successful:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"server_port"</span><span class="p">:</span><span class="w"> </span><span class="mi">8080</span><span class="p">,</span><span class="w">
    </span><span class="nl">"db"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"dbtype"</span><span class="p">:</span><span class="w">   </span><span class="s2">"mysql"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"dbname"</span><span class="p">:</span><span class="w">   </span><span class="s2">"book"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"user"</span><span class="p">:</span><span class="w">     </span><span class="s2">"ivan"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"password"</span><span class="p">:</span><span class="w"> </span><span class="s2">"*(&amp;fd}A53z#$!"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"event"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"2019-07-05T12:00:00"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"2019-07-12T23:59:59"</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>To write the result to a file, add an output statement to the end:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>config.tpl.json | envsubst <span class="o">&gt;</span> config.ready.json
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">envsubst</code> method seems primitive, but it is useful in practice. The template frees you from worries about the structure: variables are in the right places, so no trouble with nesting.</p>

<p>Sometimes an application requires multiple config files, including one for infrastructure. You need to specify the same parameter in different files to make the programs work in concert. For example, Nginx requires a web server port for proxying. In Sendmail, you need to specify the same email address as in the application. It goes without saying that there should be a single data source, and a template render can be such a source.</p>

<p>The <code class="language-plaintext highlighter-rouge">envsubst</code> utility becomes the configuration manager. To automate the process, add a script that runs templates and renders them based on variables. It is not an enterprise-level solution, but it is suitable for simple projects.</p>

<h2 id="reading-the-environment-from-config">Reading the Environment from Config</h2>

<p>The following techniques make an application read parameters from file and environment simultaneously. The difference is at what step it happens.</p>

<p>Suppose we put the main parameters in a file, and the password for the database comes from the environment. Since such solutions are team-wide, agree among yourselves that the <code class="language-plaintext highlighter-rouge">password</code> field contains not a password, but a variable name, for example, <code class="language-plaintext highlighter-rouge">"DB_PASS"</code>. Let’s write a spec that infers the variable value by its name:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;env</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">varname</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="n">varname</span><span class="p">)</span><span class="w"> </span><span class="no">::s/invalid</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>If the variable is not set, the output will return an error. For more control, remove the white space around the edges and make sure the string is not empty.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::db-password</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w"> </span><span class="no">::-&gt;env</span><span class="w">
         </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">str/trim</span><span class="p">)</span><span class="w">
         </span><span class="n">not-empty</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>A quick test: run the REPL with the <code class="language-plaintext highlighter-rouge">DB_PASS</code> variable and read it using the spec:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">DB_PASS</span><span class="o">=</span><span class="s1">'secret123'</span> lein repl

<span class="o">(</span>s/conform ::db-password <span class="s2">"DB_PASS"</span><span class="o">)</span>
<span class="s2">"secret123"</span>
</code></pre></div></div>

<p>To move a field out of the file to the environment, replace its value with the variable name. Update the spec for this field: add <code class="language-plaintext highlighter-rouge">::-&gt;env</code> to the beginning of the <code class="language-plaintext highlighter-rouge">s/and</code> chain.</p>

<p>Another way to read variables from a file is to expand it with tags. A tag is a short word that indicates that the meaning behind it is read in a certain way. YAML and EDN formats support tags. Libraries offer several basic ones for them. You can easily add your own tag.</p>

<p>In EDN, a tag starts with a hash sign and captures the next value. For example, <code class="language-plaintext highlighter-rouge">#inst "2019-07-10"</code> converts a string to a date. The tag is associated with a single argument function that finds a value from the initial one. To set your tag, pass a special map to the <code class="language-plaintext highlighter-rouge">clojure.edn/read-string</code> function. Its keys are symbols, and values are functions.</p>

<p>Add the <code class="language-plaintext highlighter-rouge">#env</code> tag that will return the value of the variable by name. The name can be a string or a symbol. Let’s define a function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tag-env</span><span class="w">
  </span><span class="p">[</span><span class="n">varname</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="n">varname</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="p">(</span><span class="nb">name</span><span class="w"> </span><span class="n">varname</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">varname</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="n">varname</span><span class="p">)</span><span class="w">
    </span><span class="no">:else</span><span class="w">
    </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="s">"Wrong variable type"</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Now we’ll read the EDN line with the new tag:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.edn</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">edn</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">edn/read-string</span><span class="w"> </span><span class="p">{</span><span class="no">:readers</span><span class="w"> </span><span class="p">{</span><span class="ss">'env</span><span class="w"> </span><span class="n">tag-env</span><span class="p">}}</span><span class="w">
                 </span><span class="s">"{:db-password #env DB_PASS}"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; {:db-password "secret123"}</span><span class="w">
</span></code></pre></div></div>

<p>To avoid passing the tags every time, let’s prepare the <code class="language-plaintext highlighter-rouge">read-config</code> function “charged” with the tags. We build it using <code class="language-plaintext highlighter-rouge">partial</code>. The new function accepts only a string:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">read-config</span><span class="w">
  </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">edn/read-string</span><span class="w">
           </span><span class="p">{</span><span class="no">:readers</span><span class="w"> </span><span class="p">{</span><span class="ss">'env</span><span class="w"> </span><span class="n">tag-env</span><span class="p">}}))</span><span class="w">
</span></code></pre></div></div>

<p>To parse a file with tags, read it into a string and pass it to <code class="language-plaintext highlighter-rouge">read-config</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"/path/to/config.edn"</span><span class="w">
    </span><span class="nb">slurp</span><span class="w">
    </span><span class="n">read-config</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>YAML tags start with one or two exclamation marks, depending on the semantics. Standard tags have two marks, while third-party tags have one. This way, when we run into a tag, we immediately understand its semantics.</p>

<p>The Yummy library offers a YAML parser that has useful tags. Among others, we are interested in the <code class="language-plaintext highlighter-rouge">!envvar</code> tag, which returns the value of a variable by name. Let’s describe the configuration in the <code class="language-plaintext highlighter-rouge">config.yaml</code> file:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">server_port</span><span class="pi">:</span> <span class="m">8080</span>
<span class="na">db</span><span class="pi">:</span>
  <span class="na">dbtype</span><span class="pi">:</span>   <span class="s">mysql</span>
  <span class="na">dbname</span><span class="pi">:</span>   <span class="s">book</span>
  <span class="na">user</span><span class="pi">:</span>     <span class="kt">!envvar</span> <span class="s">DB_USER</span>
  <span class="na">password</span><span class="pi">:</span> <span class="kt">!envvar</span> <span class="s">DB_PASS</span>
</code></pre></div></div>

<p>Let’s add the library and read the file. In place of the tags, we get the environment values:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">yummy.config</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">yummy</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">yummy/load-config</span><span class="w"> </span><span class="p">{</span><span class="no">:path</span><span class="w"> </span><span class="s">"config.yaml"</span><span class="p">})</span><span class="w">

</span><span class="p">{</span><span class="no">:server_port</span><span class="w"> </span><span class="mi">8080</span><span class="w">
 </span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"mysql"</span><span class="w">
      </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"book"</span><span class="w">
      </span><span class="no">:user</span><span class="w"> </span><span class="s">"ivan"</span><span class="w">
      </span><span class="no">:password</span><span class="w"> </span><span class="s">"*(&amp;fd}A53z#$!"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>We’ll take a closer look at Yummy in the next section of the chapter.</p>

<p>Tags have both advantages and disadvantages. On the one hand, they make the config more concise: a line with a tag makes more sense. An expression like <code class="language-plaintext highlighter-rouge">#env DB_PASS</code> is shorter and more pleasing to the eye. Some libraries provide tags for complex types and classes.</p>

<p>On the other hand, tags make a config platform-specific. For example, the Python library fails to read the <code class="language-plaintext highlighter-rouge">!envvar</code> tag in the YAML file because this library does not have such a tag (more precisely, it does, but with a different name). Technically, this can be fixed: skip unfamiliar tags or install a stub. However, the approach does not guarantee the same results across platforms.</p>

<p>With tags, a config is overgrown with side effects. In functional programming terms, it loses its purity. It is tempting to move too much logic into a tag: include a child file, format strings. Tags blur the line between reading a config and processing it. When there are too many of them, the configuration is difficult to maintain.</p>

<p>These techniques — parsing with spec and tags — are opponents. Choose the method that is convenient for the team and process.</p>

<h2 id="overview-of-formats">Overview of Formats</h2>

<p>We have mentioned three data formats: JSON, EDN, and YAML. Let’s run through the features of each of them.  Our goal is not to identify the ideal format but to prepare you for the unobvious moments that arise while working with these formats.</p>

<h3 id="json">JSON</h3>

<p>Even non-web developers are familiar with JSON. It is a data format based on JavaScript syntax. The standard’s basic types are numbers, strings, boolean, null, and two collections – an array and object, which is considered as a map. The collections can be nested within each other.</p>

<p>The advantage of JSON is its popularity. Today it is the standard for exchanging data between client and server.  It is easier to read and maintain than XML. Today’s editors, languages, and platforms work with JSON. It is the natural way to store data in JavaScript.</p>

<p>But JSON does not provide an opportunity to comment. At first glance, this is a trifle, but in practice, comments are important to us. If you have added a new parameter, you should write a comment about what it does and what values it takes. Look at Redis, PostgreSQL, or Nginx configurations – more than half of the file are comments.</p>

<p>Developers have come up with tricks to get around this limitation in JSON.  For example, put the same name field in front of the one to which the comment relates:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"server_port"</span><span class="p">:</span><span class="w"> </span><span class="s2">"A port for the HTTP server."</span><span class="p">,</span><span class="w">
    </span><span class="nl">"server_port"</span><span class="p">:</span><span class="w"> </span><span class="mi">8080</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>We expect the library to walk through the fields in turn, and the second field will replace the first. The JSON standard does not specify the order of the fields, so proceed at your own risk. The library logic can be different, for example, to throw an exception or skip an already processed key.</p>

<p>Some programs carry their own JSON parser that supports comments. For example, Sublime Text editor stores settings in <code class="language-plaintext highlighter-rouge">.json</code> files with JavaScript comments (double slash). But there is no general solution to the problem.</p>

<p>The format does not support the tags we talked about above. There are <a href="https://github.com/dakrone/cheshire">Cheshire</a> and <a href="https://github.com/clojure/data.json">Data.json</a> libraries to work with JSON in Clojure. Both of them provide two main functions: to read and write a document. You will find detailed examples in GitHub pages of the projects.</p>

<p>JSON compares favorably with the verbose XML it replaces. JSON data looks cleaner and more convenient than a tag tree.  But more modern formats express data even more clearly. In YAML, you can express any structure without a single bracket, thanks to indentation.</p>

<p>JSON syntax is noisy: it requires quotes, colons, and commas where other formats do without them. A comma at the end of an array or object is considered an error. Map keys must not be numbers. It is not allowed to write text on multiple lines.</p>

<p>Compare data in JSON and YAML (on the right). The YAML entry is shorter and visually better perceived:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"server_port"</span><span class="p">:</span><span class="w"> </span><span class="mi">8080</span><span class="p">,</span><span class="w">
    </span><span class="nl">"db"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"dbtype"</span><span class="p">:</span><span class="w">   </span><span class="s2">"mysql"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"dbname"</span><span class="p">:</span><span class="w">   </span><span class="s2">"book"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"user"</span><span class="p">:</span><span class="w">     </span><span class="s2">"ivan"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"password"</span><span class="p">:</span><span class="w"> </span><span class="s2">"****"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"event"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"2019-07-05T12:00:00"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"2019-07-12T23:59:59"</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>vs</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">server_port</span><span class="pi">:</span> <span class="m">8080</span>
<span class="na">db</span><span class="pi">:</span>
  <span class="na">dbtype</span><span class="pi">:</span>   <span class="s">mysql</span>
  <span class="na">dbname</span><span class="pi">:</span>   <span class="s">book</span>
  <span class="na">user</span><span class="pi">:</span>     <span class="s">user</span>
  <span class="na">password</span><span class="pi">:</span> <span class="s1">'</span><span class="s">****'</span>
<span class="na">event</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">2019-07-05T12:00:00</span>
  <span class="pi">-</span> <span class="s">2019-07-12T23:59:59</span>
</code></pre></div></div>

<h3 id="yaml">YAML</h3>

<p>The YAML language, like JSON, has basic types: scalars, null, and collections. YAML focuses on code conciseness: it sets the nesting using indents rather than brackets. Commas are optional where they might be guessed by parser.  An array of numbers written to a line looks like in JSON:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">numbers</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">1</span><span class="pi">,</span> <span class="nv">2</span><span class="pi">,</span> <span class="nv">3</span><span class="pi">]</span>
</code></pre></div></div>

<p>But for columns, commas and square brackets disappear:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">numbers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="m">1</span>
  <span class="pi">-</span> <span class="m">2</span>
  <span class="pi">-</span> <span class="m">3</span>
</code></pre></div></div>

<p>DevOps engineers like YAML because it supports Python-style comments (with hashes). Programs like Docker-compose and Kubernetes use YAML for configuration.</p>

<p>YAML allows you to write text across multiple lines. It is easier to read and copy than a single line with a newline character <code class="language-plaintext highlighter-rouge">\n</code>.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">description</span><span class="pi">:</span> <span class="pi">|</span>
  <span class="s">To solve the problem, please do the following:</span>

  <span class="s">- Press Control + Alt + Delete;</span>
  <span class="s">- Turn off your computer;</span>
  <span class="s">- Walk for a while.</span>

  <span class="s">Then try again.</span>
</code></pre></div></div>

<p>The language officially supports tags.</p>

<p>The cons of YAML stem from its pros. Indentation seems to be a good solution until the file gets too large. The gaze hops across the file to check if the structure levels are correct. Sometimes part of the data steps to the wrong level due to an unnecessary indent. In terms of YAML, there is no error, so it’s hard to find it.</p>

<p>Sometimes, missing quotes will result in incorrect types or structure. Suppose the <code class="language-plaintext highlighter-rouge">phrases</code> field lists phrases that a user will see:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">phrases</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Welcome!</span>
  <span class="pi">-</span> <span class="s">See you soon!</span>
  <span class="pi">-</span> <span class="na">Warning</span><span class="pi">:</span> <span class="s">wrong email address.</span>
</code></pre></div></div>

<p>Because of the colon in the last line, the parser will think it is a nested map (pay attention to syntax highlighting). As a result, we get the wrong structure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:phrases</span><span class="w"> </span><span class="p">[</span><span class="s">"Welcome!"</span><span class="w">
           </span><span class="s">"See you soon!"</span><span class="w">
           </span><span class="p">{</span><span class="no">:Warning</span><span class="w"> </span><span class="s">"wrong email address."</span><span class="p">}]}</span><span class="w">
</span></code></pre></div></div>

<p>Other examples: product version <code class="language-plaintext highlighter-rouge">3.3</code> is a number, but <code class="language-plaintext highlighter-rouge">3.3.1</code> is a string. Phone <code class="language-plaintext highlighter-rouge">+79625241745</code> is a number because the plus sign is considered a unary operator by analogy with the minus. Leading zeros mean octal notation, so if you don’t add quotes to <code class="language-plaintext highlighter-rouge">000042</code>, you’ll get <code class="language-plaintext highlighter-rouge">34</code>.</p>

<p>This does not mean that YAML is a failed format. The cases above are described in the documentation and have a logical explanation. But sometimes YAML doesn’t behave the way you expect – it’s a price to pay for a simplified syntax.</p>

<h3 id="edn">EDN</h3>

<p>The EDN format occupies a special place in our review. It is as close as possible to Clojure and therefore plays the same role in the language as JSON in JavaScript. It is a Clojure-native way to associate data with a file.</p>

<p>EDN syntax is almost identical to the language grammar. The format covers more types than JSON and YAML. It contains scalars such as symbols and keywords (the <code class="language-plaintext highlighter-rouge">Symbol</code> and <code class="language-plaintext highlighter-rouge">Keyword</code> classes from the <code class="language-plaintext highlighter-rouge">clojure.lang</code> package). In addition to vectors and maps, EDN offers lists and sets. Maps can be typed to allow creating <code class="language-plaintext highlighter-rouge">defrecord</code> instances upon reading. We will talk more about entries in the chapter on systems.</p>

<p>A tag starts with a hash character. The standard offers two tags by default: <code class="language-plaintext highlighter-rouge">#inst</code> and <code class="language-plaintext highlighter-rouge">#uuid</code>. The former reads a string into a date and the latter into a <code class="language-plaintext highlighter-rouge">java.util.UUID</code> instance. Above, we showed how to add your own tag: you need to bind it to a one-argument function when reading a line.</p>

<p>Here’s an example with different types, collections, and tags:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:user/banned?</span><span class="w"> </span><span class="n">false</span><span class="w">
 </span><span class="no">:task-state</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:pending</span><span class="w"> </span><span class="no">:in-progress</span><span class="w"> </span><span class="no">:done</span><span class="p">}</span><span class="w">
 </span><span class="no">:account-ids</span><span class="w"> </span><span class="p">[</span><span class="mi">1001</span><span class="w"> </span><span class="mi">1002</span><span class="w"> </span><span class="mi">1003</span><span class="p">]</span><span class="w">
 </span><span class="no">:server</span><span class="w"> </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w"> </span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="p">}</span><span class="w">
 </span><span class="no">:date-range</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019-07-01"</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019-07-31"</span><span class="p">]</span><span class="w">
 </span><span class="no">:cassandra-id</span><span class="w"> </span><span class="o">#</span><span class="n">uuid</span><span class="w"> </span><span class="s">"26577362-902e-49e3-83fb-9106be7f60e1"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>In EDN, data does not differ from code. If you copy them to the REPL or a module, the compiler will execute them. Conversely, the REPL output can be written to a file for further work.</p>

<p>Saving data to EDN means to bake them into a string a write to a file. The function <code class="language-plaintext highlighter-rouge">pr-str</code> returns a string which would appear in console if you would print an object. The code below creates a file <code class="language-plaintext highlighter-rouge">dataset.edn</code> with the data:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:some</span><span class="w"> </span><span class="p">[</span><span class="s">"data"</span><span class="p">]}</span><span class="w">
    </span><span class="p">(</span><span class="nb">pr-str</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="s">"dataset.edn"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The opposite action is to read the file and parse the code in Clojure using <code class="language-plaintext highlighter-rouge">edn/read-string</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.edn</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">edn</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"dataset.edn"</span><span class="w"> </span><span class="nb">slurp</span><span class="w"> </span><span class="n">edn/read-string</span><span class="p">)</span><span class="w">
</span><span class="c1">;; {:some ["data"]}</span><span class="w">
</span></code></pre></div></div>

<p>(ignoring)}</p>

<p>EDN supports more than just regular comments. The <code class="language-plaintext highlighter-rouge">#_</code> tag ignores any item following it, including the collection. If you need to “ignore” a map that spans several lines, put <code class="language-plaintext highlighter-rouge">#_</code> in front of it, and the parser will skip it.</p>

<p>(comments)}</p>

<p>This way, you can disable entire sections of the configuration. In the following example, we ignore the third element of the vector. If you put a regular comment (semicolon) on a line, it would affect the closing brackets, and the expression will become invalid.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:users</span><span class="w"> </span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}</span><span class="w">
         </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Juan"</span><span class="p">}</span><span class="w">
         </span><span class="o">#</span><span class="n">_</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Huan"</span><span class="p">}]}</span><span class="w">
</span></code></pre></div></div>

<p>EDN is closely related to Clojure and, therefore, is not popular in other languages. Editors don’t highlight its syntax without plugins. EDN will provide challenges for DevOps engineers who mostly work with JSON and YAML. If your configuration is precessed with Python or Ruby scripts, you will have to install a library to work with EDN format.</p>

<p>Choose EDN where Clojure prevails over other technologies. It is the right choice when both the backend and the frontend run on the same Clojure(Script) stack.</p>

<h2 id="industrial-solutions">Industrial Solutions</h2>

<p>Configuration is significant to understand, but we don’t encorouge you to write it from scratch every time you run a new project. In the final section, we’ll take a look at what does the community provides for configuration handling. We’ll focus on Cprop, Aero, and Yummy. These libraries differ in ideology and architecture. We have specially selected them to see the problem from different angles.</p>

<h3 id="cprop">Cprop</h3>

<p>The <a href="https://github.com/tolitius/cprop">Cprop</a> library works on the principle of “data from everywhere”. Unlike our loader, Cprop understands more sources. The library can read not only a file and environment variables but also resources, property files, and ordinary maps.</p>

<p>The library has a preset order of walking through sources and their priority. Fields from one source replace others. For example, environment variables are considered more important than a file. In Cprop, you can easily set your own loading order for special cases.</p>

<p>We are interested in the <code class="language-plaintext highlighter-rouge">load-config</code> function. If you call it without any parameters, it will start the standard loader. By default, it looks for two data sources: a resource and a property file. This resource must be named <code class="language-plaintext highlighter-rouge">config.edn</code>. If the system property <code class="language-plaintext highlighter-rouge">conf</code> is not empty, the library assumes that this is the property file path and loads it.</p>

<p>Properties are Java runtime variables, similar to the system environment. When loaded, JVM receives the default properties: operating system type, line separator, and others. Additional properties are set with the <code class="language-plaintext highlighter-rouge">-D</code> parameter when starting. The example below runs a jar file with a <code class="language-plaintext highlighter-rouge">conf</code> property:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>java <span class="nt">-Dconf</span><span class="o">=</span><span class="s2">"/path/to/config.properties"</span> <span class="nt">-jar</span> project.jar
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">.properties</code> files are <code class="language-plaintext highlighter-rouge">field=value</code> pairs, one per line. Fields are like domains: they are lexemes separated by dots. Lexemes follow in descending order of priority:</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">db.type</span><span class="p">=</span><span class="s">mysql</span>
<span class="py">db.host</span><span class="p">=</span><span class="s">127.0.0.1</span>
<span class="py">db.pool.connections</span><span class="p">=</span><span class="s">8</span>
</code></pre></div></div>

<p>The library treats dots as nested maps. The file above will return the following structure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="s">"mysql"</span><span class="w">
      </span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
      </span><span class="no">:pool</span><span class="w"> </span><span class="p">{</span><span class="no">:connections</span><span class="w"> </span><span class="mi">8</span><span class="p">}}}</span><span class="w">
</span></code></pre></div></div>

<p>After receiving the configuration, Cprop looks for overriding in the environment variables. For example, the variable <code class="language-plaintext highlighter-rouge">DB__POOL__CONNECTIONS=16</code> will replace the value 8 in the nested map. Cprop ignores variables that are not part of the config and thus keeps it tidy.</p>

<p>Non-standard paths to the resource and file are specified with the keys:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w">
 </span><span class="no">:resource</span><span class="w"> </span><span class="s">"private/config.edn"</span><span class="w">
 </span><span class="no">:file</span><span class="w"> </span><span class="s">"/path/custom/config.edn"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>For delicate work, Cprop offers the <code class="language-plaintext highlighter-rouge">cprop.source</code> module. Its <code class="language-plaintext highlighter-rouge">from-env</code> function reads all environment variables, and <code class="language-plaintext highlighter-rouge">from-props-file</code> loads the property file, and so on. It is easy to build the combination that the project needs using the module.</p>

<p>The <code class="language-plaintext highlighter-rouge">:merge</code> key unites the config with any source. The former holds a sequence of expressions that will return a map. Here is a detailed example from documentation:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w">
 </span><span class="no">:resource</span><span class="w"> </span><span class="s">"path/within/classpath/to.edn"</span><span class="w">
 </span><span class="no">:file</span><span class="w"> </span><span class="s">"/path/to/some.edn"</span><span class="w">
 </span><span class="no">:merge</span><span class="w"> </span><span class="p">[{</span><span class="no">:datomic</span><span class="w"> </span><span class="p">{</span><span class="no">:url</span><span class="w"> </span><span class="s">"datomic:mem://test"</span><span class="p">}}</span><span class="w">
         </span><span class="p">(</span><span class="nf">from-file</span><span class="w"> </span><span class="s">"/path/to/another.edn"</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">from-resource</span><span class="w"> </span><span class="s">"path/within/classpath/to-another.edn"</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">from-props-file</span><span class="w"> </span><span class="s">"/path/to/some.properties"</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">from-system-props</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">from-env</span><span class="p">)])</span><span class="w">
</span></code></pre></div></div>

<p>To track loading, set the <code class="language-plaintext highlighter-rouge">DEBUG=y</code> environment variable. With it, Cprop displays service information: a list of sources, loading order, overrides, and so on.</p>

<p>Cprop only reads data from sources but doesn’t validate it. There is no validation with a spec in the library, as it is done in our loader. The step is up to you.</p>

<p>The library casts types its own way. If the string contains only digits, it is converted to a number. Comma-separated values become lists. Sometimes these rules are not enough for complete type control. Thus, Spec and <code class="language-plaintext highlighter-rouge">s/conform</code> are still useful for error reporting and type inference.</p>

<h3 id="aero">Aero</h3>

<p><a href="https://github.com/juxt/aero">Aero</a> works with EDN files. The library offers tags, making the format look like a mini-programming language. Branching, import, formatting operators appear in it. This approach can be figuratively called “EDN on steroids”.</p>

<p>The <code class="language-plaintext highlighter-rouge">read-config</code> function reads an EDN file or resource:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">aero.core</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">(</span><span class="nf">read-config</span><span class="p">)])</span><span class="w">

</span><span class="p">(</span><span class="nf">read-config</span><span class="w"> </span><span class="s">"config.edn"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">read-config</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.java.io/resource</span><span class="w"> </span><span class="s">"config.edn"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Tags are the main point in Aero, so let’s take a look at the main ones. The familiar <code class="language-plaintext highlighter-rouge">#env</code> one discovers the value of a variable by its name:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:passwod</span><span class="w"> </span><span class="o">#</span><span class="n">env</span><span class="w"> </span><span class="n">DB_PASS</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">#envf</code> tag formats a string using environment variables. Let’s say the connection to the database consists of separate fields, but you prefer the JDBC URI, a long string that looks like a web address. In order not to duplicate data, the address is composed from the original fields:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db-uri</span><span class="w"> </span><span class="o">#</span><span class="n">envf</span><span class="w"> </span><span class="p">[</span><span class="s">"jdbc:postgresql://%s/%s?user=%s"</span><span class="w">
                </span><span class="n">DB_HOST</span><span class="w"> </span><span class="n">DB_NAME</span><span class="w"> </span><span class="n">DB_USER</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">#or</code> tag is similar to its Clojure counterpart and is needed for default values. Suppose no database port is specified in the file. In this case, let’s specify the standard PostgreSQL port:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="o">#</span><span class="nb">or</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="n">env</span><span class="w"> </span><span class="n">DB_PORT</span><span class="w"> </span><span class="mi">5432</span><span class="p">]}}</span><span class="w">
</span></code></pre></div></div>

<p>Pay attention, the value for the tag is always a vector or a list. Also, the example above introduces nested tags (<code class="language-plaintext highlighter-rouge">#env</code> inside <code class="language-plaintext highlighter-rouge">#or</code>).</p>

<p>The <code class="language-plaintext highlighter-rouge">#profile</code> tag allows you to find the value by profile. The value behind the tag must be a map. The map key is the profile, and the value is what we get as a result of its discovery. The profile is set in parameters of <code class="language-plaintext highlighter-rouge">read-config</code>.</p>

<p>The example below shows how to find the database name by profile. Without a profile, we get the “book” name, but for <code class="language-plaintext highlighter-rouge">:test</code>, it becomes “book_test”.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="o">#</span><span class="n">profile</span><span class="w"> </span><span class="p">{</span><span class="no">:default</span><span class="w"> </span><span class="s">"book"</span><span class="w">
                      </span><span class="no">:dev</span><span class="w">     </span><span class="s">"book_dev"</span><span class="w">
                      </span><span class="no">:test</span><span class="w">    </span><span class="s">"book_test"</span><span class="p">}}}</span><span class="w">

</span><span class="p">(</span><span class="nf">read-config</span><span class="w"> </span><span class="s">"aero.test.edn"</span><span class="w"> </span><span class="p">{</span><span class="no">:profile</span><span class="w"> </span><span class="no">:test</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"book_test"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">#include</code> tag puts another EDN file in the config. The file can also contain tags, and the library will execute them recursively. We use imports when the configuration becomes too large or there is a need to share its parts across multiple projects.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:queue</span><span class="w"> </span><span class="o">#</span><span class="n">include</span><span class="w"> </span><span class="s">"message-queue.edn"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">#ref</code> tag refers to any part of the configuration file. It is a vector of keys that is usually passed to <code class="language-plaintext highlighter-rouge">get-in</code>. A reference will allow you to avoid duplication. For example, a background task component needs the user we specified for the database. In order not to copy it, let’s put the link:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; config.edn</span><span class="w">
</span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="o">#</span><span class="n">env</span><span class="w"> </span><span class="n">DB_USER</span><span class="p">}</span><span class="w">
 </span><span class="no">:worker</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="o">#</span><span class="nb">ref</span><span class="w"> </span><span class="p">[</span><span class="no">:db</span><span class="w"> </span><span class="no">:user</span><span class="p">]}}</span><span class="w">
</span></code></pre></div></div>

<p>When reading a file, the link resolves to the value:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="s">"ivan"</span><span class="p">}</span><span class="n">,</span><span class="w"> </span><span class="no">:worker</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="s">"ivan"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Aero offers a simple configuration language. The library entices developers with the beauty of its idea and implementation. But the moment you feel like moving from inflexible JSON to Aero, think about the other side of the coin.</p>

<p>We do not accidentally separate config from code. If it weren’t for the industry’s need, we would store the parameters in the source files. But best practices, on the contrary, advise separating parameters from the code. This is also because, unlike code, the configuration is declarative.</p>

<p>Inflexible JSON files have an important feature: they are declarative. If you open a file or run <code class="language-plaintext highlighter-rouge">cat</code> on it, you will see the data. The syntax may be awkward, but data is self-explanatory, and there is only one way to read it.</p>

<p>On the contrary, a file with an abundance of tags is hard to read. It is not a config but code. To see the final data, you have to execute the file. When reading a file, your head runs a mini interpreter, which does not guarantee the correct result.</p>

<p>It turns out to be a kind of vicious circle: we moved the parameters into the config, added tags, and returned to the code. The approach has the right to exist, but you should choose it after weighing the pros and cons.</p>

<h3 id="yummy">Yummy</h3>

<p>The <a href="https://github.com/exoscale/yummy">Yummy</a> library closes the overview. It differs from the libraries discussed above in two ways. First, it works with YAML files to read a config (hence the name). Second, the loading process is similar to the one we covered at the beginning of the chapter.</p>

<p>A fully featured loader does more than just read parameters. The cycle includes data validation and error output. The message clearly explains the cause of the error. Using options, you can set a reaction to an exception that occurred while working. Yummy offers all of the above.</p>

<p>The file path either might be set with parameters, or the library searches for it according to special rules. Here’s an option when the path is explicitly set:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">yummy.config</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">load-config</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">load-config</span><span class="w"> </span><span class="p">{</span><span class="no">:path</span><span class="w"> </span><span class="s">"/path/to/config.yaml"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>In the second case, we specified the name of the project instead of the path. Yummy looks for the file path in the <code class="language-plaintext highlighter-rouge">&lt;project&gt;_CONFIGURATION</code> environment variable or the <code class="language-plaintext highlighter-rouge">&lt;project&gt;.configuration</code> property:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">export </span><span class="nv">BOOK_CONFIGURATION</span><span class="o">=</span>config.yaml
</code></pre></div></div>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w"> </span><span class="p">{</span><span class="no">:program-name</span><span class="w"> </span><span class="no">:book</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>The library extends YAML with several tags. One is the familiar <code class="language-plaintext highlighter-rouge">!envvar</code> for environment variables:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">db</span><span class="pi">:</span>
  <span class="na">password</span><span class="pi">:</span> <span class="kt">!envvar</span> <span class="s">DB_PASS</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">keyword!</code> tag is useful for converting a string to the keyword:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">states</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="kt">!keyword</span> <span class="s">task/pending</span>
  <span class="pi">-</span> <span class="kt">!keyword</span> <span class="s">task/in-progress</span>
  <span class="pi">-</span> <span class="kt">!keyword</span> <span class="s">task/done</span>
</code></pre></div></div>

<p>Here is the result:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:states</span><span class="w"> </span><span class="p">[</span><span class="no">:task/pending</span><span class="w"> </span><span class="no">:task/in-progress</span><span class="w"> </span><span class="no">:task/done</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">!uuid</code> tag is similar to the <code class="language-plaintext highlighter-rouge">#uuid</code> one for EDN; it returns the <code class="language-plaintext highlighter-rouge">java.util.UUID</code> object from a string:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">system-user</span><span class="pi">:</span> <span class="kt">!uuid</span> <span class="s">cb7aa305-997c-4d53-a61a-38e0d8628dbb</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">!slurp</code> tag reads the file, which is useful for encryption certificates. Their content is a long string that is inconvenient to store in a general configuration. The <code class="language-plaintext highlighter-rouge">:auth</code>, <code class="language-plaintext highlighter-rouge">:cert</code>, and <code class="language-plaintext highlighter-rouge">:pkey</code> keys will hold the contents of the files from the <code class="language-plaintext highlighter-rouge">certs</code> directory.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">tls</span><span class="pi">:</span>
  <span class="na">auth</span><span class="pi">:</span> <span class="kt">!slurp</span> <span class="s2">"</span><span class="s">certs/ca.pem"</span>
  <span class="na">cert</span><span class="pi">:</span> <span class="kt">!slurp</span> <span class="s2">"</span><span class="s">certs/cert.pem"</span>
  <span class="na">pkey</span><span class="pi">:</span> <span class="kt">!slurp</span> <span class="s2">"</span><span class="s">certs/key.pk8"</span>
</code></pre></div></div>

<p>To check the configuration, pass the spec key to the <code class="language-plaintext highlighter-rouge">load-config</code> parameters. When a key is specified, Yummy executes <code class="language-plaintext highlighter-rouge">s/assert</code> with the data from the file. If the validation returns false, an exception will float up. For better reading of spec validation reports, Yummy uses Expound.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w"> </span><span class="p">{</span><span class="no">:program-name</span><span class="w"> </span><span class="no">:book</span><span class="w">
              </span><span class="no">:spec</span><span class="w"> </span><span class="no">::config</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>An options map takes the <code class="language-plaintext highlighter-rouge">:die-fn</code> parameter. It is a function that will run if any stage fails. The function takes an exception and a label with a stage name.</p>

<p>If <code class="language-plaintext highlighter-rouge">:die-fn</code> is not specified, Yummy will call the default handler. It prints the text to <code class="language-plaintext highlighter-rouge">stderr</code> and exits the JVM with code 1. During the development phase, we do not want to terminate the REPL due to a config error. In an interactive session, our <code class="language-plaintext highlighter-rouge">die-fn</code> only prints the text and the error:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w">
 </span><span class="p">{</span><span class="no">:program-name</span><span class="w"> </span><span class="no">:book</span><span class="w">
  </span><span class="no">:spec</span><span class="w"> </span><span class="no">::config</span><span class="w">
  </span><span class="no">:die-fn</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="n">msg</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*out*</span><span class="w"> </span><span class="n">*err*</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))))})</span><span class="w">
</span></code></pre></div></div>

<p>In production mode, write the exception to the log and exit the program.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">load-config</span><span class="w">
 </span><span class="p">{</span><span class="no">:program-name</span><span class="w"> </span><span class="no">:book</span><span class="w">
  </span><span class="no">:spec</span><span class="w"> </span><span class="no">::config</span><span class="w">
  </span><span class="no">:die-fn</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="n">msg</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nf">log/error</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"Config error"</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nf">System/exit</span><span class="w"> </span><span class="mi">1</span><span class="p">))})</span><span class="w">
</span></code></pre></div></div>

<p>One note about the <code class="language-plaintext highlighter-rouge">s/assert</code> macro which Yummy uses for validation. This macro does not coerce values, as <code class="language-plaintext highlighter-rouge">s/conform</code> does, but only throws an exception. This is done on purpose: types are coerced by tags, and the spec only validates them.</p>

<h2 id="summary">Summary</h2>

<p>Let us briefly outline the main points of this chapter. The configuration is necessary for the project to go through the production stages: development, testing, release. At each step, the project is launched with different settings. This is not possible without configuration.</p>

<p>Loading configuration means reading data, infer types and validate values. In case of an error, a program displays a message and exits with an emergency code. It cannot continue working with invalid parameters.</p>

<p>Configuration sources can be a file, a resource, or environment variables. There are hybrid schemes when most of the data come from the file and secret fields from the environment.</p>

<p>Environment variables live in operating system memory. When there are many of these variables, we can place them in the ENV file. An application does not read it; this is done by a script that controls the app on the server. The application does not know where the variables come from.</p>

<p>The environment is a flat map. Variables store only text; there is no nesting or namespace in keys. Different systems have different conventions on how to extract a structure from a variable name. Dots, double underscores, or something else can be used.</p>

<p>Data formats differ in syntax and types. General-purpose formats define strings, numbers, maps, and lists. They are not very flexible, but they work everywhere. On the contrary, the platform-specific data format is closely tied to the platform but is unpopular in other languages.</p>

<p>Some formats support tags. Use them to describe complex types with primitives: strings and numbers. Tags are also helpful for pre-processing a document, for example, to import its nested parts. The danger of tags is: when there are too many, config turns into code.</p>

<p>Clojure offers several libraries for configuring applications. They differ in design and architecture, and each developer will find what they like. There is no definite answer to the question of which format or library is better. Choose what will solve your problem most cheaply.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментарии</center>

<div id="comments">
  
    <div id="comment-5793014365" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Norman Kabir,
            17th Mar 2022,
            <a href="#comment-5793014365">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Under Semantics, there's a typo:</p>
<p>This leads to the fact that even a <b>/sligh/ </b>change in the code will take hours to get in production.</p>
</div>
    </div>
  
    <div id="comment-5796713638" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            19th Mar 2022,
            <a href="#comment-5796713638">link</a>
            , <a href="#comment-5793014365">parent</a>
          </em>
        </small>
      </p>
      <div><p>Thank you, that was fixed.</p>
</div>
    </div>
  
</div>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/en/clj-book-config/">
    <input required name="captcha" type="hidden" value="5 &#215; 8">

    <div class="block">
        <span class="comment-form-label"><small>5 &#215; 8 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
