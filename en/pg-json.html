<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>PG2 release 0.1.6: rich JSON capabilities</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/en/pg-json">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">PG2 release 0.1.6: rich JSON capabilities</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2024-03-20T00:00:00+00:00">
        Mar 20, 2024
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/postgres/" rel="tag">postgres</a>, <a href="/tag/sql/" rel="tag">sql</a>, <a href="/tag/json/" rel="tag">json</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<p><a href="https://github.com/igrishaev/pg2">PG2 version 0.1.6</a> is out, and it ships various improvements to JSON(b)
handling.</p>

<h2>

    Table of Content

</h2>

<ul id="toc-item-pg2-json">
  <li><a href="#basic-usage" id="toc-item-pg2-json-basic-usage">Basic usage</a></li>
  <li><a href="#json-wrapper" id="toc-item-pg2-json-json-wrapper">Json Wrapper</a></li>
  <li><a href="#custom-object-mapper" id="toc-item-pg2-json-custom-object-mapper">Custom Object Mapper</a></li>
  <li><a href="#utility-pgjson-namespace" id="toc-item-pg2-json-utility-pgjson-namespace">Utility pg.json namespace</a>    <ul>
      <li><a href="#reading-json" id="toc-item-pg2-json-reading-json">Reading JSON</a></li>
      <li><a href="#writing-json" id="toc-item-pg2-json-writing-json">Writing JSON</a></li>
    </ul>
  </li>
  <li><a href="#ring-http-middleware" id="toc-item-pg2-json-ring-http-middleware">Ring HTTP middleware</a></li>
</ul>

<p>Postgres is amazing when dealing with JSON. There hardly can be a database that
serves it better. Unfortunately, Postgres clients never respect the JSON
feature, which is horrible. Take JDBC, for example: when querying a JSON(b)
value, you’ll get a dull <code class="language-plaintext highlighter-rouge">PGObject</code> which should be decoded manually. The same
applies to insertion: one cannot just pass a Clojure map or a vector. It should
be packed into the <code class="language-plaintext highlighter-rouge">PGObject</code> as well.</p>

<p>Of course, this can be automated by extending certain protocols. But it’s still
slow as it’s done on Clojure level (not Java), and it forces you to copy the
same code across projects.</p>

<p>Fortunately, PG2 supports JSON out from the box. If you query a JSON value,
you’ll get its Clojure counter-part: a map, a vector, etc. To insert a JSON
value to a table, you pass either a Clojure map or a vector. No additional steps
are required.</p>

<p>PG2 relies on <a href="https://github.com/metosin/jsonista">jsonista</a> library to handle JSON. At the moment of
writing, this is the fastest JSON library for Clojure. Jsonista uses a concept
of object mappers: objects holding custom rules to encode and decode values. You
can compose your own mapper with custom rules and pass it into the connection
config.</p>

<h2 id="basic-usage">Basic usage</h2>

<p>Let’s prepare a connection and a test table with a jsonb column:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">config</span><span class="w">
  </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
   </span><span class="no">:port</span><span class="w"> </span><span class="mi">10140</span><span class="w">
   </span><span class="no">:user</span><span class="w"> </span><span class="s">"test"</span><span class="w">
   </span><span class="no">:password</span><span class="w"> </span><span class="s">"test"</span><span class="w">
   </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"test"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/get-connection</span><span class="w"> </span><span class="n">config</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">pg/query</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"create table test_json (
  id serial primary key,
  data jsonb not null
)"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now insert a row:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pg/execute</span><span class="w"> </span><span class="n">conn</span><span class="w">
            </span><span class="s">"insert into test_json (data) values ($1)"</span><span class="w">
            </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">[{</span><span class="no">:some</span><span class="w"> </span><span class="p">{</span><span class="no">:nested</span><span class="w"> </span><span class="p">{</span><span class="no">:json</span><span class="w"> </span><span class="mi">42</span><span class="p">}}}]})</span><span class="w">
</span></code></pre></div></div>

<p>No need to encode a map manually nor wrap it into a sort of <code class="language-plaintext highlighter-rouge">PGObject</code>. Let’s
fetch the new row by id:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pg/execute</span><span class="w"> </span><span class="n">conn</span><span class="w">
            </span><span class="s">"select * from test_json where id = $1"</span><span class="w">
            </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">
             </span><span class="no">:first?</span><span class="w"> </span><span class="n">true</span><span class="p">})</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:some</span><span class="w"> </span><span class="p">{</span><span class="no">:nested</span><span class="w"> </span><span class="p">{</span><span class="no">:json</span><span class="w"> </span><span class="mi">42</span><span class="p">}}}}</span><span class="w">
</span></code></pre></div></div>

<p>Again, the JSON data returns as a Clojure map with no wrappers.</p>

<p>When using JSON with HoneySQL though, some circs are still needed. Namely, you
have to wrap a value with <code class="language-plaintext highlighter-rouge">[:lift ...]</code> as follows:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pgh/insert-one</span><span class="w"> </span><span class="n">conn</span><span class="w">
                </span><span class="no">:test_json</span><span class="w">
                </span><span class="p">{</span><span class="no">:data</span><span class="w"> </span><span class="p">[</span><span class="no">:lift</span><span class="w"> </span><span class="p">{</span><span class="no">:another</span><span class="w"> </span><span class="p">{</span><span class="no">:json</span><span class="w"> </span><span class="p">{</span><span class="no">:value</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]}}}]})</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:another</span><span class="w"> </span><span class="p">{</span><span class="no">:json</span><span class="w"> </span><span class="p">{</span><span class="no">:value</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]}}}}</span><span class="w">
</span></code></pre></div></div>

<p>Without the <code class="language-plaintext highlighter-rouge">[:lift ...]</code> tag, HoneySQL will treat the value as a nested SQL map
and try to render it as a string, which will fail of course or lead to a SQL
injection.</p>

<p>Another way is to use HoneySQL parameters conception:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pgh/insert-one</span><span class="w"> </span><span class="n">conn</span><span class="w">
                </span><span class="no">:test_json</span><span class="w">
                </span><span class="p">{</span><span class="no">:data</span><span class="w"> </span><span class="p">[</span><span class="no">:param</span><span class="w"> </span><span class="no">:data</span><span class="p">]}</span><span class="w">
                </span><span class="p">{</span><span class="no">:honey</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">{</span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:some</span><span class="w"> </span><span class="p">[</span><span class="no">:json</span><span class="w"> </span><span class="p">{</span><span class="no">:map</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]}]}}}})</span><span class="w">
</span></code></pre></div></div>

<p>For details, see the “HoneySQL Integration” section.</p>

<p>PG2 supports not only Clojure maps but vectors, sets, and lists. Here is an
example with with a vector:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pg/execute</span><span class="w"> </span><span class="n">conn</span><span class="w">
            </span><span class="s">"insert into test_json (data) values ($1)"</span><span class="w">
            </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">[[</span><span class="no">:some</span><span class="w"> </span><span class="no">:vector</span><span class="w"> </span><span class="p">[</span><span class="no">:nested</span><span class="w"> </span><span class="no">:vector</span><span class="p">]]]})</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">3</span><span class="n">,</span><span class="w"> </span><span class="no">:data</span><span class="w"> </span><span class="p">[</span><span class="s">"some"</span><span class="w"> </span><span class="s">"vector"</span><span class="w"> </span><span class="p">[</span><span class="s">"nested"</span><span class="w"> </span><span class="s">"vector"</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<h2 id="json-wrapper">Json Wrapper</h2>

<p>In rare cases you might store a string or a number in a JSON field. Say, 123 is
a valid JSON value but it’s treated as a number. To tell Postgres it’s a JSON
indeed, wrap the value with <code class="language-plaintext highlighter-rouge">pg/json-wrap</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pgh/insert-one</span><span class="w"> </span><span class="n">conn</span><span class="w">
                </span><span class="no">:test_json</span><span class="w">
                </span><span class="p">{</span><span class="no">:data</span><span class="w"> </span><span class="p">(</span><span class="nf">pg/json-wrap</span><span class="w"> </span><span class="mi">42</span><span class="p">)})</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">4</span><span class="n">,</span><span class="w"> </span><span class="no">:data</span><span class="w"> </span><span class="mi">42</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>The wrapper is especially useful to store a “null” JSON value: not the standard
<code class="language-plaintext highlighter-rouge">NULL</code> but <code class="language-plaintext highlighter-rouge">"null"</code> which, when parsed, becomes <code class="language-plaintext highlighter-rouge">nil</code>. For this, pass
<code class="language-plaintext highlighter-rouge">(pg/json-wrap nil)</code> as follows:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pgh/insert-one</span><span class="w"> </span><span class="n">conn</span><span class="w">
                </span><span class="no">:test_json</span><span class="w">
                </span><span class="p">{</span><span class="no">:data</span><span class="w"> </span><span class="p">(</span><span class="nf">pg/json-wrap</span><span class="w"> </span><span class="n">nil</span><span class="p">)})</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">5</span><span class="n">,</span><span class="w"> </span><span class="no">:data</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w"> </span><span class="c1">;; "null" in the database</span><span class="w">
</span></code></pre></div></div>

<h2 id="custom-object-mapper">Custom Object Mapper</h2>

<p>One great thing about Jsonista is a conception of mapper objects. A mapper is a
set of rules how to encode and decode data. Jsonista provides a way to build a
custom mapper. Once built, it can be passed to a connection config so the JSON
data is written and read back in a special way.</p>

<p>Let’s assume you’re going to tag JSON sub-parts to track their types. For
example, if encoding a keyword <code class="language-plaintext highlighter-rouge">:foo</code>, you’ll get a vector of <code class="language-plaintext highlighter-rouge">["!kw",
"foo"]</code>. When decoding that vector, by the <code class="language-plaintext highlighter-rouge">"!kw"</code> string, the mapper
understands it a keyword and coerces <code class="language-plaintext highlighter-rouge">"foo"</code> to <code class="language-plaintext highlighter-rouge">:foo</code>.</p>

<p>Here is how you create a mapper with Jsonista:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="no">:import</span><span class="w">
   </span><span class="n">clojure.lang.Keyword</span><span class="w">
   </span><span class="n">clojure.lang.PersistentHashSet</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
    </span><span class="p">[</span><span class="n">jsonista.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w">
    </span><span class="p">[</span><span class="n">jsonista.tagged</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jt</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">tagged-mapper</span><span class="w">
  </span><span class="p">(</span><span class="nf">j/object-mapper</span><span class="w">
   </span><span class="p">{</span><span class="no">:encode-key-fn</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:decode-key-fn</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:modules</span><span class="w">
    </span><span class="p">[(</span><span class="nf">jt/module</span><span class="w">
      </span><span class="p">{</span><span class="no">:handlers</span><span class="w">
       </span><span class="p">{</span><span class="n">Keyword</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="s">"!kw"</span><span class="w">
                 </span><span class="no">:encode</span><span class="w"> </span><span class="n">jt/encode-keyword</span><span class="w">
                 </span><span class="no">:decode</span><span class="w"> </span><span class="nb">keyword</span><span class="p">}</span><span class="w">
        </span><span class="n">PersistentHashSet</span><span class="w"> </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="s">"!set"</span><span class="w">
                           </span><span class="no">:encode</span><span class="w"> </span><span class="n">jt/encode-collection</span><span class="w">
                           </span><span class="no">:decode</span><span class="w"> </span><span class="nb">set</span><span class="p">}}})]}))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">object-mapper</code> function accepts even more options but we skip them for now.</p>

<p>Now that you have a mapper, pass it into a config:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">config</span><span class="w">
  </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
   </span><span class="no">:port</span><span class="w"> </span><span class="mi">10140</span><span class="w">
   </span><span class="no">:user</span><span class="w"> </span><span class="s">"test"</span><span class="w">
   </span><span class="no">:password</span><span class="w"> </span><span class="s">"test"</span><span class="w">
   </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"test"</span><span class="w">
   </span><span class="no">:object-mapper</span><span class="w"> </span><span class="n">tagged-mapper</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/get-connection</span><span class="w"> </span><span class="n">config</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>All the JSON operations made by this connection will use the passed object
mapper. Let’s insert a set of keywords:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pg/execute</span><span class="w"> </span><span class="n">conn</span><span class="w">
            </span><span class="s">"insert into test_json (data) values ($1)"</span><span class="w">
            </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">[{</span><span class="no">:object</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="no">:bar</span><span class="w"> </span><span class="no">:baz</span><span class="p">}}]})</span><span class="w">
</span></code></pre></div></div>

<p>When read back, the JSON value is not a vector of strings any longer but a set
of keywords:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pg/execute</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"select * from test_json"</span><span class="p">)</span><span class="w">

</span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:object</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:baz</span><span class="w"> </span><span class="no">:bar</span><span class="w"> </span><span class="no">:foo</span><span class="p">}}}]</span><span class="w">
</span></code></pre></div></div>

<p>To peek a raw JSON value, select it as a plain text and print (just to avoid
escaping quotes):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">printl</span><span class="w"> </span><span class="p">(</span><span class="nf">pg/execute</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"select data::text json_raw from test_json where id = 10"</span><span class="p">))</span><span class="w">

</span><span class="c1">;; [{:json_raw {"object": ["!set", [["!kw", "baz"], ["!kw", "bar"], ["!kw", "foo"]]]}}]</span><span class="w">
</span></code></pre></div></div>

<p>If you read that row using another connection with a default object mapper, the
data is returned without expanding tags.</p>

<h2 id="utility-pgjson-namespace">Utility pg.json namespace</h2>

<p>PG2 provides an utility namespace for JSON encoding and decoding. You can use it
for files, HTTP API, etc. If you already have PG2 in the project, there is no
need to plug in Cheshire or another JSON library. The namespace is <code class="language-plaintext highlighter-rouge">pg.json</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">pg.json</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">json</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<h3 id="reading-json">Reading JSON</h3>

<p>The <code class="language-plaintext highlighter-rouge">read-string</code> function reads a value from a JSON string:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">json/read-string</span><span class="w"> </span><span class="s">"[1, 2, 3]"</span><span class="p">)</span><span class="w">

</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>The first argument might be an object mapper:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">json/read-string</span><span class="w"> </span><span class="n">tagged-mapper</span><span class="w"> </span><span class="s">"[\"!kw\", \"hello\"]"</span><span class="p">)</span><span class="w">

</span><span class="no">:hello</span><span class="w">
</span></code></pre></div></div>

<p>The functions <code class="language-plaintext highlighter-rouge">read-stream</code> and <code class="language-plaintext highlighter-rouge">read-reader</code> act the same but accept either an
<code class="language-plaintext highlighter-rouge">InputStream</code> or a <code class="language-plaintext highlighter-rouge">Reader</code> object:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">in</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"[1, 2, 3]"</span><span class="w"> </span><span class="n">.getBytes</span><span class="w"> </span><span class="n">io/input-stream</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">json/read-stream</span><span class="w"> </span><span class="n">tagged-mapper</span><span class="w"> </span><span class="n">in</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">in</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"[1, 2, 3]"</span><span class="w"> </span><span class="n">.getBytes</span><span class="w"> </span><span class="n">io/reader</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">json/read-reader</span><span class="w"> </span><span class="n">tagged-mapper</span><span class="w"> </span><span class="n">in</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h3 id="writing-json">Writing JSON</h3>

<p>The <code class="language-plaintext highlighter-rouge">write-string</code> function dumps an value into a JSON string:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">json/write-string</span><span class="w"> </span><span class="p">{</span><span class="no">:test</span><span class="w"> </span><span class="p">[</span><span class="no">:hello</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">true</span><span class="p">]})</span><span class="w">

</span><span class="c1">;; "{\"test\":[\"hello\",1,true]}"</span><span class="w">
</span></code></pre></div></div>

<p>The first argument might be a custom object mapper. Let’s reuse our tagger
mapper:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">json/write-string</span><span class="w"> </span><span class="n">tagged-mapper</span><span class="w"> </span><span class="p">{</span><span class="no">:test</span><span class="w"> </span><span class="p">[</span><span class="no">:hello</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">true</span><span class="p">]})</span><span class="w">

</span><span class="c1">;; "{\"test\":[[\"!kw\",\"hello\"],1,true]}"</span><span class="w">
</span></code></pre></div></div>

<p>The functions <code class="language-plaintext highlighter-rouge">write-stream</code> and <code class="language-plaintext highlighter-rouge">write-writer</code> act the same. The only
difference is, they accept either an <code class="language-plaintext highlighter-rouge">OutputStream</code> or <code class="language-plaintext highlighter-rouge">Writer</code> objects. The
first argument might be a mapper as well:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">ByteArrayOutputStream</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">json/write-stream</span><span class="w"> </span><span class="n">tagged-mapper</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">]}</span><span class="w"> </span><span class="n">out</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">StringWriter</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">json/write-writer</span><span class="w"> </span><span class="n">tagged-mapper</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">]}</span><span class="w"> </span><span class="n">out</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h2 id="ring-http-middleware">Ring HTTP middleware</h2>

<p>PG2 provides an HTTP Ring middleware for JSON. It acts like <code class="language-plaintext highlighter-rouge">wrap-json-request</code>
and <code class="language-plaintext highlighter-rouge">wrap-json-response</code> middleware from the <a href="https://github.com/ring-clojure/ring-json">ring-json</a>
library. Comparing to it, the PG2 stuff has the following advantages:</p>

<ul>
  <li>it’s faster because of Jsonista, whereas Ring-json relies on Cheshire;</li>
  <li>it wraps both request and response at once with a shortcut;</li>
  <li>it supports custom object mappers.</li>
</ul>

<p>Imagine you have a Ring handler that reads JSON body and returns a JSON
map. Something like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">api-handler</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:data</span><span class="w"> </span><span class="no">:user_id</span><span class="p">)</span><span class="w">
        </span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">user-id</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="n">user</span><span class="p">}}))</span><span class="w">
</span></code></pre></div></div>

<p>Here is how you wrap it:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">pg.ring.json</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-json</span><span class="w">
                         </span><span class="n">wrap-json-response</span><span class="w">
                         </span><span class="n">wrap-json-request</span><span class="p">]]))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">api-handler</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-this-foo</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-json</span><span class="w"> </span><span class="n">&lt;opt&gt;</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-that-bar</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Above, the <code class="language-plaintext highlighter-rouge">wrap-json</code> wrapper is a combination of <code class="language-plaintext highlighter-rouge">wrap-json-request</code> and
<code class="language-plaintext highlighter-rouge">wrap-json-response</code>. You can apply them both explicitly:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">api-handler</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-this-foo</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-json-request</span><span class="w"> </span><span class="n">&lt;opt&gt;</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-json-response</span><span class="w"> </span><span class="n">&lt;opt&gt;</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-that-bar</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>All the three <code class="language-plaintext highlighter-rouge">wrap-json...</code> middleware accept a handler to wrap and a map of
options. Here is the options supported:</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Direction</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">:object-mapper</code></td>
      <td>request, response</td>
      <td>An custom instance of <code class="language-plaintext highlighter-rouge">ObjectMapper</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">:slot</code></td>
      <td>request</td>
      <td>A field to <code class="language-plaintext highlighter-rouge">assoc</code> the parsed JSON data (1)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">:malformed-response</code></td>
      <td>request</td>
      <td>A ring response returned when payload cannot be parsed (2)</td>
    </tr>
  </tbody>
</table>

<p>Notes:</p>

<ol>
  <li>
    <p>The default slot name is <code class="language-plaintext highlighter-rouge">:json</code>. Please avoid using <code class="language-plaintext highlighter-rouge">:body</code> or <code class="language-plaintext highlighter-rouge">:params</code> to
prevent overriding existing request fields. This is especially important for
<code class="language-plaintext highlighter-rouge">:body</code>! Often, you need the origin input stream to calculate an MD5 or
SHA-256 hash-sum of the payload. If you overwrite the <code class="language-plaintext highlighter-rouge">:body</code> field, you
cannot do that.</p>
  </li>
  <li>
    <p>The default malformed response is something like 400 “Malformed JSON” (plain
text).</p>
  </li>
</ol>

<p>A full example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">json-opt</span><span class="w">
  </span><span class="p">{</span><span class="no">:slot</span><span class="w"> </span><span class="no">:data</span><span class="w">
   </span><span class="no">:object-mapper</span><span class="w"> </span><span class="n">tagged-mapper</span><span class="w"> </span><span class="c1">;; see above</span><span class="w">
   </span><span class="no">:malformed-response</span><span class="w"> </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w">
                        </span><span class="no">:body</span><span class="w"> </span><span class="s">"&lt;h1&gt;Bad JSON&lt;/h1&gt;"</span><span class="w">
                        </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="s">"content-type"</span><span class="w"> </span><span class="s">"text/html"</span><span class="p">}}})</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">api-handler</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-this-foo</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-json</span><span class="w"> </span><span class="n">json-opt</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-that-bar</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/en/pg-json">
    <input required name="captcha" type="hidden" value="1 &#215; 7">

    <div class="block">
        <span class="comment-form-label"><small>1 &#215; 7 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
