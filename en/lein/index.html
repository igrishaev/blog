<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Don't use Leiningen to run shell-scripts</title>
  <meta name="description" content="Working with various Clojure projects, I noticed one thing that really worriesme. I’m talking about developers who add more and more entries into:prep-tasks ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/en/lein/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Don't use Leiningen to run shell-scripts</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2018-01-09T00:00:00+00:00">
        Jan 9, 2018
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/lein/" rel="tag">lein</a>, <a href="/tag/make/" rel="tag">make</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Working with various Clojure projects, I noticed one thing that really worries
me. I’m talking about developers who add more and more entries into
<code class="language-plaintext highlighter-rouge">:prep-tasks</code> vector in <code class="language-plaintext highlighter-rouge">project.clj</code> file. Please stop it. Every time you want
to put there a new task to compile CSS or build a Docker image, take a minute or
two to think on that. Let’s discuss the problem.</p>

<p><a href="https://leiningen.org/">Lein</a> is a great tool of course, really a piece of art. But its abilities
are not unlimited. Remember, its main purpose is to manage a Clojure-driven
project. I think, everybody agree with that statement.</p>

<p>The Clojure project you are working on is only a part of a top-level project in
business terms. Besides both server and UI sides, your application probably
sends emails, pushes notifications, interacts with Blockchain network and does
further more things.</p>

<p>According to GitHub statistics, you may have even 99% percent of code written
with Clojure. But still, there is definitely something that is beyond it. Thus,
please do not use Lein for those tasks that do no have any relation to Clojure
code.</p>

<p>Recently, I faced a situation when running REPL caused building Ethereum smart
contracts first. That step assumes you have installed software of proper
versions and configured paths, text configs, etc. Compiling them was a really
resource- and time-consuming duty.</p>

<p>The next step was to compile CSS sources. Again, it required installing Ruby,
less and wait for some time.</p>

<p>Remember, I did’n want all of this to happen. All I wanted to do is to connect
to REPL from Emacs and debug one tiny function. Needless to say, I just
commented those tasks in project file.</p>

<p>Again: your Clojure project should know nothing about compiling CSS, building
email templates, fetching anything from the network, querying Ethereum, building
Docker image or whatever else. Especially when we talking about running REPL. It
should run without any troubles at any time.</p>

<p>That’s why I’m strictly against using <code class="language-plaintext highlighter-rouge">lein-shell</code> plugin or something similar
that lets you run shell commands from Lein.</p>

<p>Of course, building a project requires passing through a list of particular
steps that were partially mentioned above. What should we use for that?
Shell-scripts? Any modern Javascript task runner? No, just <a href="https://www.gnu.org/software/make/">Make utility</a>
that has been here for ages.</p>

<p>“Put that gun down and let me explain.” (c)</p>

<p>I know Make is an ancient tool that came from rough C/C++ times. Those days,
developers knew quite few about a pipeline, CI or methodologies in
general. Almost every single programming language nowadays offers a task runner
that takes modern requirements into account. But still, for a set of tasks that
might be run upon your project, there is nothing better then a Makefile at the
top of file structure. And here is why.</p>

<p>Make utility is a binary tool that does not force you to install a new version
of Node.js, Python or Ruby. Probably, it’s already installed on your computer
since most of Linux distributions have it out from the box. It works perfectly
of various systems. I have never faced any troubles with it switching between
Linux and Mac.</p>

<p>Such modern shells as <a href="https://en.wikipedia.org/wiki/Z_shell">zsh</a> support auto-completing make targets when
pressing <code class="language-plaintext highlighter-rouge">&lt;TAB&gt;</code> character after “make”. That really saves time especially when
you use prefixes. Say, in my pet project, besides Clojure-related targets, I’ve
got a bunch of commands to operate on Docker images. These are <code class="language-plaintext highlighter-rouge">docker-run</code>,
<code class="language-plaintext highlighter-rouge">docker-build</code>, <code class="language-plaintext highlighter-rouge">docker-compose-up/down</code> and more. Each of them takes 60 to 100
characters so it’s impossible to remember them. So in terminal, I type <code class="language-plaintext highlighter-rouge">make
doc&lt;TAB&gt;</code> and see a short subset of Docker-related stuff.</p>

<p>I consider any Makefile as not just a list of commands but rather a knowledge
base of your project. The more the project develops, the more operations you
need to perform over it. Where to store all the those commands? <strong>In your wiki?
Nobody reads it.</strong> A better solution would be to keep them as close to the code
as it possible.</p>

<p>Make utility runs extremely fast whereas lein needs about five seconds to boot
up. That’s pretty long time, really. Imagine each command line tool hangs for a
couple of seconds before it runs. That would be a hell on your computer. A
situation that makes me angry is when I mistype in a long lein command like
<code class="language-plaintext highlighter-rouge">lein migratus craete user-updated</code>, wait for five seconds and see an error
message saying there is no <code class="language-plaintext highlighter-rouge">craete</code> subcommand in migratus. With make utility,
there is no an option for such things.</p>

<p>One of my favorite features is to ask a user for prompt when typing names,
passwords or any other sensitive data. Here is an example of how usually I
create a new SQL migration:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>create-migration:
    @read <span class="nt">-p</span> <span class="s2">"Enter migration name: "</span> migration <span class="se">\</span>
    <span class="o">&amp;&amp;</span> lein migratus create <span class="nv">$$</span>migration
</code></pre></div></div>

<p>When I type <code class="language-plaintext highlighter-rouge">make crea&lt;TAB&gt;&lt;RET&gt;</code> (remember, auto-complete magic works here),
the system asks for a new migration name. I enter a string that I need and a new
migration named properly appears.</p>

<p>Makefiles may include other ones so probably you can maintain separate files for
both production/developer modes or for developers/ops teams. Since those files
support comments, you are welcome to put doc hints there.</p>

<p>The utility allows to chain targets. When I start working on a new task, at
least I need to perform three steps: 1) migrate the database; 2) run tests to
ensure everything works before I change something; 3) launch REPL. In my make
file, I’ve got a separate target for each step. But I can call them in chain as
well:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make mig&lt;TAB&gt; te&lt;TAB&gt; re&lt;TAB&gt;
</code></pre></div></div>

<p>that expands into:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make migrate <span class="nb">test </span>repl
</code></pre></div></div>

<p>and finally becomes:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein migratus migrate
lein <span class="nb">test
</span>lein repl
</code></pre></div></div>

<p>Inside a makefile, you can call for another makefile what may become a powerful
feature of your build process. Here is how it works.</p>

<p>Say, in our project, on the top level of it there is a “email” folder that
brings Node.js project for building email templates. Our Clojure application use
those compiled templates for further processing with Selmer to send final emails
to our clients. It’s obvious, I need those templates only when I work with our
email subsystem and never else. So it would be madness to force all our
developers to install Node.js with tons of packages and compile the templates
each time they launch REPL.</p>

<p>Inside “email” folder, there is a separate Makefile that knows how to deal with
that sub-project. It installs all the requirements and has some useful targets,
say, to run compiler in debug mode or open a browser window for preview.</p>

<p>A small fragment of that make file:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>all: <span class="nb">install </span>build dist

<span class="nb">install</span>:
	yarn <span class="nb">install

</span>build:
	node_modules/.bin/gulp build <span class="nt">--production</span>

dist:
    <span class="nb">cp</span> ...
</code></pre></div></div>

<p>The default target performs all the targets that are required to get final
templates. Now, in the main make file that is on the root of the project, I put:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EMAILDIR :<span class="o">=</span> <span class="si">$(</span>CURDIR<span class="si">)</span>/email

.PHONY: email
email:
    make <span class="nt">-C</span> <span class="si">$(</span>EMAILDIR<span class="si">)</span>

uberjar-build: email
    lein uberjar
</code></pre></div></div>

<p>So this configuration gives me freedom of choice. When I launch REPL, I don’t
need all that stuff to deal with compiling emails. Probably, I may work in a
company for years without touching them. But those guys who do, they run <code class="language-plaintext highlighter-rouge">make
email</code> and get the full and ready email installation. Finally, no one be able to
build an Uberjar without compiling fresh emails.</p>

<p>Now take into account that those emails were just a small part of a
project. Remember, for successful production build you might need fetching huge
JSON declarations from 3rd-party services; compiling smart contracts; building
Docker images; building CSS and much more. Now answer, whey <code class="language-plaintext highlighter-rouge">lein</code> utility that
even doesn’t have any default capabilities for that, should do it instead of
special tools designed for exactly those things?</p>

<p>I think it’s obvious now that <code class="language-plaintext highlighter-rouge">lein</code> only should be used to manage your Clojure
code. Never configure it to run non-Clojure-related stuff.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/en/lein/">
    <input required name="captcha" type="hidden" value="1 &#215; 2">

    <div class="block">
        <span class="comment-form-label"><small>1 &#215; 2 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
