<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Clojure Zippers</title>
  <meta name="description" content="    ">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/en/clojure-zippers/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Clojure Zippers</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2021-05-20T00:00:00+00:00">
        May 20, 2021
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/zippers/" rel="tag">zippers</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<h2>

    

</h2>

<ul id="toc-item-clojure-zippers-en">
  <li><a href="#part-1-the-basics-of-navigation" id="toc-item-clojure-zippers-en-part-1-the-basics-of-navigation">Part 1. The Basics of Navigation</a></li>
  <li><a href="#part-2-automatic-navigation" id="toc-item-clojure-zippers-en-part-2-automatic-navigation">Part 2. Automatic navigation</a></li>
  <li><a href="#part-3-xml-zippers" id="toc-item-clojure-zippers-en-part-3-xml-zippers">Part 3. XML zippers</a></li>
  <li><a href="#part-4-xml-search" id="toc-item-clojure-zippers-en-part-4-xml-search">Part 4. XML search</a></li>
  <li><a href="#part-5-editing" id="toc-item-clojure-zippers-en-part-5-editing">Part 5. Editing</a>    <ul>
      <li><a href="#multiple-change" id="toc-item-clojure-zippers-en-multiple-change">Multiple change</a></li>
      <li><a href="#prices-in-xml" id="toc-item-clojure-zippers-en-prices-in-xml">Prices in XML</a></li>
    </ul>
  </li>
  <li><a href="#part-6-virtual-trees-currency-exchange" id="toc-item-clojure-zippers-en-part-6-virtual-trees-currency-exchange">Part 6. Virtual Trees. Currency Exchange</a></li>
  <li><a href="#part-7-breadth-first-traversal-improved-currency-exchange" id="toc-item-clojure-zippers-en-part-7-breadth-first-traversal-improved-currency-exchange">Part 7. Breadth-First Traversal. Improved Currency Exchange</a></li>
  <li><a href="#part-8-summary" id="toc-item-clojure-zippers-en-part-8-summary">Part 8. Summary</a>    <ul>
      <li><a href="#html" id="toc-item-clojure-zippers-en-html">HTML</a></li>
      <li><a href="#data-and-serialization" id="toc-item-clojure-zippers-en-data-and-serialization">Data and Serialization</a></li>
      <li><a href="#other-uses" id="toc-item-clojure-zippers-en-other-uses">Other Uses</a></li>
      <li><a href="#third-party-libraries" id="toc-item-clojure-zippers-en-third-party-libraries">Third-party Libraries</a></li>
      <li><a href="#summary" id="toc-item-clojure-zippers-en-summary">Summary</a></li>
    </ul>
  </li>
</ul>

<h2 id="part-1-the-basics-of-navigation">Part 1. The Basics of Navigation</h2>

<p><em>In this article, we will discuss zippers in the Clojure language. These are an unusual way
to work with collections. Using a zipper, you can traverse a data structure arbitrarily and modify its content as well as search in it. A zipper is a powerful abstraction that pays off over time. However, it is not as straightforward as regular tools and requires training to deal with.</em></p>

<p>Let’s talk about a zipper in simple terms. It is a wrapper that offers a variety of data manipulations. Let’s list the main ones:</p>

<ul>
  <li>moving vertically: down to children or up to a parent;</li>
  <li>moving horizontally: left or right among children;</li>
  <li>traversal of the entire data structure;</li>
  <li>adding, editing and deleting nodes.</li>
</ul>

<!-- more -->

<p>This is a partial list, and you will see the most interesting solutions more later. Note: these capabilities are available when working with arbitrary data, whether it’s a combination of vectors and maps, XML, or a tree. This makes zippers a powerful tool. If you figure out how to handle them, you will boost your skills and open new doors.</p>

<p>The good news is that zippers are available in the base Clojure package. It’s better than a third party library that needs to be included. Zippers are easy to add to a project with no fear of license issues or new dependencies.</p>

<p>Clojure zippers harness the power of immutable collections. Technically, a zipper is a collection that stores data and the position of the pointer. Together they are called a location. A step in either direction returns a new location, just like the <code class="language-plaintext highlighter-rouge">assoc</code> or <code class="language-plaintext highlighter-rouge">update</code> functions generate new data from old data.</p>

<p>From the current location, you can get a node,  that is, a piece of data that the pointer refers to. Let’s clarify their difference to avoid confusing beginners. Location is the source data and the position in it. Moving around the location generates a new location. From the location, you can retrieve a node — the data that is in this area.</p>

<p>Below is an example with the vector <code class="language-plaintext highlighter-rouge">[1 2 3]</code>. To move to the second item, the <strong>two</strong>, you need to wrap the data in a zipper and execute the <code class="language-plaintext highlighter-rouge">zip/down</code> and<code class="language-plaintext highlighter-rouge"> zip/right</code> commands. In the first step, we’ll get into the vector and find ourselves on element 1. A step to the right will move us to 2. Let’s express it in code: include the package with the alias <code class="language-plaintext highlighter-rouge">zip</code> and traverse the vector.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.zip</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">zip</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/right</span><span class="w">
    </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">
</span></code></pre></div></div>

<p>Chaining these functions will return 2 as expected. The last action — <code class="language-plaintext highlighter-rouge">zip/node</code> — outputs the value (a node) from the current location. If we remove <code class="language-plaintext highlighter-rouge">zip/node</code>, we’ll get a location that corresponds to 2. It looks like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/right</span><span class="p">)</span><span class="w">

</span><span class="c1">;; [2 {:l [1], :pnodes [[1 2 3]], :ppath nil, :r (3)}]</span><span class="w">
</span></code></pre></div></div>

<p>Maybe you have some questions: how do we know the path to the 2 when it could have been elsewhere in the vector? What happens if we go outside the collection?
You’ll find the answers to these questions below. For now, if something is not clear to you, do not
panic: we’ll clarify more than once everything happening here.</p>

<p>So, the zipper suggests navigating through the data. Despite its power, it doesn’t know how to do
this for a specific collection, so you need to teach it. In addition to data, a zipper requires answers to two questions:</p>

<ul>
  <li>
    <p>Is the current element a branch? This is the name of the element from which
you can get other ones.</p>
  </li>
  <li>
    <p>If it’s a branch, how do you fetch children from it?</p>
  </li>
</ul>

<p>That’s all a zipper needs to know to navigate. Note, for changing the zipper itself, you need
to know the answer to one more question — how to attach children to a branch. However, we are only looking at navigation, so the third question can wait.</p>

<p>Technically, functions give the answers to the first and second questions. The first one takes a node and returns <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>. If it returns <code class="language-plaintext highlighter-rouge">true</code>, the zipper calls the second function. It takes the same node but should return a sequence of child nodes or <code class="language-plaintext highlighter-rouge">nil</code> if they don’t exist. In code, these functions are called <code class="language-plaintext highlighter-rouge">branch?</code> and <code class="language-plaintext highlighter-rouge">children</code>.</p>

<p>To get a zipper, you need to tell it input data and the two functions just described. As long as we only read a zipper, the third function can be <code class="language-plaintext highlighter-rouge">nil</code>. The zippers locate in the <code class="language-plaintext highlighter-rouge">clojure.zip</code> package. Include it into namespace:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">my.project</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.zip</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">zip</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Explore the source code for this module in your leisure time. It is only 280 lines long!</p>

<p>The <code class="language-plaintext highlighter-rouge">zip/zipper</code> function creates a zipper from source data and functions. This is the module’s main point, its building blocks. For common cases, the module offers some predefined zippers that only expect data. <code class="language-plaintext highlighter-rouge">Vector-zip</code> for nested vectors is a good example. Here is its code without the third parameter:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">vector-zip</span><span class="w">
  </span><span class="p">[</span><span class="nb">root</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nb">vector?</span><span class="w">
          </span><span class="nb">seq</span><span class="w">
          </span><span class="n">...</span><span class="w">
          </span><span class="nb">root</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>We replaced it with three dots. The third parameter is a function that attaches child nodes to the branch on change (ignore it for now). If you pass the vector <code class="language-plaintext highlighter-rouge">[1 2 3]</code> to <code class="language-plaintext highlighter-rouge">vector-zip</code>, the following happens:</p>

<p>The zipper will wrap the vector and expose a pointer to it. From the starting position, you can only traverse down, because at the top a zipper has no parent (up) and neighbors (left and right). When navigating <strong>down</strong>, the zipper first checks if the branch is the current node. That triggers the expression <code class="language-plaintext highlighter-rouge">(vector? [1 2 3])</code> that gets evaluated to <code class="language-plaintext highlighter-rouge">true</code>. In this case, the zipper will execute <code class="language-plaintext highlighter-rouge">(seq [1 2 3])</code> to get children. They will be the sequence <code class="language-plaintext highlighter-rouge">(1 2 3)</code>. Once the children are found, the zipper will set the pointer to the leftmost child — 1.</p>

<p>Let’s show this in the diagram. Start position, a pointer is on the source vector:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌───────┐
                │  nil  │
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃  [1 2 3]  ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   1   │
                └───────┘
</code></pre></div></div>

<p>Step down, the pointer is at 1:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌───────┐
                │[1 2 3]│
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     1     ┃───▶│   2   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>Step to the right, the pointer on 2:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌───────┐
                │[1 2 3]│
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>So, we are on 2 and can move horizontally. A step to the right will move us to 3,  to the left — to 1. In the code, it looks like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc2</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc2</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc2</span><span class="w"> </span><span class="n">zip/right</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 3</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc2</span><span class="w"> </span><span class="n">zip/left</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 1</span><span class="w">
</span></code></pre></div></div>

<p>When trying to move down, the zipper will execute the <code class="language-plaintext highlighter-rouge">(vector? 2)</code> predicate. The result
will be <code class="language-plaintext highlighter-rouge">false</code>, which means that the current element is not a branch and no downward movement is allowed.</p>

<p>Remember the following as you traverse. Each step creates a new location without changing the old one. If you save any particular location in a variable, subsequent calls to <code class="language-plaintext highlighter-rouge">zip/right,</code> <code class="language-plaintext highlighter-rouge">zip/down</code>, and others will not change it in any way. Above, we have declared the <code class="language-plaintext highlighter-rouge">loc2</code> variable,
which points to 2. You can use it to get the source vector.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc2</span><span class="w"> </span><span class="n">zip/up</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 2 3]</span><span class="w">
</span></code></pre></div></div>

<p>If you move along manually, chances are good that you will go outside the collection. A step to nowhere will return <code class="language-plaintext highlighter-rouge">nil</code> instead of a location:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/left</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p>This is a signal that you are on the wrong route. The bad news is that you cannot go back from <code class="language-plaintext highlighter-rouge">nil</code>. <code class="language-plaintext highlighter-rouge">Nil</code> signifies an empty location, and there is no reference to the previous step in it. The <code class="language-plaintext highlighter-rouge">zip/up</code>, <code class="language-plaintext highlighter-rouge">zip/right</code> and other functions also return <code class="language-plaintext highlighter-rouge">nil</code> for an empty location. If you iterate in a cycle and do not take this into account, you’ll just end up spinning your wheels.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span><span class="n">zip/vector-zip</span><span class="w">
</span><span class="n">zip/down</span><span class="w">
</span><span class="n">zip/left</span><span class="w">
</span><span class="n">zip/left</span><span class="w">
</span><span class="n">zip/left</span><span class="w">
</span><span class="n">zip/left</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">zip/down</code> function is an exception: if you try to descend from <code class="language-plaintext highlighter-rouge">nil</code>, you’ll get a <code class="language-plaintext highlighter-rouge">NullPointerException</code> error. This is a slight defect that probably will be fixed on day.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span><span class="n">zip/vector-zip</span><span class="w">
</span><span class="n">zip/down</span><span class="w">
</span><span class="n">zip/left</span><span class="w">
</span><span class="n">zip/down</span><span class="p">)</span><span class="w">

</span><span class="c1">;; Execution error (NullPointerException)...</span><span class="w">
</span></code></pre></div></div>

<p>Let’s take a look at a more complex vector. One of its children is another vector — <code class="language-plaintext highlighter-rouge">[1 [2 3] 4]</code>. To move the pointer to <strong>3</strong>, make the steps <code class="language-plaintext highlighter-rouge">down</code>, <code class="language-plaintext highlighter-rouge">right</code>, <code class="language-plaintext highlighter-rouge">down</code>, and <code class="language-plaintext highlighter-rouge">right</code>. Let’s store a location in a variable:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc3</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc3</span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre></div></div>

<p>The pictures below show what happens at each step. Starting position:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌───────┐
                │  nil  │
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃[1 [2 3] 4]┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   1   │
                └───────┘
</code></pre></div></div>

<p>Step down:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     1     ┃───▶│ [2 3] │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>To the right:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃   [2 3]   ┃───▶│   4   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   2   │
                └───────┘
</code></pre></div></div>

<p>Down:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>To the right. We are at our goal:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   2   │◀───┃     3     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>To move to <strong>4</strong> from the current position, you first need to go up. The pointer will move to vector <code class="language-plaintext highlighter-rouge">[2 3]</code>. Now we are among the children of the original vector and can move horizontally. Let’s take a step to the right and find ourselves at number <strong>4</strong>.</p>

<p>Here the same actions are shown graphically. The current location (i.e., 3):</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   2   │◀───┃     3     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>Step up:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃   [2 3]   ┃───▶│   4   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   2   │
                └───────┘
</code></pre></div></div>

<p>Step to the right:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │ [2 3] │◀───┃     4     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>The original vector can be of any nesting. As an exercise, replace 3 with another vector and go down into it.</p>

<p>What does happen if you pass something other than a vector to <code class="language-plaintext highlighter-rouge">vector-zip</code>?  For example, it might be a string, nil, or a number. Before traversing, the zipper checks to see if the node is a branch and if it has child nodes. For <code class="language-plaintext highlighter-rouge">vector-zip</code>, it checks the data with the <code class="language-plaintext highlighter-rouge">vector?</code> function, which returns <code class="language-plaintext highlighter-rouge">nil</code> for all non-vector values. As a result, we get a location from where we can’t step anywhere: neither down nor laterally. This dead end must be avoided.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"test"</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">clojure.zip</code> module also offers other built-in zippers. The <code class="language-plaintext highlighter-rouge">xml-zip</code> is especially interesting for navigating XML trees. We’ll discuss it separately when you get to know the other zipper features.</p>

<h2 id="part-2-automatic-navigation">Part 2. Automatic navigation</h2>

<p>We figured out how to navigate through the collection. However, you might wonder how the path
goes? How do you know in advance in which direction to go?</p>

<p>The main message of this section is: <strong>Manual navigation through data makes no sense.</strong>
If you know the path beforehand, you don’t need a zipper.</p>

<p>For data whose structure you know in advance, Clojure offers an easier way to work with. For example, if we know for sure that the input data structure is a vector, and its second element is another vector, we’ll use <code class="language-plaintext highlighter-rouge">get-in</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w">
</span><span class="c1">;; 3</span><span class="w">
</span></code></pre></div></div>

<p>The same goes for other data types. It doesn’t matter what combination lists and maps make.  If the structure is known in advance, the data you need can be easily reached with a <code class="language-plaintext highlighter-rouge">get-in</code> or threading macro. In this case, zippers will only complicate the code.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">{</span><span class="no">:users</span><span class="w"> </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}]})</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="no">:name</span><span class="p">)</span><span class="w">
</span><span class="c1">;; "Ivan"</span><span class="w">
</span></code></pre></div></div>

<p>What is the advantage of zippers? Their strengths are manifested in situations where <code class="language-plaintext highlighter-rouge">get-in</code> can’t work. It’s about data with an <em>unknown</em> structure. Let’s say there is an arbitrary vector as input, and you need to find a string in it. For example, it might be at the first nesting level, or at the third, and so on. Another example is an XML document. The required tag can be located anywhere in it, but you need to find it somehow. In short, the ideal situation for a zipper is a fuzzy data structure that we’re only guessing about.</p>

<p>Together, the functions <code class="language-plaintext highlighter-rouge">zip/up</code>, <code class="language-plaintext highlighter-rouge">zip/down</code>, and others form the universal function — <code class="language-plaintext highlighter-rouge">zip/next</code>. It
moves the pointer so that sooner or later we’ll traverse the entire structure. When traversing, repetitions are excluded: we’ll visit each place only once. Here is an example with a vector:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">vzip</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/vector-zip</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">vzip</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 [2 3] 4]</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">vzip</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 1</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">vzip</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [2 3]</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">vzip</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">
</span></code></pre></div></div>

<p>We don’t know how many times to call  <code class="language-plaintext highlighter-rouge">zip/next</code>, so let’s resort to a ploy. The <code class="language-plaintext highlighter-rouge">iterate</code> function takes the <code class="language-plaintext highlighter-rouge">f</code> function and an <code class="language-plaintext highlighter-rouge">x</code> value. It returns a sequence where the first element is <code class="language-plaintext highlighter-rouge">x</code>, and each next is an <code class="language-plaintext highlighter-rouge">f(x)</code> from the previous one. For a zipper, we get the initial location, then <code class="language-plaintext highlighter-rouge">zip/next</code> from it, then <code class="language-plaintext highlighter-rouge">zip/next</code> from the previous movement, and so on.</p>

<p>Below, the variable <code class="language-plaintext highlighter-rouge">loc-seq</code> is the location chain of the source zipper. To get the nodes, we take the first six elements (the number we take randomly) and call <code class="language-plaintext highlighter-rouge">zip/node</code> for each.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-seq</span><span class="w"> </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">vzip</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">loc-seq</span><span class="w">
     </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">zip/node</span><span class="p">))</span><span class="w">

</span><span class="c1">;; ([1 [2 3] 4]</span><span class="w">
</span><span class="c1">;;   1</span><span class="w">
</span><span class="c1">;;   [2 3]</span><span class="w">
</span><span class="c1">;;   2</span><span class="w">
</span><span class="c1">;;   3</span><span class="w">
</span><span class="c1">;;   4)</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Iterate</code> returns a <em>lazy</em> and <em>infinite</em> sequence. Both characteristics are important. Laziness means that the next shift (i.e., calling <code class="language-plaintext highlighter-rouge">zip/next</code>) will not happen until you reach an element in the chain. Infinity means that <code class="language-plaintext highlighter-rouge">zip/next</code> is called an unlimited number of times. We need a flag to indicate that we need to stop calling <code class="language-plaintext highlighter-rouge">zip/next</code>, otherwise the stream of locations will never end.</p>

<p>In addition, at some point, <code class="language-plaintext highlighter-rouge">zip/next</code> stops moving the pointer. Take, for example, the hundredth and thousandth elements of an iteration. Their node will be the initial vector:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-seq</span><span class="w"> </span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 [2 3] 4]</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-seq</span><span class="w"> </span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 [2 3] 4]</span><span class="w">
</span></code></pre></div></div>

<p>The reason lies in how the zipper traversal works. The <code class="language-plaintext highlighter-rouge">zip/next</code> function acts like a ring. When it reaches the initial location, the loop ends. In this case, the location will get a completion flag, and the next calling <code class="language-plaintext highlighter-rouge">zip/next</code> will return the same location. You can check a flag presence with the <code class="language-plaintext highlighter-rouge">zip/end?</code> function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-end</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="n">zip/next</span><span class="w">
      </span><span class="n">zip/next</span><span class="w">
      </span><span class="n">zip/next</span><span class="w">
      </span><span class="n">zip/next</span><span class="p">))</span><span class="w">

</span><span class="n">loc-end</span><span class="w">
</span><span class="c1">;; [[1 2 3] :end]</span><span class="w">

</span><span class="p">(</span><span class="nf">zip/end?</span><span class="w"> </span><span class="n">loc-end</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>To create the finite chain of locations, we’ll keep moving the pointer until we get the last location. Together, this gives the following function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">iter-zip</span><span class="w"> </span><span class="p">[</span><span class="n">zipper</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">zipper</span><span class="w">
       </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="n">zip/next</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">take-while</span><span class="w"> </span><span class="p">(</span><span class="nb">complement</span><span class="w"> </span><span class="n">zip/end?</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>This function returns all locations in the data structure. Recall that a location stores a node (a data element) that we can get using <code class="language-plaintext highlighter-rouge">zip/node</code>. The example below shows how to convert locations into data:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
     </span><span class="n">zip/vector-zip</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">zip/node</span><span class="p">))</span><span class="w">

</span><span class="c1">;; ([1 [2 3] 4]</span><span class="w">
</span><span class="c1">;;  1</span><span class="w">
</span><span class="c1">;;  [2 3]</span><span class="w">
</span><span class="c1">;;  2</span><span class="w">
</span><span class="c1">;;  3</span><span class="w">
</span><span class="c1">;;  4)</span><span class="w">
</span></code></pre></div></div>

<p>Now we have a chain of locations. Let’s write a search. Suppose you want to check if the vector
contains the <code class="language-plaintext highlighter-rouge">:error</code> keyword. First, let’s write a predicate for a location to know whether its node is equal to this value.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-error?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:error</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Well, let’s check if there is one in the chain of locations that matches our predicate.
To do this, call <code class="language-plaintext highlighter-rouge">some</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">[</span><span class="no">:test</span><span class="w"> </span><span class="p">[</span><span class="no">:foo</span><span class="w"> </span><span class="no">:error</span><span class="p">]]]</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="n">loc-error?</span><span class="w">
      </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">zip/vector-zip</span><span class="w"> </span><span class="n">iter-zip</span><span class="p">))</span><span class="w">

</span><span class="c1">;; true</span><span class="w">
</span></code></pre></div></div>

<p>Note that due to laziness, we are not scanning the entire tree. If the required node appears in the middle, <code class="language-plaintext highlighter-rouge">iter-zip</code> ends the iteration and stops making calls, and further <code class="language-plaintext highlighter-rouge">zip/next</code> calls won’t happen.</p>

<p>It’s useful to know that <code class="language-plaintext highlighter-rouge">zip/next</code> traverses a tree in depth-first order. As it moves, it tends to go down or to the right, but up only when steps in these directions return <code class="language-plaintext highlighter-rouge">nil</code>. As we’ll see later, sometimes the traversal order is important. There’re tasks where we have to traverse in breadth-first order. There’re no other default options for traversal in <code class="language-plaintext highlighter-rouge">clojure.zip</code>, but we can easily write
our own. We’ll look at a task that requires traversal in breadth later.</p>

<p>The built-in <code class="language-plaintext highlighter-rouge">vector-zip</code> zipper is for nested vectors. But nested maps are much more common. Let’s write a zipper to traverse such data:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">map-data</span><span class="w">
  </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="mi">1</span><span class="w">
   </span><span class="no">:bar</span><span class="w"> </span><span class="mi">2</span><span class="w">
   </span><span class="no">:baz</span><span class="w"> </span><span class="p">{</span><span class="no">:test</span><span class="w"> </span><span class="s">"hello"</span><span class="w">
         </span><span class="no">:word</span><span class="w"> </span><span class="p">{</span><span class="no">:nested</span><span class="w"> </span><span class="n">true</span><span class="p">}}})</span><span class="w">
</span></code></pre></div></div>

<p>Let’s take the familiar vector-zip as a basis. These zippers are similar, the only difference is the collection type they work with. Let’s think about how to define functions that answer the questions. The map is a branch whose children are <code class="language-plaintext highlighter-rouge">MapEntry</code> elements. This type represents a key-value pair. If the value is a map, we get a chain of nested <code class="language-plaintext highlighter-rouge">MapEntry</code> from it and so on.</p>

<p>To warm up, let’s write a predicate for checking the <code class="language-plaintext highlighter-rouge">MapEntry</code> type:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">entry?</span><span class="w">
  </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">instance?</span><span class="w"> </span><span class="n">clojure.lang.MapEntry</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">map-zip</code> zipper looks like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">map-zip</span><span class="w"> </span><span class="p">[</span><span class="n">mapping</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w">
   </span><span class="p">(</span><span class="nf">some-fn</span><span class="w"> </span><span class="n">entry?</span><span class="w"> </span><span class="nb">map?</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="k">cond</span><span class="w">
       </span><span class="p">(</span><span class="nb">map?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">

       </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nf">entry?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="nb">map?</span><span class="p">))</span><span class="w">
       </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="nb">seq</span><span class="p">)))</span><span class="w">
   </span><span class="n">nil</span><span class="w">
   </span><span class="n">mapping</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Let’s discuss the main points. The <code class="language-plaintext highlighter-rouge">(some-fn ...)</code> composition returns <code class="language-plaintext highlighter-rouge">true</code> if one of the predicate-parameters works positively. In other words, we consider only the map or its entry (key-value pair) as a branch.</p>

<p>In the second function, which looks for children, we have to check some conditions. If the current value is a map, we return a sequence of map entries using the <code class="language-plaintext highlighter-rouge">seq</code> function. If we are already in <code class="language-plaintext highlighter-rouge">MapEntry</code>, then check if the value is a nested map. If it is, we should get its children with the same <code class="language-plaintext highlighter-rouge">seq</code> function.</p>

<p>When traversing the tree, we’ll get all the key-value pairs. If the value is a nested dictionary,
we’ll fall into it when traversing. Here is an example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="mi">42</span><span class="w">
      </span><span class="no">:bar</span><span class="w"> </span><span class="p">{</span><span class="no">:baz</span><span class="w"> </span><span class="mi">11</span><span class="w">
            </span><span class="no">:user/name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}}</span><span class="w">
     </span><span class="n">map-zip</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="nb">rest</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">zip/node</span><span class="p">))</span><span class="w">

</span><span class="c1">;; ([:foo 42]</span><span class="w">
</span><span class="c1">;;  [:bar {:baz 11, :user/name "Ivan"}]</span><span class="w">
</span><span class="c1">;;  [:baz 11]</span><span class="w">
</span><span class="c1">;;  [:user/name "Ivan"])</span><span class="w">
</span></code></pre></div></div>

<p>Notice the <code class="language-plaintext highlighter-rouge">rest</code> function after <code class="language-plaintext highlighter-rouge">iter-zip</code>. We skipped the first location that contains the original data. Since they are already known, their printing makes no sense.</p>

<p>Using our <code class="language-plaintext highlighter-rouge">map-zip</code>, we can check if the map contains the <code class="language-plaintext highlighter-rouge">:error</code> key with the <code class="language-plaintext highlighter-rouge">:auth</code> value. Each of these keywords can be anywhere, both in keys and in values at any level. However, we are interested in their combination. To do this, let’s write a predicate:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-err-auth?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[</span><span class="no">:error</span><span class="w"> </span><span class="no">:auth</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>Let’s make sure that there is no such pair in the first dictionary, even if the values appear separately:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:response</span><span class="w"> </span><span class="p">{</span><span class="no">:error</span><span class="w"> </span><span class="no">:expired</span><span class="w">
                 </span><span class="no">:auth</span><span class="w"> </span><span class="no">:failed</span><span class="p">}}</span><span class="w">
     </span><span class="n">map-zip</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="n">loc-err-auth?</span><span class="p">))</span><span class="w">

</span><span class="c1">;; nil</span><span class="w">
</span></code></pre></div></div>

<p>We’ll find this pair, even if it is deeply nested:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w">
  </span><span class="p">{</span><span class="no">:response</span><span class="w"> </span><span class="p">{</span><span class="no">:info</span><span class="w"> </span><span class="p">{</span><span class="no">:message</span><span class="w"> </span><span class="s">"Auth error"</span><span class="w">
                     </span><span class="no">:error</span><span class="w"> </span><span class="no">:auth</span><span class="w">
                     </span><span class="no">:code</span><span class="w"> </span><span class="mi">1005</span><span class="p">}}})</span><span class="w">

</span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">data</span><span class="w">
     </span><span class="n">map-zip</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="n">loc-err-auth?</span><span class="p">))</span><span class="w">

</span><span class="c1">;; true</span><span class="w">
</span></code></pre></div></div>

<p>Below are a few tasks for independent work.</p>

<p><strong>1.</strong> The <code class="language-plaintext highlighter-rouge">map-zip</code> zipper ignores the situation where the map key is another map.
For example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{{</span><span class="no">:alg</span><span class="w"> </span><span class="s">"MD5"</span><span class="w"> </span><span class="no">:salt</span><span class="w"> </span><span class="s">"***"</span><span class="p">}</span><span class="w"> </span><span class="s">"deprecated"</span><span class="w">
</span><span class="p">{</span><span class="no">:alg</span><span class="w"> </span><span class="s">"SHA2"</span><span class="w"> </span><span class="no">:salt</span><span class="w"> </span><span class="s">"****"</span><span class="p">}</span><span class="w"> </span><span class="s">"deprecated"</span><span class="w">
</span><span class="p">{</span><span class="no">:alg</span><span class="w"> </span><span class="s">"HMAC-SHA256"</span><span class="w"> </span><span class="no">:key</span><span class="w"> </span><span class="s">"xxx"</span><span class="p">}</span><span class="w"> </span><span class="s">"ok"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Such collections, although rarely, are used sometimes. Modify <code class="language-plaintext highlighter-rouge">map-zip</code> so that it checks not only the value of <code class="language-plaintext highlighter-rouge">MapEntry</code> but also the key.</p>

<p><strong>2.</strong> In practice, we work with a combination of vectors and maps. Write a universal zipper that takes into account both the map and the vector when traversing.</p>

<h2 id="part-3-xml-zippers">Part 3. XML zippers</h2>

<p>The power of zippers is fully revealed when working with XML. Unlike other formats, it is specified recursively. For example, JSON, YAML, and other formats offer data types (numbers, strings, collections) with different syntax and structure. In XML, wherever we are, the current node always consists of three components: tag, attributes, and content. Content is a set of strings or other nodes. Here’s a recursive pseudocode notation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>XML = [Tag, Attrs, [String|XML]]
</code></pre></div></div>

<p>To make sure the XML is homogeneous, consider an abstract file with vendor items:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone SE<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"tablet"</span><span class="nt">&gt;</span>iPad 3<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"notebook"</span><span class="nt">&gt;</span>Macbook Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p>At the top of the XML is the <code class="language-plaintext highlighter-rouge">catalog</code> node. It’s just a grouping tag; we need it because there can’t be multiple tags at the top. The <code class="language-plaintext highlighter-rouge">catalog</code> children are organizations. The <code class="language-plaintext highlighter-rouge">name</code> attribute of the organization contains its name. Products are under the organization. A product is a node with a <code class="language-plaintext highlighter-rouge">product</code> tag and a description of the product type. Instead of children, it has text content — its description. It’s impossible to go down below a product.</p>

<p>Clojure offers an XML parser that returns a structure similar to the <code class="language-plaintext highlighter-rouge">[Tag, Attrs, Content]</code> schema above. Each node becomes a map with the keys :tag, :attrs, and <code class="language-plaintext highlighter-rouge">:content</code>. The <code class="language-plaintext highlighter-rouge">:content</code> key stores a vector where an element is either a string or a nested map.</p>

<p>We put the XML data with products in the <code class="language-plaintext highlighter-rouge">resources/products.xml</code> file. Let’s write a function to parse a file into an XML zipper. Add module imports:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="no">:require</span><span class="w">
 </span><span class="p">[</span><span class="n">clojure.java.io</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">io</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="n">clojure.xml</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">xml</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Both come with Clojure and therefore do not require dependencies. To get the zipper, we pass the <code class="language-plaintext highlighter-rouge">path</code> parameter through a series of functions:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-&gt;xml-zipper</span><span class="w"> </span><span class="p">[</span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">path</span><span class="w">
      </span><span class="n">io/resource</span><span class="w">
      </span><span class="n">io/file</span><span class="w">
      </span><span class="n">xml/parse</span><span class="w">
      </span><span class="n">zip/xml-zip</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">xml/parse</code> function should return a nested structure consisting of maps with keys <code class="language-plaintext highlighter-rouge">: tag</code>,
<code class="language-plaintext highlighter-rouge">:attrs</code>, and <code class="language-plaintext highlighter-rouge">:content</code>. Note that text content such as a product name, is also a vector with one string. This achieves the homogeneity of each node.</p>

<p>This is what we should get after calling <code class="language-plaintext highlighter-rouge">xml/parse</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:catalog</span><span class="w">
 </span><span class="no">:attrs</span><span class="w"> </span><span class="n">nil</span><span class="w">
 </span><span class="no">:content</span><span class="w">
 </span><span class="p">[{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:organization</span><span class="w">
   </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"re-Store"</span><span class="p">}</span><span class="w">
   </span><span class="no">:content</span><span class="w">
   </span><span class="p">[{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:product</span><span class="w">
     </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="s">"iphone"</span><span class="p">}</span><span class="w">
     </span><span class="no">:content</span><span class="w"> </span><span class="p">[</span><span class="s">"iPhone 11 Pro"</span><span class="p">]}</span><span class="w">
    </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:product</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="s">"iphone"</span><span class="p">}</span><span class="w"> </span><span class="no">:content</span><span class="w"> </span><span class="p">[</span><span class="s">"iPhone SE"</span><span class="p">]}]}</span><span class="w">
  </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:organization</span><span class="w">
   </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"DNS"</span><span class="p">}</span><span class="w">
   </span><span class="no">:content</span><span class="w">
   </span><span class="p">[{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:product</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="s">"tablet"</span><span class="p">}</span><span class="w"> </span><span class="no">:content</span><span class="w"> </span><span class="p">[</span><span class="s">"iPad 3"</span><span class="p">]}</span><span class="w">
    </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:product</span><span class="w">
     </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="s">"notebook"</span><span class="p">}</span><span class="w">
     </span><span class="no">:content</span><span class="w"> </span><span class="p">[</span><span class="s">"Macbook Pro"</span><span class="p">]}]}]}</span><span class="w">
</span></code></pre></div></div>

<p>The call of <code class="language-plaintext highlighter-rouge">(-&gt;xml-zipper "products.xml")</code> creates the initial location of the XML zipper from the data above. First, let’s take a look at the definition of <code class="language-plaintext highlighter-rouge">xml-zip</code> to understand how it works. Here we present code excerpts:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">xml-zip</span><span class="w">
  </span><span class="p">[</span><span class="nb">root</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="p">(</span><span class="nb">complement</span><span class="w"> </span><span class="nb">string?</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="nb">seq</span><span class="w"> </span><span class="no">:content</span><span class="p">)</span><span class="w">
          </span><span class="n">...</span><span class="w">
          </span><span class="nb">root</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>As you might guess, the children of the node are its <code class="language-plaintext highlighter-rouge">:content</code>, additionally wrapped in <code class="language-plaintext highlighter-rouge">seq</code>. A string can’t have children, so <code class="language-plaintext highlighter-rouge">(complement string?)</code> means — search for children only in non-string nodes.</p>

<p>Look at how we would find all products from a given XML. First, let’s get a lazy iteration over its zipper. Recall that at each step we get not a map with  <code class="language-plaintext highlighter-rouge">:tag</code> and other fields, but a zip location with a pointer to it. It remains only to filter out the locations which nodes contain the product tag. To do this let’s write a predicate:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-product?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="no">:tag</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:product</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>And let’s write a transforming selection:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"products.xml"</span><span class="w">
     </span><span class="n">-&gt;xml-zipper</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-product?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">loc-&gt;product</span><span class="p">))</span><span class="w">

</span><span class="c1">;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")</span><span class="w">
</span></code></pre></div></div>

<p>At first glance, there is nothing special here. The XML structure is known in advance, so we can do it without zipper. Let’s select catalog children and get organizations, then we’ll get organizations’ children (i.e., goods). Here’s this simple code:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">xml-data</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"products.xml"</span><span class="w">
      </span><span class="n">io/resource</span><span class="w">
      </span><span class="n">io/file</span><span class="w">
      </span><span class="n">xml/parse</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">orgs</span><span class="w">
  </span><span class="p">(</span><span class="no">:content</span><span class="w"> </span><span class="n">xml-data</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">products</span><span class="w">
  </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="no">:content</span><span class="w"> </span><span class="n">orgs</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">product-names</span><span class="w">
  </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="no">:content</span><span class="w"> </span><span class="n">products</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>To make the code more concise, you can remove the intermediate variables and narrow it down to one form:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"products.xml"</span><span class="w">
     </span><span class="n">io/resource</span><span class="w">
     </span><span class="n">io/file</span><span class="w">
     </span><span class="n">xml/parse</span><span class="w">
     </span><span class="no">:content</span><span class="w">
     </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="no">:content</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="no">:content</span><span class="p">))</span><span class="w">

</span><span class="c1">;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")</span><span class="w">
</span></code></pre></div></div>

<p>In practice, the structure of XML always changes. Suppose a super-large dealer breaks down products by branch. In this case, the XML looks like this (a snippet):</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"tablet"</span><span class="nt">&gt;</span>iPad 3<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"notebook"</span><span class="nt">&gt;</span>Macbook Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/branch&gt;</span>
  <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 2"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"tablet"</span><span class="nt">&gt;</span>iPad 4<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"phone"</span><span class="nt">&gt;</span>Samsung A6+<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/branch&gt;</span>
<span class="nt">&lt;/organization&gt;</span>
</code></pre></div></div>

<p>The above code that selected data only by level won’t work anymore. If we run it against the new XML, we’ll get a branch node along with the products:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="s">"iPhone 11 Pro"</span><span class="w">
 </span><span class="s">"iPhone SE"</span><span class="w">
 </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:product,</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="s">"tablet"</span><span class="p">}</span><span class="n">,</span><span class="w"> </span><span class="no">:content</span><span class="w"> </span><span class="p">[</span><span class="s">"iPad 3"</span><span class="p">]}</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>If we used a zipper, it would return <strong>only</strong> products, including those from the branch:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"products-branch.xml"</span><span class="w">
     </span><span class="n">-&gt;xml-zipper</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-product?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">loc-&gt;product</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="s">"iPhone 11 Pro"</span><span class="w"> </span><span class="s">"iPhone SE"</span><span class="w"> </span><span class="s">"iPad 3"</span><span class="w"> </span><span class="s">"Macbook Pro"</span><span class="w"> </span><span class="s">"iPad 4"</span><span class="w"> </span><span class="s">"Samsung A6+"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Obviously, it’s beneficial to use code that works with both XML rather than maintaining a separate version for a large dealer. In the latter case, you have to store the flag, which supplier is normal and which is large, and promptly update it.</p>

<p>However, this example doesn’t cover the full capacity of the zippers. The <code class="language-plaintext highlighter-rouge">xml-seq</code> function from the core Clojure module also provides XML traversal. The function returns a lazy sequence of XML nodes in the same form (a map with <code class="language-plaintext highlighter-rouge">:tag</code>, <code class="language-plaintext highlighter-rouge">:attr</code>, and <code class="language-plaintext highlighter-rouge">:content</code>). <code class="language-plaintext highlighter-rouge">Xml-seq</code> is a special case of the more abstract <code class="language-plaintext highlighter-rouge">tree-seq</code> function. The latter is similar to a zipper in that it takes similar functions to determine if a node can be a branch and how to get its children. As you can see from the code, the <code class="language-plaintext highlighter-rouge">xml-seq</code> and <code class="language-plaintext highlighter-rouge">xml-zip</code> definitions are similar:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">xml-seq</span><span class="w">
  </span><span class="p">[</span><span class="nb">root</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">tree-seq</span><span class="w">
    </span><span class="p">(</span><span class="nb">complement</span><span class="w"> </span><span class="nb">string?</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="nb">seq</span><span class="w"> </span><span class="no">:content</span><span class="p">)</span><span class="w">
    </span><span class="nb">root</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The difference between a zipper and <code class="language-plaintext highlighter-rouge">tree-seq</code> is that when iterating, the zipper returns a location — a more abstract and more informative element. Instead, <code class="language-plaintext highlighter-rouge">tree-seq</code> produces unwrapped elements during iteration. For ordinary searches, <code class="language-plaintext highlighter-rouge">tree-seq</code> is even preferable, since it doesn’t generate unnecessary abstractions. The selection of goods, taking into account branches, looks like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">node-product?</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:tag</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:product</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"products-branch.xml"</span><span class="w">
     </span><span class="n">io/resource</span><span class="w">
     </span><span class="n">io/file</span><span class="w">
     </span><span class="n">xml/parse</span><span class="w">
     </span><span class="nb">xml-seq</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">node-product?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="no">:content</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="s">"iPhone 11 Pro"</span><span class="w"> </span><span class="s">"iPhone SE"</span><span class="w"> </span><span class="s">"iPad 3"</span><span class="w"> </span><span class="s">"Macbook Pro"</span><span class="w"> </span><span class="s">"iPad 4"</span><span class="w"> </span><span class="s">"Samsung A6+"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>To get back to zippers, let’s pick a problem where <code class="language-plaintext highlighter-rouge">tree-seq</code> loses its benefits. Manual search can be such a task.</p>

<h2 id="part-4-xml-search">Part 4. XML search</h2>

<p>Let’s say we need to select the stores that sell iPhones from an XML with products. Note: this is the first time we’ve touched on the relationship between nodes. That’s important! It’s easy to select the data individually. Shops are locations that have the <code class="language-plaintext highlighter-rouge">organization</code> tag. iPhones are locations that have a node with the <code class="language-plaintext highlighter-rouge">product</code> tag and the <code class="language-plaintext highlighter-rouge">type="tablet"</code> attribute. But how to find a relationship between them?</p>

<p>The previous time, we decomposed the XML into a sequence using <code class="language-plaintext highlighter-rouge">xml-seq</code>. The problem is that the function returns a collection of nodes with no relationship, which prevents us from solving our task. Let’s show this with an example: First, let’s get a chain of nodes:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">xml-nodes</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"products-branch.xml"</span><span class="w">
     </span><span class="n">io/resource</span><span class="w">
     </span><span class="n">io/file</span><span class="w">
     </span><span class="n">xml/parse</span><span class="w">
     </span><span class="nb">xml-seq</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Let’s say the product we want is in one of the elements. For example, we’ll find an iPhone in the third (second from zero) node:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">xml-nodes</span><span class="w"> </span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="c1">;; {:tag :product :attrs {:type "iphone"} :content ["iPhone 11 Pro"]}</span><span class="w">
</span></code></pre></div></div>

<p>However, it is difficult to find out which store it is from. You can guess that the store is to the left of
the product, because when traversing the tree, it precedes the product. This becomes clear if you print the node tags:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">xml-nodes</span><span class="w"> </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="no">:tag</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="nb">nil?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">run!</span><span class="w"> </span><span class="nb">print</span><span class="p">))</span><span class="w">
</span><span class="c1">;; :catalog :organization :product :product :organization ...</span><span class="w">
</span></code></pre></div></div>

<p>This is a more or less correct assumption, but you shouldn’t rely on it too much because the result depends on the XML traversal order. In addition, solving the problem becomes more complicated. When traversing, you need not only to select the desired products but also to move back in search of a store. Then you will have to move forward again, skipping the found product, otherwise, you’ll find yourself in an infinite loop. This approach is stateful and works well in imperative languages but not in Clojure.</p>

<p>This is where a zipper comes in. A location, which it returns at each step, remembers its position in the structure. This means that we can navigate from the location to the required place using the functions <code class="language-plaintext highlighter-rouge">zip/up</code>, <code class="language-plaintext highlighter-rouge">zip/right</code>, and others, which we discussed in the first part. In this case, the use of manual navigation is reasonable.</p>

<p>Let’s go back to XML with a simple catalog-organization-products structure. Let’s refresh it in memory.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone SE<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"tablet"</span><span class="nt">&gt;</span>iPad 3<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"notebook"</span><span class="nt">&gt;</span>Macbook Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p>First of all, let’s find iPhones-locations and write the predicate for the iPhone:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-iphone?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:tag</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:product</span><span class="p">))</span><span class="w">
         </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"iphone"</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Get locations with iPhones:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-iphones</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"products.xml"</span><span class="w">
       </span><span class="n">-&gt;xml-zipper</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-iphone?</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">loc-iphones</span><span class="p">)</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span></code></pre></div></div>

<p>Now, to find an organization by the product, just go up one level using <code class="language-plaintext highlighter-rouge">zip/up</code>. This is true because the organization is the parent of the product:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-orgs</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">loc-iphones</span><span class="w">
       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">zip/up</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="n">zip/node</span><span class="p">))))</span><span class="w">

</span><span class="p">({</span><span class="no">:name</span><span class="w"> </span><span class="s">"re-Store"</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"re-Store"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>For each iPhone, we should get the organization that sells it. We got duplicates because both iPhones are sold in the re:Store shop. To make the result unique, wrap it in <code class="language-plaintext highlighter-rouge">set</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="n">loc-orgs</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="p">{{</span><span class="no">:name</span><span class="w"> </span><span class="s">"re-Store"</span><span class="p">}}</span><span class="w">

</span></code></pre></div></div>

<p>This is the answer to the question: iPhones can be bought at re:Store. If you add an iPhone to the DNS organization, the latter also appears in <code class="language-plaintext highlighter-rouge">loc-orgs</code>.</p>

<p>Let’s solve the same problem for XML with branches. Now we can’t call <code class="language-plaintext highlighter-rouge">zip/up</code> on a product to get the organization, because in some cases we’ll get a branch and it will take one more step up. In order not to guess how many steps to take up, let’s write the function <code class="language-plaintext highlighter-rouge">loc-&gt;org</code>. It’ll step up until we find the required tag:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-org?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="no">:tag</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:organization</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-&gt;org</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w">
       </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="n">zip/up</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">find-first</span><span class="w"> </span><span class="n">loc-org?</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">find-first</code> utility function finds the first collection element that matches the predicate. We’ll use this function more than once.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">find-first</span><span class="w"> </span><span class="p">[</span><span class="n">pred</span><span class="w"> </span><span class="n">coll</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nf">pred</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
            </span><span class="n">x</span><span class="p">))</span><span class="w">
        </span><span class="n">coll</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>To shorten the code, we won’t declare the variables <code class="language-plaintext highlighter-rouge">loc-iphones</code> and others. Let’s express the search in one form:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"products-branch.xml"</span><span class="w">
     </span><span class="n">-&gt;xml-zipper</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-iphone?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">loc-&gt;org</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="n">zip/node</span><span class="p">))</span><span class="w">
     </span><span class="p">(</span><span class="nb">set</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>In the new solution, we have replaced <code class="language-plaintext highlighter-rouge">zip/up</code> with a function of a more complex climbing algorithm. Otherwise, nothing has changed.</p>

<p>Notice how convenient XML is for searching and navigating. If we store data in JSON, it is a combination of lists and dictionaries, and the versions with and without branches are different.</p>

<p>Here are products without branch stores:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"re-Store"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"products"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iphone"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iPhone 11 Pro"</span><span class="p">},</span><span class="w">
               </span><span class="p">{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iphone"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iPhone SE"</span><span class="p">}]},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"DNS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"products"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tablet"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iPad 3"</span><span class="p">},</span><span class="w">
               </span><span class="p">{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"notebook"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Macbook Pro"</span><span class="p">}]}]</span><span class="w">
</span></code></pre></div></div>

<p>Here are products with them:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"re-Store"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"products"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iphone"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iPhone 11 Pro"</span><span class="p">},</span><span class="w">
               </span><span class="p">{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iphone"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iPhone SE"</span><span class="p">}]},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"DNS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"branches"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Office 1"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"products"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tablet"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iPad 3"</span><span class="p">},</span><span class="w">
                             </span><span class="p">{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"notebook"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Macbook Pro"</span><span class="p">}]},</span><span class="w">
               </span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Office 2"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"products"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tablet"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"iPad 3"</span><span class="p">},</span><span class="w">
                             </span><span class="p">{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"notebook"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Macbook Pro"</span><span class="p">}]}]}]</span><span class="w">
</span></code></pre></div></div>

<p>It goes without saying that traversing these structures requires different code.
In the case of XML, its structure is homogeneous: adding a branch only changes the depth of goods nesting, but the traversal rules remain unchanged.</p>

<p>Let’s complicate the problem requirements: there’re bundles of products among individual ones. A bundle product can’t be purchased separately. For example, screen cleaning wipes  are usually sold with the device. They ask us to find a store where a wipe is sold separately.</p>

<p>Here is an example:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>VIP Fiber Plus<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 2"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;bundle&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>Premium iFiber<span class="nt">&lt;/product&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
      <span class="nt">&lt;/bundle&gt;</span>
    <span class="nt">&lt;/branch&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p>As an exercise let’s find all the wipes. Among them will be both individual products and a set.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-fiber?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"fiber"</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"products-bundle.xml"</span><span class="w">
     </span><span class="n">-&gt;xml-zipper</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-fiber?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="no">:content</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="s">"VIP Fiber Plus"</span><span class="w"> </span><span class="s">"Premium iFiber"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Let’s start solving the problem. First, we find all the wipes as we did above. Then we cut off those that are included in the bundle. In terms of a zipper, this means that this location’s parent doesn’t have the <code class="language-plaintext highlighter-rouge">:bundle</code> tag. After that, we move on from the rest wipes to stores.</p>

<p>The <code class="language-plaintext highlighter-rouge">loc-in-bundle?</code> predicate checks if a location is included in the bundle:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-in-bundle?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/up</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="no">:tag</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:bundle</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The final solution:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"products-bundle.xml"</span><span class="w">
     </span><span class="n">-&gt;xml-zipper</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-fiber?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="n">loc-in-bundle?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">loc-&gt;org</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="n">zip/node</span><span class="p">))</span><span class="w">
     </span><span class="p">(</span><span class="nb">set</span><span class="p">))</span><span class="w">


</span><span class="o">#</span><span class="p">{{</span><span class="no">:name</span><span class="w"> </span><span class="s">"re-Store"</span><span class="p">}}</span><span class="w">

</span></code></pre></div></div>

<p>The DNS store wasn’t included in the result because it sells wipes in a bundle only.</p>

<p>New complication: we want to buy an iPhone, <em>but only in a bundle</em> with a wipe. Which store should you direct a buyer to?</p>

<p>Solution: First, look for all iPhones. Select only those that present in a bundle. Next, we are looking for a wipe among the neighbors of the iPhone. If you find it, go up to the store from the iPhone or the wipe. Most of the functions required for this search are ready: these are predicates for checking a bundle, product type, and other small things. But we have not yet considered how to get the neighbors of the location.</p>

<p>The functions <code class="language-plaintext highlighter-rouge">zip/lefts</code> and <code class="language-plaintext highlighter-rouge">zip/rights</code> return the nodes to the left and right of the current location. If we <code class="language-plaintext highlighter-rouge">concat</code> them, we get all the neighbors (also called peers):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">node-neighbors</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/lefts</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">zip/rights</span><span class="w"> </span><span class="n">loc</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Note: These are nodes, not locations. Let’s make a quick check with a vector:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/right</span><span class="w"> </span><span class="c1">;; node 2</span><span class="w">
    </span><span class="n">node-neighbors</span><span class="p">)</span><span class="w">

</span><span class="c1">;; (1 3)</span><span class="w">
</span></code></pre></div></div>

<p>The zipper is designed in such a way that getting the right and left nodes is easier than moving the location to the left or right. Therefore, when looking for neighbors, it is better to work with nodes (values) rather than locations.</p>

<p>Let’s add functions to check if there is a wipe that is adjacent to the location:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">node-fiber?</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"fiber"</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">with-fiber?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">nodes</span><span class="w"> </span><span class="p">(</span><span class="nf">node-neighbors</span><span class="w"> </span><span class="n">loc</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">find-first</span><span class="w"> </span><span class="n">node-fiber?</span><span class="w"> </span><span class="n">nodes</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Here’s the final expression:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"products-bundle.xml"</span><span class="w">
     </span><span class="n">-&gt;xml-zipper</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-iphone?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-in-bundle?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">with-fiber?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">loc-&gt;org</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="n">zip/node</span><span class="p">))</span><span class="w">
     </span><span class="p">(</span><span class="nb">set</span><span class="p">))</span><span class="w">

</span><span class="c1">;; #{"DNS"}</span><span class="w">
</span></code></pre></div></div>

<p>As a result, we get the DNS store, because it sells the bundles including an iPhone and a wipe. Both of these products are available in re:Store, but separately.
It doesn’t suit us. If we replace a wipe with a headset in the bundle, we’ll get no store.</p>

<p>Finally, we can add new constraints. For example, from the found stores, select those that are located within a radius of 300 meters from the customer. To do this, we need the store locations on the map and a function checking if a point is inside a circle. You can choose only open stores or those that offer delivery. Let’s write these features into the attributes of organizations and add selection functions.</p>

<p>Our XML zipper has become like a database. It provides answers to complex queries, and at the same time, the code grows slower than the semantic load. Because of its regular structure, XML is highly traversable, and zippers further enhance this property. Pay attention to the convenient transitions and relationships between nodes. Imagine the effort it took to split the data into tables and build SQL queries with many JOINs.</p>

<p>Of course, compared to a true database, XML has a drawback: it has no indexes and only a linear search works in it, not a binary tree one. Besides, in our approach, all data is in memory. It won’t work well for very large documents with millions of records, but we don’t care about that yet.</p>

<h2 id="part-5-editing">Part 5. Editing</h2>

<p>So far, we’ve ignored another zipper possibility. During the traversal, you can not only parse but also change locations. In broad terms, all CRUD (Create, Read, Update, Delete) operations familiar from web development are available to us. Below we’ll discuss how they work in zippers.</p>

<p>As you remember, a zipper accepts a third function — <code class="language-plaintext highlighter-rouge">make-node</code>. Until now, we’ve passed <code class="language-plaintext highlighter-rouge">nil</code> to it. We didn’t use it because we only read the data. The zipper will call the function when we ask to return the data with the changes made to the locations. The function takes two parameters: a branch and children. Its task is to relate them in the way it is customary in a tree.</p>

<p>For simple collections like a vector, the function is simple. It only wraps the children in <code class="language-plaintext highlighter-rouge">vec</code> to get a vector from the sequence. In <code class="language-plaintext highlighter-rouge">vector-zip</code>, the function is a little more complex because it takes metadata into account. Here is the entire code of this zipper.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">vector-zip</span><span class="w">
  </span><span class="p">[</span><span class="nb">root</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nb">vector?</span><span class="w">
          </span><span class="nb">seq</span><span class="w">
          </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="nb">children</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">with-meta</span><span class="w"> </span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="nb">children</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">meta</span><span class="w"> </span><span class="nb">node</span><span class="p">)))</span><span class="w">
          </span><span class="nb">root</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>You see that the new vector (form <code class="language-plaintext highlighter-rouge">(vec children)</code>) copies the metadata of the old vector (variable <code class="language-plaintext highlighter-rouge">node</code>). If you supplement the original with <code class="language-plaintext highlighter-rouge">assoc</code> or <code class="language-plaintext highlighter-rouge">conj</code>, the metadata is preserved. In the case of <code class="language-plaintext highlighter-rouge">vector-zip</code>, we are building a new vector,  so we wrap it in <code class="language-plaintext highlighter-rouge">with-meta</code>. If we remove <code class="language-plaintext highlighter-rouge">with-meta</code>, the output will be a vector with no metadata, which may affect the program logic.</p>

<p>The XML zipper has a slightly different build: the children are in the <code class="language-plaintext highlighter-rouge">:content</code> field.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="nb">children</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:content</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="nb">children</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">vector</span><span class="w"> </span><span class="nb">children</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>For our zipper <code class="language-plaintext highlighter-rouge">map-zip</code> that we developed at the beginning, the build function would look like <code class="language-plaintext highlighter-rouge">assoc</code> or <code class="language-plaintext highlighter-rouge">into</code> with a collection of <code class="language-plaintext highlighter-rouge">MapEntry</code> pairs.</p>

<p>The zipper implicitly calls this function if it finds modified nodes. The functions <code class="language-plaintext highlighter-rouge">zip/edit</code>,  <code class="language-plaintext highlighter-rouge">zip/replace</code>, and others are used to modify. Before looking at them, let’s discuss exactly how the modification occurs inside zippers.</p>

<p>The changes are specific because they affect locations, not the source data. After you have worked with a location, it is marked with the <code class="language-plaintext highlighter-rouge">:changed?</code> flag. It is a signal to data re-building using the <code class="language-plaintext highlighter-rouge">zip/root</code> function, which we will discuss later.</p>

<p>Let’s look at an example with the vector <code class="language-plaintext highlighter-rouge">[1 2 3]</code>. Move to 2 and double it using the <code class="language-plaintext highlighter-rouge">zip/edit</code> function. It takes a location, a function, and residual arguments.
You are familiar with this approach from topics about atoms (<code class="language-plaintext highlighter-rouge">swap!</code>) and collections (<code class="language-plaintext highlighter-rouge">update</code>). By analogy with them, a location will receive a new value, which the function calculated based on the previous one.</p>

<p>Here’s the location before changes:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/right</span><span class="p">)</span><span class="w">

</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="no">:l</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="no">:pnodes</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]]</span><span class="w"> </span><span class="no">:ppath</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:r</span><span class="w"> </span><span class="p">(</span><span class="nf">3</span><span class="p">)}]</span><span class="w">
</span></code></pre></div></div>

<p>Now, it’s the location after the changes: Pay attention to the <code class="language-plaintext highlighter-rouge">:changed?</code> key:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="w">
      </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w">

</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="p">{</span><span class="no">:l</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="no">:pnodes</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]]</span><span class="w"> </span><span class="no">:ppath</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:r</span><span class="w"> </span><span class="p">(</span><span class="nf">3</span><span class="p">)</span><span class="w">
    </span><span class="no">:changed?</span><span class="w"> </span><span class="n">true</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>Next, we would like to get the modified vector <code class="language-plaintext highlighter-rouge">[1 4 3]</code>. Let’s do it manually:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
    </span><span class="n">zip/up</span><span class="w">
    </span><span class="n">zip/node</span><span class="p">)</span><span class="w">

</span><span class="c1">;; [1 4 3]</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">zip/root</code> function accepts the location with changes and does the same. Its algorithm looks like this:</p>

<ul>
  <li>ascend to the root location;</li>
  <li>return a node.</li>
</ul>

<p>To get the result in one pass, add <code class="language-plaintext highlighter-rouge">zip/root</code> to the end of the threading macro:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/right</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/root</span><span class="p">)</span><span class="w">

</span><span class="c1">;; [1 4 3]</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">zip/up</code> function, which we called either manually or implicitly in <code class="language-plaintext highlighter-rouge">zip/root</code>, does the bulk of the work. When going up, it checks if the location has been changed, and if so, rebuilds it with <code class="language-plaintext highlighter-rouge">make-node</code>. Here’s a snippet of its code:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">up</span><span class="w">
  </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="nb">node</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="w"> </span><span class="n">changed?</span><span class="w"> </span><span class="no">:changed?</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">path</span><span class="p">}]</span><span class="w"> </span><span class="n">loc</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">pnodes</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pnode</span><span class="w"> </span><span class="p">(</span><span class="nb">peek</span><span class="w"> </span><span class="n">pnodes</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">with-meta</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">changed?</span><span class="w">
                     </span><span class="p">[(</span><span class="nb">make-node</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">pnode</span><span class="w"> </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">
                      </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">ppath</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">...</span><span class="p">))]</span><span class="w">
                     </span><span class="p">[</span><span class="n">pnode</span><span class="w"> </span><span class="n">ppath</span><span class="p">])</span><span class="w">
                   </span><span class="p">(</span><span class="nb">meta</span><span class="w"> </span><span class="n">loc</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<h3 id="multiple-change">Multiple change</h3>

<p>When changing one location, problems usually don’t arise. However, we rarely modify a single location. In practice, we do it in a batch depending on some conditions.</p>

<p>Previously, we decomposed the zipper into a sequence of locations using <code class="language-plaintext highlighter-rouge">iter-zip</code>, and then passed it through a series of <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>, and other functions. This method isn’t suitable when editing. For example, we selected the second item from the <code class="language-plaintext highlighter-rouge">zip-iter</code> result and modified it:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-seq</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="n">iter-zip</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-seq</span><span class="w"> </span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">

</span><span class="c1">;; [4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)</span><span class="w">
</span><span class="c1">;;    :changed? true}]</span><span class="w">
</span></code></pre></div></div>

<p>Zippers themselves are immutable, and any action will return a new location. At the same time, the <code class="language-plaintext highlighter-rouge">zip-iter</code> function is designed so that each next location is obtained from the previous one. Calling <code class="language-plaintext highlighter-rouge">zip/edit</code> on one of the elements will not affect subsequent ones. If we go up from the last location, we get the vector unchanged, even if we have edited some locations in the middle before.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-seq</span><span class="w"> </span><span class="nb">last</span><span class="w"> </span><span class="n">zip/up</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 2 3]</span><span class="w">
</span></code></pre></div></div>

<p>The following patterns are used when editing zippers.</p>

<p><strong>One element changes.</strong> In this case, we iterate through the zipper until we meet the required location in the chain. Then we change it and call <code class="language-plaintext highlighter-rouge">zip/root</code>.</p>

<p><strong>Many elements change.</strong> With <code class="language-plaintext highlighter-rouge">loop</code> and <code class="language-plaintext highlighter-rouge">zip/next</code> we manually iterate through the zipper. In this case, the specified function either changes the location or leaves it intact. The <code class="language-plaintext highlighter-rouge">recur</code> form gets <code class="language-plaintext highlighter-rouge">zip/next</code> from the function result. So if there were changes, <code class="language-plaintext highlighter-rouge">zip/next</code> will work with the new location, not the previous one.</p>

<p>The following functions can change locations:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">zip/replace</code> is a literal replacement of the current node with another;</li>
  <li><code class="language-plaintext highlighter-rouge">zip/edit</code> is a more flexible node replacement. Similar to <code class="language-plaintext highlighter-rouge">update</code> and <code class="language-plaintext highlighter-rouge">swap!</code>
it takes a function and additional arguments. The current node is the first argument
of the function. The result will replace the location content;</li>
  <li><code class="language-plaintext highlighter-rouge">zip/remove</code> deletes a location and moves the pointer to the parent.</li>
</ul>

<p>Functions for inserting neighbors or children:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">zip/insert-left</code> adds a neighbor to the left of the current location;</li>
  <li><code class="language-plaintext highlighter-rouge">zip/insert-right</code> adds a neighbor to the right;</li>
  <li><code class="language-plaintext highlighter-rouge">zip/insert-child</code> adds a child to the beginning of the current location;</li>
  <li><code class="language-plaintext highlighter-rouge">zip/append-child</code> adds a child to the end.</li>
</ul>

<p>Neighbors and children differ in hierarchy. The neighbor appears on the same level as the location, and the child appears below. In the center of the diagram is the location with the vector <code class="language-plaintext highlighter-rouge">[2 3]</code>. Its neighbors are numbers 1 and 4, and its children are 2 and 3.</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

                ┌─────────────┐
                │ [1 [2 3] 4] │
                └─────────────┘
                       ▲
                       │
    ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
    │   1   │◀───┃   [2 3]   ┃───▶│   4   │
    └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                       │
                 ┌─────┴─────┐
                 ▼           ▼
             ┌───────┐   ┌───────┐
             │   2   │   │   3   │
             └───────┘   └───────┘

</code></pre></div></div>

<p>Let’s look at these functions with simple examples. Suppose there is the key <code class="language-plaintext highlighter-rouge">:error</code> deep in the nested vectors. You need to change this to <code class="language-plaintext highlighter-rouge">:ok</code>. First, let’s add a predicate for the search:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-error?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:error</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Now, we’ll find the location, fix it and go up to the root:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="w"> </span><span class="no">:error</span><span class="p">]]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-error</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">data</span><span class="w">
       </span><span class="n">zip/vector-zip</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nf">find-first</span><span class="w"> </span><span class="n">loc-error?</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-error</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/replace</span><span class="w"> </span><span class="no">:ok</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/root</span><span class="p">)</span><span class="w">

</span><span class="c1">;; [1 2 [3 4 [5 :ok]]]</span><span class="w">
</span></code></pre></div></div>

<p>Another example: change all <code class="language-plaintext highlighter-rouge">nil</code> items to <code class="language-plaintext highlighter-rouge">0</code> in the nested vector to make the math safe. This time there may be more than one location, so a traversal through the <code class="language-plaintext highlighter-rouge">loop</code> is required. At each step, we check if the location matches the condition, and if so, we pass the <code class="language-plaintext highlighter-rouge">zip/next</code> call from the modified version to <code class="language-plaintext highlighter-rouge">recur</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="n">nil</span><span class="p">]]</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/vector-zip</span><span class="w"> </span><span class="n">data</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/end?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="nb">nil?</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/next</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/replace</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/next</span><span class="w"> </span><span class="n">loc</span><span class="p">)))))</span><span class="w">

</span><span class="c1">;; [1 2 [5 0 2 [3 0]] 0 1]</span><span class="w">
</span></code></pre></div></div>

<p>Do the same, but replace all negative numbers modulo. First, let’s declare the <code class="language-plaintext highlighter-rouge">abs</code> function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">abs</span><span class="w"> </span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">neg?</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w">
    </span><span class="n">num</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The traversal is similar to the previous one, but now instead of <code class="language-plaintext highlighter-rouge">zip/replace</code>, we call
<code class="language-plaintext highlighter-rouge">zip/edit</code>. It updates the content of the location, based on the previous value:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">-1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="w"> </span><span class="mi">-2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">-3</span><span class="w"> </span><span class="mi">2</span><span class="p">]]</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">5</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/vector-zip</span><span class="w"> </span><span class="n">data</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/end?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="n">number?</span><span class="p">)</span><span class="w">
             </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="nb">neg?</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/next</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">abs</span><span class="p">)))</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/next</span><span class="w"> </span><span class="n">loc</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>In both cases, the loop logic is simple. If this is the final location, return its node. Recall that the final location is the initial location when you’ve returned to it after a series of <code class="language-plaintext highlighter-rouge">zip/next</code> calls. Otherwise, if the location contains a negative number, we change the content with <code class="language-plaintext highlighter-rouge">zip/edit</code>. From the changed location, we traverse to the next one. The key point: on the penultimate line, the call
<code class="language-plaintext highlighter-rouge">zip/next</code> takes the result of <code class="language-plaintext highlighter-rouge">zip/edit</code>, not the initial location. That is, changes in it will be passed on to the next step.</p>

<p>The examples above allow you to see patterns — repetitive techniques. Let’s put them in separate functions so as not to waste attention on them in the future.</p>

<p><strong>Search for a location by predicate.</strong>  It takes an initial location and predicate, and starts iteration. It returns the first location that matches the predicate:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">find-loc</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">loc-pred</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nf">find-first</span><span class="w"> </span><span class="n">loc-pred</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><strong>Run locations with changes.</strong> It iterates locations using <code class="language-plaintext highlighter-rouge">zip/next</code> and <code class="language-plaintext highlighter-rouge">loop/recur</code>. When moving to the next step, it wraps the location into a function. The function should either change the location or return it unchanged. This is a generic version of <code class="language-plaintext highlighter-rouge">loop</code> we wrote above.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">alter-loc</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">loc-fn</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">loc</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/end?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
      </span><span class="n">loc</span><span class="w">
      </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">loc-fn</span><span class="w"> </span><span class="n">zip/next</span><span class="w"> </span><span class="n">recur</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Let’s rewrite the example with the new functions. Find in the vector a location which node is 2.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-2?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="p">(</span><span class="nf">find-loc</span><span class="w"> </span><span class="n">loc-2?</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Let’s double it and go to the final vector:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-2</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">zip/root</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 4 2]</span><span class="w">
</span></code></pre></div></div>

<p>Let’s change the negative numbers modulo. To do this, we’ll create the <code class="language-plaintext highlighter-rouge">loc-abs</code> function. If the node has a negative number, we’ll return the corrected location, otherwise, the original one:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-abs</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="n">number?</span><span class="p">)</span><span class="w">
           </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="nb">neg?</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">abs</span><span class="p">)</span><span class="w">
    </span><span class="n">loc</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Pass it to <code class="language-plaintext highlighter-rouge">alter-loc</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">-1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="w"> </span><span class="mi">-2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">-3</span><span class="w"> </span><span class="mi">2</span><span class="p">]]</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="p">(</span><span class="nf">alter-loc</span><span class="w"> </span><span class="n">loc-abs</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/node</span><span class="p">)</span><span class="w">

</span><span class="c1">;; [1 2 [5 2 2 [3 2]] 1 5]</span><span class="w">
</span></code></pre></div></div>

<h3 id="prices-in-xml">Prices in XML</h3>

<p>Let’s move on to more realistic examples with XML and products. Prepare the next file:
<code class="language-plaintext highlighter-rouge">products-price.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"fiber"</span> <span class="na">price=</span><span class="s">"8.99"</span><span class="nt">&gt;</span>VIP Fiber Plus<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"iphone"</span> <span class="na">price=</span><span class="s">"899.99"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 2"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;bundle&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"fiber"</span> <span class="na">price=</span><span class="s">"9.99"</span><span class="nt">&gt;</span>Premium iFiber<span class="nt">&lt;/product&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">type=</span><span class="s">"iphone"</span> <span class="na">price=</span><span class="s">"999.99"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
      <span class="nt">&lt;/bundle&gt;</span>
    <span class="nt">&lt;/branch&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p>Note that products now have prices — a characteristic that changes frequently.</p>

<p>As you might remember, in terms of Clojure, XML is nested dictionaries with keys.
<code class="language-plaintext highlighter-rouge">:tag</code>, <code class="language-plaintext highlighter-rouge">:attrs</code> и <code class="language-plaintext highlighter-rouge">:content</code>. But after the changes, we would like to see it in its usual, textual form. We need the opposite action: converting XML from the data structure to text. To do this, import the built-in <code class="language-plaintext highlighter-rouge">clojure.xml</code> module. Its <code class="language-plaintext highlighter-rouge">emit</code> function prints XML.</p>

<p>Often, <code class="language-plaintext highlighter-rouge">emit</code> is wrapped in <code class="language-plaintext highlighter-rouge">with-out-str</code> (a macro to intercept printing to a string). In the examples below, we’ll output the XML in the console. Since <code class="language-plaintext highlighter-rouge">emit</code> doesn’t support indentation, we will add it manually for clarity.</p>

<p><strong>The first task</strong> is to make a 10 percent discount on all iPhones. We have almost all abstractions ready,
so let’s write the solution from top to bottom:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.xml</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">xml</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"products-price.xml"</span><span class="w">
    </span><span class="n">-&gt;xml-zipper</span><span class="w">
    </span><span class="p">(</span><span class="nf">alter-loc</span><span class="w"> </span><span class="n">alter-iphone-price</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/node</span><span class="w">
    </span><span class="n">xml/emit</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>These five lines are enough for our task. It remains to write the <code class="language-plaintext highlighter-rouge">alter-iphone-price</code> function. We need the function to take an iPhone location and return it, but with a different <code class="language-plaintext highlighter-rouge">price</code> attribute. A location of a different type will remain unchanged. Let’s describe the function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">alter-iphone-price</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">loc-iphone?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/edit</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">alter-attr-price</span><span class="w"> </span><span class="mf">0.9</span><span class="p">)</span><span class="w">
    </span><span class="n">loc</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">loc-iphone?</code> predicate checks if the location holds an iPhone. We’ve already written it in our
previous lessons:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-iphone?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:tag</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:product</span><span class="p">))</span><span class="w">
         </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"iphone"</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">alter-attr-price</code> function takes a node (i.e., location content) and must change its attribute. The second function argument is the factor by which the current price should be multiplied. The slight difficulty is that attributes in XML are strings. To perform multiplication, you need to convert a string to a number, multiply it by a factor, and then convert the result, rounded to two digits, back to a string. All together gives us this function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">alter-attr-price</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="n">ratio</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="p">[</span><span class="no">:attrs</span><span class="w"> </span><span class="no">:price</span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">price</span><span class="p">]</span><span class="w">
               </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">price</span><span class="w">
                    </span><span class="n">read-string</span><span class="w">
                    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">ratio</span><span class="p">)</span><span class="w">
                    </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%.2f"</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Quick check of the function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">alter-attr-price</span><span class="w"> </span><span class="p">{</span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:price</span><span class="w"> </span><span class="s">"10"</span><span class="p">}}</span><span class="w"> </span><span class="mf">1.1</span><span class="p">)</span><span class="w">
</span><span class="c1">;; {:attrs {:price "11.00"}}</span><span class="w">
</span></code></pre></div></div>

<p>After running the whole chain, we should get XML:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"8.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>VIP Fiber Plus<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"809.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 2"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;bundle&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"9.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>Premium iFiber<span class="nt">&lt;/product&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"899.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
      <span class="nt">&lt;/bundle&gt;</span>
    <span class="nt">&lt;/branch&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p>As a result, the price of iPhones changed by 10 percent, while the rest of the products remained
the same.</p>

<p><strong>More difficult task</strong>: add a new product — a headset — to all bundles. Again, let’s describe the solution from top to bottom:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"products-price.xml"</span><span class="w">
    </span><span class="n">-&gt;xml-zipper</span><span class="w">
    </span><span class="p">(</span><span class="nf">alter-loc</span><span class="w"> </span><span class="n">add-to-bundle</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/node</span><span class="w">
    </span><span class="n">xml/emit</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The solution differs from the previous one only in the <code class="language-plaintext highlighter-rouge">add-to-bundle</code> functions. Its logic is as follows: if the current location is a bundle, add a child to it, and if not, just return the location.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add-to-bundle</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">loc-bundle?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">zip/append-child</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">node-headset</span><span class="p">)</span><span class="w">
    </span><span class="n">loc</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Checking whether it’s a bundle or not:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-bundle?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="no">:tag</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:bundle</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">zip/append-child</code> function appends the value to the end of the location’s children. In our case, it’s the <code class="language-plaintext highlighter-rouge">node-headset</code> node, which we put into a constant:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">node-headset</span><span class="w">
  </span><span class="p">{</span><span class="no">:tag</span><span class="w"> </span><span class="no">:product</span><span class="w">
   </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="s">"headset"</span><span class="w">
           </span><span class="no">:price</span><span class="w"> </span><span class="s">"199.99"</span><span class="p">}</span><span class="w">
   </span><span class="no">:content</span><span class="w"> </span><span class="p">[</span><span class="s">"AirPods Pro"</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Here’s the final XML where a new product has been added into the bundles:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"8.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>VIP Fiber Plus<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"899.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 2"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;bundle&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"9.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>Premium iFiber<span class="nt">&lt;/product&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"999.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
        <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"199.99"</span> <span class="na">type=</span><span class="s">"headset"</span><span class="nt">&gt;</span>AirPods Pro<span class="nt">&lt;/product&gt;</span>
      <span class="nt">&lt;/bundle&gt;</span>
    <span class="nt">&lt;/branch&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p><strong>The third task</strong> is to do away with all bundles. We decided that it was not profitable to sell items in bundles. All <code class="language-plaintext highlighter-rouge">&lt;bundle&gt;</code> tags are removed from XML, but their products must go to organizations.</p>

<p>And for the third time, the solution differs only in the function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"products-price.xml"</span><span class="w">
    </span><span class="n">-&gt;xml-zipper</span><span class="w">
    </span><span class="p">(</span><span class="nf">alter-loc</span><span class="w"> </span><span class="n">disband-bundle</span><span class="p">)</span><span class="w">
    </span><span class="n">zip/node</span><span class="w">
    </span><span class="n">xml/emit</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Let’s describe the <code class="language-plaintext highlighter-rouge">disband-bundle</code> algorithm. If the current node is a bundle, we save its children (products) to a variable to not lose them. Then we delete the bundle, which will return the parent of the deleted location. In our case, it’s an organization. We return it with the products attached.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">disband-bundle</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">loc-bundle?</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">products</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/children</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w">
          </span><span class="n">loc-org</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/remove</span><span class="w"> </span><span class="n">loc</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">append-childs</span><span class="w"> </span><span class="n">loc-org</span><span class="w"> </span><span class="n">products</span><span class="p">))</span><span class="w">
    </span><span class="n">loc</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">append-childs</code> function is our wrapper over the built-in <code class="language-plaintext highlighter-rouge">zip/append-child</code>. The latter attaches only one element, which is inconvenient. To join a list, let’s write a helper function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">append-childs</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">items</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">item</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nf">zip/append-child</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">item</span><span class="p">))</span><span class="w">
          </span><span class="n">loc</span><span class="w">
          </span><span class="n">items</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Here’s the final XML with no bundles, but with the same products:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;catalog&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"re-Store"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"8.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>VIP Fiber Plus<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"899.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
  <span class="nt">&lt;organization</span> <span class="na">name=</span><span class="s">"DNS"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;branch</span> <span class="na">name=</span><span class="s">"Office 2"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"9.99"</span> <span class="na">type=</span><span class="s">"fiber"</span><span class="nt">&gt;</span>Premium iFiber<span class="nt">&lt;/product&gt;</span>
      <span class="nt">&lt;product</span> <span class="na">price=</span><span class="s">"999.99"</span> <span class="na">type=</span><span class="s">"iphone"</span><span class="nt">&gt;</span>iPhone 11 Pro<span class="nt">&lt;/product&gt;</span>
    <span class="nt">&lt;/branch&gt;</span>
  <span class="nt">&lt;/organization&gt;</span>
<span class="nt">&lt;/catalog&gt;</span>
</code></pre></div></div>

<p>We hope these examples are enough for you to understand how to edit zippers. Note that it took a little code: for each task, we wrote, on average, three functions. Another advantage is that the code is stateless. All functions are pure, and their call doesn’t affect the data. Should an exception pop up somewhere in the middle of editing, the XML tree won’t be half-changed.</p>

<h2 id="part-6-virtual-trees-currency-exchange">Part 6. Virtual Trees. Currency Exchange</h2>

<p>We hope that the theory and examples were enough to start experimenting with zippers. We bring to your attention an unusual example.</p>

<p>So far, the second function we passed to a zipper returned children from a branch. For a vector we used <code class="language-plaintext highlighter-rouge">seq</code>, for XML — a more complex combination <code class="language-plaintext highlighter-rouge">(comp seq :content)</code>. Both options depend on the parent node, and if there are no children, the functions return <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>But what happens if the function returns a constant set of children:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>How will such a zipper behave? Let’s write it:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">zip-123</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w"> </span><span class="n">any?</span><span class="w">
              </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
              </span><span class="n">nil</span><span class="w">
              </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Due to the fact that each element has three children, the zipper will become infinite. Traversing it with <code class="language-plaintext highlighter-rouge">iter-zip</code> doesn’t work. <code class="language-plaintext highlighter-rouge">Zip/next</code> will plunge deeper and deeper into the zipper but never reach its end.</p>

<p>For fun, let’s take a few steps on the new zipper. Let’s go down and to the right. We will find ourselves on 2 in the middle of the vector <code class="language-plaintext highlighter-rouge">[1 2 3]</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">zip-123</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc-2</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">
</span></code></pre></div></div>

<p>Let’s see our position on the diagram. A step to the left will move us on 1, a step to the right — on 3:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │     1     │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │[1 2 3]│
                └───────┘
</code></pre></div></div>

<p>Stepping down we fall into the next vector <code class="language-plaintext highlighter-rouge">[1 2 3]</code> and so on. Let’s go down and to the right five more times, and still end up in 2:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">down-right</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">zip/right</span><span class="w"> </span><span class="n">zip/down</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">
</span></code></pre></div></div>

<p>The zipper can be called virtual because the data we travel through doesn’t really exist — they appear on the fly.</p>

<p>What the use of this zipper is yet to be seen. However, it confirms the important thesis that you can get child nodes in the process of traversing the tree. This does not violate the zipper rules and provides new opportunities.</p>

<p>However, the explicitly specified vector <code class="language-plaintext highlighter-rouge">[1 2 3]</code> doesn’t expose them. If the children are known in advance, there is no need for a zipper, since the collection can be traversed in an easier way. A suitable case is when children depend on some external factors. For example, both functions <code class="language-plaintext highlighter-rouge">branch?</code> and <code class="language-plaintext highlighter-rouge">children</code> rely on other collections and data. This is also a traversal, but according to different rules.</p>

<p>Let’s look at the following problem. A bank exchanges currencies, for example, dollars for euros,
rubles for lira, and so on. For brevity, let’s designate them in pairs: <code class="language-plaintext highlighter-rouge">(usd, eur)</code> and <code class="language-plaintext highlighter-rouge">(rub, lir)</code>. The exchange works in one direction. To exchange euros for dollars or lira for rubles, the bank must have separate rules <code class="language-plaintext highlighter-rouge">(eur, usd)</code> and <code class="language-plaintext highlighter-rouge">(lir, rub)</code>.</p>

<p>The client contacts the bank to exchange the currency <code class="language-plaintext highlighter-rouge">X</code> for <code class="language-plaintext highlighter-rouge">Y</code>. If there is a pair <code class="language-plaintext highlighter-rouge">(X, Y)</code> in the exchange rules, there’s no problem. But if there is no such pair, the bank must build a chain of exchanges. For example, a client wants to exchange dollars for lira, but the bank doesn’t have the direct pair <code class="language-plaintext highlighter-rouge">(usd, lir)</code>. However, there are pairs <code class="language-plaintext highlighter-rouge">(usd, eur)</code> and <code class="language-plaintext highlighter-rouge">(eur, lir)</code>. In this case, the client will be offered the exchange <code class="language-plaintext highlighter-rouge">usd -&gt; eur -&gt; lir</code>.</p>

<p>Write a program that accepts exchange rules, as well as input and output currencies. You have to find the exchange chains. The shorter the chain, the better. If multiple chains of the same length are possible, return all of them so the client can choose. Consider the option when there are no solutions and provide an adequate response  to this case, so as not to go into an eternal loop and not take up all the computer’s resources.</p>

<p>Let’s describe the input data in terms of Clojure. Each rule will be a vector of two keywords — which currency is exchanged for which one. The vector of rules will be called <code class="language-plaintext highlighter-rouge">rules</code>. In addition to the rules, we takes the parameters <code class="language-plaintext highlighter-rouge">from</code> and <code class="language-plaintext highlighter-rouge">to</code> — these indicate which currency to change from and to which one.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; rules</span><span class="w">
</span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="p">]]</span><span class="w">

</span><span class="no">:usd</span><span class="w"> </span><span class="c1">;; from</span><span class="w">
</span><span class="no">:rub</span><span class="w"> </span><span class="c1">;; to</span><span class="w">
</span></code></pre></div></div>

<p>The output should be a set of chains from <code class="language-plaintext highlighter-rouge">from</code> to <code class="language-plaintext highlighter-rouge">to</code> or <code class="language-plaintext highlighter-rouge">nil</code>. For the case above, the chain from dollar to euro looks like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>All together gives the function <code class="language-plaintext highlighter-rouge">exchanges</code>, which body we have to fill:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">exchanges</span><span class="w"> </span><span class="p">[</span><span class="n">rules</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">to</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>First, let’s write some tests. They will help us warm up, and at the same time we’ll understand the problem better. The first test is a simple exchange, there is a rule for it:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-simple</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>A reverse exchange is impossible unless there is a reverse rule:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-reverse-err</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:usd</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Here’s a case where the exchange chain doesn’t exist:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-no-solution</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:usd</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:eur</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>The most important scenario is multiple exchange. You can get from dollars to rubles in two ways – with euros or lira in the middle:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-two-ways</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
          </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Another test checks if we only return the shortest chains. An exchange with four currencies (in this case, <code class="language-plaintext highlighter-rouge">[: usd: yen: eur: rub]</code>) is not included in the result:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-short-ways-only</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
          </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:yen</span><span class="w"> </span><span class="no">:eur</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>In terms of competitive programming, we can say that the problem offers separate edges of the graph. It’s required to check whether it’s possible to construct a continuous route from the vertex A to B from the edges. But since we’re solving the problem with zippers, we won’t use the terms “graph” and “edges”. We don’t guarantee that the solution will be optimal — perhaps the graph algorithm will do better. However, we hope that the example will further reveal the power of zippers.</p>

<p>As you remember, zippers are used to traverse trees, which is included in the problem statement. Let’s say the <code class="language-plaintext highlighter-rouge">from</code> currency, which we want to exchange, is at the root node of the tree. Let it be a dollar. Obviously, children of this currency are all those that can be exchanged for the dollar. To do this, select the second element from each pair, where the first element is <code class="language-plaintext highlighter-rouge">:usd</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">rules</span><span class="w">
  </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:tug</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="no">:usd</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">usd-children</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">]</span><span class="w"> </span><span class="n">rules</span><span class="w">
        </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">from</span><span class="p">)]</span><span class="w">
    </span><span class="n">v2</span><span class="p">))</span><span class="w">

</span><span class="c1">;; (:rub :lir)</span><span class="w">
</span></code></pre></div></div>

<p>In our case, the dollar children are the ruble and the lira. Let’s draw an imaginary tree and mark the levels:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                  ┌───────┐
     1            │  usd  │
                  └───────┘
                      │
          ┌───────┐   │   ┌───────┐
     2    │  rub  │◀──┴──▶│  lir  │
          └───────┘       └───────┘
</code></pre></div></div>

<p>For each currency of the second level, we’ll find child nodes according to the same rule. For convenience, let’s write the <code class="language-plaintext highlighter-rouge">get-children</code> function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-children</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">]</span><span class="w"> </span><span class="n">rules</span><span class="w">
        </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">value</span><span class="p">)]</span><span class="w">
    </span><span class="n">v2</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">get-children</span><span class="w"> </span><span class="no">:rub</span><span class="p">)</span><span class="w">
</span><span class="c1">;; (:eur :yen)</span><span class="w">
</span></code></pre></div></div>

<p>The new tree:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      ┌───────┐
    1                 │  usd  │
                      └───────┘
                          │
              ┌───────┐   │   ┌───────┐
    2         │  rub  │◀──┴──▶│  lir  │
              └───────┘       └───────┘
                  │               │
       ┌───────┐  │  ┌───────┐    │  ┌───────┐
    3  │  eur  │◀─┴─▶│  yen  │    └─▶│  tug  │
       └───────┘     └───────┘       └───────┘
</code></pre></div></div>

<p>Note: it’s exactly the virtual tree that we talked about recently. We don’t have this tree in advance, it appears in the process. The <code class="language-plaintext highlighter-rouge">make-children</code> function is closed on the original exchange pairs. This is an example of traversing a data structure that we get on the fly from other data.</p>

<p>The structure of the currency tree is known and can be traversed. The question is, how deep should we traverse it? Apparently, we should stop as soon as we meet a location which node is equal to the <code class="language-plaintext highlighter-rouge">to</code> currency. Let it be yen. That is, we’ve connected <code class="language-plaintext highlighter-rouge">from</code> and <code class="language-plaintext highlighter-rouge">to</code> using other currencies. Let’s show the solution on the diagram:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      ┌───────┐
    1                 │  usd  │
                      └───────┘
                          │
              ┌───────┐   │   ┌ ─ ─ ─ ┐
    2         │  rub  │◀──┘
              └───────┘       └ ─ ─ ─ ┘
                  │
       ┌ ─ ─ ─ ┐  │  ┌───────┐       ┌ ─ ─ ─ ┐
    3             └─▶│  yen  │
       └ ─ ─ ─ ┘     └───────┘       └ ─ ─ ─ ┘

</code></pre></div></div>

<p>To get the exchange chain, we pass the <code class="language-plaintext highlighter-rouge">to</code> location to the <code class="language-plaintext highlighter-rouge">zip/path</code> function. It should return the vector of all the location’s parents, excluding itself. So, the path to the location and its node form an exchange chain.</p>

<p>We’ll write the code based on this reasoning. Let’s prepare a zipper:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">zip-val</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w"> </span><span class="nb">keyword?</span><span class="w">      </span><span class="c1">;; is it currency?</span><span class="w">
              </span><span class="n">get-children</span><span class="w">  </span><span class="c1">;; what can it be exchanged for?</span><span class="w">
              </span><span class="n">nil</span><span class="w">
              </span><span class="n">from</span><span class="p">))</span><span class="w">        </span><span class="c1">;; original currency</span><span class="w">
</span></code></pre></div></div>

<p>Look for a location with the target currency in the zipper:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-to?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">to</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-to</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">zip-val</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nf">find-first</span><span class="w"> </span><span class="n">loc-to?</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>If it’s found, we get an exchange chain from it. To do this, add the <code class="language-plaintext highlighter-rouge">to</code> value to the path:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/path</span><span class="w"> </span><span class="n">loc-to</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc-to</span><span class="p">))</span><span class="w">

</span><span class="c1">;; [:usd :rub :yen]</span><span class="w">
</span></code></pre></div></div>

<p>We have solved the main problem. But there’re drawbacks: for any data, we receive only one chain, even if there are several of them. To fix this, let’s search not only for the first location with the <code class="language-plaintext highlighter-rouge">to</code> currency, but all of them using <code class="language-plaintext highlighter-rouge">filter</code>.</p>

<p>Let’s expand the initial data:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">rules</span><span class="w">
  </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:tug</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="no">:usd</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="no">:yen</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>and find chains. To do this, replace <code class="language-plaintext highlighter-rouge">find-first</code> with <code class="language-plaintext highlighter-rouge">filter</code>, which should return all elements matching the predicate.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">locs-to</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">zip-val</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-to?</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>For each location found, let’s build a path:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">locs-to</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/path</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)))</span><span class="w">

</span><span class="p">([</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Now we’ve found chains of any length, which may be redundant. According to the problem statement, we reject an exchange of four operations if we find it with two. Let’s write a function
that returns the shortest lists from the result above. It groups exchanges by length, finds the shortest one, and selects it from a map.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-shortest-chains</span><span class="w">
  </span><span class="p">[</span><span class="n">chains</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">chains</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">count-&gt;chains</span><span class="w"> </span><span class="p">(</span><span class="nf">group-by</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="n">chains</span><span class="p">)</span><span class="w">
          </span><span class="n">min-count</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">min</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">count-&gt;chains</span><span class="p">))]</span><span class="w">
      </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">count-&gt;chains</span><span class="w"> </span><span class="n">min-count</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>For the last result, we get two vectors with three currencies in each. The last test <code class="language-plaintext highlighter-rouge">test-short-ways-only</code>, where long chains are discarded, covers this case:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>Build the <code class="language-plaintext highlighter-rouge">exchanges</code> function from the code snippets. Make sure all tests pass. Add more cases to them.</p>

<p>It seems that the problem has been solved, but you can improve the solution. The fact is that with certain input data, the tree might become infinite. The program will either go into an infinite loop
or, with a limited number of steps, won’t find a solution. Try to guess what might be causing this and how to  fix it. In the next section, you will find the answer to these questions.</p>

<h2 id="part-7-breadth-first-traversal-improved-currency-exchange">Part 7. Breadth-First Traversal. Improved Currency Exchange</h2>

<p>Previously, we worked with the currency tree to find the exchange chain. We solved the problem, but mentioned that in special cases the tree can turn out to be infinite. How is this possible? Let’s remember how <code class="language-plaintext highlighter-rouge">zip/next</code> traverses the tree.</p>

<p>The algorithm is called <code class="language-plaintext highlighter-rouge">depth-first</code>. With this traversal, the code first walks down and only then to the side (in our case, to the right). This is easy to see if you decompose the data into parts using
a zipper:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w">
     </span><span class="n">zip/vector-zip</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">println</span><span class="p">))</span><span class="w">

</span><span class="c1">;; 1</span><span class="w">
</span><span class="c1">;; [2 [3] 4]</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">
</span><span class="c1">;; [3]</span><span class="w">
</span><span class="c1">;; 3</span><span class="w">
</span><span class="c1">;; 4</span><span class="w">
</span><span class="c1">;; 5</span><span class="w">
</span></code></pre></div></div>

<p>The number <code class="language-plaintext highlighter-rouge">3</code> preceding <code class="language-plaintext highlighter-rouge">4</code> means the zipper goes deep first (inside the vector <code class="language-plaintext highlighter-rouge">[3]</code>) and only then to the right.</p>

<p>Even more interesting is the case with a naive virtual tree, where each node has children <code class="language-plaintext highlighter-rouge">[1 2 3]</code>. When traversing such a tree, the zipper will tend downward, each time descending into the next vector <code class="language-plaintext highlighter-rouge">[1 2 3]</code> and stopping at 1. Let’s show this in the diagram:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">zip-123</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w"> </span><span class="n">any?</span><span class="w">
              </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
              </span><span class="n">nil</span><span class="w">
              </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                       ┌───────┐
                       │[1 2 3]│
                       └───────┘
                           │
               ┌───────┐   │
               │[1 2 3]│◀──┘
               └───────┘
                   │
        ┌───────┐  │
        │[1 2 3]│◀─┘
        └───────┘
            │
            │
    ...   ◀─┘

</code></pre></div></div>

<p>Since there is no condition in our zipper to stop the production of child nodes, their nesting is unlimited. The <code class="language-plaintext highlighter-rouge">iter-zip</code> function returns an infinite chain of locations, each containing <strong>1</strong>. It doesn’t matter how much “1” we take from it — a hundred or a thousand — we get the same number of “1”.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">zip-123</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">zip/node</span><span class="p">))</span><span class="w">

</span><span class="c1">;; (1 1 1 1 1 1 1 1 1 1)</span><span class="w">
</span></code></pre></div></div>

<p>Now let’s get back to currency exchange. Suppose a bank changes rubles for dollars, dollars for euros, and euros for rubles. Let’s express it in code:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">rules</span><span class="w">
  </span><span class="p">[[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:usd</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>

<p>As you can see, we have a vicious circle:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             ┌───────┐
        ┌───▶│  rub  │────┐
        │    └───────┘    │
        │                 ▼
    ┌───────┐         ┌───────┐
    │  eur  │◀────────│  usd  │
    └───────┘         └───────┘
</code></pre></div></div>

<p>The previous solution ignores the cyclical nature of the rules, this is its drawback. Suppose a client wants to exchange rubles for lira. Let’s start building a tree from the ruble. Here’s the beginning of the chain:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                       ┌───────┐
                       │  rub  │
                       └───────┘
                           │
               ┌───────┐   │
               │  usd  │◀──┘
               └───────┘
                   │
        ┌───────┐  │
        │  eur  │◀─┘
        └───────┘
            │
 ┌───────┐  │
 │  rub  │◀─┘
 └───────┘
</code></pre></div></div>

<p>So we came to the ruble again. For it, we get the dollar again, for the dollar the euro, then the ruble. If we continue to iterate, we’ll dive into this chain endlessly.</p>

<p>Logic dictates that you need to stop going deep if the next currency is equal to the initial one. Simply put, a <code class="language-plaintext highlighter-rouge">:rub</code> element that is not at the root node can’t have children. However, in the <code class="language-plaintext highlighter-rouge">branch?</code> and <code class="language-plaintext highlighter-rouge">make-children</code> functions, we don’t know where the element is located in the tree. They get values, not locations. We could fix this with a state, such as an atom, that would hold the list of the currencies that we traversed.</p>

<p>Another option is to check how many times we are referring to the <code class="language-plaintext highlighter-rouge">from</code> currency to find children. If this is the first call, then we’re at the top of the tree (i.e., at the root node) Let’s find the children
and change the atom on which the <code class="language-plaintext highlighter-rouge">children</code> function is closed. If not for the first time (atom
changed), we came across a cyclical case, and there are no children for it.</p>

<p>Both options have the right to exist, but for now, we want to do without state and mutable means.</p>

<p>If you examine the tree again, it becomes clear that the problem lies in the traversal order. Since we strive in depth, there is a high probability of falling into a wormhole from which we cannot get out. We might be lucky if we successfully stepped into the branch with the solution (on the left), and the infinite branch (on the right) remained untouched:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                 ┌───────┐
                 │  rub  │
                 └───────┘
                     │
         ┌───────┐   │   ┌───────┐
         │  yen  │◀──┴──▶│  usd  │
         └───────┘       └───────┘
             │               │
 ┏━━━━━━━┓   │               │   ┌───────┐
 ┃  lir  ┃◀──┘               └──▶│  eur  │
 ┗━━━━━━━┛                       └───────┘
                                     │
                                     │   ┌───────┐
                                     └──▶│  rub  │
                                         └───────┘
                                             │
                                             │
                                             └──▶  ...

</code></pre></div></div>

<p>However, you cannot rely on luck when solving problems.</p>

<p>Now, let the zipper traverse the location not in depth, but in breadth and to the right. With this order, we are not threatened by infinite branch. We won’t try to exhaustively traverse an infinite branch if it occurs in the tree.
Instead, we go down the levels of the tree and read all the elements of each level. Even if one of them originated from an endless branch, this doesn’t prevent you from exploring the rest of the elements. The figure below shows that horizontal traversal helps you get to the solution. In this case, the vertical traversal would go to infinity because both branches are cyclical.</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

                               ┌───────┐
                           ┌───│  rub  │
                           │   └───────┘
                           ▼
                       ┌───────┐       ┌───────┐
                       │  yen  │──────▶│  usd  │
                       └───────┘       └───────┘
                                           │
                  ┌────────────────────────┘
                  ▼
              ┏━━━━━━━┓                         ┌───────┐
              ┃  lir  ┃────────────────────────▶│  eur  │
              ┗━━━━━━━┛                         └───────┘
                                                    │
           ┌────────────────────────────────────────┘
           ▼
       ┌───────┐     ┌───────┐           ┌───────┐     ┌───────┐
       │  rub  │────▶│  tug  │──────────▶│  yen  │────▶│  rub  │
       └───────┘     └───────┘           └───────┘     └───────┘
           │                                               │
           │                                               │
    ...  ◀─┘                                               └──▶  ...


</code></pre></div></div>

<p>The problem is that the <code class="language-plaintext highlighter-rouge">clojure.zip</code> module offers only depth-first order of traversal with <code class="language-plaintext highlighter-rouge">zip/next</code>. There’s no other algorithm. We’ll write our own function to traverse the zipper “in layers”, as shown in the figure:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            ┌───────┐
  1                         │   1   │
                            └───────┘
                                │
              ┌───────┐         │         ┌───────┐
  2           │   2   │◀────────┴────────▶│   3   │
              └───────┘                   └───────┘
                  │                           │
      ┌───────┐   │   ┌───────┐   ┌───────┐   │   ┌───────┐
  3   │   4   │◀──┴──▶│   5   │   │   6   │◀──┴──▶│   7   │
      └───────┘       └───────┘   └───────┘       └───────┘
</code></pre></div></div>

<p>We’ll get the following layers:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">
</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>In this case, each element is not a primitive, but a location. This means that the element remembers its position in the tree, you can move from it to other elements, get its path, and so on.</p>

<p>First, we need a function that will return the child locations of the original one. Its logic is simple: if it’s possible to go down from the location, we move to the right until we reach emptiness.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-children</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">loc-child</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/down</span><span class="w"> </span><span class="n">loc</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">loc-child</span><span class="w">
         </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="n">zip/right</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">take-while</span><span class="w"> </span><span class="n">some?</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Note that this function isn’t the same as <code class="language-plaintext highlighter-rouge">zip/children</code>. The latter returns values, not locations, and we need locations exactly. Compare expressions:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/children</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>and</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">loc-children</span><span class="p">)</span><span class="w">

</span><span class="p">([</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="no">:l</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="no">:pnodes</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]]</span><span class="w"> </span><span class="no">:ppath</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:r</span><span class="w"> </span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)}]</span><span class="w">
 </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="no">:l</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="no">:pnodes</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]]</span><span class="w"> </span><span class="no">:ppath</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:r</span><span class="w"> </span><span class="p">(</span><span class="nf">3</span><span class="p">)}]</span><span class="w">
 </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="no">:l</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="no">:pnodes</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]]</span><span class="w"> </span><span class="no">:ppath</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:r</span><span class="w"> </span><span class="n">nil</span><span class="p">}])</span><span class="w">
</span></code></pre></div></div>

<p>In the second case, we got the locations, while <code class="language-plaintext highlighter-rouge">zip/children</code> simply accessed the find children function passing to the zipper.</p>

<p>Suppose, for some location, <code class="language-plaintext highlighter-rouge">loc-children</code> returned a list of its children. To go down one level, you need to find their children and combine the result. The easiest way to do this is to use the following expression:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="n">loc-children</span><span class="w"> </span><span class="n">locs</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">locs</code> is a list of locations of the current level. If we pass the result of <code class="language-plaintext highlighter-rouge">mapcat</code> to<code class="language-plaintext highlighter-rouge"> locs</code> parameter, we’ll move on even further. We’ll do this until we get an empty sequence. All together gives us the <code class="language-plaintext highlighter-rouge">loc-layers</code> function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-layers</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">locs</span><span class="p">]</span><span class="w">
                  </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="n">loc-children</span><span class="w"> </span><span class="n">locs</span><span class="p">)))</span><span class="w">
       </span><span class="p">(</span><span class="nb">take-while</span><span class="w"> </span><span class="nb">seq</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>It takes the root location from where to start iterating over the layers. We set the first layer explicitly as a vector of one location. Then its children follow, then children of the children and so on. We’ll only stop when getting an empty layer. Quick check:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[[[[</span><span class="mi">1</span><span class="p">]]]</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]]</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">layers</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">data</span><span class="w">
                 </span><span class="n">zip/vector-zip</span><span class="w">
                 </span><span class="n">loc-layers</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">layer</span><span class="w"> </span><span class="n">layers</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">layer</span><span class="w">
         </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
         </span><span class="nb">println</span><span class="p">)))</span><span class="w">

</span><span class="c1">;; ([[[[1]]] 2 [[[3]]] 3])</span><span class="w">
</span><span class="c1">;; ([[[1]]] 2 [[[3]]] 3)</span><span class="w">
</span><span class="c1">;; ([[1]] [[3]])</span><span class="w">
</span><span class="c1">;; ([1] [3])</span><span class="w">
</span><span class="c1">;; (1 3)</span><span class="w">
</span></code></pre></div></div>

<p>To get a chain where the elements go from left to right, we concatenate the layers using <code class="language-plaintext highlighter-rouge">concat</code>. This function is not needed for solving the problem, but it can be useful:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-seq-layers</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">concat</span><span class="w"> </span><span class="p">(</span><span class="nf">loc-layers</span><span class="w"> </span><span class="n">loc</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Let’s go back to currency exchange. Let’s select the exchange rules so that they contain cyclical dependencies. The zipper remains the same: it builds the exchange tree using the local <code class="language-plaintext highlighter-rouge">get-children</code> function, which is closed on the rules.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">rules2</span><span class="w">
  </span><span class="p">[[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:usd</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">

   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:din</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:din</span><span class="w"> </span><span class="no">:tug</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>

<p>The style of working with this zipper will change. Now we iterate through it using not <code class="language-plaintext highlighter-rouge">zip/next</code> but our <code class="language-plaintext highlighter-rouge">loc-layers</code>. At each step, we should get exchange layers. We have to find the locations, which node is equal to the final currency, in the next layer. As soon as we have found at least one, the problem is solved. It remains only to calculate the path to them.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">exchange2</span><span class="w"> </span><span class="p">[</span><span class="n">rules</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">to</span><span class="p">]</span><span class="w">

  </span><span class="p">(</span><span class="nf">letfn</span><span class="w"> </span><span class="p">[(</span><span class="nf">get-children</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">]</span><span class="w"> </span><span class="n">rules</span><span class="w">
                       </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">value</span><span class="p">)]</span><span class="w">
                   </span><span class="n">v2</span><span class="p">)))</span><span class="w">

          </span><span class="p">(</span><span class="nf">loc-to?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">to</span><span class="p">)))</span><span class="w">

          </span><span class="p">(</span><span class="nf">find-locs-to</span><span class="w"> </span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-to?</span><span class="w"> </span><span class="n">layer</span><span class="p">)))</span><span class="w">

          </span><span class="p">(</span><span class="nf">-&gt;exchange</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/path</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)))]</span><span class="w">

    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">zipper</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w"> </span><span class="nb">keyword?</span><span class="w">
                             </span><span class="n">get-children</span><span class="w">
                             </span><span class="n">nil</span><span class="w">
                             </span><span class="n">from</span><span class="p">)]</span><span class="w">

      </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">zipper</span><span class="w">
           </span><span class="n">loc-layers</span><span class="w">
           </span><span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="n">find-locs-to</span><span class="p">)</span><span class="w">
           </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">-&gt;exchange</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>As you may have noticed, now there is no need to compare the lengths of the chains: if the locations belong to the same level, the number of steps to them is the same. According to the problem statement, we are interested in the shortest exchange options. For example, if one chain was found on the third level, and there are three chains on the fourth, the latter are not interesting to us – we
complete the traversal on the third layer.</p>

<p>Here are examples of exchanges regarding the rules specified in <code class="language-plaintext highlighter-rouge">rules2</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">exchange2</span><span class="w"> </span><span class="n">rules2</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">)</span><span class="w">
</span><span class="p">([</span><span class="no">:rub</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:eur</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">exchange2</span><span class="w"> </span><span class="n">rules2</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:tug</span><span class="p">)</span><span class="w">
</span><span class="p">([</span><span class="no">:rub</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:din</span><span class="w"> </span><span class="no">:tug</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:din</span><span class="w"> </span><span class="no">:tug</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">exchange2</span><span class="w"> </span><span class="n">rules2</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:din</span><span class="p">)</span><span class="w">
</span><span class="p">([</span><span class="no">:lir</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:din</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>The solution is still not perfect. If we specify a pair of currencies for which there is no chain, we’ll get an infinite loop. To stop it, limit the number of layers to some reasonable number, such as five. From a financial point of view, currency exchange  with no restrictions is likely to be detrimental, and therefore meaningless. Technically, we need to add the form <code class="language-plaintext highlighter-rouge">(take N)</code> right after <code class="language-plaintext highlighter-rouge">loc-layers</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">zipper</span><span class="w">
     </span><span class="n">loc-layers</span><span class="w">
     </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="n">find-locs-to</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">-&gt;exchange</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Now, we get an empty result for an invalid pair:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">exchange2</span><span class="w"> </span><span class="n">rules2</span><span class="w"> </span><span class="no">:tug</span><span class="w"> </span><span class="no">:yen</span><span class="p">)</span><span class="w">
</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>

<p>The task can be improved further. For example, you can calculate costs and transaction fees for each chain. To do this, add the exchange rate and fee to the <code class="language-plaintext highlighter-rouge">[:from: to]</code> vector. Depending on whether we represent a client or a bank, we’ll look for the most optimal or the most expensive exchanges. Please, come up with your own variations for this problem. At this point we’ll finish with currencies and move on.</p>

<p>In this chapter, we’ve discussed how the traversal order affects the solution to the problem. Breadth-first and depth-first traversal ordering applies to different cases. This is important for infinite trees, when the algorithm can loop while traversing. There is no breadth-width traversal in the <code class="language-plaintext highlighter-rouge">clojure.zip</code> package, but you can easily write a function to divide the zipper into layers. You may find <code class="language-plaintext highlighter-rouge">loc-layers</code> useful in other cases involving graphs and vertices.</p>

<h2 id="part-8-summary">Part 8. Summary</h2>

<p>Finally, let’s take a look at other zipper features that you might find useful.</p>

<h3 id="html">HTML</h3>

<p>The previous examples show that zippers work fine with XML. By the way, you can apply them to HTML as well. Strictly speaking, the syntax of the formats is different: some HTML elements like <code class="language-plaintext highlighter-rouge">&lt;br&gt;</code> or <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> don’t have closing tags. Parsers that take these features into account can solve the problem. As a result, we get an HTML tree that can be traversed as in the examples above.</p>

<p>The <a href="https://github.com/davidsantiago/hickory">Hickory</a> library offers an HTML markup parser. The parsing is based on the Java library <a href="https://jsoup.org/">JSoup</a>, which builds a tree of elements. Hickory contains a function to rebuild a Java tree into Clojure-like one and get a zipper. Add a dependency to the project:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">hickory</span><span class="w"> </span><span class="s">"0.7.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>and run the example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">zipper-manual.core</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">hickory.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">h</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">hickory.zip</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">hz</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.zip</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">zip</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">html</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"https://grishaev.me/"</span><span class="w">
              </span><span class="n">java.net.URL.</span><span class="w">
              </span><span class="nb">slurp</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">doc-src</span><span class="w"> </span><span class="p">(</span><span class="nf">h/parse</span><span class="w"> </span><span class="n">html</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">doc-clj</span><span class="w"> </span><span class="p">(</span><span class="nf">h/as-hiccup</span><span class="w"> </span><span class="n">doc-src</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">doc-zip</span><span class="w"> </span><span class="p">(</span><span class="nf">hz/hiccup-zip</span><span class="w"> </span><span class="n">doc-clj</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>How are these conversions performed? A website layout is loaded into the <code class="language-plaintext highlighter-rouge">html</code> variable as a string. The <code class="language-plaintext highlighter-rouge">doc-src</code> variable contains a tree obtained from HTML. It’s an object of the <code class="language-plaintext highlighter-rouge">Document</code> class from the <code class="language-plaintext highlighter-rouge">org.jsoup.nodes</code> package. For Clojure, it’s a black box: to work with it, it needs to read the documentation for the <code class="language-plaintext highlighter-rouge">Document</code> class.</p>

<p>The <code class="language-plaintext highlighter-rouge">as-hiccup</code> function converts the document into a set of nested vectors which look like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="no">:tag</span><span class="w"> </span><span class="p">{</span><span class="no">:attr</span><span class="w"> </span><span class="s">"value"</span><span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]]</span><span class="n">,</span><span class="w">
</span></code></pre></div></div>

<p>The tag comes first, then the attribute dictionary, followed by any number of the same vectors or strings. This is the standard HTML representation in Clojure, and many libraries use the same format.</p>

<p>The <code class="language-plaintext highlighter-rouge">hiccup-zip</code> function returns the zipper for that structure. It can do everything that we’ve practiced earlier, for example:</p>

<ul>
  <li>remove unwanted tags like <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code>;</li>
  <li>leave these tags, but secure their attributes;</li>
  <li>leave dangerous tags only if their source points to trusted sites;</li>
  <li>look for items of interest to us.</li>
</ul>

<p>Here’s how to find all the images on a webpage:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-img?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:img</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-&gt;src</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="nb">second</span><span class="w"> </span><span class="no">:src</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">doc-zip</span><span class="w">
     </span><span class="n">iter-zip</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-img?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">loc-&gt;src</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="s">"/assets/static/photo-round-small.png"</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The first function checks if the location points to a node with the <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> tag, the second
extracts the <code class="language-plaintext highlighter-rouge">src</code> attribute from it. The third form returns a list of links to images.</p>

<p>Based on these actions, you can build HTML filtering, especially if an HTML markup comes from a source you don’t trust. Another scenario is to find a suitable image for a social media cover in HTML. To do this, you need to select all images, estimate their width and height, and select the largest in area (if the <code class="language-plaintext highlighter-rouge">width</code> and <code class="language-plaintext highlighter-rouge">height</code> attributes are filled in).</p>

<p>Hickory considers typical cases and offers selectors for searching by tag and attribute. It isn’t even necessary to cast the JSoup tree to a zipper to do this. However, in rare cases, you need to find tags with complex relationships, as in the product and bundle example (either only in the bundle or strictly outside it). These problems fit zippers very well.</p>

<h3 id="data-and-serialization">Data and Serialization</h3>

<p>Another plus of zippers is that they are represented by data — a combination of lists and maps. This means that you can write the current zipper in EDN or JSON. When reading, we get the old data structure and continue traversing from where we left off. This is the difference between Clojure and object languages, where, in the general case, you cannot write an object to a file without some effort.</p>

<p>When restoring a zipper, remember about its metadata. The functions <code class="language-plaintext highlighter-rouge">branch?</code>, <code class="language-plaintext highlighter-rouge">children</code>, and <code class="language-plaintext highlighter-rouge">make-node</code> that we passed to the constructor are stored in the zipper metadata. This is done to separate data from actions on it. Let’s check the zipper metadata we got from HTML:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">meta</span><span class="w"> </span><span class="n">doc-zip</span><span class="p">)</span><span class="w">

</span><span class="o">#</span><span class="no">:zip</span><span class="p">{</span><span class="no">:branch?</span><span class="w"> </span><span class="o">#</span><span class="n">function</span><span class="p">[</span><span class="n">clojure.core/sequential?</span><span class="p">]</span><span class="w">
      </span><span class="no">:children</span><span class="w"> </span><span class="o">#</span><span class="n">function</span><span class="p">[</span><span class="n">hickory.zip/children</span><span class="p">]</span><span class="w">
      </span><span class="no">:make-node</span><span class="w"> </span><span class="o">#</span><span class="n">function</span><span class="p">[</span><span class="n">hickory.zip/make</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Let’s write functions for resetting and reading EDN:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">edn-save</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="w"> </span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="nb">path</span><span class="w"> </span><span class="p">(</span><span class="nb">pr-str</span><span class="w"> </span><span class="n">data</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">edn-load</span><span class="w"> </span><span class="p">[</span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="nb">path</span><span class="w"> </span><span class="nb">slurp</span><span class="w"> </span><span class="n">edn/read-string</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Let’s say we’ve made some iterations on a zipper and saved it:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">doc-zip</span><span class="w">
    </span><span class="n">zip/next</span><span class="w">
    </span><span class="n">zip/next</span><span class="w">
    </span><span class="n">zip/next</span><span class="w">
    </span><span class="p">(</span><span class="nf">edn-save</span><span class="w"> </span><span class="s">"zipper.edn"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>If we read the EDN and pass the result to <code class="language-plaintext highlighter-rouge">zip/next</code>, we’ll get an error. The function will call <code class="language-plaintext highlighter-rouge">branch?</code> and <code class="language-plaintext highlighter-rouge">children</code> from the metadata that has not been saved, resulting in an exception. To make a zipper from a file work, add metadata to it. You can either move it into a variable in advance or declare it manually.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">zip-meta</span><span class="w"> </span><span class="p">(</span><span class="nb">meta</span><span class="w"> </span><span class="n">doc-zip</span><span class="p">))</span><span class="w">

</span><span class="c1">;; or</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">zip-meta</span><span class="w">
  </span><span class="o">#</span><span class="no">:zip</span><span class="p">{</span><span class="no">:branch?</span><span class="w"> </span><span class="n">sequential?</span><span class="w">
        </span><span class="no">:children</span><span class="w"> </span><span class="o">#</span><span class="ss">'hickory.zip/children</span><span class="w">
        </span><span class="no">:make-node</span><span class="w"> </span><span class="o">#</span><span class="ss">'hickory.zip/make</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>In the second case, we had to specify the <code class="language-plaintext highlighter-rouge">children</code> and <code class="language-plaintext highlighter-rouge">make-node</code> functions as variables (instances of the <code class="language-plaintext highlighter-rouge">Var</code> class) because they are private. The read zipper will be in the same state as at the time of saving.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">doc-zip-new</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"zipper.edn"</span><span class="w">
      </span><span class="n">edn-load</span><span class="w">
      </span><span class="p">(</span><span class="nb">with-meta</span><span class="w"> </span><span class="n">zip-meta</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">doc-zip-new</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="nb">first</span><span class="p">)</span><span class="w">
</span><span class="no">:head</span><span class="w">
</span></code></pre></div></div>

<p>Storing the zipper in long-term memory brings new possibilities. For example, traversal of certain data takes time, and the program can perform the task in chunks, keeping the intermediate result. This is how complex business scenarios work. If a customer refuses the services of the company, you must delete their records in the database, files, links to them in documents and much more. This process can be thought of as a set of steps. At each step, the code reads a zipper as EDN from the database and adds metadata. Then it shifts the zipper one <code class="language-plaintext highlighter-rouge">zip/next</code>, performs the task, and updates the record in the database with the new version of the zipper. Once you’ve reached the initial node (<code class="language-plaintext highlighter-rouge">zip/end?</code> returns <code class="language-plaintext highlighter-rouge">true</code>), you mark the record in the database as resolved.</p>

<h3 id="other-uses">Other Uses</h3>

<p>The example with the currency exchange shows how to find a solution to the problem by brute force search. Whether you’re looking for the optimal chain of steps, maximum cost, or a traversal route, zippers might help you. It is easy to check if they are suitable for solving your problem. The zipper implies that you have a value and several others based on it, they in turn have their values and so on. If the condition works, you are one step away from building the tree and traversing it.</p>

<p>Let’s say, according to the exchange table, the dollar (current value) can be exchanged for the euro and the ruble (child values). From point A (current) you can drive to points B and C (children). In HTML, one tag can include other tags. In all three cases, you can use a zipper. You only need to define the functions <code class="language-plaintext highlighter-rouge">branch?</code> (if an element can have children) and <code class="language-plaintext highlighter-rouge">children</code> (how to find them specifically).</p>

<h3 id="third-party-libraries">Third-party Libraries</h3>

<p>The <code class="language-plaintext highlighter-rouge">clojure.zip</code> module offers enough navigation functions. Nevertheless, throughout this chapter, we had to write a few functions ourselves. The library <strong><a href="https://github.com/clojure/data.zip/">data.zip</a></strong> contains various add-ons for zippers, including the same ones as we wrote. Perhaps the library will shorten your utility code.</p>

<h3 id="summary">Summary</h3>

<p>Zippers are means for navigating the data structure. A zipper offers movement in four directions: down, up, left, and right. An element in the center is called a node.</p>

<p>A zipper can navigate a wide variety of structures. It needs to know only two things: whether the current element is a branch of a tree, and if so, how to find the children. To do this, the zipper takes the <code class="language-plaintext highlighter-rouge">branch?</code> and <code class="language-plaintext highlighter-rouge">children</code> functions, which are later stored in metadata.</p>

<p>Usually, children are found from the parent node, but in some cases we get them dynamically. For example, to find out which currencies can be exchanged for the current one, you can refer to the exchange map. To do this, the <code class="language-plaintext highlighter-rouge">children</code> function has to see the map as a global variable or a closure.</p>

<p>The current zipper element is called a location. It stores not only the value, but also the data for going in all directions, as well as the path. These qualities set zippers apart from <code class="language-plaintext highlighter-rouge">tree-seq</code> and analogs that decompose a tree into a chain not including a path to an element. Some tasks consist precisely of finding the right path.</p>

<p>The zipper offers functions for editing and deleting the current node. Editing can be based on the current value (<code class="language-plaintext highlighter-rouge">zip/edit</code>) or the new one (<code class="language-plaintext highlighter-rouge">zip/replace</code>).</p>

<p>By default, zipper traversal is depth-first. When moving to the end, the location will receive a mark that the cycle has been completed. Use the <code class="language-plaintext highlighter-rouge">zip/end?</code> function as a sign of ending an iteration. In our examples, we wrote the <code class="language-plaintext highlighter-rouge">zip-iter</code> function that does exactly one traversal.</p>

<p>Breadth-first traversal is required for some tasks. This can happen when one of the tree branches is potentially infinite. For breadth-first traversal, we wrote our own  functions that don’t come with the Clojure.zip.</p>

<p>Zippers are useful for working with XML, finding solutions, and filtering HTML. Try to figure them out to solve such problems in a short and elegant way.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментарии</center>

<div id="comments">
  
    <div id="comment-5972869936" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            VK,
            7th Sep 2022,
            <a href="#comment-5972869936">link</a>
            
          </em>
        </small>
      </p>
      <div><p>отлично. Thanks for sharing your wonderful perspective.</p>
</div>
    </div>
  
    <div id="comment-1666082871514" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            temco,
            18th Oct 2022,
            <a href="#comment-1666082871514">link</a>
            
          </em>
        </small>
      </p>
      <div><p>thanks for your introduction to zipper, which I didn’t use before in the past years on clojure programming</p>
</div>
    </div>
  
</div>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/en/clojure-zippers/">
    <input required name="captcha" type="hidden" value="6 &#215; 4">

    <div class="block">
        <span class="comment-form-label"><small>6 &#215; 4 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
