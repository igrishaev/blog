<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Conditional Queries in Datomic</title>
  <meta name="description" content="Let’s discuss one thing related to Clojure and Datomic that might be a bittricky especially if you have never faced it so far.">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/en/datomic-query/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Conditional Queries in Datomic</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2017-09-01T20:49:00+00:00">
        Sep 1, 2017
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/datomic/" rel="tag">datomic</a>, <a href="/tag/sql/" rel="tag">sql</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Let’s discuss one thing related to Clojure and Datomic that might be a bit
tricky especially if you have never faced it so far.</p>

<p>Imagine you return a list of some entities to the client. It might be a list of
orders, visits or whatever. Usually, when a user is exploring a long list of
something, it’s a good idea to let them filter the list by some criteria: price,
date, age etc. On the server side, you need to apply those filters
conditionally. Say, when the <code class="language-plaintext highlighter-rouge">date_from</code> query string parameter is passed, you
apply it to the query as well or live it untouched otherwise. The same for the
rest of filters.</p>

<p>Things become more tough when filters are applied to foreign entities. For
example, an order references a user, and a user references a department. If the
<code class="language-plaintext highlighter-rouge">department_name</code> parameter has been passed, you should join all the required
tables and filter a proper field.</p>

<p>Joining all the tables even if no filters were supplied is a wrong
approach. Join operations are expensive and should never be performed in vain. A
toolset that joins tables should take into account which ones has already been
added into a query and never link them twice.</p>

<p>Such systems that control the cases mentioned above are names ORMs. They are
pretty complicated and full of ugly code and implicit hacks. But on the top
level they behave quite friendly. Say, in <a href="https://www.djangoproject.com/">Django</a> (a major Python
framework) I would perform something like that:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">query</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">Order</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">all</span><span class="p">()</span>
<span class="n">department_name</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">query_string</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"department_name"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">department_name</span><span class="p">:</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">query</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">user__department_name</span><span class="o">=</span><span class="n">department_name</span><span class="p">)</span>
</code></pre></div></div>

<p>Looks pretty neat. This automatically joins <code class="language-plaintext highlighter-rouge">users</code> and <code class="language-plaintext highlighter-rouge">department</code> tables
under the hood using <code class="language-plaintext highlighter-rouge">inner join</code> SQL clause and puts <code class="language-plaintext highlighter-rouge">department.name = ?</code>
condition into <code class="language-plaintext highlighter-rouge">where</code> section.</p>

<p>People who work with such non-wide spreaded languages as Clojure usually do not
use ORMs. But still, we need to build complicated queries. The community offers
a handful of libraries (<a href="https://github.com/krisajenkins/yesql">YeSQL</a>, <a href="https://github.com/jkk/honeysql">HoneySQL</a>, <a href="https://github.com/korma/Korma">Korma</a>)
where a query is being constructed within data structures: vectors, maps. I’ve
been always against that approach. Before getting more experienced with Clojure,
I felt uncomfortable constructing nested vectors like this one:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[:select [:foo :bar]
 :from :test
 :where [(= :name "test")
         (when age-param
           (&gt; :age age-param))]]
</code></pre></div></div>

<p>The reason why I do not appreciate that is I cannot see the final query behind
brackets and colons. It will definitely fail me once I need to express
something like this (a fragment of a query from production):</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
  <span class="n">array_agg</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">type_id</span><span class="p">)</span> <span class="n">filter</span> <span class="p">(</span><span class="k">where</span> <span class="n">foo</span> <span class="k">is</span> <span class="k">not</span> <span class="k">null</span><span class="p">)</span> <span class="k">as</span> <span class="n">type_ids</span><span class="p">,</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">name</span>
<span class="k">from</span> <span class="n">foo_table</span> <span class="k">as</span> <span class="n">foo</span>
</code></pre></div></div>

<p>Modern libraries say it’s easy and fun to express your queries through data
structures, but it is not, really. It becomes a challenge when applying multiple
conditions to a data structure without seeing the final result.</p>

<p>A good approach might be using a templating system. Say, <a href="https://github.com/layerware/hugsql">HugSQL</a>
library allows to inject Clojure snippets into your SQL query. Those snippets
are surrounded with standard SQL comments so they do not break syntax. There
won’t be an error if you copy and paste such a Clojure-instrumented query into
some RDBS administration tool.</p>

<p>Here is an example of declaring such a query:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :name get-oreders :?</span>
<span class="k">select</span> <span class="n">o</span><span class="p">.</span><span class="o">*</span>
<span class="k">from</span> <span class="n">oreders</span> <span class="n">o</span>
<span class="cm">/*~ (when (:department-name params) ~*/</span>
<span class="k">join</span> <span class="k">user</span> <span class="n">u</span> <span class="k">on</span> <span class="n">o</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span>
<span class="k">join</span> <span class="n">departments</span> <span class="n">d</span> <span class="k">on</span> <span class="k">user</span><span class="p">.</span><span class="n">department_id</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">id</span>
<span class="k">where</span>
    <span class="n">d</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">:</span><span class="n">department</span><span class="o">-</span><span class="n">name</span>
<span class="cm">/*~ ) ~*/</span>
<span class="k">order</span> <span class="k">by</span> <span class="n">o</span><span class="p">.</span><span class="n">created_at</span><span class="p">;</span>
</code></pre></div></div>

<p>Than it compiles into a Clojure function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; no joins, no filters</span><span class="w">
</span><span class="p">(</span><span class="nf">get-oreders</span><span class="w"> </span><span class="n">db</span><span class="p">)</span><span class="w">

</span><span class="c1">;; causes joins and filtering</span><span class="w">
</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">dep-name</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:params</span><span class="w"> </span><span class="no">:department-name</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-oreders</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:department-name</span><span class="w"> </span><span class="n">dep-name</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>You may go further and include <a href="https://github.com/yogthos/Selmer">Selmer</a>, a template library inspired by
Django. It’s aimed at HTML rendering first but still may be used for any kind of
documents including SQL.</p>

<p>As I see it, a good templating system would be enough to generate SQL that fits
your business logic.</p>

<p>Now I’d like to discuss the same problem when using Datomic instead of classical
RDBS solutions. All the tutorials that I have read do not cover a case then you
need to apply several filters to a query. Suddenly, it may really become a
problem. Let’s return to our example with orders. Once you don’t have any
filters, the query looks simple:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="p">(</span><span class="nf">pull</span><span class="w"> </span><span class="n">?o</span><span class="w"> </span><span class="p">[</span><span class="nb">*</span><span class="p">])</span><span class="w">
  </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w">
  </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="n">?o</span><span class="w"> </span><span class="no">:order/number</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>But if you’ve got a department name you need to:</p>

<ol>
  <li>inject a new parameter into <code class="language-plaintext highlighter-rouge">:in</code> section;</li>
  <li>inject additional clauses into <code class="language-plaintext highlighter-rouge">:where</code> section;</li>
  <li>prevent joining a user or a department entities twice if you need to filter
by other department or user field.</li>
</ol>

<p>As we’ve seen, once you have a template system, you may render SQL queries as
well. All you need is to write a query, test how does it behaves and then wrap
some parts of it with special conditional tags.</p>

<p>In Datomic, a query is usually a vector of symbols. Moreover, an immutable
one. Thus, you cannot modify a query and adding something in the middle of it
would be difficult. Surely you could wrap a query into an atom or track indexes
where to inject a new item somehow but all of that would be a mess.</p>

<p>What I propose is using a special kind of a query represented as a map with
<code class="language-plaintext highlighter-rouge">:find</code>, <code class="language-plaintext highlighter-rouge">:where</code> and other keys. As
the <a href="http://docs.datomic.com/query.html#list-vs-map">Datomic documentation says</a>, when processing a query, every
vector is turned into a map anyway. If we had a map, it would be easier to
inject new items into it.</p>

<p>To avoid wrapping a map with an atom or redefining it continuously inside <code class="language-plaintext highlighter-rouge">let</code>
clause, there is a great form named <a href="https://clojuredocs.org/clojure.core/cond-%3E">cond-&gt;</a>. It is a mix of both
threading macro and <code class="language-plaintext highlighter-rouge">cond</code> clause. It takes an initial value and a bunch of
predicate/update pairs. If a predicate form evaluates in true, an update form is
fired using the standard threading macro. Thus, an update form should be either
a function or a list where the second argument is missing and will be
substituted with a value from a previous pair.</p>

<p>What’s the most interesting about <code class="language-plaintext highlighter-rouge">cond-&gt;</code> is unlike <code class="language-plaintext highlighter-rouge">cond</code> or <code class="language-plaintext highlighter-rouge">case</code> forms, its
branches are evaluated continuously. Each update form takes a value that a
previous form has produced. In other terms, an initial value goes through
multiple updates without being saved in some temporary variable.</p>

<p>In example below, I’ve got a data set that consists from <code class="language-plaintext highlighter-rouge">user</code>, <code class="language-plaintext highlighter-rouge">location</code> and
<code class="language-plaintext highlighter-rouge">visit</code> entities. Both <code class="language-plaintext highlighter-rouge">user</code> and <code class="language-plaintext highlighter-rouge">location</code> are simple ones and store just
dates, strings and so on. A <code class="language-plaintext highlighter-rouge">visit</code> is a bit more complex. It means that a user
has visited a location and assigned a mark to it. Therefore, a visit references
a user and a location entities as well.</p>

<p>The goal is to get an average mark for a specific location. In addition, such a
value might be filtered by user’s age, gender or location’s country name. Those
parameters come from a query string and could be either totally skipped, passed
partially or completely. I’ve got a function that accepts a location id and a
map of optional parameters:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">location-avg</span><span class="w">
  </span><span class="p">[</span><span class="n">location-id</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">fromDate</span><span class="w">
                       </span><span class="n">toDate</span><span class="w">
                       </span><span class="n">fromAge</span><span class="w">
                       </span><span class="n">toAge</span><span class="w">
                       </span><span class="n">gender</span><span class="p">]}]</span><span class="w">

</span></code></pre></div></div>

<p>The initial Datomic query:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">query-initial</span><span class="w">
  </span><span class="o">'</span><span class="p">{</span><span class="no">:find</span><span class="w"> </span><span class="p">[(</span><span class="nf">avg</span><span class="w"> </span><span class="n">?mark</span><span class="p">)</span><span class="w"> </span><span class="nb">.</span><span class="p">]</span><span class="w">
    </span><span class="no">:with</span><span class="w"> </span><span class="p">[</span><span class="n">?v</span><span class="p">]</span><span class="w">
    </span><span class="no">:in</span><span class="w"> </span><span class="p">[</span><span class="n">$</span><span class="w"> </span><span class="n">?location</span><span class="p">]</span><span class="w">
    </span><span class="no">:args</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="no">:where</span><span class="w"> </span><span class="p">[[</span><span class="n">?v</span><span class="w"> </span><span class="no">:location</span><span class="w"> </span><span class="n">?location</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">?v</span><span class="w"> </span><span class="no">:mark</span><span class="w"> </span><span class="n">?mark</span><span class="p">]]})</span><span class="w">
</span></code></pre></div></div>

<p>Now, here is a long pipeline with comments:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">cond-&gt;</span><span class="w"> </span><span class="n">query-initial</span><span class="w">

  </span><span class="c1">;; First, add two initial arguments: database instance and location reference.</span><span class="w">
  </span><span class="c1">;; This form will always be evaluated.</span><span class="w">
  </span><span class="n">true</span><span class="w">
  </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:args</span><span class="w"> </span><span class="nb">conj</span><span class="w">
          </span><span class="p">(</span><span class="nf">get-db</span><span class="p">)</span><span class="w">                    </span><span class="c1">;; returns the DB instance</span><span class="w">
          </span><span class="p">[</span><span class="no">:location/id</span><span class="w"> </span><span class="n">location-id</span><span class="p">])</span><span class="w"> </span><span class="c1">;; location reference</span><span class="w">

  </span><span class="c1">;; If either from- or to- date were passed, join the `visit` entity</span><span class="w">
  </span><span class="c1">;; and bind its `visited_at` attribute to the `?visited-at` variable.</span><span class="w">
  </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">fromDate</span><span class="w"> </span><span class="n">toDate</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="nb">conj</span><span class="w">
          </span><span class="o">'</span><span class="p">[</span><span class="n">?v</span><span class="w"> </span><span class="no">:visited_at</span><span class="w"> </span><span class="n">?visited-at</span><span class="p">])</span><span class="w">

  </span><span class="c1">;; If the `fromDate` filter was passed, do the following:</span><span class="w">
  </span><span class="c1">;; 1. add a parameter placeholder into the query;</span><span class="w">
  </span><span class="c1">;; 2. add an actual value to the arguments;</span><span class="w">
  </span><span class="c1">;; 3. add a proper condition against `?visited-at` variable</span><span class="w">
  </span><span class="c1">;; (remember, it was bound above).</span><span class="w">
  </span><span class="n">fromDate</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="ss">'?fromDate</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:args</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">fromDate</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="nb">conj</span><span class="w">
           </span><span class="o">'</span><span class="p">[(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">?visited-at</span><span class="w"> </span><span class="n">?fromDate</span><span class="p">)]))</span><span class="w">

  </span><span class="c1">;; Do the same steps for the `toDate` filter,</span><span class="w">
  </span><span class="c1">;; but the condition slightly differs (&lt; instead of &gt;).</span><span class="w">
  </span><span class="n">toDate</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="ss">'?toDate</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:args</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">toDate</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="nb">conj</span><span class="w">
           </span><span class="o">'</span><span class="p">[(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">?visited-at</span><span class="w"> </span><span class="n">?toDate</span><span class="p">)]))</span><span class="w">

  </span><span class="c1">;; To filter by user's fields, we bind a user reference</span><span class="w">
  </span><span class="c1">;; to the `?user` variable:</span><span class="w">
  </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">fromAge</span><span class="w"> </span><span class="n">toAge</span><span class="w"> </span><span class="n">gender</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="nb">conj</span><span class="w">
          </span><span class="o">'</span><span class="p">[</span><span class="n">?v</span><span class="w"> </span><span class="no">:user</span><span class="w"> </span><span class="n">?user</span><span class="p">])</span><span class="w">

  </span><span class="c1">;; If from/to age filters we passed, bind user's age</span><span class="w">
  </span><span class="c1">;; to the `?birth-date` variable.</span><span class="w">
  </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">fromAge</span><span class="w"> </span><span class="n">toAge</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="nb">conj</span><span class="w">
          </span><span class="o">'</span><span class="p">[</span><span class="n">?user</span><span class="w"> </span><span class="no">:birth_date</span><span class="w"> </span><span class="n">?birth-date</span><span class="p">])</span><span class="w">

  </span><span class="c1">;; Then add placeholders, arguments and where clauses</span><span class="w">
  </span><span class="c1">;; for specific filters: fromAge, if passed...</span><span class="w">
  </span><span class="n">fromAge</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="ss">'?fromAge</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:args</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">age-to-ts</span><span class="w"> </span><span class="n">fromAge</span><span class="p">))</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="nb">conj</span><span class="w">
           </span><span class="o">'</span><span class="p">[(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">?birth-date</span><span class="w"> </span><span class="n">?fromAge</span><span class="p">)]))</span><span class="w">

  </span><span class="c1">;; ...and the same for toAge.</span><span class="w">
  </span><span class="n">toAge</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="ss">'?toAge</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:args</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">age-to-ts</span><span class="w"> </span><span class="n">toAge</span><span class="p">))</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="nb">conj</span><span class="w">
           </span><span class="o">'</span><span class="p">[(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">?birth-date</span><span class="w"> </span><span class="n">?toAge</span><span class="p">)]))</span><span class="w">

  </span><span class="c1">;; To filter by gender, bind user's gender to a variable</span><span class="w">
  </span><span class="c1">;; and add a clause:</span><span class="w">
  </span><span class="n">gender</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="ss">'?gender</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:args</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">gender</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="nb">conj</span><span class="w">
           </span><span class="o">'</span><span class="p">[</span><span class="n">?user</span><span class="w"> </span><span class="no">:gender</span><span class="w"> </span><span class="n">?gender</span><span class="p">]))</span><span class="w">

  </span><span class="c1">;; The final step is to remap a query (see below).</span><span class="w">
  </span><span class="n">true</span><span class="w">
  </span><span class="n">remap-query</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Remapping a query is important because the initial data is a bit wrong. The
proper structure for a map query looks as follows:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:query</span><span class="w"> </span><span class="n">&lt;query-map&gt;</span><span class="w">
 </span><span class="no">:args</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">location_id</span><span class="w"> </span><span class="n">fromDate</span><span class="w"> </span><span class="n">...</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>In my case, I believe it’s simpler to keep one-level map rather than deal with
two levels (<code class="language-plaintext highlighter-rouge">:query</code> first, then <code class="language-plaintext highlighter-rouge">:args</code>). It would force me to use <code class="language-plaintext highlighter-rouge">update-in</code>
instead if just <code class="language-plaintext highlighter-rouge">update</code> and write more code. Here is the <code class="language-plaintext highlighter-rouge">remap-query</code>
function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-query</span><span class="w">
  </span><span class="p">[{</span><span class="n">args</span><span class="w"> </span><span class="no">:args</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">m</span><span class="p">}]</span><span class="w">
  </span><span class="p">{</span><span class="no">:query</span><span class="w"> </span><span class="p">(</span><span class="nb">dissoc</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="no">:args</span><span class="p">)</span><span class="w">
   </span><span class="no">:args</span><span class="w"> </span><span class="n">args</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Finally, let’s check our results. If somebody passes all the filters, the query
will look like:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:query</span><span class="w">
 </span><span class="p">{</span><span class="no">:find</span><span class="w"> </span><span class="p">[(</span><span class="nf">avg</span><span class="w"> </span><span class="n">?mark</span><span class="p">)</span><span class="w"> </span><span class="nb">.</span><span class="p">]</span><span class="n">,</span><span class="w">
  </span><span class="no">:with</span><span class="w"> </span><span class="p">[</span><span class="n">?v</span><span class="p">]</span><span class="n">,</span><span class="w">
  </span><span class="no">:in</span><span class="w"> </span><span class="p">[</span><span class="n">$</span><span class="w"> </span><span class="n">?location</span><span class="w"> </span><span class="n">?fromDate</span><span class="w"> </span><span class="n">?toDate</span><span class="w"> </span><span class="n">?fromAge</span><span class="w"> </span><span class="n">?toAge</span><span class="w"> </span><span class="n">?gender</span><span class="p">]</span><span class="n">,</span><span class="w">
  </span><span class="no">:where</span><span class="w">
  </span><span class="p">[[</span><span class="n">?v</span><span class="w"> </span><span class="no">:location</span><span class="w"> </span><span class="n">?location</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">?v</span><span class="w"> </span><span class="no">:mark</span><span class="w"> </span><span class="n">?mark</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">?v</span><span class="w"> </span><span class="no">:visited_at</span><span class="w"> </span><span class="n">?visited-at</span><span class="p">]</span><span class="w">
   </span><span class="p">[(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">?visited-at</span><span class="w"> </span><span class="n">?fromDate</span><span class="p">)]</span><span class="w">
   </span><span class="p">[(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">?visited-at</span><span class="w"> </span><span class="n">?toDate</span><span class="p">)]</span><span class="w">
   </span><span class="p">[</span><span class="n">?v</span><span class="w"> </span><span class="no">:user</span><span class="w"> </span><span class="n">?user</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">?user</span><span class="w"> </span><span class="no">:birth_date</span><span class="w"> </span><span class="n">?birth-date</span><span class="p">]</span><span class="w">
   </span><span class="p">[(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">?birth-date</span><span class="w"> </span><span class="n">?fromAge</span><span class="p">)]</span><span class="w">
   </span><span class="p">[(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">?birth-date</span><span class="w"> </span><span class="n">?toAge</span><span class="p">)]</span><span class="w">
   </span><span class="p">[</span><span class="n">?user</span><span class="w"> </span><span class="no">:gender</span><span class="w"> </span><span class="n">?gender</span><span class="p">]]}</span><span class="n">,</span><span class="w">
 </span><span class="no">:args</span><span class="w"> </span><span class="p">[</span><span class="n">&lt;db-object&gt;</span><span class="w"> </span><span class="p">[</span><span class="no">:location/id</span><span class="w"> </span><span class="mi">42</span><span class="p">]</span><span class="w"> </span><span class="mi">1504210734</span><span class="w"> </span><span class="mi">1504280734</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s">"m"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Now you pass it into <a href="http://docs.datomic.com/clojure/#datomic.api/query">datomic.api/query</a> function that accepts a map-like
query. In my case, the result is something like: <code class="language-plaintext highlighter-rouge">4.18525</code>.</p>

<p>As you have seen, composing complicated queries with Datomic might a bit tricky
due do immutability and differences between string templates and data
structures. But still, Clojure provides rich set of tools for processing
collections. In my case, the standard <code class="language-plaintext highlighter-rouge">cond-&gt;</code> has made all the
pipeline. Neither atoms nor other tricks to track the state were required. There
is a common rule: once you’ve got stuck with a data structure, keep yourself
from inventing “smart” ways to deal with it. There is probably a built-in macro
in <code class="language-plaintext highlighter-rouge">clojure.core</code> for that.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/en/datomic-query/">
    <input required name="captcha" type="hidden" value="8 &#215; 9">

    <div class="block">
        <span class="comment-form-label"><small>8 &#215; 9 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
