<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Exceptions in Clojure</title>
  <meta name="description" content="Clojure in Production  Chapter 1. Web development  Chapter 2. Clojure.spec  Chapter 3. Exceptions  Chapter 4. Mutability  Chapter 5. Configuration  Chapter 6...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/en/clj-book-exceptions/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Exceptions in Clojure</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2021-04-05T00:00:00+00:00">
        Apr 5, 2021
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/exceptions/" rel="tag">exceptions</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p><strong>Clojure in Production</strong></p>

<ul>
  <li>Chapter 1. Web development</li>
  <li>Chapter 2. Clojure.spec</li>
  <li><a href="/en/clj-book-exceptions/">Chapter 3. Exceptions</a></li>
  <li>Chapter 4. Mutability</li>
  <li><a href="/en/clj-book-config/">Chapter 5. Configuration</a></li>
  <li><a href="/en/clj-book-systems/">Chapter 6. Systems in Clojure</a></li>
  <li>Chapter 7. Tests</li>
</ul>

<h2>

    In This Chapter

</h2>

<ul id="toc-item-clj-book-exceptions-en">
  <li><a href="#exceptions" id="toc-item-clj-book-exceptions-en-exceptions">Exceptions</a>    <ul>
      <li><a href="#basics-of-exceptions" id="toc-item-clj-book-exceptions-en-basics-of-exceptions">Basics of Exceptions</a></li>
      <li><a href="#chains-and-context" id="toc-item-clj-book-exceptions-en-chains-and-context">Chains and Context</a></li>
      <li><a href="#moving-on-to-clojure" id="toc-item-clj-book-exceptions-en-moving-on-to-clojure">Moving on to Clojure</a></li>
      <li><a href="#more-about-context" id="toc-item-clj-book-exceptions-en-more-about-context">More about Context</a></li>
      <li><a href="#when-to-throw-exceptions" id="toc-item-clj-book-exceptions-en-when-to-throw-exceptions">When to Throw Exceptions</a></li>
      <li><a href="#more-about-chains" id="toc-item-clj-book-exceptions-en-more-about-chains">More about Chains</a></li>
      <li><a href="#printing-of-exceptions" id="toc-item-clj-book-exceptions-en-printing-of-exceptions">Printing of Exceptions</a></li>
      <li><a href="#logging" id="toc-item-clj-book-exceptions-en-logging">Logging</a></li>
      <li><a href="#exception-context" id="toc-item-clj-book-exceptions-en-exception-context">Exception Context</a></li>
      <li><a href="#collecting-exceptions" id="toc-item-clj-book-exceptions-en-collecting-exceptions">Collecting Exceptions</a></li>
      <li><a href="#sentry-and-ring" id="toc-item-clj-book-exceptions-en-sentry-and-ring">Sentry and Ring</a></li>
      <li><a href="#jumping-code" id="toc-item-clj-book-exceptions-en-jumping-code">Jumping Code</a></li>
      <li><a href="#finally-form-and-context-manager" id="toc-item-clj-book-exceptions-en-finally-form-and-context-manager">Finally Form and Context Manager</a></li>
      <li><a href="#exceptions-and-predicates" id="toc-item-clj-book-exceptions-en-exceptions-and-predicates">Exceptions and Predicates</a></li>
      <li><a href="#techniques-and-functions" id="toc-item-clj-book-exceptions-en-techniques-and-functions">Techniques and Functions</a></li>
      <li><a href="#summary" id="toc-item-clj-book-exceptions-en-summary">Summary</a></li>
    </ul>
  </li>
</ul>

<h1 id="exceptions">Exceptions</h1>

<p><em>This chapter considers exceptions in Clojure. How do they work and how do they differ from their Java counterparts? When is it better to throw and when to catch exceptions? What and how to write in logs to investigate an incident quickly?</em></p>

<p>Somebody might find it strange to devote an entire chapter to exceptions. The topic, after all, is simple: exceptions can only be thrown, caught, and logged. Theoretically, this is enough to work on a project.</p>

<p>Exceptions are technically simple, but they have rich <em>semantics</em>. When exactly should you throw and catch exceptions? What useful information do they carry? Where to write exceptions? Can we catch them with predicates? In practice, we are overwhelmed with countless specific cases.</p>

<p>Newbies tend to follow the positive path. They write code such as there basically cannot be exceptions in their work. This is why it is so hard to troubleshoot errors afterwards. Why did the server respond with code 500? There are innumerable possible reasons why the request failed. However, the log entry provides too little information to understand what has happened.</p>

<p>A good programmer pays close attention to errors. With experience, it becomes clear – refusing exceptions does not pay off. Without them, we will complete the task faster, and there will be less code – that is right. But later, you will have problems with detailing and fixing said errors.</p>

<p>Exceptions in code are just as important as normal behavior. If you think this kind of problem will not happen to you, think again. If your project encounters trouble due to uncaught errors, then it is time to study the topic.</p>

<!-- more -->

<h2 id="basics-of-exceptions">Basics of Exceptions</h2>

<p>Before going into detail, let us remember what exceptions are and how they behave.</p>

<p>An exception is an object, most often an instance of the <code class="language-plaintext highlighter-rouge">Exception</code> class. It differs from other classes in that we can throw it. In different languages, there are operators which serve this purpose. Among those are <code class="language-plaintext highlighter-rouge">throw</code>, <code class="language-plaintext highlighter-rouge">raise</code>, and others.</p>

<p>The thrown object interrupts execution and floats up the call stack. There are two possible outcomes: either the <code class="language-plaintext highlighter-rouge">catch</code> statement catches it at one of the levels or not – knowingly or by mistake.</p>

<p>In the first case, we will get an exception object. We access it as usual: get fields, call methods, pass to functions. Further behavior depends on program logic. Sometimes an exception is logged, and the program is terminated; otherwise, the program continues running.</p>

<p>If we do not catch the exception, the program will exit with nonzero code. Unless otherwise specified, the program will write the exception to <code class="language-plaintext highlighter-rouge">stderr</code> (the standard error channel) before exiting. We will see its class, text, and stack trace there. The last is the chain of calls that an exception passed through from the moment it was thrown to caught.</p>

<p>Some platforms allow you to specify a reaction to an uncaught exception. For example, to write it to a file or terminate the program in a special way.</p>

<p>Clojure is a hosted language: it relies on the capabilities that the host offers. Exceptions are an area where Clojure leverages Java best practices. By default, Clojure uses the <code class="language-plaintext highlighter-rouge">try</code> and <code class="language-plaintext highlighter-rouge">catch</code> forms similar to Java’s.</p>

<p>Let’s take a look at Java’s exceptions. The platform contains the <code class="language-plaintext highlighter-rouge">Throwable</code> base class, the ancestor of all exceptions. Other classes inherit from it and extend its semantics. The <code class="language-plaintext highlighter-rouge">Error</code> and <code class="language-plaintext highlighter-rouge">Exception</code> classes are first-level heirs. The <code class="language-plaintext highlighter-rouge">RuntimeException</code> class inherits from from the <code class="language-plaintext highlighter-rouge">Exception</code> one and so on.</p>

<div class="language-plaintext code_chart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌─────────────┐
                │   Object    │
                └─────────────┘
                       │
                       ▼
                ┌─────────────┐
             ┌──│  Throwable  │──┐
             │  └─────────────┘  │
             │                   │
             ▼                   ▼
      ┌─────────────┐     ┌─────────────┐
      │    Error    │     │  Exception  │──┐
      └─────────────┘     └─────────────┘  │
                                           │
                                           ▼
                                ┌─────────────────────┐
                                │  RuntimeException   │
                                └─────────────────────┘

</code></pre></div></div>

<p>Java packages contain additional exceptions inherited from those described above. For example, <code class="language-plaintext highlighter-rouge">java.io.IOException</code> is for I/O errors, <code class="language-plaintext highlighter-rouge">java.net.ConnectException</code> – for network problems. Throwing <code class="language-plaintext highlighter-rouge">Throwable</code> is considered bad manner because this class carries too little information about what happened.</p>

<p>In the exception tree, each class complements the semantics of the ancestor. Consider the <code class="language-plaintext highlighter-rouge">FileNotFoundException</code> exception. It arises when a file is not on disk. The class pedigree looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.lang.Object.
  java.lang.Throwable.
    java.lang.Exception.
      java.io.IOException.
        java.io.FileNotFoundException.
</code></pre></div></div>

<p>The diagram is read like this “object → throwable → exception → I/O error → file not found”. It’s easy to guess by the name <code class="language-plaintext highlighter-rouge">FileNotFoundException</code> what the problem is. If a developer threw a <code class="language-plaintext highlighter-rouge">Throwable</code>, it would make it harder to find the cause of the error.</p>

<p>There are checked and unchecked exceptions in Java. They differ in semantics. The developer must anticipate checked exceptions and handle them in code. When we read a file, it’s quite normal that the file is missing. Thus, the <code class="language-plaintext highlighter-rouge">FileNotFoundException</code> class is a checked exception.</p>

<p>However, it is difficult to predict a memory shortage, so <code class="language-plaintext highlighter-rouge">OutOfMemoryError</code> is an unchecked exception. Like any other resource, memory is limited, and our careless actions can exhaust it. There is no point in catching this exception since the system is unstable when there is insufficient memory.</p>

<p>The classes inherited from <code class="language-plaintext highlighter-rouge">Error</code> and <code class="language-plaintext highlighter-rouge">RuntimeException</code> are unchecked exceptions. Those inherited from <code class="language-plaintext highlighter-rouge">Exception</code> are checked exceptions.</p>

<p>To throw an exception, we pass its instance to the <code class="language-plaintext highlighter-rouge">throw</code> statement. The <code class="language-plaintext highlighter-rouge">catch</code> statement catches exceptions. In Java and other languages, it relies on a class hierarchy. If the type we are looking for is <code class="language-plaintext highlighter-rouge">IOException</code>, we will catch all exceptions inherited from this class.</p>

<p>The higher the class in the inheritance tree, the more exceptions the <code class="language-plaintext highlighter-rouge">catch</code> statement will cover. In Java, it is bad manner to catch errors with the <code class="language-plaintext highlighter-rouge">Throwable</code> or <code class="language-plaintext highlighter-rouge">Exception</code> classes. Modern IDEs generate the warning “too broad catch expression” or similar. It is better to replace the <code class="language-plaintext highlighter-rouge">Exception</code> class with some more precise ones: for example, I/O errors, network errors, and others separately.</p>

<p>One class is not enough to understand an exception cause.
<code class="language-plaintext highlighter-rouge">FileNotFoundException</code> does not have the <code class="language-plaintext highlighter-rouge">file</code> field to track down which particular file does not exist. Most exceptions take an error message string. The message must be understandable to a person.
If we see the message “File C:/work/test.txt not found”, it becomes clear which file we were trying to access.</p>

<p>Sometimes a text is not enough to explain the reason for the error. Let us say data validation failed, and we would like to investigate it later. If you write the data to the message, the text will be too large. Additionally, this is not secure: the data may contain personal information or access keys. Such a message must not be logged or shown to a user. Even the file path can reveal valuable information to outsiders.</p>

<p>If you need to store data for investigation, create a new exception class with a separate field for the data that caused the error. The field is populated in the exception constructor. Create your message so that it does not reveal private information.</p>

<h2 id="chains-and-context">Chains and Context</h2>

<p>Exceptions are chained. Each instance takes an optional <code class="language-plaintext highlighter-rouge">cause</code> argument. It stores either <code class="language-plaintext highlighter-rouge">Null</code> or a link to another exception.</p>

<p>Chains appear when the code catches an exception but does not know how to deal with it. Since the code does not see the full picture at a low level, this is normal. Suppose the method writes data to a file. It has no authority to decide what to do if the file does not exist so an exception will be thrown. Another method that also does not make decisions will catch this exception. You only need to create a new exception with a link to the first one. This is the chain.</p>

<p>Eventually, control will pass to the method that knows what to do. The logic depends on an exception type and business rules. If a file does not exist, the program will create it or search elsewhere. If an HTTP request fails, the method waits for a second and repeats it, and after the third attempt, the program shuts down.</p>

<p>The system should have the last frontier where all exceptions are caught. If the error has reached this level, then the rules below did not catch it. This indicates abnormal system behavior. A client will receive a text stating that the request has failed. For investigating the cause, the exception is logged and passed to the error collector.</p>

<p>We, programmers, mostly work on expressing the business logic of a company in code. The logic lies at the top level of code, but more technical parts come into play at lower levels. Let us say the <code class="language-plaintext highlighter-rouge">get_user</code> function finds a user by their number. It’s a black box from the outside: we do not know where the data comes from. Suppose the function is communicating with a network. Let us write this in Python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_user</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
  <span class="n">url</span> <span class="o">=</span> <span class="s">"http://api.company.com/user/"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">http</span><span class="p">.</span><span class="n">GET</span><span class="p">(</span><span class="n">url</span><span class="p">).</span><span class="n">body</span><span class="p">.</span><span class="n">json</span><span class="p">()</span>
</code></pre></div></div>

<p>If we call a function with a number that does not exist in the system, we will get the <code class="language-plaintext highlighter-rouge">HTTP Error: status 404</code> exception. This text does not say anything about the user. We will not even understand from this wording which service we tried to reach.</p>

<p>The more we go into technical details, the less we know about the business. In HTTP, there is no such thing as a company user. Only the method, address, and other fields of the request are known. Let us divide the error into two halves. The top half indicates the business reason: User 5 was not found. Why? The GET request to the <code class="language-plaintext highlighter-rouge">http://api.company.com/user/5</code> address returned status 404, which we consider as a negative one.</p>

<p>Let us place <code class="language-plaintext highlighter-rouge">try/catch</code> in our code. If the exception came from technical levels, we will add context and send it up. The pattern is called <code class="language-plaintext highlighter-rouge">re-throw</code>. Here is the new Python code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_user</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s">"http://api.company.com/user/"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">http</span><span class="p">.</span><span class="n">GET</span><span class="p">(</span><span class="n">url</span><span class="p">).</span><span class="n">body</span><span class="p">.</span><span class="n">json</span><span class="p">()</span>
  <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">"Cannot fetch user "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span> \
      <span class="k">from</span> <span class="n">e</span>
</code></pre></div></div>

<p>The new exception describes a business problem while referring to a technical one. An HTTP error might also have its own causes: an expired certificate or connection problems. A chain of exceptions is formed. There might be up to five or more links in exceptions from real projects.</p>

<p>Descending a chain is like an interrogation. In response to each “why” question, we receive new information until we get to the heart of the matter. This is not to say that the innermost exception is more important than the others: the <code class="language-plaintext highlighter-rouge">HTTPError</code> exception cannot answer all questions alone. The important thing is how you came to it.</p>

<p>That is how exceptions work in languages like Java, Python, and others. Each platform has its features, but the overall picture stays the same. Now let us take a look at what Clojure has to offer.</p>

<h2 id="moving-on-to-clojure">Moving on to Clojure</h2>

<p>To get acquainted with the exception, let’s provoke it. A surefire trick is to divide a number by zero. Turn on REPL and do <code class="language-plaintext highlighter-rouge">(/ 1 0)</code>. The following text will appear:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Execution error (ArithmeticException)...
Divide by zero
</code></pre></div></div>

<p>This is the error report. It looks different depending on the editor and settings. Emacs with the CIDER module will open the <code class="language-plaintext highlighter-rouge">*cider-error*</code> buffer with detailed information.</p>

<p>Note that an exception in the REPL does not stop it: the program still waits for us to type something. The REPL catches errors and only displays them on a screen. In production, Clojure programs work as usual. If no exception is caught in the main thread, the program will stop.</p>

<p>To catch the exception, place the code in the <code class="language-plaintext highlighter-rouge">try</code> form. It is followed by one or more <code class="language-plaintext highlighter-rouge">catch</code> forms. They indicate which classes to catch and what to do with an exception. Here’s how to safely divide a number:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Weird arithmetics"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">catch</code> form takes a class and an arbitrary symbol. An exception will be bound to that symbol if control is taken to this branch. Next goes the arbitrary code. There, the exception is available as the local variable, which is <code class="language-plaintext highlighter-rouge">e</code> in our case.</p>

<p>We display the text about the failure of calculations without explaining the reason. Let the text be more detailed. The <code class="language-plaintext highlighter-rouge">.getMessage</code> method will return the message assigned to the exception when it was created. Since version 1.10, Clojure offers the <code class="language-plaintext highlighter-rouge">ex-message</code> function that does the same:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))))</span><span class="w">
</span><span class="c1">;; Divide by zero</span><span class="w">
</span></code></pre></div></div>

<p>Clojure beginners might be surprised that the <code class="language-plaintext highlighter-rouge">ArithmeticException</code> class fails to catch some computation errors. What will happen if you add 1 to <code class="language-plaintext highlighter-rouge">nil</code>? Even if we put the calculations in <code class="language-plaintext highlighter-rouge">try/catch</code>, we won’t catch the exception:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Weird arithmetics"</span><span class="p">)))</span><span class="w">
</span><span class="c1">;; Execution error (NullPointerException)...</span><span class="w">
</span></code></pre></div></div>

<p>That is because the <code class="language-plaintext highlighter-rouge">ArithmeticException</code> and <code class="language-plaintext highlighter-rouge">NullPointerException</code> classes do not overlap. They have different paths in the inheritance tree, so catching one does not affect the other. And rightly so, because the classes have different semantics. An arithmetic error is not the same as <code class="language-plaintext highlighter-rouge">Null</code> instead of a value.</p>

<p>The <code class="language-plaintext highlighter-rouge">try</code> form takes several <code class="language-plaintext highlighter-rouge">catch</code> ones. Let’s catch both cases:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Weird arithmetics"</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">NullPointerException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"You've got a null value"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The macro iterates over the classes from each <code class="language-plaintext highlighter-rouge">catch</code> and stops at the first one that matches. The <code class="language-plaintext highlighter-rouge">try</code> will result in the last expression from the <code class="language-plaintext highlighter-rouge">catch</code> block that matched. In the example above, the result will be <code class="language-plaintext highlighter-rouge">nil</code> because the <code class="language-plaintext highlighter-rouge">println</code> function will return it. If no branches match, the exception will continue to go up the call stack.</p>

<p>The higher the exception class in the tree, the more cases it covers. If you replace <code class="language-plaintext highlighter-rouge">ArithmeticException</code> with <code class="language-plaintext highlighter-rouge">Throwable</code>, the branch will catch any exception, whether it’s division by zero or <code class="language-plaintext highlighter-rouge">NPE</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"I catch everything!"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Unlike Java, Clojure doesn’t have strict rules about which exceptions to catch. That’s up to you. Common sense dictates that intercepting with <code class="language-plaintext highlighter-rouge">Throwable</code> should not be used: there will be a false impression that the code works without errors.</p>

<p>In the case of <code class="language-plaintext highlighter-rouge">ArithmeticException</code>, the problem is in the calculations, but for <code class="language-plaintext highlighter-rouge">NPE</code> – it is not. <code class="language-plaintext highlighter-rouge">Nil</code> instead of a number tells us that the problem is in the source, which passed <code class="language-plaintext highlighter-rouge">nil</code>, and not in arithmetic. That is why catching <code class="language-plaintext highlighter-rouge">NPE</code> might put you on the wrong track. We’ll explore this issue in detail in the chapter on tests.</p>

<p>Usually, we put the <code class="language-plaintext highlighter-rouge">try/catch</code> form on the top level of the code with a broad scope. That is needed so that the program never stops. That is how web servers, message queues, and networking software work.</p>

<p>Sometimes an exception is thrown deliberately to report an abnormal situation. The <code class="language-plaintext highlighter-rouge">new</code> operator creates a new Java object. It accepts a class name and its constructor parameters. The <code class="language-plaintext highlighter-rouge">throw</code> form takes an exception and runs the throwing mechanism.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="s">"Something is wrong!"</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The message above is not informative. But even if we indicated that the problem is in arithmetic or the database, we would like to know which values exactly caused the error. For this, build the message using the <code class="language-plaintext highlighter-rouge">format</code> function. It takes the template and substitution parameters:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">message</span><span class="w">
          </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Value error, a: %s, b: %s"</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">message</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Calling <code class="language-plaintext highlighter-rouge">add</code> with <code class="language-plaintext highlighter-rouge">nil</code> makes the message clearer:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Execution error at book.exceptions/add (exceptions.clj:86).
Value error, a: 1, b: null
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">format</code> function is useful in that it displays <code class="language-plaintext highlighter-rouge">nil</code> as <code class="language-plaintext highlighter-rouge">null</code>. That is its advantage over <code class="language-plaintext highlighter-rouge">str</code>, which converts <code class="language-plaintext highlighter-rouge">nil</code> to an empty string. The <code class="language-plaintext highlighter-rouge">str</code> variant would look like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Value error, a:"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">", b: "</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">;; Value error, a:1, b:</span><span class="w">
</span></code></pre></div></div>

<p>The text is misleading: is <code class="language-plaintext highlighter-rouge">b</code> an empty string or <code class="language-plaintext highlighter-rouge">nil</code>? In the case of <code class="language-plaintext highlighter-rouge">format</code>, you won’t get confused.</p>

<h2 id="more-about-context">More about Context</h2>

<p>The data in a text leads to risk. A message may be too large or disclose unnecessary information. The <code class="language-plaintext highlighter-rouge">ExceptionInfo</code> class, a Clojure exception, solves this problem. It is designed to carry arbitrary data. Clojure offers some functions for working with it.</p>

<p>The key <code class="language-plaintext highlighter-rouge">ex-info</code> function creates an instance of <code class="language-plaintext highlighter-rouge">ExceptionInfo</code>. The former takes a message and a data map. That is the context in which the exception arose. For example, if an HTTP request fails, the map will contain the method, address, and response code.</p>

<p><code class="language-plaintext highlighter-rouge">Ex-info</code> only creates an exception but doesn’t throw it. The result goes to <code class="language-plaintext highlighter-rouge">throw</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w">
        </span><span class="s">"Cannot fetch user."</span><span class="w">
        </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">5</span><span class="w">
         </span><span class="no">:http-status</span><span class="w"> </span><span class="mi">404</span><span class="w">
         </span><span class="no">:http-method</span><span class="w"> </span><span class="s">"GET"</span><span class="w">
         </span><span class="no">:http-url</span><span class="w"> </span><span class="s">"https://host.com/users/5"</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>We have separated the message and the data. The text does not reveal a user number and service address. It will be logged or sent to a user, and the context will be processed separately.</p>

<p>Remember a few rules when working with context. A map must not be <code class="language-plaintext highlighter-rouge">nil</code>. That is the rare case where Clojure distinguishes <code class="language-plaintext highlighter-rouge">nil</code> from an empty map. Do not store values that cannot be written to a file, such as a stream or a network connection, in a map. Ideally, the context is transmitted over the network in JSON format. We’ll look at what to do with the context later.</p>

<p>The <code class="language-plaintext highlighter-rouge">ex-data</code> function will return the exception data. If this is a native <code class="language-plaintext highlighter-rouge">ExceptionInfo</code>, we’ll get a map. For other classes, the function will return <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>Let’s catch the exception: in the <code class="language-plaintext highlighter-rouge">catch</code> form, we’ll specify the <code class="language-plaintext highlighter-rouge">ExceptionInfo</code> class. The <code class="language-plaintext highlighter-rouge">ex-data</code> function retrieves the map that was passed to <code class="language-plaintext highlighter-rouge">ex-info</code>.
Let’s split it into fields and build a message.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-user</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">clojure.lang.ExceptionInfo</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">http-method</span><span class="w"> </span><span class="n">http-url</span><span class="p">]}</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-data</span><span class="w"> </span><span class="n">e</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"HTTP error: %s %s"</span><span class="w"> </span><span class="n">http-method</span><span class="w"> </span><span class="n">http-url</span><span class="p">))))</span><span class="w">
</span><span class="c1">;; HTTP error: GET https://host.com/users/5</span><span class="w">
</span></code></pre></div></div>

<h2 id="when-to-throw-exceptions">When to Throw Exceptions</h2>

<p>It is still unclear when to throw exceptions and when to catch them. Let’s look at typical situations and solutions.</p>

<p>There is no point in throwing exceptions when walking through collections. <code class="language-plaintext highlighter-rouge">Nil</code> behaves like an empty collection of the type that the function accepts.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:test</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="no">:test</span><span class="w"> </span><span class="p">(</span><span class="nf">fnil</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nb">merge</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span><span class="no">:test</span><span class="w"> </span><span class="mi">5</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>The expressions above should return lists and maps. The key for <code class="language-plaintext highlighter-rouge">nil</code> will return <code class="language-plaintext highlighter-rouge">nil</code>. Splitting a map or vector will set the variables to <code class="language-plaintext highlighter-rouge">nil</code> if the fields don’t match. Both of the <code class="language-plaintext highlighter-rouge">let</code> directives below will create a vector of three <code class="language-plaintext highlighter-rouge">nil</code> references.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">]}</span><span class="w"> </span><span class="n">nil</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="n">nil</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>The “nil punning” term means the language is tolerant to <code class="language-plaintext highlighter-rouge">nil</code> values and might deal with it without raising exceptions. For example, all the collections functions treat <code class="language-plaintext highlighter-rouge">nil</code> as an empty collection of a type that is actually meant. Of course, Clojure doesn’t make full use of nil punning. In Clojure, <code class="language-plaintext highlighter-rouge">nil</code> works with collections, but not arithmetic and regular expressions.</p>

<p>When in doubt about a collection, use a spec. The <code class="language-plaintext highlighter-rouge">s/valid?</code> and <code class="language-plaintext highlighter-rouge">s/conform</code> functions from the last chapter will help you make sure the collection is correct. That will separate validation from data manipulation. If validation fails — throw an exception. Pass the <code class="language-plaintext highlighter-rouge">explain</code> data into the context so you can parse it later.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.spec.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::data</span><span class="w"> </span><span class="p">(</span><span class="nf">s/coll-of</span><span class="w"> </span><span class="n">int?</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">explain</span><span class="w"> </span><span class="p">(</span><span class="nf">s/explain-data</span><span class="w"> </span><span class="no">::data</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">nil</span><span class="p">])]</span><span class="w">
  </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"Some item is not an integer"</span><span class="w">
                  </span><span class="p">{</span><span class="no">:explain</span><span class="w"> </span><span class="n">explain</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>For the sake of shortness, use the <code class="language-plaintext highlighter-rouge">assert</code> macro from Spec (don’t mix it with the standard <code class="language-plaintext highlighter-rouge">assert</code> from <code class="language-plaintext highlighter-rouge">clojure.core</code>). It does the same: validates the data and either returns it or throws an exception with <code class="language-plaintext highlighter-rouge">explain</code> data. The <code class="language-plaintext highlighter-rouge">check-asserts</code> global flag defines the macro behavior. If it is off, the effect of <code class="language-plaintext highlighter-rouge">assert</code> disappears, and there will be no exception.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.spec.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::ne-string</span><span class="w"> </span><span class="p">(</span><span class="nf">s/and</span><span class="w"> </span><span class="nb">string?</span><span class="w"> </span><span class="n">not-empty</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/check-asserts</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/assert</span><span class="w"> </span><span class="no">::ne-string</span><span class="w"> </span><span class="s">"test"</span><span class="p">)</span><span class="w"> </span><span class="c1">;; ok</span><span class="w">

</span><span class="p">(</span><span class="nf">s/assert</span><span class="w"> </span><span class="no">::ne-string</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">;; Execution error - invalid arguments</span><span class="w">
</span><span class="c1">;; nil - failed: string?</span><span class="w">

</span><span class="p">(</span><span class="nf">s/check-asserts</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/assert</span><span class="w"> </span><span class="no">::ne-string</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w"> </span><span class="c1">;; nil</span><span class="w">
</span></code></pre></div></div>

<p>Another case of resorting to an exception is resource failure. If the file could not be read, simply reporting this fact is not enough. That might have happened for various reasons: the file does not exist or is occupied by another process; there is insufficient disk space or an encoding error, etc. The error category determines what to do with it and how to prevent it from recurring.</p>

<p>There is no industry consensus on whether to throw an exception on a negative HTTP response. According to the protocol, a 404 response is as correct as 200. Advanced libraries offer the flag to choose whether to throw an exception at 4xx statuses or not.</p>

<p>Let’s say our HTTP client doesn’t throw an exception. Let’s do it manually – check the status and run <code class="language-plaintext highlighter-rouge">ex-info</code> with details:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">authenticate-user</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">url</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"http://auth.company.com/"</span><span class="w"> </span><span class="n">user-id</span><span class="p">)</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">status</span><span class="w"> </span><span class="n">body</span><span class="p">]}</span><span class="w"> </span><span class="p">(</span><span class="nf">client/get</span><span class="w"> </span><span class="n">url</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w">
      </span><span class="n">body</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"Authentication error"</span><span class="w">
                      </span><span class="p">{</span><span class="no">:http-url</span><span class="w"> </span><span class="n">url</span><span class="w">
                       </span><span class="no">:http-status</span><span class="w"> </span><span class="n">status</span><span class="w">
                       </span><span class="no">:http-body</span><span class="w"> </span><span class="n">body</span><span class="p">})))))</span><span class="w">
</span></code></pre></div></div>

<p>Exceptions are helpful in libraries. At their level, we don’t make business decisions because we don’t see the whole context. Suppose if an image library cannot find a file, it will throw an exception. The code above will catch it and perform a fallback script: maybe it will download the image from the Internet, open another file, or fail. But the library doesn’t know for sure what will happen, so raising an error is the only way to report abnormal behaviour.</p>

<p>Now imagine that if the file does not exist, the library will silently skip writing data. Users will be dissatisfied with this logic: how to make sure everything went smoothly? This also applies to the pattern “return <code class="language-plaintext highlighter-rouge">nil</code> and write to the log”, that is, ignore the problem.</p>

<h2 id="more-about-chains">More about Chains</h2>

<p>Now let’s see how to work with exception chains exactly. The <code class="language-plaintext highlighter-rouge">ex-info</code> function takes a third optional <code class="language-plaintext highlighter-rouge">cause</code> parameter. It might be <code class="language-plaintext highlighter-rouge">nil</code> or another exception that will become part of the new one. Below, the <code class="language-plaintext highlighter-rouge">divide</code> function catches an arithmetic error and throws a new exception with a full context.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w">
               </span><span class="s">"Calculation error"</span><span class="w">
               </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="n">b</span><span class="p">}</span><span class="w">
               </span><span class="n">e</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ex-cause</code> function returns a cause of an exception. If there is no cause, we’ll get <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nf">divide</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-cause</span><span class="w"> </span><span class="n">e</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>The code will output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Calculation error
Divide by zero
</code></pre></div></div>

<p>Let’s write a function that returns an exception list in descending order of precedence. The original exception comes first, the cause of the exception comes second, then – the cause of the cause, and so on. Using the <code class="language-plaintext highlighter-rouge">loop</code> form is the simplest way of doing this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">ex-chain</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="n">e</span><span class="w">
         </span><span class="n">result</span><span class="w"> </span><span class="p">[]]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
      </span><span class="n">result</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-cause</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">e</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>To experiment, let’s declare the variable <code class="language-plaintext highlighter-rouge">e</code>. That is a three-link chain of exceptions. At the first level, there is a business logic error: Failed to retrieve a user. At the second level – a problem with authorization: Not enough permissions for the resource. There is a transport error at the third one: The HTTP request returned status 403.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">e</span><span class="w">
  </span><span class="p">(</span><span class="nf">ex-info</span><span class="w">
   </span><span class="s">"Get user info error"</span><span class="w">
   </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w">
   </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"Auth error"</span><span class="w">
            </span><span class="p">{</span><span class="no">:token</span><span class="w"> </span><span class="s">"........."</span><span class="p">}</span><span class="w">
            </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"HTTP error"</span><span class="w">
                     </span><span class="p">{</span><span class="no">:method</span><span class="w"> </span><span class="s">"POST"</span><span class="w">
                      </span><span class="no">:url</span><span class="w"> </span><span class="s">"http://api.site.com"</span><span class="p">}))))</span><span class="w">
</span></code></pre></div></div>

<p>We got an exception tree as a result, but it is not always convenient to work with the tree. Walking through a flat structure is better. The <code class="language-plaintext highlighter-rouge">ex-chain</code> function we wrote will be useful for us. Here’s how to get messages of all exceptions:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">ex-message</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-chain</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
</span><span class="c1">;; ("Get user info error" "Auth error" "HTTP error")</span><span class="w">
</span></code></pre></div></div>

<p>And print line by line (we’ll get a column of the same lines):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-chain</span><span class="w"> </span><span class="n">e</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">ex-message</span><span class="w"> </span><span class="nb">println</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Let’s express <code class="language-plaintext highlighter-rouge">ex-chain</code> in short through the <code class="language-plaintext highlighter-rouge">iterate</code> function. This function applies another one to the initial argument, then to the result, then to the new result and so on. We need the <code class="language-plaintext highlighter-rouge">take-while</code> constraint to stop before the first <code class="language-plaintext highlighter-rouge">nil</code> item.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">ex-chain</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">take-while</span><span class="w"> </span><span class="n">some?</span><span class="w"> </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="n">ex-cause</span><span class="w"> </span><span class="n">e</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h2 id="printing-of-exceptions">Printing of Exceptions</h2>

<p>Something went wrong, and we found ourselves in the <code class="language-plaintext highlighter-rouge">catch</code> thread. A local variable points to the exception. What can we do about it?</p>

<p>The simplest thing is to print the exception to the console. The <code class="language-plaintext highlighter-rouge">println</code> function is smart enough: it converts the exception to a map before printing. The map is easy to divide into parts, so it is convenient for editors and IDE. For example, to show only that part of the stack trace that concerns project-related namespaces.</p>

<p>The last exception in the chain is called the root. For convenience, <code class="language-plaintext highlighter-rouge">println</code> duplicates it to the beginning, so that we can see the root cause immediately. This is what <code class="language-plaintext highlighter-rouge">(println e)</code> will output:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="n">error</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="no">:cause</span><span class="w"> </span><span class="n">HTTP</span><span class="w"> </span><span class="n">error</span><span class="w">
 </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:method</span><span class="w"> </span><span class="n">POST,</span><span class="w"> </span><span class="no">:url</span><span class="w"> </span><span class="n">http</span><span class="no">://api.site.com</span><span class="p">}</span><span class="w">
 </span><span class="no">:via</span><span class="w">
 </span><span class="p">[{</span><span class="no">:type</span><span class="w"> </span><span class="n">clojure.lang.ExceptionInfo</span><span class="w">
   </span><span class="no">:message</span><span class="w"> </span><span class="n">Get</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="n">error</span><span class="w">
   </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">5</span><span class="p">}}</span><span class="w">
  </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="n">clojure.lang.ExceptionInfo</span><span class="w">
   </span><span class="no">:message</span><span class="w"> </span><span class="n">Auth</span><span class="w"> </span><span class="n">error</span><span class="w">
   </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:token</span><span class="w"> </span><span class="n">.........</span><span class="p">}}</span><span class="w">
  </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="n">clojure.lang.ExceptionInfo</span><span class="w">
   </span><span class="no">:message</span><span class="w"> </span><span class="n">HTTP</span><span class="w"> </span><span class="n">error</span><span class="w">
   </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:method</span><span class="w"> </span><span class="n">POST,</span><span class="w"> </span><span class="no">:url</span><span class="w"> </span><span class="n">http</span><span class="no">://api.site.com</span><span class="p">}}]</span><span class="w">
 </span><span class="no">:trace</span><span class="w">
 </span><span class="p">[[</span><span class="n">clojure.lang.AFn</span><span class="w"> </span><span class="n">applyToHelper</span><span class="w"> </span><span class="n">AFn.java</span><span class="w"> </span><span class="mi">156</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">clojure.lang.AFn</span><span class="w"> </span><span class="n">applyTo</span><span class="w"> </span><span class="n">AFn.java</span><span class="w"> </span><span class="mi">144</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">clojure.lang.Compiler$InvokeExpr</span><span class="w"> </span><span class="nb">eval</span><span class="w"> </span><span class="n">Compiler.java</span><span class="w"> </span><span class="mi">3701</span><span class="p">]</span><span class="w">
  </span><span class="n">..........</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">:trace</code> vector is called a stack trace. It is a list of Java methods that the exception passed through, from being thrown to being caught. A trace element is a vector with a class, method, and file names as well as a line number.</p>

<p>We have shortened the trace, but usually, they take up several screens. It’s important to understand that they signify not Clojure, but Java code made after compilation. When analysing the trace, you should perform a reverse action in your mind: match compiled names with your Clojure code. The trick is not always easy and confuses beginners. Noisy traces are a fair reproach to Clojure. On the other hand, this is a common flaw of most of the JVM languages.</p>

<p>The <code class="language-plaintext highlighter-rouge">clojure.stacktrace</code> package has several functions for printing exceptions. <code class="language-plaintext highlighter-rouge">Print-throwable</code> shows a message and a context:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.stacktrace</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">trace</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">trace/print-throwable</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
</span><span class="c1">;; clojure.lang.ExceptionInfo: Get user info error</span><span class="w">
</span><span class="c1">;; {:user-id 5}</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">with-out-str</code> macro intercepts the output to the console. The code below does not print anything, but it will return a string:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">with-out-str</span><span class="w">
  </span><span class="p">(</span><span class="nf">clojure.stacktrace/print-stack-trace</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">print-stack-trace</code> and <code class="language-plaintext highlighter-rouge">print-cause-trace</code> functions
print a~trace with slight differences. They take the <code class="language-plaintext highlighter-rouge">n</code> parameter
to~specify the depth of the trace.</p>

<h2 id="logging">Logging</h2>

<p>Console output helps in debugging, but, in a production run, it is not quite usefull. Here’s what you can expect from code that catches exceptions.</p>

<p>For any message, we expect to see its auxiliary data. These are the time, namespace, process number. Messages differ in importance: informational, warning, alarm, and others. Printing functions lack this information, and if you collect it manually, the code grows.</p>

<p>When the program runs on multiple servers, message collection is centralized. Imagine an employee switching between hundreds of machines to read logs – that is no good. If the message came over the network, you need to remember the source address.</p>

<p>Not all messages are of equal importance. Sometimes libraries generate hundreds of debug messages per minute. We need an algorithm to drop some of them by rules.</p>

<p>Plus, the console and file aren’t the only data feeds. Especially important messages need to be written to the operating system log, sent to email and chatbots, or people in charge as text messages.</p>

<p>Logging solves the above problems. This system gets messages and sends them to the required channels. The <code class="language-plaintext highlighter-rouge">clojure.tools.logging</code> library offers functions and macros to log messages. That is a third-party project, so add the dependency:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">org.clojure/tools.logging</span><span class="w"> </span><span class="s">"0.4.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Let’s write a simple message:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.tools.logging</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">log</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"A message from my module"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>A line will appear in REPL. By default, the log adds a severity level. In our case, this is an informational message, <code class="language-plaintext highlighter-rouge">INFO</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INFO: A message from my module
</code></pre></div></div>

<p>Clojure logging has two levels. The first one is the entry point, the <code class="language-plaintext highlighter-rouge">log/info</code>, <code class="language-plaintext highlighter-rouge">log/error</code>, and other macros. The second level is called the backend. It is a Java library that does the bulk of the work: writes messages to files, sends them over the network, and so on.</p>

<p>Such a structure has advantages. Historically, many logging libraries have written for Java. Each of them offers its classes and methods. If the project uses a particular Java backend, you won’t be able to change it without code editing.</p>

<p>In Clojure, this problem was solved by design. At startup, the <code class="language-plaintext highlighter-rouge">logging</code> module looks for the <code class="language-plaintext highlighter-rouge">Logback</code>, <code class="language-plaintext highlighter-rouge">Log4j</code>, and other libraries. If not, it uses the standard <code class="language-plaintext highlighter-rouge">java.util.logging</code>. The <code class="language-plaintext highlighter-rouge">log/info</code> call boils down to calling a class from the found library.</p>

<p>To pick up the required backend, add it to the dependencies. The <code class="language-plaintext highlighter-rouge">Logback</code> project is especially popular among other logging backends. It has a large selection of appenders, unlike its analogs. An appender determines the destination where to write messages. It may be a file, a remote syslog, or a mail server.</p>

<p>Add Logback to your project:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ch.qos.logback/logback-classic</span><span class="w"> </span><span class="s">"1.2.3"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Logging libraries look for settings in standard locations. If you put an XML file in the <code class="language-plaintext highlighter-rouge">resources</code> folder, the backend will read it at startup. Write the following <code class="language-plaintext highlighter-rouge">logback.xml</code> file there:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;configuration&gt;</span>
  <span class="nt">&lt;appender</span> <span class="na">name=</span><span class="s">"STDOUT"</span> <span class="na">class=</span><span class="s">"...ConsoleAppender"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;encoder&gt;</span>
      <span class="nt">&lt;charset&gt;</span>UTF-8<span class="nt">&lt;/charset&gt;</span>
      <span class="nt">&lt;pattern&gt;</span>
        %date %-5level %logger{36} - %msg %n
      <span class="nt">&lt;/pattern&gt;</span>
    <span class="nt">&lt;/encoder&gt;</span>
  <span class="nt">&lt;/appender&gt;</span>
  <span class="nt">&lt;root</span> <span class="na">level=</span><span class="s">"INFO"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;appender-ref</span> <span class="na">ref=</span><span class="s">"STDOUT"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/root&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div></div>

<p>So, we have set the appender to output to the console. The <code class="language-plaintext highlighter-rouge">pattern</code> tag contains a message template. Template parameters start with a percent sign. Substitution <code class="language-plaintext highlighter-rouge">%msg</code> stands for a message, <code class="language-plaintext highlighter-rouge">%date</code>  – for the current date. Its format is specified in curly braces, for example, <code class="language-plaintext highlighter-rouge">%date{ISO8601}</code>. Restart the REPL to apply the new settings and log something. The output will change:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"Hello Logback!"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2019-05-03 17:36:04,001 INFO book.exceptions - Hello Logback!</span><span class="w">
</span></code></pre></div></div>

<h2 id="exception-context">Exception Context</h2>

<p>The <code class="language-plaintext highlighter-rouge">log/info</code>, <code class="language-plaintext highlighter-rouge">log/error</code>, and other macros first argument might be not a text, but an exception. Above, we have declared the variable <code class="language-plaintext highlighter-rouge">e</code> for experiments. Let’s write it to the log:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">log/error</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"HTTP Error"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2019-05-03 17:41:03,913 ERROR book.exceptions - HTTP Error
clojure.lang.ExceptionInfo: Get user info error
    at java.lang.Thread.run(Thread.java:745)
Caused by: clojure.lang.ExceptionInfo: Auth error
    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
    ... 30 common frames omitted
Caused by: clojure.lang.ExceptionInfo: HTTP error
    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
    ... 31 common frames omitted
</code></pre></div></div>

<p>To save space, we have removed part of the trace. From the example, you can see the chain consists of three links, which we specified as <code class="language-plaintext highlighter-rouge">e</code>. But each link has lost data! The problem is that Logback is unaware that the <code class="language-plaintext highlighter-rouge">data</code> field of the <code class="language-plaintext highlighter-rouge">ExceptionInfo</code> class is so important to us.</p>

<p>The library offers several templates for exceptions (<code class="language-plaintext highlighter-rouge">%xEx</code>, <code class="language-plaintext highlighter-rouge">%xException</code>, and others). They affect the length and detail of the trace but ignore data. Log4j and other projects behave similarly.</p>

<p>In Java, the problem is solved with a new class. Typically, the logging backend offers a class that converts the exception into a string. We create a descendant class and override specific methods. Then we specify a full path to that class in logging settings.</p>

<p>This approach works in Clojure as well, but with some problems. Clojure requires a separate module with the <code class="language-plaintext highlighter-rouge">:gen-class</code> directive to inherit a class. You will have to read the library documentation, and explore the classes and interfaces. The decision will depend on the specific backend. Switching to Log4 will force us to inherit from another class. There is another way you can follow in Clojure.</p>

<p>First, we write a function ex-print which prints an exception the way we need. Using ex-chain, we traverse the elements and for each one print its class, message and contex. To visually separate parts, we use indents and the pretty printing function which aligns data.</p>

<p>First, we write a function <code class="language-plaintext highlighter-rouge">ex-print</code> that prints an exception the way we need. With <code class="language-plaintext highlighter-rouge">ex-chain</code>, we traverse the elements and, for each one, print its class, message and context. To visually separate parts, we use indents and the pretty-printing function, which aligns data.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">ex-print</span><span class="w">
  </span><span class="p">[</span><span class="o">^</span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">indent</span><span class="w"> </span><span class="s">"  "</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-chain</span><span class="w"> </span><span class="n">e</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="nb">class</span><span class="w"> </span><span class="n">.getCanonicalName</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="n">indent</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-data</span><span class="w"> </span><span class="n">e</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="n">indent</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="n">data</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>The result looks more attractive than the trace pyramid. The data that led to the error is more visible:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ex-print</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">

</span><span class="n">clojure.lang.ExceptionInfo</span><span class="w">
  </span><span class="n">Get</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="n">error</span><span class="w">
  </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w">
</span><span class="n">clojure.lang.ExceptionInfo</span><span class="w">
  </span><span class="n">Auth</span><span class="w"> </span><span class="n">error</span><span class="w">
  </span><span class="p">{</span><span class="no">:token</span><span class="w"> </span><span class="s">"........."</span><span class="p">}</span><span class="w">
</span><span class="n">clojure.lang.ExceptionInfo</span><span class="w">
  </span><span class="n">HTTP</span><span class="w"> </span><span class="n">error</span><span class="w">
  </span><span class="p">{</span><span class="no">:method</span><span class="w"> </span><span class="s">"POST"</span><span class="n">,</span><span class="w"> </span><span class="no">:url</span><span class="w"> </span><span class="s">"http://api.site.com"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Now we add a <code class="language-plaintext highlighter-rouge">log-error</code> function which is a wrapper on top of the <code class="language-plaintext highlighter-rouge">log/error</code> macro. The difference is, the macro accepts not an instance of an exception but a finite message produced by <code class="language-plaintext highlighter-rouge">ex-print</code>. To catch printing into a string, we put <code class="language-plaintext highlighter-rouge">ex-print</code> call inside the <code class="language-plaintext highlighter-rouge">with-out-str</code> macro.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">log-error</span><span class="w">
  </span><span class="p">[</span><span class="o">^</span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="n">message</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/error</span><span class="w">
   </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w">
     </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="s">"Error"</span><span class="p">))</span><span class="w">
     </span><span class="p">(</span><span class="nf">ex-print</span><span class="w"> </span><span class="n">e</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>We pass a message to <code class="language-plaintext highlighter-rouge">log-error</code> as the second argument. If it does not exist, write a neutral Error. To prevent the message and body from sticking together, we use <code class="language-plaintext highlighter-rouge">println</code> to break a line. Here are some examples:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">log-error</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">log-error</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"HTTP Error 500"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The second call will log the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2019-05-03 19:00:05,590 ERROR book.exceptions - HTTP Error 500
clojure.lang.ExceptionInfo
  Get user info error
  ...
</code></pre></div></div>

<p>Modify the <code class="language-plaintext highlighter-rouge">log-error</code> so that the message will be a template, and the function will take substitution parameters like <code class="language-plaintext highlighter-rouge">format</code> does:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">log-error</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"Cannot find user %s, status %s"</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">404</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>In the chapter on mutability, we’ll show you how to boil down the <code class="language-plaintext highlighter-rouge">log/error</code> macro to calling <code class="language-plaintext highlighter-rouge">log-error</code>. This way, we get rid of importing <code class="language-plaintext highlighter-rouge">log-error</code> into each module where an error is logged. However, it is too early to talk about it now.</p>

<h2 id="collecting-exceptions">Collecting Exceptions</h2>

<p>Error messages are separate from other entries. There are at least two appenders for this: a console and a file. All messages are output to the console to keep the programmer informed. Errors require our attention so they are written to a file or sent over the network. Later we analyze them manually or with special programs.</p>

<p>We’ve figured out how to express an exception as text. Now you can write it to a file, send it by email or even print it. A disadvantage to text is that it is not structured. From a code point of view, this is a stream of characters, and it is not clear where things are. When collecting errors, it is crucial to distinguish the key fields such as severity, a subsystem, and module. They are necessary for the following reasons.</p>

<p><strong>Prevent duplication.</strong> During an influx of customers, there might pop up an error that we did not notice before. If we write it to a file every time, we will get a ton of identical messages. That is resource-intensive and makes it difficult to find other errors.</p>

<p>A collector determines the error similarity according to special rules. The “user1 not found” and “user2 not found” messages are slightly different, but the collector will combine them into one entry and show the rest on demand.</p>

<p><strong>Search.</strong> You cannot build an efficient search without a structure.
When errors are in the form of text, you can search only by the occurrence of a word or regular expression. This search is not relevant; it ignores how closely the item matches the request. It also does not cut out duplicates: we run the risk of being overwhelmed by identical messages in the search results.</p>

<p><strong>Statistics.</strong> When we have identified error parts, we can build reports on them. For example, we can find out how many errors happened in the last month or year, or group data by projects or teams, or identify projects where mistakes happen most often.</p>

<p><strong>Knowledge base.</strong> In a collection system, every error becomes an artifact. We write comments to it, attach screenshots and screen recordings. You can refer to an error in a task or review. If exceptions are logged to plain files, these options are not available.</p>

<p><a href="https://sentry.io">Sentry</a>, a web application based on Django, looks decent compared to other systems. One uses it to create projects that accumulate customer errors. To send an error to Sentry, use the HTTP POST method. Its body contains JSON with various fields. Sentry offers dozens of fields to describe an error with. There are parameters of a machine, an operating system, HTTP request details, a stack trace, and others.</p>

<p>An application does not collect these data on its own but rather uses libraries. They are often called Raven or similar. It’s like a pun – a raven carries news to a sentry.</p>

<p>For Clojure, <a href="https://github.com/getsentry/sentry-clj">Sentry-clj</a> and <a href="https://github.com/exoscale/raven">Exoscale Raven</a> libraries are available. The former relies on the official Java library. Add it to your project:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">io.sentry/sentry-clj</span><span class="w"> </span><span class="s">"0.7.2"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Set the required DSN to the library. DSN is a project address in Sentry. The project combines messages according to the main feature: backend errors will be in one project, front-end errors – in the second one, mobile appl’s – in the third. DSN located in the project settings of the Integration section.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">sentry-clj.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">sentry</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">DSN</span><span class="w"> </span><span class="s">"https://user:pass@sentry.io/project-id"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">sentry/init!</span><span class="w"> </span><span class="n">DSN</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Once the library knows the DSN, send the message using the <code class="language-plaintext highlighter-rouge">send-event</code> function. We’re especially interested in the <code class="language-plaintext highlighter-rouge">:throwable</code> parameter that accepts an exception.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">sentry/send-event</span><span class="w"> </span><span class="p">{</span><span class="no">:throwable</span><span class="w"> </span><span class="n">e</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>In response, we will receive the event number, and a new entry will appear in the project. Suppose we passed <em>e</em>, which is a chain of three exceptions defined above. In the Sentry interface, we will see information about each level. The <code class="language-plaintext highlighter-rouge">:extra</code> field will contain the data of the top-level exception – the map <code class="language-plaintext highlighter-rouge">{:user-id 5}</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Sentry-clj</code> does not transmit the entire context; this is its drawback. We would like to see data from all levels, not just the top one. Otherwise, we will not know what the token was, at what address we tried to access the network, and other details. It is possible to collect data manually and pass it to the <code class="language-plaintext highlighter-rouge">:extra</code> key, but this will increase the code.</p>

<p>The Exoscale Raven library is written in Clojure and therefore takes the language nuances into account. The recent release of the library transmits the complete exception data. Include it in the project and send an exception <code class="language-plaintext highlighter-rouge">e</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">exoscale/raven</span><span class="w"> </span><span class="s">"0.4.13"</span><span class="p">]</span><span class="w"> </span><span class="c1">;; project.clj</span><span class="w">

</span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">raven.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">raven</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">raven/capture!</span><span class="w"> </span><span class="n">DSN</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"clojure.lang.ExceptionInfo"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Get user info error"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"user-id"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"at"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"clojure.lang.AFn"</span><span class="p">,</span><span class="w"> </span><span class="s2">"applyToHelper"</span><span class="p">,</span><span class="w"> </span><span class="s2">"AFn.java"</span><span class="p">,</span><span class="w"> </span><span class="mi">160</span><span class="p">]</span><span class="w">
</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"clojure.lang.ExceptionInfo"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Auth error"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"token"</span><span class="p">:</span><span class="w"> </span><span class="s2">"........."</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"at"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"clojure.lang.AFn"</span><span class="p">,</span><span class="w"> </span><span class="s2">"applyToHelper"</span><span class="p">,</span><span class="w"> </span><span class="s2">"AFn.java"</span><span class="p">,</span><span class="w"> </span><span class="mi">160</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w"> </span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Open the event in Sentry and scroll down. In the <code class="language-plaintext highlighter-rouge">extra</code> section, the <code class="language-plaintext highlighter-rouge">:via</code> key with detailed information will appear. Below is a snippet of it. Each map consists of an exception class, message, and data. The <code class="language-plaintext highlighter-rouge">:at</code> field is a vector of four elements: a class, a method, a filename, and the line where an exception was thrown. Such a report makes it easier to find the cause.</p>

<p>The library builds the structure above with the <code class="language-plaintext highlighter-rouge">Throwable-&gt;map</code> function. It takes an exception and returns a map with the <code class="language-plaintext highlighter-rouge">:via</code>, <code class="language-plaintext highlighter-rouge">:cause</code>, and other keys. Map items are strings and characters, so the result can be easily written in JSON or EDN formats.</p>

<h2 id="sentry-and-ring">Sentry and Ring</h2>

<p>Now that you are familiar with Sentry, let’s write a protective decorator for a Ring application. It catches errors, sends them to Sentry, and returns a neutral response that the request failed. The decorator stays on top of the middleware stack.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">raven.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">r</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-exception</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="p">(</span><span class="nf">report-exception</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
        </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">500</span><span class="w">
         </span><span class="no">:body</span><span class="w"> </span><span class="s">"Internal error"</span><span class="p">}))))</span><span class="w">
</span></code></pre></div></div>

<p>The ninth line carries the main feature of the decorator. This is where we decide what to do with the exception which occurred in the HTTP request. To keep the code simple, let’s move this part into a separate function. In addition to the exception, it accepts the request so we can report its method and URI. The overall function is pretty dense, so let’s review it in chunks.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">report-exception</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">event</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">nil</span><span class="w">
                  </span><span class="p">(</span><span class="nf">r/add-exception!</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
                  </span><span class="p">(</span><span class="nf">r/add-ring-request!</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
                  </span><span class="p">(</span><span class="nf">r/add-extra!</span><span class="w"> </span><span class="p">{</span><span class="no">:some</span><span class="w"> </span><span class="s">"data"</span><span class="p">}))]</span><span class="w">
</span></code></pre></div></div>

<p>We are passing to Sentry not just an exception, but an event (line 2). First, we augment it with the exception, the request data and some extra fields. Functions named <code class="language-plaintext highlighter-rouge">(r/add-...)</code> complement the event with various fields. Raven offers functions to add tags, user and other entities. The second step is to send the event safely:</p>

<pre><code class="language-clojure{firstnumber=6}">    (try
      @(r/capture! DSN event)
      (catch Exception e-sentry
        (log/errorf e-sentry "Sentry error: %s" DSN)
        (log/error e "Request failed")))))
</code></pre>

<p>Note that calling Sentry is also wrapped in <code class="language-plaintext highlighter-rouge">try/catch</code>. Since Sentry is a separate service, it might be unavailable. In this case, both exceptions are written to the log: the original one and the latter we got when calling Sentry. If you forgot how decorators and middleware work, go back to the web-development chapter.</p>

<p>Let’s explain the <code class="language-plaintext highlighter-rouge">@</code> operator before calling <code class="language-plaintext highlighter-rouge">r/capture!</code> (line 7). The function works asynchronously due to the Manifold library. The result is a special <code class="language-plaintext highlighter-rouge">deferred</code> object which acts as the Java Future object. We won’t know about an error until we dereference the former. We’ll encounter the <code class="language-plaintext highlighter-rouge">@</code> operator in following chapters.</p>

<p>In production systems, one doesn’t usually do the dereference of <code class="language-plaintext highlighter-rouge">deferred</code> objects but wraps them in <code class="language-plaintext highlighter-rouge">d/catch</code> and <code class="language-plaintext highlighter-rouge">d/chain</code> macros – asynchronous analogs of <code class="language-plaintext highlighter-rouge">catch</code> and the arrow operator →. Programming in Manifold is a separate topic; we won’t touch on it in this book.</p>

<h2 id="jumping-code">Jumping Code</h2>

<p>Until now, we have regarded an exception as an error signal. Recall the fundamental property of an exception – it interrupts the program flow and bubbles up until it is caught. Sometimes you can use that to move up the stack. If we throw a custom <code class="language-plaintext highlighter-rouge">MyGOTOException</code> and, at the top, put <code class="language-plaintext highlighter-rouge">catch</code> with this class, we’ll get <code class="language-plaintext highlighter-rouge">GOTO</code> behaviour:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nf">do-step-1</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">do-step-2</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nf">condition</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">MyGOTOException</span><span class="p">)))</span><span class="w">
  </span><span class="p">(</span><span class="nf">do-step-3</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">MyGOTOException</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"The third step has been skipped"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">(condition)</code> in the fourth line returns true, we’ll skip the third
step. This is known as the “exception as a control flow mechanism”
technique. The method is controversial; use it carefully. Code becomes obscure
and difficult to maintain.</p>

<p>Still, there are times when you need to interrupt execution. For example, we have found that a user does not have permissions to the resource. Let’s complicate the task: there are several checks, and you need to cancel request if any of them fails. Writing in imperative languages, this is easy to solve. Python code might look like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AccountHandler</span><span class="p">(</span><span class="n">RequestHandler</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">on_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">check_params</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">BadRequest</span><span class="p">(</span><span class="s">"Wrong input data"</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">check_account</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">NotFound</span><span class="p">(</span><span class="s">"No such an account"</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">check_quotas</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">QuotasReached</span><span class="p">(</span><span class="s">"Request rate is limited"</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">JSONResponse</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">get_data_from_db</span><span class="p">())</span>
</code></pre></div></div>

<p>There is no <code class="language-plaintext highlighter-rouge">return</code> statement in Clojure. The result of multiple forms is the result of the last one. We cannot place multiple <code class="language-plaintext highlighter-rouge">when</code> on the same level, one below the other. Even if only one of them returns false, execution will go to the next form.</p>

<p>The <code class="language-plaintext highlighter-rouge">if/else</code> cascade works, but looks unwieldy. The issue is also known as the pyramid of doom. The deeper the nesting, the more problems the developer has. For fun, add another condition to the middle of the Clojure code:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">account-handler</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">check-this</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">check-that</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">check-quotas</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
        </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
         </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">get-data-from-db</span><span class="p">)}</span><span class="w">
        </span><span class="p">(</span><span class="nf">quotas-reached</span><span class="w"> </span><span class="s">"Request rate is limited"</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">not-found</span><span class="w"> </span><span class="s">"No such an account"</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">bad-request</span><span class="w"> </span><span class="s">"Wrong input data"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>You can solve the pyramid problem in different ways, including exceptions. The Ring HTTP Response library offers functions to throw HTTP response exceptions. There is also a decorator which is put on top of the middleware. It catches HTTP-specific exceptions and return the response brought by them. Add the library to your project:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">metosin/ring-http-response</span><span class="w"> </span><span class="s">"0.9.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Let’s rewrite <code class="language-plaintext highlighter-rouge">account-handler</code> using exceptions for control flow:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.util.http-response</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">not-found!</span><span class="w">
                   </span><span class="n">bad-request!</span><span class="w">
                   </span><span class="n">enhance-your-calm!</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">account-handler</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nf">check-params</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">bad-request!</span><span class="w"> </span><span class="s">"Wrong input data"</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nf">check-account</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">not-found!</span><span class="w"> </span><span class="s">"No such an account"</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nf">check-quotas</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">enhance-your-calm!</span><span class="w"> </span><span class="s">"Request rate is limited"</span><span class="p">))</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">get-data-from-db</span><span class="p">)})</span><span class="w">
</span></code></pre></div></div>

<p>Our new code is now similar to its Python version. Some people feel confused when Clojure code gets reduced to imperative style. Never mind. Our goal is to make the code maintainable. Loyalty to the paradigm doesn’t matter here.</p>

<p>Functions of the <code class="language-plaintext highlighter-rouge">ring.util.http-response</code> module are available with and without an exclamation mark. It signals that a function throws an exception. For example, <code class="language-plaintext highlighter-rouge">not-found!</code> will throw the <code class="language-plaintext highlighter-rouge">ex-info</code> which body contains an HTTP response with a 404 status. The ordinary <code class="language-plaintext highlighter-rouge">not-found</code> would only return the negative response without throwing it.</p>

<p>To make the scheme work, let’s add the <code class="language-plaintext highlighter-rouge">wrap-http-response</code> decorator. It catches errors from functions with an exclamation mark, extracts an answer from them, and returns it to a client. Thus, calling <code class="language-plaintext highlighter-rouge">(not-found!)</code> in a handler will lead to the 404 Not Found response but not 500 which denotes a server failure.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.http-response</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-http-response</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">app-naked</span><span class="w">
      </span><span class="n">wrap-params</span><span class="w">
      </span><span class="n">wrap-session</span><span class="w">
      </span><span class="n">wrap-cookies</span><span class="w">
      </span><span class="n">wrap-http-response</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Try to use code jumping only as a last resort. You should have a powerful argument for that, say, shorten the code or quickly solve the problem. If you have to take this step, use the library to refer to examples and documentation.</p>

<h2 id="finally-form-and-context-manager">Finally Form and Context Manager</h2>

<p>Sometimes the code is executed within a resource. It might be a file, socket, or a database transaction. At the beginning of work, one “opens” the resource and – at the end – “closes” it. An open resource is considered busy. When a resource is busy, other clients cannot make full use of it. You can read someone’s open file, but can’t change it.</p>

<p>Close the resource as soon as you no longer need it. But an unhandled exception can prevent this. If the code working with the resource does not catch the exception, the file or port will remain open until the end of the work. To close the resource even in the case of an error, resort to the <code class="language-plaintext highlighter-rouge">finally</code> form.</p>

<p>It is placed last in the <code class="language-plaintext highlighter-rouge">try</code> block. If there is no error, the <code class="language-plaintext highlighter-rouge">finally</code> form is executed after the main code of <code class="language-plaintext highlighter-rouge">try</code>. If an exception arises, <code class="language-plaintext highlighter-rouge">finally</code> will perform between its occurrence and throwing.</p>

<p>Let’s take a look at manual access to a file: write a few bytes to it. <code class="language-plaintext highlighter-rouge">Finally</code> ensures that the file will close even though an exception is thrown in the process.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">java.io</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="n">FileWriter</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">FileWriter</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="s">"test.txt"</span><span class="p">))]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nf">.write</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">.write</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="s">" "</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">.write</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="s">"Clojure"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">finally</span><span class="w">
      </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="n">out</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Today’s languages offer context managers, so you don’t forget to close the file. A manager can be a class, operator, or macro. The manager executes a block of code with side effects. The entry logic is triggered before the block, and the exit logic – after it. The exit logic will take control even if the block has thrown an exception.
The platform will hold it, execute the exit code, and throw it again.</p>

<p>The Python manager is remarkably elegant. It is the <code class="language-plaintext highlighter-rouge">with</code> statement that expects an object. The object must have the <code class="language-plaintext highlighter-rouge">__enter__</code> and <code class="language-plaintext highlighter-rouge">__exit__</code> methods that will work when entering and exiting the block of code. You can use the <code class="language-plaintext highlighter-rouge">with</code> statement for files, database transactions, and test fixtures. Here’s an example with a file:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"/path/to/file.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">"test"</span><span class="p">)</span>
</code></pre></div></div>

<p>Let’s write a similar manager for Clojure. It is a macro that takes a symbol and a file path. Within a macro, a file is bound to a symbol we specified. <code class="language-plaintext highlighter-rouge">Finally</code> ensures the file will close when exiting the block.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-file-writer</span><span class="w">
  </span><span class="p">[[</span><span class="n">bind</span><span class="w"> </span><span class="nb">path</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="o">~</span><span class="n">bind</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">FileWriter</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="o">~</span><span class="nb">path</span><span class="p">))]</span><span class="w">
     </span><span class="p">(</span><span class="nf">try</span><span class="w">
       </span><span class="o">~@</span><span class="n">body</span><span class="w">
       </span><span class="p">(</span><span class="nf">finally</span><span class="w">
         </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="o">~</span><span class="n">bind</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Execute the code and check the <code class="language-plaintext highlighter-rouge">test.txt</code> file. It must be with the text and also closed. To ensure it is, delete it using your file manager.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-file-writer</span><span class="w"> </span><span class="p">[</span><span class="n">out</span><span class="w"> </span><span class="s">"test.txt"</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">.write</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="s">"Hello macro!"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Context managers’ name begins with the prefix <code class="language-plaintext highlighter-rouge">with-</code>. So they emphasize that the code works within the resource.</p>

<p>Clojure provides the <code class="language-plaintext highlighter-rouge">with-open</code> macro. It is an improved version of the code we have written. Unlike our example, <code class="language-plaintext highlighter-rouge">with-open</code> works with a more abstract source, including a file. Exiting the macro, even with an error, closes the resource.</p>

<p>It is important to remember that the code from <code class="language-plaintext highlighter-rouge">finally</code> will not be included in the result. The <code class="language-plaintext highlighter-rouge">try</code> expression is designed so that if an error occurs, the result comes from one of the <code class="language-plaintext highlighter-rouge">catch</code> branches. The <code class="language-plaintext highlighter-rouge">finally</code> branch serves only for side effects. This is best seen in the example with printing:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
       </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"catch"</span><span class="p">)</span><span class="w">
       </span><span class="no">:result-catch</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">finally</span><span class="w">
       </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"finally"</span><span class="p">)</span><span class="w">
       </span><span class="no">:result-finally</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>narrow
Running this form in REPL will print:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">catch</span><span class="w">
</span><span class="n">finally</span><span class="w">
</span><span class="no">:result-catch</span><span class="w">
</span></code></pre></div></div>

<p>This order means that Clojure will first execute the code from <code class="language-plaintext highlighter-rouge">catch</code> (print “catch”) and remember the result (keyword <code class="language-plaintext highlighter-rouge">:result-catch</code>). Then it will execute <code class="language-plaintext highlighter-rouge">finally</code> (print «finally») and discard the result (keyword <code class="language-plaintext highlighter-rouge">:result-finally</code>). The <code class="language-plaintext highlighter-rouge">:result-catch</code> keyword will be the result of the whole <code class="language-plaintext highlighter-rouge">try</code>.</p>

<p>For comparison, let’s give an unfortunate example from practice. It was necessary to perform some action and, regardless of the outcome, return a positive result. The programmer wrapped the code into the <code class="language-plaintext highlighter-rouge">try/catch</code> block and logged the exception. However, he put the result ino the <code class="language-plaintext highlighter-rouge">finally</code> branch, which caused strange behavior: <code class="language-plaintext highlighter-rouge">nil</code> was returned instead of a map.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nf">do-something</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nf">log/error</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"some error"</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">finally</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Apparently, the programmer decided that <code class="language-plaintext highlighter-rouge">finally</code> is literally the final result of <code class="language-plaintext highlighter-rouge">try</code>. This is not entirely true: <code class="language-plaintext highlighter-rouge">finally</code> will actually work last, but <code class="language-plaintext highlighter-rouge">try</code> will return either the result of the main code or one of the <code class="language-plaintext highlighter-rouge">catch</code> branches.</p>

<p>There is no point in using <code class="language-plaintext highlighter-rouge">finally</code> when working with collections or pure functions. Use it only when you need to free a busy resource.</p>

<h2 id="exceptions-and-predicates">Exceptions and Predicates</h2>

<p>The <code class="language-plaintext highlighter-rouge">try/catch</code> system relies on classes and inheritance. If you need to catch a particular exception, write a class and throw an instance of it. A typical Java or Python project carries a module with custom exceptions. Usually, there is a <code class="language-plaintext highlighter-rouge">ProjectException</code> class, and others like <code class="language-plaintext highlighter-rouge">UserNotFound</code> or <code class="language-plaintext highlighter-rouge">AccessDenied</code> inherited from it.</p>

<p>In the chapter on Spec, we’ve said that predicates were more powerful than types. The same is true for exceptions: if you can catch them with a function, you don’t need a class. The <a href="https://github.com/scgilardi/slingshot">Slingshot</a> library offers a predicate approach. There are improved versions of <code class="language-plaintext highlighter-rouge">try</code>, <code class="language-plaintext highlighter-rouge">catch</code> and <code class="language-plaintext highlighter-rouge">throw</code> macros in Slingshot.</p>

<p>Those who are not familiar with Clojure will be surprised: you can change even such fundamental things as catching exceptions with the help of macros in it. In other languages, such changes have been waiting for years. In Clojure, you just add a library.</p>

<p>Slingshot contains the <code class="language-plaintext highlighter-rouge">throw+</code> and <code class="language-plaintext highlighter-rouge">try+</code> macros. They are compatible with regular <code class="language-plaintext highlighter-rouge">throw</code> and <code class="language-plaintext highlighter-rouge">try</code>; if you replace the usual forms with the plus versions, nothing changes. However, these new forms are capable of more.</p>

<p>The <code class="language-plaintext highlighter-rouge">throw+</code> macro accepts any object, not just an exception. A map works best since it combines multiple values. The code below will throw <code class="language-plaintext highlighter-rouge">ex-info</code> with the given map:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">slingshot.slingshot</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">try+</span><span class="w"> </span><span class="n">throw+</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">throw+</span><span class="w"> </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">:action</span><span class="w"> </span><span class="no">:create</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Throw+</code> takes an object, a cause exception, a message template, and substitution parameters. Below, here is a code snippet that takes all the arguments into account. Note: the order of the arguments is different from <code class="language-plaintext highlighter-rouge">ex-info</code>. As Slingshot relies on data, it accepts the object in the first place and a message in the last.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">path</span><span class="w"> </span><span class="s">"/var/lib/file.txt"</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="nb">path</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw+</span><span class="w"> </span><span class="p">{</span><span class="no">:path</span><span class="w"> </span><span class="nb">path</span><span class="p">}</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"File error: %s"</span><span class="w"> </span><span class="nb">path</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">catch</code> form inside <code class="language-plaintext highlighter-rouge">try+</code> catches exceptions not only with classes. Slingshot offers selectors and predicates for that. Here, a selector is a vector: its odd element is a map key, and even one is a value. The selector checks if keys and values are included in the context. If so, control passes to the branch with that selector.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try+</span><span class="w">
 </span><span class="p">(</span><span class="nf">throw+</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">::user-error</span><span class="w">
          </span><span class="no">:user</span><span class="w"> </span><span class="mi">5</span><span class="w">
          </span><span class="no">:action</span><span class="w"> </span><span class="no">:update</span><span class="w">
          </span><span class="no">:data</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}})</span><span class="w">
 </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="p">[</span><span class="no">:type</span><span class="w"> </span><span class="no">::user-error</span><span class="p">]</span><span class="w"> </span><span class="n">e</span><span class="w">
   </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="n">e</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>When the map is thrown, usually we add the <code class="language-plaintext highlighter-rouge">:type</code> field to the map (line 2). It specifies a key with the current namespace, in our case – <code class="language-plaintext highlighter-rouge">::user-error</code>. When catching exceptions in another module, the selector looks like this: <code class="language-plaintext highlighter-rouge">[:type :book.exceptions/user-error]</code>. The namespace guarantees that we will not intercept <code class="language-plaintext highlighter-rouge">:user-error</code> of someone else’s library.</p>

<p>The example above should print a thrown map. The variable <code class="language-plaintext highlighter-rouge">e</code>, which is inside <code class="language-plaintext highlighter-rouge">catch</code>, does not link to the exception, but the data we passed to <code class="language-plaintext highlighter-rouge">throw+</code>.</p>

<p>Instead of a selector, we can use a predicate, a function of one argument. If the error class is <code class="language-plaintext highlighter-rouge">ExceptionInfo</code>, the predicate will get a data map; otherwise, an exception object. The function should take into account an argument type. When the predicate returns true, control will pass to its <code class="language-plaintext highlighter-rouge">catch</code> branch.</p>

<p>Use predicates when you need fine tuned interception conditions. Let’s see how to upload a file to Amazon S3. In special cases, Java SDK throws an exception <em>after</em> the file has been uploaded to S3 (for example, if the checksums do not match). We have to delete the unsuccessful uploaded file so as not to waste resources.</p>

<p>Unfortunately, there is neither the <code class="language-plaintext highlighter-rouge">ChecksumError</code> class nor an equivalent in SDK. Instead, we’ll receive a regular <code class="language-plaintext highlighter-rouge">AmazonS3Exception</code> with a long text. To highlight our case, let’s compare the message with the template. Let’s make a check function first:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">aws-checksum-error?</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">instance?</span><span class="w"> </span><span class="n">AmazonS3Exception</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">some?</span><span class="w">
        </span><span class="p">(</span><span class="nb">re-find</span><span class="w">
         </span><span class="o">#</span><span class="s">"(?i)The Content-Md5 you specified did not match"</span><span class="w">
         </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Now we put it in <code class="language-plaintext highlighter-rouge">try+</code> to catch the checksum mismatch case:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">try+</span><span class="w">
  </span><span class="p">(</span><span class="nf">s3/put-object</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">aws-checksum-error?</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nf">s3/delete-object</span><span class="w"> </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><a href="https://github.com/dakrone/clj-http">Clj-http</a>, a popular HTTP client for Clojure, uses Slingshot. In case of an error, it throws a response with <code class="language-plaintext highlighter-rouge">throw+</code>. If we wrap the request in <code class="language-plaintext highlighter-rouge">try+</code>, we’ll get a more detailed analysis of errors. For example, we can get separate branches for status 403, 500, and for the general negative response.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clj-http.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">client</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">try+</span><span class="w">
 </span><span class="p">(</span><span class="nf">client/get</span><span class="w"> </span><span class="s">"http://example.com/test"</span><span class="p">)</span><span class="w">
 </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="p">[</span><span class="no">:status</span><span class="w"> </span><span class="mi">403</span><span class="p">]</span><span class="w"> </span><span class="n">e</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Access denied"</span><span class="p">))</span><span class="w">
 </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="p">[</span><span class="no">:status</span><span class="w"> </span><span class="mi">500</span><span class="p">]</span><span class="w"> </span><span class="n">e</span><span class="w">
   </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"The service is unavailable"</span><span class="p">))</span><span class="w">
 </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="p">[</span><span class="no">:type</span><span class="w"> </span><span class="no">:client/unexceptional-status</span><span class="p">]</span><span class="w"> </span><span class="n">e</span><span class="w">
   </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Negative response"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Slingshot relies on data, not classes, as Clojure encourages. Benefits of this approach are not always apparent to newbies. It is helpful to understand the usual <code class="language-plaintext highlighter-rouge">try/catch</code> method first. Include Slingshot only if it makes sense to do so.</p>

<p>Slingshot is not the only example of exceptions for Clojure. Pay attention to <a href="https://github.com/exoscale/ex">Ex</a> – the analog developed at Exoscale. The library takes into account the semantics of the keys (a failure, conflict, etc), and their inheritance, supports Manifold, and much more.</p>

<h2 id="techniques-and-functions">Techniques and Functions</h2>

<p>Let’s look at several techniques for exceptions. They are simple, so you shouldn’t put them in a separate library. They are usually copied from a project to a project with some changes.</p>

<p><strong>Safe function call.</strong> Lua language has no <code class="language-plaintext highlighter-rouge">try</code> and <code class="language-plaintext highlighter-rouge">catch</code> statements. To make the call safe from error, use the <a href="https://www.lua.org/pil/8.4.html"><code class="language-plaintext highlighter-rouge">pcall</code></a> operator. It is short for a protected call. Sometimes this technique is useful in Clojure, too.</p>

<p><code class="language-plaintext highlighter-rouge">Pcall</code> takes a function and arguments and returns a pair of values. The first of them signifies a successful execution. If it is true, the second value will be the result of the computation, otherwise – an error instance. Clojure version:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">pcall</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">[</span><span class="n">true</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">[</span><span class="n">false</span><span class="w"> </span><span class="n">e</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>To make the result more concise, process it with <code class="language-plaintext highlighter-rouge">let</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">ok?</span><span class="w"> </span><span class="n">result-error</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">pcall</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">ok?</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"The result is "</span><span class="w"> </span><span class="n">result-error</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Failure"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>A different semantics is popular in JavaScript: callback functions take the <code class="language-plaintext highlighter-rouge">error</code> and <code class="language-plaintext highlighter-rouge">result</code> arguments. The <code class="language-plaintext highlighter-rouge">pcall-js</code> function is a modified version of <code class="language-plaintext highlighter-rouge">pcall</code> that returns an 〈 error, result 〉 pair. When the first item if the pair is not <code class="language-plaintext highlighter-rouge">nil</code>, it means the call failed.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">pcall-js</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">[</span><span class="n">nil</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="n">nil</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>The split looks different:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">e</span><span class="w"> </span><span class="n">user</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">pcall-js</span><span class="w"> </span><span class="n">get-user-by-id</span><span class="w"> </span><span class="mi">7</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">user</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><strong>Retries with delay.</strong> Sometimes a third party service is unstable, and you have to access it multiple times. Let’s wrap the retrying in a function so as not to copy the code. <code class="language-plaintext highlighter-rouge">Call-retry</code> tries to call the target function in multiple passes. The result will be the first successful calling. If an error occurs but the number of attempts haven’t completed, the function waits and retries the call. When the number of attempts is over, the function will throw an exception. Internally, we use the <code class="language-plaintext highlighter-rouge">pcall</code> function to prevent an exception from raising.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">call-retry</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">attempt</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">ok?</span><span class="w"> </span><span class="n">res</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">pcall</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="k">cond</span><span class="w">
        </span><span class="n">ok?</span><span class="w"> </span><span class="n">res</span><span class="w">

        </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">attempt</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">attempt</span><span class="w"> </span><span class="mi">1000</span><span class="p">))</span><span class="w">
            </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">n</span><span class="p">)))</span><span class="w">

        </span><span class="no">:else</span><span class="w"> </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="n">res</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Here is how we fetch a user by id from a remote server in three attempts:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">call-retry</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">get-user-by-id</span><span class="w"> </span><span class="n">user-id</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>That is a naive version; you can improve it by changing the waiting strategy and adding logs. However, the principle remains the same.</p>

<p>By the way, these functions are compatible with each other. Let’s build a combination of <code class="language-plaintext highlighter-rouge">pcall</code> and <code class="language-plaintext highlighter-rouge">call-retry</code>. Even if the service is not available and we have knocked on it many times, we will get a pair <code class="language-plaintext highlighter-rouge">[ok? result]</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pcall</span><span class="w"> </span><span class="n">call-retry</span><span class="w"> </span><span class="n">get-user-by-id</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>Exceptions in a loop.</strong> The <code class="language-plaintext highlighter-rouge">loop</code> form is designed in a special way: its <code class="language-plaintext highlighter-rouge">recur</code> part cannot be inside <code class="language-plaintext highlighter-rouge">try</code>. Let’s say we want to express retry logic without <code class="language-plaintext highlighter-rouge">pcall</code>. Here is a snippet of code:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">call-retry</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">attempt</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="n">...</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">n</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>The compiler will not accept the code with the message: “Can only recur from tail position”. To fix the error, you need to take out <code class="language-plaintext highlighter-rouge">recur</code> from <code class="language-plaintext highlighter-rouge">try</code>. The easiest way to do this is with <code class="language-plaintext highlighter-rouge">pcall</code>, as in the example with <code class="language-plaintext highlighter-rouge">call-retry</code>.</p>

<p><strong>Throw in place.</strong> By now, we have thrown exceptions using <code class="language-plaintext highlighter-rouge">ex-info</code> and <code class="language-plaintext highlighter-rouge">throw</code>. The former builds an exception, the latter throws it. Let’s combine them in the <code class="language-plaintext highlighter-rouge">error!</code> function and simplify the arguments:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">error!</span><span class="w"> </span><span class="p">[</span><span class="n">message</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="w"> </span><span class="n">e</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">{})</span><span class="w"> </span><span class="n">e</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The function needs only one parameter – a string – to throw an exception, and the others are optional:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">error!</span><span class="w"> </span><span class="s">"Error"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">error!</span><span class="w"> </span><span class="s">"Error"</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">::error</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">error!</span><span class="w"> </span><span class="s">"Error"</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">::error</span><span class="p">}</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>Messages with parameters.</strong> Sometimes a detailed string is enough for an error. In this case, <code class="language-plaintext highlighter-rouge">ex-info</code> is redundant because it requires a map as an argument. Now, we’ll write a function that throws <code class="language-plaintext highlighter-rouge">Exception</code> with a formatted message. It takes a template and substitution values.
The <code class="language-plaintext highlighter-rouge">f</code> added to the function name means formatting.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">errorf!</span><span class="w"> </span><span class="p">[</span><span class="n">template</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">message</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="n">message</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">errorf!</span><span class="w"> </span><span class="s">"Error, user: %s, action: %s"</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="no">:delete</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>Safe macro.</strong> Catching of exceptions works in macros as well. Code with macros is usually shorter and more expressive than a regular function (of course, it doesn’t mean you should misuse them). The following example shows how to execute code in safe mode, ignoring an exception:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-safe</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nf">try</span><span class="w">
     </span><span class="o">~@</span><span class="n">body</span><span class="w">
     </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="o">#</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>An empty <code class="language-plaintext highlighter-rouge">catch</code> form will return <code class="language-plaintext highlighter-rouge">nil</code>. We’ll get it if an error occurs:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-safe</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p>In practice, <code class="language-plaintext highlighter-rouge">nil</code> does not always mean an error, so the <code class="language-plaintext highlighter-rouge">:error</code> or <code class="language-plaintext highlighter-rouge">:invalid</code> keys are returned. That is how the Spec library works, which we discussed in the last chapter. Sometimes, we add logging or a Sentry call in the <code class="language-plaintext highlighter-rouge">catch</code> block. Only suppress the error if the result is unimportant at all.</p>

<h2 id="summary">Summary</h2>

<p>Exceptions in Clojure are similar to Java’s. The <code class="language-plaintext highlighter-rouge">try</code> and <code class="language-plaintext highlighter-rouge">catch</code> forms are similar to Java statements of the same name. Interception works on classes and inheritance. The higher the class in the hierarchy, the more error cases it covers.</p>

<p>The <code class="language-plaintext highlighter-rouge">ExceptionInfo</code> class is specifically designed for Clojure. Its <code class="language-plaintext highlighter-rouge">data</code> field takes any map. The exception type is determined by the <code class="language-plaintext highlighter-rouge">:type</code> field of the map which usually carries a full-qualified keyword. The <code class="language-plaintext highlighter-rouge">ex-info</code> function is an exception constructor.</p>

<p>An error may have a <code class="language-plaintext highlighter-rouge">cause</code>. If you catch an exception but don’t know what to do with it, throw a new one with a context and a link to the initial exception. That is how exception chains are built. Data from the entire chain is taken into account, not just from the top link, to investigate the issue.</p>

<p>Special code on top of an application decides what to do with an exception. The best choice would be to pass it to the error collection system. Sentry or its analogs can be such a system. Make sure the Sentry client passes complete information about an exception, not just the stack trace.</p>

<p>If an error occurs, we usually close the resource in the <code class="language-plaintext highlighter-rouge">finally</code> branch – to prevent it from staying busy. A context manager makes it easy to access the resource. Usually, it is a <code class="language-plaintext highlighter-rouge">with-&lt;something&gt;</code> macro wrapping a block of code in <code class="language-plaintext highlighter-rouge">try/finally</code>. Clojure offers a <code class="language-plaintext highlighter-rouge">with-open</code> macro working with various data sources.</p>

<p>Sometimes we can use an exception to jump to a particular place in the code. That is a controversial approach, and you must have good reasons for using it. If jumping code is vital, use a particular library but not a handmade solution.</p>

<p>Slingshot offers the improved macros <code class="language-plaintext highlighter-rouge">try+</code> and <code class="language-plaintext highlighter-rouge">throw+</code>. With them, you catch errors with selectors and predicates, not classes. Instead of exception objects, Slingshot uses plain maps.</p>

<p>Some functions simplify the exception control. Please take note of them to shorten your code.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/en/clj-book-exceptions/">
    <input required name="captcha" type="hidden" value="9 &#215; 6">

    <div class="block">
        <span class="comment-form-label"><small>9 &#215; 6 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
