<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>I will never let monads be in a Clojure project</title>
  <meta name="description" content="Sounds a bit aggressive, doesn’t it? Well, let me explain. Monads are finewhile you’re playing with them in Haskell. But don’t bring them to Clojure. Theyare...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/en/no-monads/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">I will never let monads be in a Clojure project</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2018-11-29T00:00:00+00:00">
        Nov 29, 2018
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/monads/" rel="tag">monads</a>, <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/haskell/" rel="tag">haskell</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>Sounds a bit aggressive, doesn’t it? Well, let me explain. Monads are fine
while you’re playing with them in Haskell. But don’t bring them to Clojure. They
are completely foreign beings to Clojure ecosystem. Besides the technical
issues, there is a problem with sharing monads across the team. Read the
following, and I hope you’ll get into what I’m worried about.</em></p>

<p><strong>Nobody uses monads in libraries</strong></p>

<p>So, why you’d better not to ship monads into Clojure code? First, they are used
quite rarely in production. Let me open my recent project which is just another
two-in-one boring stuff. An HTTP server plus a single page application. I’ve got
plenty of dependencies here in my <code class="language-plaintext highlighter-rouge">project.clj</code> file. There are about 40 of them
just to cover basic stuff. Database, oAuth, UI… I don’t want to dump the whole
list here. Check <a href="https://gist.github.com/igrishaev/a0de14d135924434ae3c243e3d111780">this gist</a> for the reference.</p>

<p>The full tree of dependencies expands into multiple screens. Their children
libraries, and their children, and so forth. There are about 100 packages in
total.</p>

<p>Now guess how many of them use monads? You know that, it’s zero. None of the
libraries needs monads to bear their functionality. I’d like to stress
that. Some of them provide a really tough stuff: database access, template
system, HTTP communication, etc. Yet they work without monadic operations. Why?
Just because Clojure is powerful enough. It brings everything you need for
convenient development. The authors of those libraries didn’t use monads not
because they are not aware of them but because they just don’t need them.</p>

<p>I don’t believe you are experiencing a trouble which is much more serious then
something mentioned above and thus craves for monads. There is definitely a
plain way for doing this.</p>

<p><strong>Railway Programming is a toy</strong></p>

<p>Moving on, most of the people who are using monads told me, they are fascinated
with the idea of <a href="https://fsharpforfunandprofit.com/rop/">Railway Programming</a>. I believe you are aware of this site
and their mental model in general. Several years ago I fell into it completely
thinking I’ve found the ultimate solution. It didn’t work, I regret to say.</p>

<p>The problem with it is, it’s just a mock. A toy model which looks nice on the
screen. At first glance, it reminds a holy grail that you’ve been looking for
years and got it finally. So simple: just cut your code into a set of same
looking chunks and then build a pipeline.</p>

<p><img src="/assets/static/aws/1059232/49207523-36026180-f3c6-11e8-92ae-cbd6a011f728.png" title="rop-pic" /></p>

<p><em>I’ve been praying for that picture for months.</em></p>

<p>Suddenly, it becomes clumsy and tough once you try to fit it into a real
project. You’ve got to write more code. As I mentioned, none of the libraries
really use it. All the functions should be wrapped to return monadic values
rather than plain ones.</p>

<p>The standard <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">cond</code>, <code class="language-plaintext highlighter-rouge">when</code>, and dozens of useful core functions don’t
work with monadic values. You’ll lose a huge stuff for no reason. Instead,
you’ll have to implement <em>monadic</em> versions of <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">if</code>, etc. Then test them,
write documentation. Why? It’s clear to me, the more code you’ve brought on
board, the less the project is maintainable.</p>

<p><strong>We are already there</strong></p>

<p>The Railway Programming proposes a happy path where each step leads either to
the next happy step or to the negative outcome. This is fine, but we’ve already
got the same stuff, indeed. These are exceptions. They act the same way.</p>

<p>Take a look at the standard <a href="https://fsharpforfunandprofit.com/posts/recipe-part2/">Railway example</a>. They query the
database, send email, write a file, etc. Surely, each of these steps is
dangerous, whoever argues. But I don’t see a reason for why not to wrap the
whole code with a simple try-catch statement? It acts exactly the same. For
example, when an error occurs on the third step which is sending email, the
entire pipeline terminates so we end up in the catch clause.</p>

<p>Here, we’ve got an exception instance with most of the data we need. What to do
next is up to us. We can log the error and fail silently. Or rise another
exception with a high-detailed message plus the source exception attached for a
cause. That’s is sufficient for maintaining the business logic.</p>

<p>The main reason people turn to monads is, they’ve got lack of knowledge of using
exceptions. There is no common rule for handling exceptions and thus it might be
tricky sometimes. Some of them must be caught right here, others should flow
up. For example, when iterating through the list, I wouldn’t like to stop the
whole program once failing on a certain item. I just log the detailed message
and go on. Or if I found a user doesn’t have enough permission for that
endpoint, I throw an exception so it called by the top-level middleware. It does
know how to turn in into a proper HTTP response.</p>

<p>I know this is just an extended version of the GOTO operator. It looks
completely imperative but I don’t care. This is a business problem, not a
Haskell tutorial.</p>

<p><strong>Monads are built upon strict types</strong></p>

<p>In fact, I don’t see any reason for using monads with a language of dynamic
typing system. Don’t see at all. In Clojure, we’ve got nice collections for
storing either data or a <code class="language-plaintext highlighter-rouge">nil</code> value. Since <code class="language-plaintext highlighter-rouge">nil</code> is treated as an empty
collection and we mostly process collections in Clojure, there is no reason to
worry about whether it was a map or just <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>When I doubt if a value I’ve got might be <code class="language-plaintext highlighter-rouge">nil</code>, I just wrap the top-level form
with <code class="language-plaintext highlighter-rouge">(when value ...)</code> which prevents me from dealing with <code class="language-plaintext highlighter-rouge">nil</code>. In addition,
it returns <code class="language-plaintext highlighter-rouge">nil</code> and thus is compatible with threading macros as well.</p>

<p>The very need for monads comes when you’ve got an honest typing system. An
honest system is such a one that doesn’t allow to pass empty values (nil, NULL,
None, etc) for an arbitrary object like one does in Java. When you are out of
this trick, you’ve got to compose a complex type with a bunch of special
operations upon it.</p>

<p>A good example might a language with a strict typing system and algebraic types,
say Scala. They haven’t got a <code class="language-plaintext highlighter-rouge">Nil</code> type at all. You cannot just pass an dummy
value instead of a <code class="language-plaintext highlighter-rouge">DateTime</code> parameter. Instead, there is an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> type
which is a composition of either an instance of <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code> class or a <code class="language-plaintext highlighter-rouge">None</code>
value. This is only because of their type system’s limitations.</p>

<p>But this is not our case! In Clojure, we are not suffering from such
things. It’s much easier to check the value for its completeness with the
standard <code class="language-plaintext highlighter-rouge">if</code> form rather than wrapping it into a monad. You overcomplicate
things, and that’s the problem.</p>

<p>By the way, talking about complexity. In Clojure, we don’t like complex things,
we’d rather take simple ones. The entire language is about simplicity, you
know. You either have got some data represented with a map or <code class="language-plaintext highlighter-rouge">nil</code>. That is
simple. That is something you can always check within REPL out from your
editor. Instead, a monad is a wrapper what obscures the original value and
forces me to recover it with special macro. That’s too complex.</p>

<p><strong>Leave other languages alone</strong></p>

<p>That situation with monads in Clojure reminds me something from Python. Since it
has <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">reduce</code> functions as well as flexible syntax, one believes it’s
possible to program with Python in a functional way. The Internet is full of
tutorials about higher order functions, functors and even monads. My shame, I
used to write my own “functional” library for Python with all that stuff. It was
an mess stiched from chunks of Scala and Clojure. I was really proud of it being
sure this is really a great stuff. So do other authors, I suppose.</p>

<p>One minor detail is, nobody uses those “functional” libraries. I’ve seen a lot
of Python code before switching to Clojure. Let me assure you, a functional way
in Python is a myth. There is no a chance to deliver a Django project in
functional terms. Put <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">reduce</code> here and there, it won’t affect the
whole picture. After all, the very language is completely imperative so you end
up with changing objects through their lifetime. This is not because Python
sucks, no. I love it. It’s just a matter of different design.</p>

<p>Clojure also has got other design. It doesn’t know anything about
monads. Talking in a more broad way, the idea of fetching foreign ideas from
other languages doesn’t work. If a language is entirely imperative, functional
way won’t apply here. When it has got dynamic types, the idea of adding strict
type checks manually neither applies. Otherwise, you get something that we call
Chimera. A strange mix of foreign elements that do not match each other. This is
subject to break.</p>

<p><strong>What would you do with the team?</strong></p>

<p>One other note is, think for a while about not yourself but the whole
team. Look, not everyone is as smart as you. We know you’ve been drilling
Haskell by nights but know what? Nobody cares. You’ve been hired to solve
business problems, not to tickle your arrogance.</p>

<p>With monads, we’ve got to teach the team first. Some of my friends are really
great developers yet they know nothing about monads. I don’t see any reason to
violate their brains. For what? To force them to know monads? They are already
capable of solving any possible business problem. Live them alone.</p>

<p>I’m not against one-man-band use cases when you are the only one person
responsible for everything. Use monads, monoids, do what you want. Yet it’s
still an amateur way. You won’t go far as a single developer.</p>

<p><strong>Wrapping up</strong></p>

<p>Using monads is fine when you’ve got a language which is monad-friendly. They
should be a part of the language’s design. Haskell or Scala would be a great
choice for that.</p>

<p>Railway programming looks fine right until you put that gizmo into a real
project. Dull exceptions would be enough.</p>

<p>Don’t borrow too much from other languages. What has been in Haskell should be
left behind. It’s Clojure time! Shifting your mind between paradigms is really
fun. But not sticking around the only “truthful” way!</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментарии</center>

<div id="comments">
  
    <div id="comment-4217312260" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Val Waeselynck,
            29th Nov 2018,
            <a href="#comment-4217312260">link</a>
            
          </em>
        </small>
      </p>
      <div><p>I would argue projects like Manifold (<a href="https://github.com/ztellman/manifold)" rel="nofollow noopener" title="https://github.com/ztellman/manifold)">https://github.com/ztellman...</a> and Promesa (<a href="https://funcool.github.io/promesa/latest/)" rel="nofollow noopener" title="https://funcool.github.io/promesa/latest/)">https://funcool.github.io/p...</a> totally have their place in the Clojure ecosystem (I can tell from experience that not all but many projects would be better off using that instead of / in addition to core.async). These projects expose monadic abstractions, for problems than raw Exceptions could not have addressed.</p>
</div>
    </div>
  
    <div id="comment-4217328408" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            You Are Here,
            29th Nov 2018,
            <a href="#comment-4217328408">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Completely agree about monads, but rop can be done without them using exception instances as failure values. I've created small lib using that approach:<br /><a href="https://github.com/dawcs/flow" rel="nofollow noopener" title="https://github.com/dawcs/flow">https://github.com/dawcs/flow</a></p>
</div>
    </div>
  
    <div id="comment-4223692054" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            anonymous,
            3rd Dec 2018,
            <a href="#comment-4223692054">link</a>
            
          </em>
        </small>
      </p>
      <div><p>&gt;Monads are fine<br />until you play with them in Haskell.<br />until -&gt; while?</p>
</div>
    </div>
  
    <div id="comment-4566076463" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Alexis Rodriguez,
            5th Aug 2019,
            <a href="#comment-4566076463">link</a>
            
          </em>
        </small>
      </p>
      <div><p>You can make DSLs in Lisps and verify at macro-expansion time that a lot of static properties hold just like with Monads, but more flexible but yeah there is no mechanism to tell you this and this function is pure and stuff.</p>
</div>
    </div>
  
    <div id="comment-4566251922" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            5th Aug 2019,
            <a href="#comment-4566251922">link</a>
            , <a href="#comment-4223692054">parent</a>
          </em>
        </small>
      </p>
      <div><p>fixed, thank you</p>
</div>
    </div>
  
    <div id="comment-4566253688" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            5th Aug 2019,
            <a href="#comment-4566253688">link</a>
            , <a href="#comment-4566076463">parent</a>
          </em>
        </small>
      </p>
      <div><p>Well, the only library that I'm OK with as Manifold what brings chaining macros. That really works, although Manifold is about async stuff, not monads. I can stand with a single library but adding more monadic stuff would be over me.</p>
</div>
    </div>
  
    <div id="comment-4618679019" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Pierre Thierry,
            17th Sep 2019,
            <a href="#comment-4618679019">link</a>
            
          </em>
        </small>
      </p>
      <div><p>I don't get it. You seem to say that we already have Railway Programming with exceptions and they are great and people don't know them enough, but you close with saying nobody should put Railway Programming in a real project.</p>
<p>Do you mean that nobody should use exceptions in production?</p>
</div>
    </div>
  
    <div id="comment-5574981207" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ed,
            18th Oct 2021,
            <a href="#comment-5574981207">link</a>
            
          </em>
        </small>
      </p>
      <div><p>"The main reason people turn to monads is, they’ve got lack of knowledge of using exceptions"<br />Most people who use monads are people who have used exceptions and don't like them, and the reason people don't like exceptions is because as you said "I know this is just an extended version of the GOTO operator". yes, and GOTO sucks for reasons that you probably know, but then you say "It looks completely imperative but I don’t care. This is a business problem, not a Haskell tutorial." What does that even mean? So you're OK with with unclear code and execution paths?</p>
<p>The main problem people have with exceptions is that it makes your code unpredictable.<br />Sure, it's easy to wrap everything in a try/catch and do the error handling at the bottom. You probably save some time, but that will lead to a codebase where the norm isn't to handle errors on the spot, but to simple defer their handling for later.</p>
<p>Programmers like exceptions because it allows them to segregate their error-handling code from their happy-path code, but the problem is that error handling code shouldn't be treated as "exceptions". Errors happen all the time and good software should handle as many of them as possible. Exceptions train programmers into thinking that error-handling is some kind of afterthought, but things like monads force programmers to handle errors on the spot.</p>
<p>Another example is golang. It doesn't have exceptions. Although it doesn't force programmers to do this, the convention is to return an error as the last return value and force users to write <code>if err != nil</code> every time because that's how good software is written.</p>
</div>
    </div>
  
    <div id="comment-5736980129" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            You Are Here,
            15th Feb 2022,
            <a href="#comment-5736980129">link</a>
            
          </em>
        </small>
      </p>
      <div><p>nice reading especially in context of new Pact library)</p>
</div>
    </div>
  
    <div id="comment-1665597814457" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            rebcabin,
            12th Oct 2022,
            <a href="#comment-1665597814457">link</a>
            
          </em>
        </small>
      </p>
      <div><p>in clojure.test.check.generators, tgen/let is essential. It’s monadic bind.</p>
</div>
    </div>
  
</div>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/en/no-monads/">
    <input required name="captcha" type="hidden" value="4 &#215; 8">

    <div class="block">
        <span class="comment-form-label"><small>4 &#215; 8 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
