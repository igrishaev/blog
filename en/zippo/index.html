<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Zippo: additions to the standard clojure.zip package.</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/en/zippo/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Zippo: additions to the standard clojure.zip package.</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2022-09-02T00:00:00+00:00">
        Sep 2, 2022
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/zippers/" rel="tag">zippers</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<p>The <code class="language-plaintext highlighter-rouge">clojure.zip</code> package is a masterpiece yet misses some utility
functions. For example, finding locations, bulk updates, lookups, breadth-first
traversing and so on. <a href="https://github.com/igrishaev/zippo">Zippo</a>, the library I’m introducing in this post,
brings some bits of missing functionality.</p>

<h3 id="installation">Installation</h3>

<p>Lein:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">com.github.igrishaev/zippo</span><span class="w"> </span><span class="s">"0.1.0"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Deps.edn</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">com.github.igrishaev/zippo</span><span class="w"> </span><span class="p">{</span><span class="no">:mvn/version</span><span class="w"> </span><span class="s">"0.1.0"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<h3 id="usage--examples">Usage &amp; examples</h3>

<p>First, import both Zippo and <code class="language-plaintext highlighter-rouge">clojure.zip</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">zippo.core-test</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.zip</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">zip</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">zippo.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">zippo</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Declare a zipper:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">z</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/vector-zip</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[[</span><span class="mi">4</span><span class="p">]]]))</span><span class="w">
</span></code></pre></div></div>

<p>Now check out the following Zippo functions.</p>

<h4 id="a-finite-seq-of-locations">A finite seq of locations</h4>

<p>The <code class="language-plaintext highlighter-rouge">loc-seq</code> funtion takes a location and returns a lazy seq of locations
untill it reaches the end:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">locs</span><span class="w"> </span><span class="p">(</span><span class="nf">zippo/loc-seq</span><span class="w"> </span><span class="n">z</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="n">locs</span><span class="p">))</span><span class="w">

</span><span class="c1">;; get a vector of notes to reduce the output</span><span class="w">
</span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[[</span><span class="mi">4</span><span class="p">]]]</span><span class="w">
 </span><span class="mi">1</span><span class="w">
 </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
 </span><span class="mi">2</span><span class="w">
 </span><span class="mi">3</span><span class="w">
 </span><span class="p">[[</span><span class="mi">4</span><span class="p">]]</span><span class="w">
 </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">
 </span><span class="mi">4</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>This is quite useful to traverse a zipper without keeping in mind the ending
condition (<code class="language-plaintext highlighter-rouge">zip/end?</code>).</p>

<h4 id="finding-locations">Finding locations</h4>

<p>The <code class="language-plaintext highlighter-rouge">loc-find</code> function looks for the first location that matches a predicate:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="p">(</span><span class="nf">zippo/loc-find</span><span class="w">
           </span><span class="n">z</span><span class="w">
           </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">3</span><span class="p">))))]</span><span class="w">

  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Above, we found a location which node equals 3.</p>

<p>The <code class="language-plaintext highlighter-rouge">loc-find-all</code> function finds all the locatins that match the predicate:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">locs</span><span class="w"> </span><span class="p">(</span><span class="nf">zippo/loc-find-all</span><span class="w">
            </span><span class="n">z</span><span class="w">
            </span><span class="p">(</span><span class="nf">zippo/-&gt;loc-pred</span><span class="w"> </span><span class="p">(</span><span class="nf">every-pred</span><span class="w"> </span><span class="n">int?</span><span class="w"> </span><span class="n">even?</span><span class="p">)))]</span><span class="w">

  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="n">locs</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Since the predicate accepts a location, you can check its children, siblings and
so on. For example, check if a location belongs to a special kind of parent.</p>

<p>However, most of the time you’re interested in a value (node) rather than a
location. The <code class="language-plaintext highlighter-rouge">-&gt;loc-pred</code> function converts a node predicate, which accepts a
node, into a location predicate. In the example above, the line</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">zippo/-&gt;loc-pred</span><span class="w"> </span><span class="p">(</span><span class="nf">every-pred</span><span class="w"> </span><span class="n">int?</span><span class="w"> </span><span class="n">even?</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>makes a location predicate which node is an even integer.</p>

<h4 id="updating-a-zipper">Updating a zipper</h4>

<p>Zippo offers some functions to update a zipper.</p>

<p>The <code class="language-plaintext highlighter-rouge">loc-update</code> one takes a location predicate, an update function and the rest
arguments. Here is how you douple all the even numbers in a nested vector:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w">
      </span><span class="p">(</span><span class="nf">zippo/loc-update</span><span class="w">
       </span><span class="n">z</span><span class="w">
       </span><span class="p">(</span><span class="nf">zippo/-&gt;loc-pred</span><span class="w"> </span><span class="p">(</span><span class="nf">every-pred</span><span class="w"> </span><span class="n">int?</span><span class="w"> </span><span class="n">even?</span><span class="p">))</span><span class="w">
       </span><span class="n">zip/edit</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)]</span><span class="w">

  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[[</span><span class="mi">8</span><span class="p">]]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">zip/root</span><span class="w"> </span><span class="n">loc</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>For the updating function, one may use <code class="language-plaintext highlighter-rouge">zip/append-child</code> to append a child,
<code class="language-plaintext highlighter-rouge">zip/remove</code> to drop the entire location and so on:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w">
      </span><span class="p">(</span><span class="nf">zippo/loc-update</span><span class="w">
       </span><span class="n">z</span><span class="w">
       </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])))</span><span class="w">
       </span><span class="n">zip/append-child</span><span class="w">
       </span><span class="no">:A</span><span class="p">)]</span><span class="w">

  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">:A</span><span class="p">]</span><span class="w"> </span><span class="p">[[</span><span class="mi">4</span><span class="p">]]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">zip/root</span><span class="w"> </span><span class="n">loc</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">node-update</code> function is similar but acts on nodes. Instead of <code class="language-plaintext highlighter-rouge">loc-pred</code>
and <code class="language-plaintext highlighter-rouge">loc-fn</code>, it accepts <code class="language-plaintext highlighter-rouge">node-pred</code> and <code class="language-plaintext highlighter-rouge">node-fn</code> what operate on nodes.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w">
    </span><span class="p">(</span><span class="nf">zippo/node-update</span><span class="w">
     </span><span class="n">z</span><span class="w">
     </span><span class="n">int?</span><span class="w">
     </span><span class="nb">inc</span><span class="p">)]</span><span class="w">
</span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="p">[[</span><span class="mi">5</span><span class="p">]]]</span><span class="w">
       </span><span class="p">(</span><span class="nf">zip/root</span><span class="w"> </span><span class="n">loc</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<h4 id="slicing-a-zipper-by-layers">Slicing a zipper by layers</h4>

<p>Sometimes, you need to slice a zipper on layers. This is what is better seen on
a chart:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     +---ROOT---+    ;; layer 1
     |          |
   +-A-+      +-B-+  ;; layer 2
   | | |      | | |
   X Y Z      J H K  ;; layer 3
</code></pre></div></div>

<ul>
  <li>Layer 1 is <code class="language-plaintext highlighter-rouge">[Root]</code>;</li>
  <li>Layer 1 is <code class="language-plaintext highlighter-rouge">[A B]</code>;</li>
  <li>Layer 3 is <code class="language-plaintext highlighter-rouge">[X Y Z J H K]</code></li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">loc-layers</code> function takes a location and builds a lazy seq of layers. The
first layer is the given location, then its children, the children of children
and so on.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">layers</span><span class="w">
      </span><span class="p">(</span><span class="nf">zippo/loc-layers</span><span class="w"> </span><span class="n">z</span><span class="p">)]</span><span class="w">

  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="o">'</span><span class="p">(([</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[[</span><span class="mi">4</span><span class="p">]]])</span><span class="w">
           </span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[[</span><span class="mi">4</span><span class="p">]])</span><span class="w">
           </span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="w">
           </span><span class="p">(</span><span class="nf">4</span><span class="p">))</span><span class="w">
         </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">layer</span><span class="w"> </span><span class="n">layers</span><span class="p">]</span><span class="w">
           </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">layer</span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<h4 id="breadth-first-seq-of-locations">Breadth-first seq of locations</h4>

<p>The <code class="language-plaintext highlighter-rouge">clojure.zip</code> package uses <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first method</a> of traversing a
tree. Let’s number the items:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       +-----ROOT[1]----+
       |                |
 +----A[2]---+     +---B[6]--+
 |     |     |     |    |    |
 X[3] Y[4] Z[5]   J[7] H[8] K[9]
</code></pre></div></div>

<p>This sometimes may end up with an infinity loop when you generate children
on the fly.</p>

<p>The <code class="language-plaintext highlighter-rouge">loc-seq-breadth</code> functions offers the opposite way of traversing a zipper:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       +-----ROOT[1]----+
       |                |
 +----A[2]---+     +---B[3]--+
 |     |     |     |    |    |
 X[4] Y[5] Z[6]   J[7] H[8] K[9]
</code></pre></div></div>

<p>This is useful to solve some special tasks related to zippers.</p>

<h4 id="lookups">Lookups</h4>

<p>When working with zippers, you often need such functionality as “go
up/left/right until meet something”. For example, from a given location, go up
until a parent has a special attribute. Zippo offers four functions for that,
namely <code class="language-plaintext highlighter-rouge">lookup-up</code>, <code class="language-plaintext highlighter-rouge">lookup-left</code>, <code class="language-plaintext highlighter-rouge">lookup-right</code>, and <code class="language-plaintext highlighter-rouge">lookup-down.</code> All of
them take a location and a predicate:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w">
      </span><span class="p">(</span><span class="nf">zip/vector-zip</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="p">[</span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="no">:d</span><span class="p">]]]</span><span class="w"> </span><span class="no">:e</span><span class="p">])</span><span class="w">

      </span><span class="n">loc-d</span><span class="w">
      </span><span class="p">(</span><span class="nf">zippo/loc-find</span><span class="w"> </span><span class="n">loc</span><span class="w">
                      </span><span class="p">(</span><span class="nf">zippo/-&gt;loc-pred</span><span class="w">
                       </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="p">]</span><span class="w">
                         </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="no">:d</span><span class="p">))))</span><span class="w">

      </span><span class="n">loc-b</span><span class="w">
      </span><span class="p">(</span><span class="nf">zippo/lookup-up</span><span class="w"> </span><span class="n">loc-d</span><span class="w">
                       </span><span class="p">(</span><span class="nf">zippo/-&gt;loc-pred</span><span class="w">
                        </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="p">]</span><span class="w">
                          </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">vector?</span><span class="w"> </span><span class="nb">node</span><span class="p">)</span><span class="w">
                               </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nb">node</span><span class="p">))))))]</span><span class="w">

  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:d</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc-d</span><span class="p">)))</span><span class="w">

  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="p">[</span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="no">:d</span><span class="p">]]]</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc-b</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>In the example above, first we find the <code class="language-plaintext highlighter-rouge">:d</code> location. From there, we go up
until we meet <code class="language-plaintext highlighter-rouge">[:b [:c [:d]]]</code>. If there is no such a location, the result will
be nil.</p>

<h3 id="also-see">Also See</h3>

<p>The code from this library was used for <a href="/en/clojure-zippers/">Clojure Zippers manual</a>
– the complete guide to zippers in Clojure from the very scratch.</p>

<p>© 2022 Ivan Grishaev</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/en/zippo/">
    <input required name="captcha" type="hidden" value="8 &#215; 9">

    <div class="block">
        <span class="comment-form-label"><small>8 &#215; 9 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
