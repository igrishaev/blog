<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Clojure Coding Guide</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/en/clojure-guide/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px"><a href="/">Ivan Grishaev's blog</a></p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/open-source/">Open Source</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Clojure Coding Guide</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2022-12-03T00:00:00+00:00">
        Dec 3, 2022
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/code/" rel="tag">code</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<p><em>TL;DR: this is a detailed description of how to write good Clojure code. It’s based on my 8 years of experience with Clojure for both commercial purposes and side projects as well. Some parts of this document repeat the <a href="https://github.com/bbatsov/clojure-style-guide">well-known guide</a> by Bojidar. Other parts instead break the conventional rules in Clojure development. For such cases, I give an explanation of why they are what they are. Everything written below has come from practice, and I hope you’ll find it useful.</em></p>

<h2>

    Table of Contents

</h2>

<ul id="toc-item-clojure-guide">
  <li><a href="#parentheses" id="toc-item-clojure-guide-parentheses">Parentheses</a></li>
  <li><a href="#namespaces" id="toc-item-clojure-guide-namespaces">Namespaces</a></li>
  <li><a href="#variables-and-defs" id="toc-item-clojure-guide-variables-and-defs">Variables and defs</a></li>
  <li><a href="#atoms" id="toc-item-clojure-guide-atoms">Atoms</a></li>
  <li><a href="#exceptions" id="toc-item-clojure-guide-exceptions">Exceptions</a></li>
  <li><a href="#assertions" id="toc-item-clojure-guide-assertions">Assertions</a></li>
  <li><a href="#functions" id="toc-item-clojure-guide-functions">Functions</a></li>
  <li><a href="#arguments" id="toc-item-clojure-guide-arguments">Arguments</a></li>
  <li><a href="#destructuring" id="toc-item-clojure-guide-destructuring">Destructuring</a></li>
  <li><a href="#keywords" id="toc-item-clojure-guide-keywords">Keywords</a></li>
  <li><a href="#keyword-processing" id="toc-item-clojure-guide-keyword-processing">Keyword processing</a></li>
  <li><a href="#type-hints" id="toc-item-clojure-guide-type-hints">Type hints</a></li>
  <li><a href="#naming" id="toc-item-clojure-guide-naming">Naming</a></li>
  <li><a href="#lines-and-indentation" id="toc-item-clojure-guide-lines-and-indentation">Lines and indentation</a></li>
  <li><a href="#maps" id="toc-item-clojure-guide-maps">Maps</a></li>
  <li><a href="#let" id="toc-item-clojure-guide-let">Let</a></li>
  <li><a href="#case-cond" id="toc-item-clojure-guide-case-cond">Case, cond</a></li>
  <li><a href="#macros-indentation" id="toc-item-clojure-guide-macros-indentation">Macros indentation</a></li>
  <li><a href="#java-interop" id="toc-item-clojure-guide-java-interop">Java interop</a></li>
  <li><a href="#java-like-classes" id="toc-item-clojure-guide-java-like-classes">Java-like classes</a></li>
  <li><a href="#reuse-java-classes" id="toc-item-clojure-guide-reuse-java-classes">Reuse Java classes</a></li>
  <li><a href="#systems-and-components" id="toc-item-clojure-guide-systems-and-components">Systems and Components</a></li>
  <li><a href="#collections" id="toc-item-clojure-guide-collections">Collections</a></li>
  <li><a href="#clojurespec" id="toc-item-clojure-guide-clojurespec">Clojure.spec</a></li>
  <li><a href="#types--records" id="toc-item-clojure-guide-types--records">Types &amp; Records</a></li>
  <li><a href="#named-sections" id="toc-item-clojure-guide-named-sections">Named sections</a></li>
  <li><a href="#comments" id="toc-item-clojure-guide-comments">Comments</a></li>
  <li><a href="#trailing-spaces" id="toc-item-clojure-guide-trailing-spaces">Trailing spaces</a></li>
  <li><a href="#commented-code-and-dev-sections" id="toc-item-clojure-guide-commented-code-and-dev-sections">Commented code and dev sections</a></li>
  <li><a href="#tests" id="toc-item-clojure-guide-tests">Tests</a></li>
  <li><a href="#coreasync" id="toc-item-clojure-guide-coreasync">Core.async</a></li>
  <li><a href="#amazonica" id="toc-item-clojure-guide-amazonica">Amazonica</a></li>
  <li><a href="#libraries" id="toc-item-clojure-guide-libraries">Libraries</a></li>
</ul>

<h2 id="parentheses">Parentheses</h2>

<p>Let’s start with something obvious yet worthy of repeating. When writing Lisp code, don’t balance parentheses as you did before in Python or JavaScript. Not like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">time</span><span class="w">
 </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]]</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="p">)]</span><span class="w">
     </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
     </span><span class="p">)</span><span class="w">
   </span><span class="p">)</span><span class="w">
 </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>But this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">time</span><span class="w">
 </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]]</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="p">)]</span><span class="w">
     </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">b</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>The same rule applies to collections. The following code fragments look weird in Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">mapping</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
   </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="p">[</span><span class="w">
  </span><span class="mi">1</span><span class="n">,</span><span class="w">
  </span><span class="mi">2</span><span class="n">,</span><span class="w">
  </span><span class="mi">3</span><span class="w">
</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>It is a strong rule for every Lisp dialect and you’ve got to get on with it. The sooner you get an editor powered with a plugin to manage parenthesis the better it is for you as a programmer. Emacs + Paredit is a good choice but it’s a matter of preference.</p>

<!-- more -->

<h2 id="namespaces">Namespaces</h2>

<p>In the <code class="language-plaintext highlighter-rouge">:require</code> sub-form of the <code class="language-plaintext highlighter-rouge">ns</code> header, place the imports on the next line but not on the same. Namely, likes this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some.ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.java.io</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">io</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>But not this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some.ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">clojure.java.io</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">io</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>The second example takes 9 more spaces in breadth. Both our software and hardware are developed such that it’s easier to scroll the text down rather than to the right. Thus, grow your code vertically but not horizontally. When it’s possible to shorter a line by pressing enter, always do this.</p>

<p>When importing a namespace, specify its full path. Don’t use nested vectors although technically it’s possible:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some.ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure</span><span class="w"> </span><span class="p">[</span><span class="n">edn</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">edn</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">walk</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">walk</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]]))</span><span class="w">
</span></code></pre></div></div>

<p>In this case, you’ll get troubles with grepping the code with <code class="language-plaintext highlighter-rouge">clojure.walk</code> or any other namespace — there won’t be such a match.</p>

<p>For aliases, use the part of a namespace after the last dot. If there are two and more namespaces with the same ending, use two last parts, and so on:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some.ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.walk</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">walk</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some.ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.walk</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">clojure.walk</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">some.utils.walk</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">utils.walk</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Don’t use one-letter aliases even for the built-in modules like <code class="language-plaintext highlighter-rouge">clojure.string</code> or <code class="language-plaintext highlighter-rouge">clojure.walk</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some.ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/starts-with?</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Instead, use <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">walk</code>, <code class="language-plaintext highlighter-rouge">edn</code>, and similar. By the way, the <code class="language-plaintext highlighter-rouge">str</code> alias is OK for <code class="language-plaintext highlighter-rouge">clojure.string</code> but it’s a well-known exception:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some.ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">str/starts-with?</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Never use the <code class="language-plaintext highlighter-rouge">:use</code> clause in the namespace form. The <code class="language-plaintext highlighter-rouge">:use</code> form acts like the <code class="language-plaintext highlighter-rouge">import *</code> clause in Python or <code class="language-plaintext highlighter-rouge">import foo.bar.*</code> in Java. Both two are considered bad practices as the code becomes confusing. The same works for Clojure: without an alias, it’s unobvious where a certain function comes from:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some.ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:use</span><span class="w"> </span><span class="n">clojure.walk</span><span class="w"> </span><span class="n">clojure.string</span><span class="p">))</span><span class="w">

</span><span class="n">...</span><span class="w">

</span><span class="p">(</span><span class="nf">stringify-keys</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="c1">;; .walk or .string?</span><span class="w">
</span></code></pre></div></div>

<p>That’s a good idea to group imports by their semantics, namely:</p>

<ol>
  <li>modules of this project;</li>
  <li>third-party modules;</li>
  <li>built-in Clojure modules.</li>
</ol>

<p>For example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">project.core</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">project.handlers</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">handlers</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">project.routes</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">routes</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">project.server</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">server</span><span class="p">]</span><span class="w">

   </span><span class="p">[</span><span class="n">honey.sql</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">sql</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">cheshire.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">json</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.java.jdbc</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc</span><span class="p">]</span><span class="w">

   </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.java.io</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">io</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Should the <code class="language-plaintext highlighter-rouge">:require</code> section grow in time, such grouping will help you to review and control the dependencies.</p>

<p>And instead, when all the imports are dumped in a single vector, that’s difficult to understand what’s going on.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">project.core</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">project.handlers</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">handlers</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.java.io</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">io</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">project.routes</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">routes</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">cheshire.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">json</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.java.jdbc</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">honey.sql</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">sql</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">project.server</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">server</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Sorting modules is useful even if they’re not grouped as described in the previous paragraph. In Emacs, there is a <code class="language-plaintext highlighter-rouge">M-x clojure-sort-ns</code> command that does it for you. You can also sort the imports manually using <code class="language-plaintext highlighter-rouge">M-x sort-lines</code>.</p>

<p>Some modules change the global state, for example extend multimethods, protocols and so on. Always import them in the core module of your project to prevent loosing their effect. Use neither alias nor square brackets for them to highlight it’s a special case. Put a short comment on the right saying what it does:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">project.core</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="n">project.db.json</span><span class="w"> </span><span class="c1">;; extends JDBC PGObject for json(b)</span><span class="w">
   </span><span class="p">[</span><span class="n">project.handlers</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">handlers</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">project.routes</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">routes</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Without this precaution, you teammates might take it as an unused namespace, delete it and face a weird behaviour when a multimethod or a protocol lacks implementation.</p>

<h2 id="variables-and-defs">Variables and defs</h2>

<p>Both <code class="language-plaintext highlighter-rouge">def</code> and <code class="language-plaintext highlighter-rouge">defn</code> forms must only be on top of a module but never inside <code class="language-plaintext highlighter-rouge">let</code> or other forms. Not this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-user-info</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user</span><span class="w"> </span><span class="n">user-id</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">profile-id</span><span class="w"> </span><span class="p">(</span><span class="no">:profile-id</span><span class="w"> </span><span class="n">user</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">profile</span><span class="w"> </span><span class="p">(</span><span class="nf">get-profile</span><span class="w"> </span><span class="n">profile-id</span><span class="p">))</span><span class="w">
  </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="n">user</span><span class="w">
   </span><span class="no">:profile</span><span class="w"> </span><span class="n">profile</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>But this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-user-info</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user</span><span class="w"> </span><span class="n">user-id</span><span class="p">)</span><span class="w">
        </span><span class="n">profile-id</span><span class="w"> </span><span class="p">(</span><span class="no">:profile-id</span><span class="w"> </span><span class="n">user</span><span class="p">)</span><span class="w">
        </span><span class="n">profile</span><span class="w"> </span><span class="p">(</span><span class="nf">get-profile</span><span class="w"> </span><span class="n">profile-id</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="n">user</span><span class="w">
     </span><span class="no">:profile</span><span class="w"> </span><span class="n">profile</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Inner <code class="language-plaintext highlighter-rouge">define</code> forms are OK for Scheme which most people familiar with by SICP. But this is Clojure not Scheme.</p>

<p>In some rare cases though, we <em>do use</em> inner Clojure definitions. This is useful when a function is closed over some precalculated value and thus is put inside <code class="language-plaintext highlighter-rouge">let</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">-rules</span><span class="w"> </span><span class="p">(</span><span class="nf">read-json</span><span class="w"> </span><span class="s">"resources/rules.json"</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-rule</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">-rules</span><span class="w"> </span><span class="p">[</span><span class="no">:system</span><span class="w"> </span><span class="no">:rules</span><span class="w"> </span><span class="n">id</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">-rules</code> variable is processed once so there is no need to parse JSON for every call. Also, it is only visible to the <code class="language-plaintext highlighter-rouge">get-rule</code> function so no one can interfere.</p>

<p>When introducing a dynamic variable, don’t anticipate the users typing something like this every time:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*locale*</span><span class="w"> </span><span class="no">:ru</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">translate</span><span class="w"> </span><span class="no">:message/hello</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Instead, provide <code class="language-plaintext highlighter-rouge">with-locale</code> macro that does everything for them:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">with-locale</span><span class="w"> </span><span class="no">:ru</span><span class="w">
  </span><span class="p">(</span><span class="nf">translate</span><span class="w"> </span><span class="no">:message/hello</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Thanks to its name, the macro gives more sense of what’s happening. Also, you can adjust it in time (add logs, side effects and so on).</p>

<h2 id="atoms">Atoms</h2>

<p>In general, avoid using atoms. Every time you’re about to bring one into your code, think if it’s possible to get rid of it. <code class="language-plaintext highlighter-rouge">Loop</code>, <code class="language-plaintext highlighter-rouge">reduce</code> and other patterns most likely will satisfy your intentions with no atoms.</p>

<p>Even if you drive your code with atoms, avoid storing them on the top of a module. This is a bad example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">storage</span><span class="w">
  </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{}))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">set-item</span><span class="w"> </span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="n">item</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="nb">assoc</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="n">item</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-item</span><span class="w"> </span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="o">@</span><span class="n">storage</span><span class="w"> </span><span class="n">idx</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Such code is quite tricky to test as you continuously need to reset the state between the tests. The state, although driven by an atom, must have been a component of the system (see below).</p>

<p>Don’t use <code class="language-plaintext highlighter-rouge">*</code> or <code class="language-plaintext highlighter-rouge">%</code> characters to highlight it’s an atom. This is bad:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">*storage</span><span class="w">
  </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{}))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">%storage</span><span class="w">
  </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{}))</span><span class="w">
</span></code></pre></div></div>

<p>Stars, ticks and similar bring noise into the code. The <code class="language-plaintext highlighter-rouge">atom-</code> or just <code class="language-plaintext highlighter-rouge">a-</code> prefix usually is enough:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">atom-storage</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{}))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">a-storage</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{}))</span><span class="w">
</span></code></pre></div></div>

<p>The better choice is an exclamation mark at the end of the name:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">storage!</span><span class="w">
  </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{}))</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">storage!</code> name is in line with the functions that operate on atoms: <code class="language-plaintext highlighter-rouge">swap!</code>, <code class="language-plaintext highlighter-rouge">reset!</code> and so on. Thus, the code with ! looks neat:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">storage!</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{}))</span><span class="w">

</span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">storage!</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">storage!</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Talking more generally, an exclamation mark is a good option to highlight <em>any mutable type</em>, for example, a transient collection. Their functions also end with !:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">acc!</span><span class="w"> </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="p">[])]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">...</span><span class="w">
    </span><span class="p">(</span><span class="nf">persistent!</span><span class="w"> </span><span class="n">acc!</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">conj!</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="n">item</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<h2 id="exceptions">Exceptions</h2>

<p>Use exceptions but not monads. Exceptions are dull yet straightforward and predictable. Clojure ecosystem is not monad-friendly at all. Although we do have some developed libraries for monands, they’re rarely used in production.</p>

<p>The main problem with monads is, implementing a <code class="language-plaintext highlighter-rouge">Maybe</code> type is not enough; you’ve got to write monadic versions of <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">when</code>, <code class="language-plaintext highlighter-rouge">cond</code>, <code class="language-plaintext highlighter-rouge">case</code>, <code class="language-plaintext highlighter-rouge">-&gt;</code>, <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> and so forth. Moreover, people must learn all this which they rarely have time and motivation for.</p>

<p>I recall I only needed something like monads once before. Throwing an exception was not the case so I made <code class="language-plaintext highlighter-rouge">Success</code> and <code class="language-plaintext highlighter-rouge">Failure</code> wrappers on top of ordinary data types. With a couple of custom macros, it worked fine without introducing a new library to the project.</p>

<p>Don’t return exceptions as values. Everyone who uses your code has to check the result with if/else which brings nesting and complexity:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-user</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/get-by-id</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="n">user-id</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="n">e</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">throwable?</span><span class="w"> </span><span class="n">user</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">do</span><span class="w">
      </span><span class="p">(</span><span class="nf">log/error</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="n">user</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">process</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The same applies to returning error maps. Again, everyone has to if/else on the result, which most likely they will forget one day:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-user</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/get-by-id</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="n">user-id</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">:error</span><span class="w"> </span><span class="no">:message</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-message</span><span class="w"> </span><span class="n">e</span><span class="p">)})))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">error-map?</span><span class="w"> </span><span class="n">user</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">do</span><span class="w">
      </span><span class="p">(</span><span class="nf">log/error</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">process</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The standard way of throwing exceptions in Clojure is verbose: it requires two forms (<code class="language-plaintext highlighter-rouge">throw</code> and <code class="language-plaintext highlighter-rouge">ex-info</code>) as well as a context map where sometimes you have nothing to put into it yet you must:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"Some message"</span><span class="w"> </span><span class="p">{</span><span class="no">:some</span><span class="w"> </span><span class="s">"context"</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>A good idea would be to create a <code class="language-plaintext highlighter-rouge">project.error</code> namespace in your project and provide shortcuts that combine initialisation and throwing:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">error!</span><span class="w">

  </span><span class="p">([</span><span class="n">message</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="p">{})))</span><span class="w">

  </span><span class="p">([</span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="p">)))</span><span class="w">

  </span><span class="p">([</span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">cause</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">cause</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>The example below takes less code and is more readable:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="n">user</span><span class="w">
  </span><span class="p">(</span><span class="nf">error/error!</span><span class="w"> </span><span class="s">"User not found"</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="n">user-id</span><span class="p">}))</span><span class="w">

</span><span class="c1">;;  or when the error! function was :refer-red</span><span class="w">
</span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="n">user</span><span class="w">
  </span><span class="p">(</span><span class="nf">error!</span><span class="w"> </span><span class="s">"User not found"</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="n">user-id</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Having a bottleneck that all the exceptions pass through, you can adjust it in the future. Say, add more data into the context map (time, host, type, the namespace, etc). Introduce this error module as soon as possible and stick with it through the whole code base.</p>

<p>An error module is also a good place for various exception-handling macros. Namely, retrying, protected call which returns a pair of <code class="language-plaintext highlighter-rouge">[result, exception]</code>, and so on.</p>

<h2 id="assertions">Assertions</h2>

<p>Assertions are somewhat exceptions as they blow up when something goes wrong. Having assertions is good for development but not for production. The thing is, the <code class="language-plaintext highlighter-rouge">assert</code> macro relies on the <code class="language-plaintext highlighter-rouge">*assert*</code> global dynamic var. When it’s false, none of the <code class="language-plaintext highlighter-rouge">assert</code> forms works as expected:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*assert*</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="mi">1</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="no">:bar</span><span class="p">)</span><span class="w"> </span><span class="s">"Bar is missing"</span><span class="p">))</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p>Setting <code class="language-plaintext highlighter-rouge">*assert*</code> to false is common when building an uberjar. In this case, all the assertions are removed completely from the resulting bytecode. If you rely on assertions in code a lot, keep in mind they can be disabled on prod.</p>

<p>The pre- and post- checks in <code class="language-plaintext highlighter-rouge">defn</code> rely on <code class="language-plaintext highlighter-rouge">*assert*</code> as well:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*assert*</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-user</span><span class="w">
  </span><span class="p">[</span><span class="n">user</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:pre</span><span class="w"> </span><span class="p">[(</span><span class="nf">some?</span><span class="w"> </span><span class="n">user</span><span class="p">)]}</span><span class="w">
  </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="no">:some</span><span class="w"> </span><span class="s">"field"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">process-user</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">;; {:some "field"}</span><span class="w">
</span></code></pre></div></div>

<p>Anyway, pre- and post- are great for critical parts of the code; using them is considered as a good practice.</p>

<h2 id="functions">Functions</h2>

<p>Never use the <code class="language-plaintext highlighter-rouge">#(...)</code> syntax for anonymous functions since they’re really difficult to read. The <code class="language-plaintext highlighter-rouge">%1</code>, <code class="language-plaintext highlighter-rouge">%2</code>, … symbols bring chaos to code. Whenever you typed <code class="language-plaintext highlighter-rouge">#(...</code>, delete it and provide an ordinary named function. No:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="no">:id</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">product-id</span><span class="p">)</span><span class="w"> </span><span class="n">products</span><span class="p">)</span><span class="w">
</span><span class="c1">;; or</span><span class="w">
</span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">json/parse-string</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="nb">keyword</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Yes:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">product</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="no">:id</span><span class="w"> </span><span class="n">product</span><span class="p">)</span><span class="w"> </span><span class="n">product-id</span><span class="p">))</span><span class="w">
        </span><span class="n">products</span><span class="p">)</span><span class="w">
</span><span class="c1">;; or</span><span class="w">
</span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="n">json/parse-string</span><span class="w"> </span><span class="nb">keyword</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>What is really bad with <code class="language-plaintext highlighter-rouge">#(...)</code>, the arguments have no names and thus lack semantics. The <code class="language-plaintext highlighter-rouge">(fn ...)</code> form can be easily put on the top level of a module and transformed into <code class="language-plaintext highlighter-rouge">defn</code>, so it can be tested in REPL or unit tests.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">this-product?</span><span class="w"> </span><span class="p">[</span><span class="n">product</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="no">:id</span><span class="w"> </span><span class="n">product</span><span class="p">)</span><span class="w"> </span><span class="n">product-id</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Use <code class="language-plaintext highlighter-rouge">map</code> only for primitive cases like <code class="language-plaintext highlighter-rouge">inc</code>-ing a collection of numbers or similar:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="n">numbers</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="n">objects</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Passing vast anonymous functions into <code class="language-plaintext highlighter-rouge">map</code> makes the code unreadable:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]}]</span><span class="w">
       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">this</span><span class="w">
         </span><span class="p">(</span><span class="nf">with-something</span><span class="w">
           </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
           </span><span class="p">(</span><span class="nf">do-that</span><span class="w"> </span><span class="n">this</span><span class="p">))</span><span class="w">
         </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">foo</span><span class="w"> </span><span class="mi">1</span><span class="w">
               </span><span class="n">bar</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
           </span><span class="p">(</span><span class="nf">otherwise</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">...</span><span class="p">))))</span><span class="w"> </span><span class="n">entities</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>This is taken from a real project I’ve worked on. I always hang when facing such code. The first thing I usually do is take the function out from the map either on top of the module or at least into the preceding <code class="language-plaintext highlighter-rouge">let</code> clause. Then, pass the function as a variable:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-entity</span><span class="w"> </span><span class="p">[</span><span class="n">entity</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">process-entity</span><span class="w"> </span><span class="n">entities</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The better approach would be just to get rid of <code class="language-plaintext highlighter-rouge">map</code> in favour of <code class="language-plaintext highlighter-rouge">for</code> macro:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">entity</span><span class="w"> </span><span class="n">entities</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]}]</span><span class="w">
    </span><span class="p">(</span><span class="nf">return</span><span class="w"> </span><span class="n">something</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>It’s clearer and simpler for the readers.</p>

<p>Don’t use <code class="language-plaintext highlighter-rouge">partial</code> for the same reason: it ruins the easiness of reading. The worst thing is a combination of <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">partial</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">items</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">process-item</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">current-time</span><span class="p">))</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">check-item</span><span class="w"> </span><span class="n">event-type</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Partial</code> is sometimes good for declarations where it’s isolated from the outer world:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">enumerate</span><span class="w">
  </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">map-indexed</span><span class="w"> </span><span class="nb">vector</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">enumerate</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">])</span><span class="w">
</span><span class="c1">;; ([0 :a] [1 :b] [2 :c])</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Comp</code> is also hard to read as the order of functions is opposite: not left to right but right to left:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="nb">comp</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="n">abs</span><span class="p">)</span><span class="w"> </span><span class="mi">-3</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 4</span><span class="w">
</span></code></pre></div></div>

<p>Like partial, <code class="language-plaintext highlighter-rouge">comp</code> is good when it’s hidden from the outer code. The in-place use of <code class="language-plaintext highlighter-rouge">comp</code> is horrible, please don’t do that:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">more</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>A good example of <code class="language-plaintext highlighter-rouge">comp</code> usage where it’s isolated:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-xform</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">...</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">xform</span><span class="w"> </span><span class="p">(</span><span class="nf">make-xform</span><span class="p">)]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h2 id="arguments">Arguments</h2>

<p>For optional arguments, use a single map but not a list. Not like in the following example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">connect</span><span class="w"> </span><span class="p">[</span><span class="n">host</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">log-level</span><span class="w">
                                   </span><span class="n">log-file</span><span class="p">]}]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">connect</span><span class="w"> </span><span class="s">"localhost"</span><span class="w"> </span><span class="mi">5432</span><span class="w"> </span><span class="no">:log-level</span><span class="w"> </span><span class="s">"info"</span><span class="w"> </span><span class="no">:log-file</span><span class="w"> </span><span class="s">"log.txt"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>But like in this one:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">connect</span><span class="w">
  </span><span class="p">([</span><span class="n">host</span><span class="w"> </span><span class="n">port</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">connect</span><span class="w"> </span><span class="n">host</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">

  </span><span class="p">([</span><span class="n">host</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">log-level</span><span class="w"> </span><span class="n">log-file</span><span class="p">]}]</span><span class="w">
   </span><span class="n">...</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">options</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">connect</span><span class="w"> </span><span class="n">host</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="n">options</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The reason is, to collect the options you need a map. Then you turn it into a flat list and apply it to the function. The underlying function builds a map from that list to parse values, then turns it into a map and applies it to the third function. Eventually, you find the code full of <code class="language-plaintext highlighter-rouge">apply</code>s rather than normal function calls.</p>

<p>Since Clojure 1.11 or something both types of functions work with a map, but honestly, it’s a compromise to end the stand between the two approaches. Someone may still want to use your code with Clojure below 1.11, so it’s better to not rely on this automatic solver.</p>

<h2 id="destructuring">Destructuring</h2>

<p>When destructuring a map on variables, don’t go deeper than one level at once. This code is OK:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">response</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="p">{</span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
                 </span><span class="no">:full-name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}}})</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">status</span><span class="w"> </span><span class="n">body</span><span class="p">]}</span><span class="w">
      </span><span class="n">response</span><span class="w">

      </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="p">]}</span><span class="w">
      </span><span class="n">body</span><span class="w">

      </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">email</span><span class="w"> </span><span class="n">full-name</span><span class="p">]}</span><span class="w">
      </span><span class="n">user</span><span class="p">]</span><span class="w">

  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">email</span><span class="w"> </span><span class="n">full-name</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>But this is ambiguous:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{{{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">email</span><span class="w"> </span><span class="n">full-name</span><span class="p">]}</span><span class="w"> </span><span class="no">:user</span><span class="p">}</span><span class="w"> </span><span class="no">:body</span><span class="p">}</span><span class="w">
      </span><span class="n">response</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">email</span><span class="w"> </span><span class="n">full-name</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The problem with map destructuring syntax is, it works from the right to the left which conflicts with the ordinary way of reading. Doing it by one level takes longer, but the code is more readable.</p>

<p>Don’t use keywords inside the <code class="language-plaintext highlighter-rouge">:keys</code> vector. Technically they’re allowed, but look weird:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="no">:status</span><span class="w"> </span><span class="no">:body</span><span class="p">]}</span><span class="w">
      </span><span class="n">response</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h2 id="keywords">Keywords</h2>

<p>This section is the most controversial in this document as it conflicts with what most Clojure developers do.</p>

<p>First, avoid using namespaces in keywords. Instead of <code class="language-plaintext highlighter-rouge">:user/name</code> or <code class="language-plaintext highlighter-rouge">:book/title</code> use :<code class="language-plaintext highlighter-rouge">user-name</code> and <code class="language-plaintext highlighter-rouge">:book-title</code>. Here is why.</p>

<p><strong>1.</strong> Imagine you have a map like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data</span><span class="w">
  </span><span class="p">{</span><span class="no">:user/name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
   </span><span class="no">:event/name</span><span class="w"> </span><span class="s">"Party"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>If you transform this map into JSON with Cheshire, you’ll get the keys <code class="language-plaintext highlighter-rouge">user/name</code> and <code class="language-plaintext highlighter-rouge">event/name</code>. That’s difficult to work with such keys in JavaScript on the client side. In wider terms, your clients can handle namespaces only if they use Clojure or ClojureScript. Any other language like Python has problems with processing keys like <code class="language-plaintext highlighter-rouge">user/name</code>. There is no an easy way to split such a map on variables with the standard destructuring syntax.</p>

<p><strong>2.</strong> When using namespaces, you never know for sure what is the right key: <code class="language-plaintext highlighter-rouge">:name</code> or <code class="language-plaintext highlighter-rouge">:user/name</code>. That’s especially annoying when working with JDBC.next result. By default, it adds namespaces to the selected keys which takes an extra query. For performance, we often pass the <code class="language-plaintext highlighter-rouge">rs/as-unqualified-kebab-maps</code> parameter to skip the namespaces. But when you edit someone else’s code, you’ve got to scroll up and check what row function was passed to the query. That really slows down the development.</p>

<p><strong>3.</strong> Maps with namespaces are hard to destructure. Imagine from the map mentioned above, we need to fetch both name of a user and a name of the party. Since the name parts are the same, we cannot use the <code class="language-plaintext highlighter-rouge">:&lt;ns&gt;/keys</code> syntax as the second clause shadows the first one:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:user/keys</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="p">]</span><span class="w">
       </span><span class="no">:event/keys</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="p">]}</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="nb">name</span><span class="p">))</span><span class="w">
</span><span class="c1">;; Party</span><span class="w">
</span></code></pre></div></div>

<p>We have to destructure manually, which is boring:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="n">user-name</span><span class="w"> </span><span class="no">:user/name</span><span class="w">
       </span><span class="n">event-name</span><span class="w"> </span><span class="no">:event/name</span><span class="p">}</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">user-name</span><span class="w"> </span><span class="s">"@"</span><span class="w"> </span><span class="n">event-name</span><span class="p">))</span><span class="w">
</span><span class="c1">;; Ivan @ Party</span><span class="w">
</span></code></pre></div></div>

<p>Ideally, a map should be free from namespaces because usually, it’s easy to guess the semantics from the context. Let’s consider some examples below:</p>

<p><strong>1.</strong> All the keys have the same namespace:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w">
      </span><span class="p">{</span><span class="no">:user/name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
       </span><span class="no">:user/email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
       </span><span class="no">:user/dob</span><span class="w"> </span><span class="s">"1985-12-31"</span><span class="w">
       </span><span class="no">:user/active?</span><span class="w"> </span><span class="n">true</span><span class="p">}]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>What is the point to put the same namespace everywhere? The following writing is much simpler and clear:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w">
      </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
       </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
       </span><span class="no">:dob</span><span class="w"> </span><span class="s">"1985-12-31"</span><span class="w">
       </span><span class="no">:active?</span><span class="w"> </span><span class="n">true</span><span class="p">}]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Of course, it’s possible to shorten it with the <code class="language-plaintext highlighter-rouge">#:&lt;ns&gt;{...}</code> syntax:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="o">#</span><span class="no">:user</span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
                  </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
                  </span><span class="no">:dob</span><span class="w"> </span><span class="s">"1985-12-31"</span><span class="w">
                  </span><span class="no">:active?</span><span class="w"> </span><span class="n">true</span><span class="p">}]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Which, anyway, leads do something like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="no">:user/email</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Since I already know it’s a user, why should I use <code class="language-plaintext highlighter-rouge">:user/email</code> instead of plain <code class="language-plaintext highlighter-rouge">:email</code>?</p>

<p><strong>2.</strong> There are two and more namespaces in a single map:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">row</span><span class="w">
      </span><span class="p">{</span><span class="no">:user/name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
       </span><span class="no">:user/email</span><span class="w"> </span><span class="s">"test@test.con"</span><span class="w">
       </span><span class="no">:user/dob</span><span class="w"> </span><span class="s">"1985-12-31"</span><span class="w">
       </span><span class="no">:user/active?</span><span class="w"> </span><span class="n">true</span><span class="w">
       </span><span class="no">:profile/user-id</span><span class="w"> </span><span class="mi">1</span><span class="w">
       </span><span class="no">:profile/created-at</span><span class="w"> </span><span class="s">"2022-01-01"</span><span class="w">
       </span><span class="no">:profile/avatar</span><span class="w"> </span><span class="s">"image.png"</span><span class="p">}]</span><span class="w">
  </span><span class="nb">..</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Either rewrite it with prefixes:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">row</span><span class="w">
      </span><span class="p">{</span><span class="no">:user-name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
       </span><span class="no">:user-email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
       </span><span class="no">:user-dob</span><span class="w"> </span><span class="s">"1985-12-31"</span><span class="w">
       </span><span class="no">:user-active?</span><span class="w"> </span><span class="n">true</span><span class="w">
       </span><span class="no">:profile-user-id</span><span class="w"> </span><span class="mi">1</span><span class="w">
       </span><span class="no">:profile-created-at</span><span class="w"> </span><span class="s">"2022-01-01"</span><span class="w">
       </span><span class="no">:profile-avatar</span><span class="w"> </span><span class="s">"image.png"</span><span class="p">}]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>or group the keys like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">row</span><span class="w">
      </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
              </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.con"</span><span class="w">
              </span><span class="no">:dob</span><span class="w"> </span><span class="s">"1985-12-31"</span><span class="w">
              </span><span class="no">:active?</span><span class="w"> </span><span class="n">true</span><span class="p">}</span><span class="w">
       </span><span class="no">:profile</span><span class="w"> </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">1</span><span class="w">
                 </span><span class="no">:created-at</span><span class="w"> </span><span class="s">"2022-01-01"</span><span class="w">
                 </span><span class="no">:avatar</span><span class="w"> </span><span class="s">"image.png"</span><span class="p">}}]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>In both cases, it is much easier to process that map in any way you like. The namespaces would only complicate the process.</p>

<p>Of course, there are systems that rely on namespaces a lot. These are Clojure.spec, Datomic and some Clojure libraries. These are exceptions because their design is built on top of namespaces. But other systems like Postgres, Redis, Cassandra, Kafka and JSON don’t need them at all. Don’t push namespaces into the areas where they’re useless.</p>

<h2 id="keyword-processing">Keyword processing</h2>

<p>The second thought about keywords is, never re-process them. By reprocessing, I mean changing the registry and replacing underscores with hyphens. Briefly, always process the data in its original form. Namely, not like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">walk/postwalk</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">map?</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">update-keys</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">-&gt;lower-cebab-case</span><span class="p">)</span><span class="w">
     </span><span class="n">x</span><span class="p">))</span><span class="w">
 </span><span class="n">data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>But this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">user_id</span><span class="w">
              </span><span class="n">user_name</span><span class="p">]}</span><span class="w"> </span><span class="n">db-row</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">user_id</span><span class="w"> </span><span class="n">user_name</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">ResponseError</span><span class="w">
              </span><span class="n">ResponseMessage</span><span class="p">]}</span><span class="w">
      </span><span class="n">api-response</span><span class="w">

      </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">Code</span><span class="w"> </span><span class="n">Category</span><span class="p">]}</span><span class="w">
      </span><span class="n">ResponseError</span><span class="p">]</span><span class="w">

  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">Code</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="n">ResponseMessage</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>It’s better to get rid of libraries that convert screaming/kebab/whatever keys.</p>

<p>Here is the explanation. First, you waste resources on transforming the keys. Walking through a nested structure was never cheap. So you traverse on it and for each keyword, convert it into a string, match/replace using a regexp and then transform it to a keyword again. It takes CPU time.</p>

<p>Second and much more important: transformed keys do not match the documentation any longer. One day I worked with AppStore API which would return keys in lower camel case, for example, <code class="language-plaintext highlighter-rouge">userName</code>, <code class="language-plaintext highlighter-rouge">initialTransaction</code> and so on. So I did:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="p">[</span><span class="no">:transactionInfo</span><span class="w"> </span><span class="no">:userName</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>against the JSON response and got nil. Why? Thanks to our HTTP client, it transformed the keys into <code class="language-plaintext highlighter-rouge">:transaction-info</code> and <code class="language-plaintext highlighter-rouge">:user-name</code>, and I was unaware of it. That’s especially terrible after you’ve done with a <code class="language-plaintext highlighter-rouge">curl</code> and <code class="language-plaintext highlighter-rouge">jq</code> session and now moving to Clojure.</p>

<p>That’s completely fine to use <code class="language-plaintext highlighter-rouge">transactionInfo</code> and <code class="language-plaintext highlighter-rouge">userName</code> keys in your code. The naming signals they came from the outer world. Please don’t transform keywords back and forth when reaching the database, Kafka or whatever else. All you do is waste CPU time and confuse programmers.</p>

<h2 id="type-hints">Type hints</h2>

<p>Always enable reflection warnings by setting the <code class="language-plaintext highlighter-rouge">*warn-on-reflection*</code> global variable to true. This can be easily done with lein:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:global-vars</span><span class="w"> </span><span class="p">{</span><span class="n">*warn-on-reflection*</span><span class="w"> </span><span class="n">true</span><span class="w">
               </span><span class="n">*assert*</span><span class="w"> </span><span class="n">true</span><span class="w">
               </span><span class="n">*print-meta*</span><span class="w"> </span><span class="n">false</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Alternatively, put that map into your local profile to enable warnings in all your Clojure projects:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="w"> </span><span class="o">~</span><span class="n">/.lein/profiles.clj</span><span class="w">
</span><span class="p">{</span><span class="no">:user</span><span class="w">
 </span><span class="p">{</span><span class="no">:global-vars</span><span class="w"> </span><span class="p">{</span><span class="n">*warn-on-reflection*</span><span class="w"> </span><span class="n">true</span><span class="w">
                </span><span class="n">*assert*</span><span class="w"> </span><span class="n">true</span><span class="w">
                </span><span class="n">*print-meta*</span><span class="w"> </span><span class="n">false</span><span class="p">}}}</span><span class="w">
</span></code></pre></div></div>

<p>Reflections significantly slow down the code. Every time you see a warning, put a type hint even if it’s out of the scope of the current task.</p>

<p>When building an uberjar, set warnings to true as well and redirect the output into a file. Then <code class="language-plaintext highlighter-rouge">grep</code> it for “Reflection warning” and terminate the pipeline if anything is found.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein uberjar <span class="o">&gt;</span> uberjar.log
<span class="o">!</span> <span class="nb">grep</span> <span class="nt">-i</span> <span class="s1">'Reflection warning'</span> uberjar.log
</code></pre></div></div>

<h2 id="naming">Naming</h2>

<p>A common rule of naming a function with side effects is to add an exclamation mark at the end:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">upsert-user!</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">fields</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>In fact, it depends on the context. The mark by itself is needed to highlight something special among the ordinary things. Thus, if there are plenty of functions that change something, don’t use ! in the end, otherwise, the code becomes too noisy. When you highlight everything, nothing in fact is highlighted. The code below is completely fine:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">create-user</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">fields</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">delete-user</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">id</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">update-user</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">fields</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Keep in mind that the exclamation mark is not a part of the word. When selecting such a function by calling <code class="language-plaintext highlighter-rouge">M-x mark-word</code> or double-clicking on it, the “!” character stays out of the selection and you have to press some extra buttons to include it.</p>

<p>The name of a function ideally starts with a verb: <code class="language-plaintext highlighter-rouge">get-</code>, <code class="language-plaintext highlighter-rouge">set-</code>, <code class="language-plaintext highlighter-rouge">process-</code>, <code class="language-plaintext highlighter-rouge">make-</code>, and so on:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-last-task</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">client-id</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Another good pattern is to use <code class="language-plaintext highlighter-rouge">what-&gt;what</code> naming where the first <code class="language-plaintext highlighter-rouge">what</code> is the input data and the second one is the result. For example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">orders-&gt;total</span><span class="w"> </span><span class="p">[</span><span class="n">orders</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">datetime-&gt;date</span><span class="w"> </span><span class="p">[</span><span class="n">dt</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>It is only a case for a function that takes a single argument. If there are two and more, don’t use the following naming:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">orders+clients-&gt;total</span><span class="w"> </span><span class="p">[</span><span class="n">orders</span><span class="w"> </span><span class="n">clients</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>For the reader, it looks machine-generated and thus weird.</p>

<p>A question mark at the end is OK for predicates or boolean values:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-active?</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">active?</span><span class="w"> </span><span class="p">(</span><span class="nf">is-active?</span><span class="w"> </span><span class="n">user</span><span class="p">)]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Don’t put <code class="language-plaintext highlighter-rouge">?</code> in front of the name as it is confusing and mixes with Datalog:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">?active</span><span class="w"> </span><span class="p">(</span><span class="nf">is-active?</span><span class="w"> </span><span class="n">user</span><span class="p">)]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>As far as you can, provide hints on the function arguments. Don’t use common words like data or similar. In fact, everything is data, so naming this way is useless.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-stats</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Add plural “s” at the end of vectors or sequences:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-stats</span><span class="w"> </span><span class="p">[</span><span class="n">orders</span><span class="w"> </span><span class="n">users</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">process-stats</span><span class="w"> </span><span class="p">[{</span><span class="no">:order-id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">...</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:order-id</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">...</span><span class="p">}]</span><span class="w">
               </span><span class="p">[{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">...</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="n">...</span><span class="p">}])</span><span class="w">
</span></code></pre></div></div>

<p>Names like <code class="language-plaintext highlighter-rouge">id-&gt;user</code> is a good choice for maps:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-users</span><span class="w"> </span><span class="p">[</span><span class="n">id-&gt;user</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">process-users</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">...</span><span class="p">}</span><span class="n">,</span><span class="w">
                </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">...</span><span class="p">}})</span><span class="w">
</span></code></pre></div></div>

<p>It also applies to the nested maps, for example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">verb-&gt;path-&gt;response</span><span class="w">
  </span><span class="p">{</span><span class="no">:get</span><span class="w"> </span><span class="p">{</span><span class="s">"/"</span><span class="w"> </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="n">...</span><span class="p">}</span><span class="w">
         </span><span class="s">"/help"</span><span class="w"> </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="n">...</span><span class="p">}}</span><span class="w">
   </span><span class="no">:post</span><span class="w"> </span><span class="p">{</span><span class="s">"/users"</span><span class="w"> </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">400</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="n">...</span><span class="p">}}})</span><span class="w">

</span><span class="p">(</span><span class="nf">with-http-server</span><span class="w"> </span><span class="n">verb-&gt;path-&gt;response</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>If a function accepts a function, name it with the <code class="language-plaintext highlighter-rouge">fn-</code> prefix:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">error-handler</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">connect</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:fn-on-error</span><span class="w"> </span><span class="n">error-handler</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Some arguments might have a prefix like <code class="language-plaintext highlighter-rouge">map-</code>, <code class="language-plaintext highlighter-rouge">coll-</code>, <code class="language-plaintext highlighter-rouge">int-</code>, <code class="language-plaintext highlighter-rouge">str-</code> to stress the type. Use them wisely: don’t blindly add prefixes to all the vars and arguments because otherwise, the code becomes too noisy:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-events</span><span class="w"> </span><span class="p">[</span><span class="n">vec-events</span><span class="w"> </span><span class="n">int-limit</span><span class="w"> </span><span class="n">str-notice</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Type hints and pre- conditions also help to understand what’s behind an argument:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-events</span><span class="w"> </span><span class="p">[</span><span class="n">events</span><span class="w"> </span><span class="o">^</span><span class="n">Integer</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="n">notice</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-events</span><span class="w"> </span><span class="p">[</span><span class="n">events</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="n">notice</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:pre</span><span class="w"> </span><span class="p">[(</span><span class="nb">vector?</span><span class="w"> </span><span class="n">events</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">int?</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">notice</span><span class="p">)]}</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Don’t use one-letter naming for the “obvious” — as you might think — cases. If you know that “p” is for the profile and “u” is for the user, it doesn’t mean everyone is aware. Use “profile” and “user”:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; so-so</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-user</span><span class="w"> </span><span class="p">[</span><span class="n">u</span><span class="w"> </span><span class="n">p</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="c1">;; better</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-user</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="n">profile</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The core Clojure namespace uses its own naming rules. For example, <code class="language-plaintext highlighter-rouge">f</code> is for a function, <code class="language-plaintext highlighter-rouge">m</code> is for a map, <code class="language-plaintext highlighter-rouge">k</code> is for a key and so on. This is not an excuse for using the same way in your code. Leave the <code class="language-plaintext highlighter-rouge">clojure.core</code> namespace alone and use more sensible names.</p>

<p>In <code class="language-plaintext highlighter-rouge">let</code>, never shadow the <code class="language-plaintext highlighter-rouge">clojure.core</code> stuff. It’s quite common when a map has a key <code class="language-plaintext highlighter-rouge">:name</code>, and you shadow the <code class="language-plaintext highlighter-rouge">name</code> function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="p">]}</span><span class="w"> </span><span class="n">user</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="nb">name</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The same applies to <code class="language-plaintext highlighter-rouge">key</code>, <code class="language-plaintext highlighter-rouge">val</code>, <code class="language-plaintext highlighter-rouge">namespace</code> and similar functions. One day the field would change to <code class="language-plaintext highlighter-rouge">:full-name</code> but you would forget to fix the underlying code as it compiles with no errors. It will provide something weird or crash:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">full-name</span><span class="p">]}</span><span class="w"> </span><span class="n">user</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="nb">name</span><span class="p">))</span><span class="w">
</span><span class="c1">;; #function[clojure.core/name]</span><span class="w">
</span></code></pre></div></div>

<p>As a result, to destructure the name of the entity, do it manually:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="n">user-name</span><span class="w"> </span><span class="no">:name</span><span class="p">}</span><span class="w"> </span><span class="n">user</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="nb">name</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h2 id="lines-and-indentation">Lines and indentation</h2>

<p>Most of the time, use two spaces for indentation in your code. If you use Emacs and Cider, there is nothing to worry about: everything is held by the standard settings. Just press RET and TAB and the code is aligned automatically:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">some-function</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-some-macro</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="mi">42</span><span class="p">}</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">dotimes</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="mi">99</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"hello"</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>When splitting the arguments on multiple lines, keep the full indentation like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">calling-a-func-with-args</span><span class="w"> </span><span class="s">"arg one"</span><span class="w">
                          </span><span class="p">{</span><span class="no">:some</span><span class="w"> </span><span class="p">{</span><span class="no">:nested</span><span class="w"> </span><span class="s">"map"</span><span class="p">}}</span><span class="w">
                          </span><span class="n">some-variable</span><span class="w">
                          </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
                          </span><span class="n">true</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>but not this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">calling-a-func-with-args</span><span class="w"> </span><span class="s">"arg one"</span><span class="w">
  </span><span class="p">{</span><span class="no">:some</span><span class="w"> </span><span class="p">{</span><span class="no">:nested</span><span class="w"> </span><span class="s">"map"</span><span class="p">}}</span><span class="w">
  </span><span class="n">some-variable</span><span class="w">
  </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
  </span><span class="n">true</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Empty lines in code are crucial. Too often, the code is hard to read just because the whole logic collapses into a huge dump of text. Empty lines play the same role that paragraphs do in text. Imagine a book without a single paragraph: an endless monolithic feed of characters impossible to read. Paragraphs give your brain a moment to take a breath before proceed to the next thought. Empty lines in code act the same: they give your readers some rest before moving to the next step.</p>

<p>Use empty lines to split logical parts. For example, you have a long <code class="language-plaintext highlighter-rouge">let</code> binding and then you compute something. Add an empty line between the binding vector and the body:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">some-long-function</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">calc-this</span><span class="w">
        </span><span class="p">(</span><span class="nf">some-vast-function</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w">

        </span><span class="n">calc-that</span><span class="w">
        </span><span class="p">(</span><span class="nf">some-another-function</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w">

        </span><span class="n">users</span><span class="w">
        </span><span class="p">(</span><span class="nf">some-massive-query-to-db</span><span class="w"> </span><span class="n">calc-that</span><span class="p">)</span><span class="w">

        </span><span class="n">events</span><span class="w">
        </span><span class="p">(</span><span class="nf">some-http-request</span><span class="w"> </span><span class="n">...</span><span class="p">)]</span><span class="w">
                                  </span><span class="c1">;; &lt;-</span><span class="w">
    </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="n">users</span><span class="p">]</span><span class="w">
      </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>When a function has multiple forms, again, separate them with an empty line. Otherwise, they’re quite difficult to read. Compare these two forms:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">error!</span><span class="w">
  </span><span class="p">([</span><span class="n">message</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="p">{})))</span><span class="w">
  </span><span class="p">([</span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="p">)))</span><span class="w">
  </span><span class="p">([</span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">cause</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">cause</span><span class="p">))))</span><span class="w">

</span><span class="c1">;; vs</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">error!</span><span class="w">

  </span><span class="p">([</span><span class="n">message</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="p">{})))</span><span class="w">

  </span><span class="p">([</span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="p">)))</span><span class="w">

  </span><span class="p">([</span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">cause</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">cause</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Adding a line after the arguments makes them clearer especially when there are a docstring, pre- and post- checks, meta and so on. All of that must be separated from the body:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">some-complex-func</span><span class="w">
  </span><span class="s">"This function does this and that..."</span><span class="w">
  </span><span class="p">[</span><span class="n">users</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="n">some-arg</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:pre</span><span class="w"> </span><span class="p">[(</span><span class="nb">seq</span><span class="w"> </span><span class="n">users</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">int?</span><span class="w"> </span><span class="n">limit</span><span class="p">)]</span><span class="w">
   </span><span class="no">:post</span><span class="w"> </span><span class="p">[(</span><span class="nb">map?</span><span class="w"> </span><span class="n">%</span><span class="p">)]}</span><span class="w">
                     </span><span class="c1">;; &lt;-</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">events</span><span class="w">
        </span><span class="p">(</span><span class="nf">get-events</span><span class="w"> </span><span class="n">...</span><span class="p">)]</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The same applies to <code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">doseq</code> and other forms. Adding just one extra line makes them much more readable:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">item</span><span class="w"> </span><span class="n">items</span><span class="w">
        </span><span class="no">:let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="n">title</span><span class="p">]}</span><span class="w"> </span><span class="n">item</span><span class="p">]</span><span class="w">
        </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nf">some?</span><span class="w"> </span><span class="n">id</span><span class="p">)]</span><span class="w">
                           </span><span class="c1">;; &lt;-</span><span class="w">
  </span><span class="p">(</span><span class="nf">process-item</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Separate top-level def and defn forms with two empty lines. That really helps one’s eyes to navigate through them.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">create-user</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
                     </span><span class="c1">;; 1</span><span class="w">
                     </span><span class="c1">;; 2</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">udpate-user</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
                     </span><span class="c1">;; 1</span><span class="w">
                     </span><span class="c1">;; 2</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-user</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>But inside a definition, use only a single line, not two:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">some-func</span><span class="w"> </span><span class="p">[</span><span class="n">arg1</span><span class="w"> </span><span class="n">arg2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="w">
        </span><span class="n">y</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
                  </span><span class="c1">;; that's</span><span class="w">
                  </span><span class="c1">;; too much space</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Empty lines look odd in GitHub’s web interface because of CSS. The distance between the lines is higher than most desktop editors have by default. Be aware of this: code that looks good in web might look bad in the editor.</p>

<h2 id="maps">Maps</h2>

<p>Some developers align maps this way:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:name</span><span class="w">    </span><span class="s">"John Smith"</span><span class="w">
 </span><span class="no">:active?</span><span class="w"> </span><span class="n">true</span><span class="w">
 </span><span class="no">:email</span><span class="w">   </span><span class="s">"john@test.com"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Editors do that manually, for example, Emacs fixes the indentation within the <code class="language-plaintext highlighter-rouge">M-x clojure-align</code> command.</p>

<p>Personally, I see a problem with this approach. Too often, when a map consists of short keys, suddenly here comes a long one and vice versa: a map with long keys obtains a short one. Now if you align an updated map you’ll get:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:name</span><span class="w">             </span><span class="s">"John Smith"</span><span class="w">
 </span><span class="no">:id</span><span class="w">               </span><span class="mi">9</span><span class="w">
 </span><span class="no">:active?</span><span class="w">          </span><span class="n">true</span><span class="w">
 </span><span class="no">:email</span><span class="w">            </span><span class="s">"john@test.com"</span><span class="w">
 </span><span class="no">:number-of-orders</span><span class="w"> </span><span class="mi">232</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>These gaps look ugly to me. What I usually prefer is to reorder a map manually. I put short keys on top of it and long ones below.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">9</span><span class="w">
 </span><span class="no">:name</span><span class="w"> </span><span class="s">"John Smith"</span><span class="w">
 </span><span class="no">:email</span><span class="w"> </span><span class="s">"john@test.com"</span><span class="w">
 </span><span class="no">:active?</span><span class="w"> </span><span class="n">true</span><span class="w">
 </span><span class="no">:number-of-orders</span><span class="w"> </span><span class="mi">232</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Another trick is to keep the longest keys apart from normal ones, then align each group:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:id</span><span class="w">      </span><span class="mi">9</span><span class="w">
 </span><span class="no">:name</span><span class="w">    </span><span class="s">"John Smith"</span><span class="w">
 </span><span class="no">:email</span><span class="w">   </span><span class="s">"john@test.com"</span><span class="w">
 </span><span class="no">:active?</span><span class="w"> </span><span class="n">true</span><span class="w">

 </span><span class="no">:another-long-field</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">}</span><span class="w">
 </span><span class="no">:number-of-orders</span><span class="w">   </span><span class="mi">232</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="let">Let</h2>

<p>The <code class="language-plaintext highlighter-rouge">let</code> macro is special in Clojure. It’s the most used form in general. Most often, a function consists of a single <code class="language-plaintext highlighter-rouge">let</code> form where you prepare something and then compose a final result.</p>

<p>What is important about <code class="language-plaintext highlighter-rouge">let</code>, the way you format it really affects the whole codebase. Thus, I’ve come up with some rules about <code class="language-plaintext highlighter-rouge">let</code> which I consider highly important.</p>

<p><code class="language-plaintext highlighter-rouge">Let</code> suffers from the same problem we mentioned about maps. If you don’t alight key-value pairs, they become hard to read:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="p">(</span><span class="no">:id</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w">
      </span><span class="n">accounts-to-delete</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from accounts where something"</span><span class="w"> </span><span class="mi">42</span><span class="p">])</span><span class="w">
      </span><span class="n">profiles</span><span class="w"> </span><span class="p">(</span><span class="nf">rest/get-pending-profiles</span><span class="w"> </span><span class="n">api</span><span class="w"> </span><span class="s">"/api/v1/profiles/"</span><span class="p">)]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>But if you align them, ugly gaps appear:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w">                 </span><span class="p">(</span><span class="no">:id</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w">
      </span><span class="n">accounts-to-delete</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from accounts where something"</span><span class="w"> </span><span class="mi">42</span><span class="p">])</span><span class="w">
      </span><span class="n">profiles</span><span class="w">           </span><span class="p">(</span><span class="nf">rest/get-pending-profiles</span><span class="w"> </span><span class="n">api</span><span class="w"> </span><span class="s">"/api/v1/profiles/"</span><span class="p">)]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Both writings are difficult to read. Thus, put the value on the next line after the name and separate pairs with an empty line:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w">
      </span><span class="p">(</span><span class="no">:id</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w">

      </span><span class="n">accounts-to-delete</span><span class="w">
      </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from accounts where something"</span><span class="w"> </span><span class="mi">42</span><span class="p">])</span><span class="w">

      </span><span class="n">profiles</span><span class="w">
      </span><span class="p">(</span><span class="nf">rest/get-pending-profiles</span><span class="w"> </span><span class="n">api</span><span class="w"> </span><span class="s">"/api/v1/profiles/"</span><span class="p">)]</span><span class="w">

  </span><span class="p">(</span><span class="nf">process-all-of-that</span><span class="w"> </span><span class="n">id</span><span class="w">
                       </span><span class="n">accounts-to-delete</span><span class="w">
                       </span><span class="n">profiles</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>This syntax, although looks strange at first glance, proves the best traits through time. It’s clear and easy to read as the items are separated. It’s free from gaps. It grows down but not to the right. It’s always easy to extend it.</p>

<h2 id="case-cond">Case, cond</h2>

<p>The same syntax applies to the <code class="language-plaintext highlighter-rouge">case</code> and <code class="language-plaintext highlighter-rouge">cond</code> forms. Since they accept key-value pairs, put the second item under the first and separate with an empty line:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">cond</span><span class="w">
  </span><span class="p">(</span><span class="nf">check-this?</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">process-that</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">

  </span><span class="p">(</span><span class="nf">now-check-that?</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">with-transaction</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">jdbc/execute</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="n">...</span><span class="p">)))</span><span class="w">

  </span><span class="p">(</span><span class="nf">one-more-case?</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">something</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">

  </span><span class="no">:else</span><span class="w">
  </span><span class="p">(</span><span class="nf">default-case</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Now compare it to the standard way of writing: which is easier to read?</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">cond</span><span class="w">
  </span><span class="p">(</span><span class="nf">check-this?</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">process-that</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">now-check-that?</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w">
                          </span><span class="p">(</span><span class="nf">with-transaction</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
                            </span><span class="p">(</span><span class="nf">jdbc/execute</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="n">...</span><span class="p">)))</span><span class="w">
  </span><span class="p">(</span><span class="nf">one-more-case?</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">something</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
  </span><span class="no">:else</span><span class="w"> </span><span class="p">(</span><span class="nf">default-case</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h2 id="macros-indentation">Macros indentation</h2>

<p>When writing a macro, keep in mind whether it is mostly used with the first threading operator (<code class="language-plaintext highlighter-rouge">-&gt;</code>) or not. Sometimes, it affects the styling/indent parameter. For example, you made a then macro to pipe a value through a set of forms. This macro takes a previous form, a binding symbol and an arbitrary body:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">then</span><span class="w">
  </span><span class="p">[</span><span class="n">value</span><span class="w"> </span><span class="p">[</span><span class="n">bind</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="o">~</span><span class="n">bind</span><span class="w"> </span><span class="o">~</span><span class="n">value</span><span class="p">]</span><span class="w">
     </span><span class="o">~@</span><span class="n">body</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>A quick example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p">(</span><span class="nf">then</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">then</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">then</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span></code></pre></div></div>

<p>Since the macro takes two parameters, most likely you specify <code class="language-plaintext highlighter-rouge">{:style/indent 2}</code> as follows:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">then</span><span class="w">
  </span><span class="p">{</span><span class="no">:style/indent</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>It works correctly when the macro is called without any other macro:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>But with <code class="language-plaintext highlighter-rouge">-&gt;</code>, the indentation fails because the macro gets one parameter:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p">(</span><span class="nf">then</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">then</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>What you need to do is to set <code class="language-plaintext highlighter-rouge">{:style/indent 1}</code> for the macro. With this change, the automatic indentation looks correct:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p">(</span><span class="nf">then</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">then</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h2 id="java-interop">Java interop</h2>

<p>Try to keep Java interop in a separate namespace. When there is too much interop, the code becomes noisy and “Javish”. Provide clean and Clojure-friendly API to cooperate with Java stuff. For example, a dedicated namespace for codecs (Base64 encode, decode), cryptography (ordinary hashes and Hash-HMAC), dates and so on.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">project.codec</span><span class="w">
  </span><span class="p">(</span><span class="no">:import</span><span class="w">
   </span><span class="n">java.text.Normalizer</span><span class="w">
   </span><span class="n">java.text.Normalizer$Form</span><span class="w">
   </span><span class="n">java.util.Base64</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">b64-decode</span><span class="w"> </span><span class="o">^</span><span class="n">bytes</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">bytes</span><span class="w"> </span><span class="n">input</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">.decode</span><span class="w"> </span><span class="p">(</span><span class="nf">Base64/getDecoder</span><span class="p">)</span><span class="w"> </span><span class="n">input</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">b64-encode</span><span class="w"> </span><span class="o">^</span><span class="n">bytes</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">bytes</span><span class="w"> </span><span class="n">input</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">.encode</span><span class="w"> </span><span class="p">(</span><span class="nf">Base64/getEncoder</span><span class="p">)</span><span class="w"> </span><span class="n">input</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">normalize-nfc</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="n">string</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">Normalizer/normalize</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">Normalizer$Form/NFC</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Then:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">project.core</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">project.codec</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">codec</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">codec/b64-decode</span><span class="w"> </span><span class="p">(</span><span class="nf">some-bytes</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>One day you can improve this namespace by introducing ClojureScript support on top of other underlying classes.</p>

<h2 id="java-like-classes">Java-like classes</h2>

<p>Everyone who ever worked on vast Clojure projects is familiar with something called “map hell”. This is when a function accepts three or four maps and you have no idea what is inside them. Although tests and REPL might help, still it’s a challenge to get on with such code. “Maps, maps are everywhere” (buzz-lighter.jpeg).</p>

<p>If you’re tired of maps, try the Java approach: classes. Conseal maps in a <code class="language-plaintext highlighter-rouge">deftype</code> instance and provide a protocol to access their fields. In one project I had three maps which completed each other and acted like a source of truth for something. It was really a mess to get one piece of data from map1, then fetch the second piece from map2 and so on. Instead, I made an interface:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defprotocol</span><span class="w"> </span><span class="n">IStorage</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-this-field</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">])</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-another-field</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">])</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-item-by-idx</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">idx</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>then a type that holds the maps and implements the interface:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftype</span><span class="w"> </span><span class="n">Storage</span><span class="w">
  </span><span class="p">[</span><span class="n">map1</span><span class="w"> </span><span class="n">map2</span><span class="w"> </span><span class="n">map3</span><span class="p">]</span><span class="w">

  </span><span class="n">IStorage</span><span class="w">

  </span><span class="p">(</span><span class="nf">get-this-field</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">chunk1</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">map1</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">])</span><span class="w">
          </span><span class="n">chunk2</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">map2</span><span class="w"> </span><span class="p">[</span><span class="no">:foo</span><span class="w"> </span><span class="p">(</span><span class="no">:id</span><span class="w"> </span><span class="n">chunk1</span><span class="p">)])</span><span class="w">
          </span><span class="n">chunk3</span><span class="w"> </span><span class="p">(</span><span class="nf">get-something-from</span><span class="w"> </span><span class="n">map3</span><span class="p">)</span><span class="w">
          </span><span class="n">...</span><span class="p">]</span><span class="w">
      </span><span class="p">{</span><span class="no">:some</span><span class="w"> </span><span class="s">"result"</span><span class="p">}))</span><span class="w">

  </span><span class="p">(</span><span class="nf">get-item-by-idx</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">idx</span><span class="p">]</span><span class="w">
    </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">map1</span><span class="w"> </span><span class="n">some-path</span><span class="p">)</span><span class="w">
     </span><span class="no">:title</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">map2</span><span class="w"> </span><span class="n">another-path</span><span class="p">)}))</span><span class="w">
</span></code></pre></div></div>

<p>A final step would be to provide a constructor function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-storage</span><span class="w"> </span><span class="p">[</span><span class="n">map1</span><span class="w"> </span><span class="n">map2</span><span class="w"> </span><span class="n">map3</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Storage</span><span class="w"> </span><span class="n">map1</span><span class="w"> </span><span class="n">map2</span><span class="w"> </span><span class="n">map3</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Now that you have all of that, operate on the instance of <code class="language-plaintext highlighter-rouge">Storage</code> but not the raw maps:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">storage</span><span class="w">
      </span><span class="p">(</span><span class="nf">storage/make-storage</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="n">m2</span><span class="w"> </span><span class="n">m3</span><span class="p">)</span><span class="w">

      </span><span class="n">this-field</span><span class="w">
      </span><span class="p">(</span><span class="nf">storage/get-this-field</span><span class="w"> </span><span class="n">storage</span><span class="p">)</span><span class="w">

      </span><span class="n">item</span><span class="w">
      </span><span class="p">(</span><span class="nf">storage/get-item-by-idx</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="mi">9</span><span class="p">)]</span><span class="w">

  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Moreover, add the <code class="language-plaintext highlighter-rouge">^Storage</code> type hint to the argument so everyone knows it’s an instance of a class with its own API but not an ordinary Clojure collection. This approach, although looks slightly foreign, really pays off in vast projects.</p>

<h2 id="reuse-java-classes">Reuse Java classes</h2>

<p>Java VM brings plenty of things that have been developed for years. Not using them in favour of writing your own code is usually a bad idea. Often, I found some code written just because a programmer was not aware of existing JVM functionality. Most likely this code is poorly tested and doesn’t take into account plenty of corner cases. Here are some examples:</p>

<ul>
  <li>manual URL parsing and building;</li>
  <li>manual URL encoding and decoding;</li>
  <li>poor IO based on <code class="language-plaintext highlighter-rouge">spit</code> and <code class="language-plaintext highlighter-rouge">slurp</code> functions rather than input/output streams and readers/writers;</li>
  <li>lack of knowledge of built-in Java collections (ArrayList, Stack);</li>
  <li>poor processing of byte arrays;</li>
</ul>

<p>Even if Java is not a language you came from, it’s definitely worth investing your time in it just to write better Clojure code.</p>

<h2 id="systems-and-components">Systems and Components</h2>

<p>To manage a global state with various data sources, cron jobs, background tasks and so on use systems and components. Pick one of three good, well-known libraries: Component, Integrant, or Mount. The first two will be a good option. Mount is a bit questionable as it relies on global variables which brings some difficulties to testing; still, it’s better than inventing your own way of state management.</p>

<p>Once you picked a certain library, stick with it to the end. What I mean here, I often see code like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-main</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="w"> </span><span class="p">(</span><span class="nf">read-config</span><span class="w"> </span><span class="n">...</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">initiate-sytem</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">start-system</span><span class="p">)</span><span class="w">

    </span><span class="p">(</span><span class="nf">initiate-cronjobs</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">initiate-something-else</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">etc</span><span class="w"> </span><span class="n">...</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Here, a programmer initiates and starts a system, but then he or she also starts some additional background stuff like cronjobs or similar. It doesn’t have to be like this. A cronjob must be a component that spawns a scheduler and knows how to stop it. There is no way to reuse the <code class="language-plaintext highlighter-rouge">-main</code> function in tests because you have no control over the background tasks.</p>

<p>Instead, when everything is held by a system, that’s extremely easy to tune it and write tests for it. For example, you just remove the cronjob component from the system as it’s useless for testing.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fixture-system</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">initiate-sytem</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="p">{</span><span class="no">:drop</span><span class="w"> </span><span class="p">[</span><span class="no">:cronjob</span><span class="p">]})</span><span class="w">
  </span><span class="p">(</span><span class="nf">start-system</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">stop-system</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>When building a system, be as much declarative as you ever can be. I often see programmers compose a system manually like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">init-system</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">component/system-map</span><span class="w">
   </span><span class="no">:database</span><span class="w"> </span><span class="p">(</span><span class="nf">db/make-database</span><span class="w"> </span><span class="p">(</span><span class="no">:db</span><span class="w"> </span><span class="n">config</span><span class="p">))</span><span class="w">
   </span><span class="no">:redis</span><span class="w"> </span><span class="p">(</span><span class="nf">redis/make-redis</span><span class="w"> </span><span class="p">(</span><span class="no">:redis</span><span class="w"> </span><span class="n">config</span><span class="p">))</span><span class="w">
   </span><span class="no">:sendmail</span><span class="w"> </span><span class="p">(</span><span class="nf">component/using</span><span class="w"> </span><span class="p">(</span><span class="nf">sendmail/sendmail</span><span class="w">
                               </span><span class="p">(</span><span class="no">:sendmail</span><span class="w"> </span><span class="n">config</span><span class="p">))</span><span class="w">
                              </span><span class="p">[</span><span class="no">:database</span><span class="w"> </span><span class="no">:redis</span><span class="p">])</span><span class="w">
   </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Instead, declare a map where the key of a component relates to its constructor:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">component-map</span><span class="w">
  </span><span class="p">{</span><span class="no">:database</span><span class="w"> </span><span class="n">db/make-database</span><span class="w">
   </span><span class="no">:redis</span><span class="w">    </span><span class="n">redis/make-redis</span><span class="w">
   </span><span class="no">:sendmail</span><span class="w"> </span><span class="n">sendmail/sendmail</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Declare a second map which specifies dependencies:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">using-map</span><span class="w">
  </span><span class="p">{</span><span class="no">:sendmail</span><span class="w"> </span><span class="p">[</span><span class="no">:database</span><span class="w"> </span><span class="no">:redis</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Now that you have these two, write a function that takes a config map and:</p>

<ul>
  <li>Travers on the first map passing the corresponding config values into the constructors;</li>
  <li>Travers on the second map to specify dependencies with <code class="language-plaintext highlighter-rouge">(using ...)</code>.</li>
</ul>

<p>Wrap the result into the <code class="language-plaintext highlighter-rouge">System</code> class, then start it, and you’re fine.</p>

<p>Having a system being run, never reach its components using <code class="language-plaintext highlighter-rouge">get</code>, <code class="language-plaintext highlighter-rouge">get-in</code> or similar. This is a gross violation of the system design. Instead, pass only required components into the functions. For the same reason don’t store a system in a global variable. That can only be an excuse when listening for SIGTERM or other signals to safely shut down the system. A variable that holds a system must be private.</p>

<h2 id="collections">Collections</h2>

<p>Don’t use long <code class="language-plaintext highlighter-rouge">-&gt;</code> and <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> threading chains. Having more than 3-4 tears, they become difficult to read especially when the types differs.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">what-is-it?</span><span class="w">
      </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="mi">42</span><span class="w">                  </span><span class="c1">;; long</span><span class="w">
          </span><span class="n">db/get-user-by-id</span><span class="w">   </span><span class="c1">;; a map</span><span class="w">
          </span><span class="no">:password</span><span class="w">           </span><span class="c1">;; a string field</span><span class="w">
          </span><span class="n">.getBytes</span><span class="w">           </span><span class="c1">;; byte array</span><span class="w">
          </span><span class="n">codec/b64-encode</span><span class="w">    </span><span class="c1">;; byte array</span><span class="w">
          </span><span class="n">String.</span><span class="p">)])</span><span class="w">          </span><span class="c1">;; string</span><span class="w">
</span></code></pre></div></div>

<p>Instead, split the chain on several intermediate steps to make it easier for debugging.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">encode-password</span><span class="w"> </span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="n">password</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">password</span><span class="w">
      </span><span class="p">(</span><span class="nf">.getBytes</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">codec/b64-encode</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">String.</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w">
      </span><span class="p">(</span><span class="nf">db/get-user-by-id</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w">

      </span><span class="n">password</span><span class="w">
      </span><span class="p">(</span><span class="no">:password</span><span class="w"> </span><span class="n">user</span><span class="p">)</span><span class="w">

      </span><span class="n">password-encoded</span><span class="w">
      </span><span class="p">(</span><span class="nf">encode-password</span><span class="w"> </span><span class="n">password</span><span class="p">)]</span><span class="w">

  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> macro is mostly used for processing collections because <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code> and similar functions accept a collection at the second argument. The problem with <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> is, it’s read less easily than <code class="language-plaintext highlighter-rouge">-&gt;</code> so use it only when it’s completely clear what’s happening.</p>

<p>The <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> macro becomes a mess when used with vast anonymous predicates:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">entity</span><span class="w"> </span><span class="no">:info</span><span class="w"> </span><span class="no">:companies</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">some-id</span><span class="w"> </span><span class="p">(</span><span class="no">:guid</span><span class="w"> </span><span class="n">%</span><span class="p">)))</span><span class="w">
     </span><span class="nb">first</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="p">[</span><span class="no">:some-field</span><span class="w"> </span><span class="no">:items</span><span class="p">])</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="no">:amount</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="nf">every-pred</span><span class="w"> </span><span class="p">(</span><span class="nb">complement</span><span class="w"> </span><span class="nb">nil?</span><span class="p">)</span><span class="w"> </span><span class="n">int?</span><span class="p">))</span><span class="w">
     </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">+</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">nodes</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">some-function!</span><span class="w"> </span><span class="n">entity-id</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w">
     </span><span class="p">(</span><span class="nb">doall</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">some.ns/process!</span><span class="w"> </span><span class="n">entity-id</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">process-data!</span><span class="w"> </span><span class="n">task-id</span><span class="w"> </span><span class="n">resource-type</span><span class="w"> </span><span class="n">end-cursor</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Reading such code takes a while. Either transform a predicate into a top-level function or declare it in <code class="language-plaintext highlighter-rouge">let</code>.</p>

<p>The general idea of using <code class="language-plaintext highlighter-rouge">-&gt;</code> and <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> is: chaining stuff by itself doesn’t mean clearness of the code. Most of the times, you’ve got to split the things for better reading and debugging.</p>

<p>Don’t use <code class="language-plaintext highlighter-rouge">as-&gt;</code> macro which is a mixture of <code class="language-plaintext highlighter-rouge">-&gt;</code> and <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code>. Use separate <code class="language-plaintext highlighter-rouge">-&gt;</code> and <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> forms for that.</p>

<p>Prefer <code class="language-plaintext highlighter-rouge">vec</code> over <code class="language-plaintext highlighter-rouge">(into [] ...)</code> just because it’s shorter and clearer:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">item</span><span class="w"> </span><span class="n">items</span><span class="p">]</span><span class="w">
       </span><span class="n">...</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">item</span><span class="w"> </span><span class="n">items</span><span class="p">]</span><span class="w">
           </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Don’t use a collection as a function because if a collection is a nil, you’ll get NPE. The only good example of this might be a hardcoded set for filtering:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:active</span><span class="w"> </span><span class="no">:inactive</span><span class="p">}</span><span class="w"> </span><span class="n">statuses</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Loop</code> and <code class="language-plaintext highlighter-rouge">reduce</code> are good places for transient collections which work faster. It’s quite simple to turn an immutable version of <code class="language-plaintext highlighter-rouge">loop/recur</code> into the transient one:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">reduce</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">acc</span><span class="w"> </span><span class="n">item</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="p">(</span><span class="no">:field</span><span class="w"> </span><span class="n">item</span><span class="p">)))</span><span class="w">
 </span><span class="p">[]</span><span class="w">
 </span><span class="n">items</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>becomes:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">persistent!</span><span class="w">
 </span><span class="p">(</span><span class="nb">reduce</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">acc!</span><span class="w"> </span><span class="n">item</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">conj!</span><span class="w"> </span><span class="n">acc!</span><span class="w"> </span><span class="p">(</span><span class="no">:field</span><span class="w"> </span><span class="n">item</span><span class="p">)))</span><span class="w">
  </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="p">[])</span><span class="w">
  </span><span class="n">items</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>And</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="mi">0</span><span class="w">
       </span><span class="n">acc</span><span class="w"> </span><span class="p">[]]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w">
    </span><span class="n">acc</span><span class="w">
    </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="p">(</span><span class="nf">get-item</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>becomes:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="mi">0</span><span class="w">
       </span><span class="n">acc!</span><span class="w"> </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="p">[])]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">persistent!</span><span class="w"> </span><span class="n">acc!</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">conj!</span><span class="w"> </span><span class="n">acc!</span><span class="w"> </span><span class="p">(</span><span class="nf">get-item</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>In general, avoid laziness. Although the idea of lazy computation is great, often it’s better to get an exception right now rather than in further computations. Thus, prepend <code class="language-plaintext highlighter-rouge">for</code> macro with <code class="language-plaintext highlighter-rouge">vec</code>. <code class="language-plaintext highlighter-rouge">Mapv</code>, <code class="language-plaintext highlighter-rouge">filterv</code> are also great as they rely on transient vectors:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="no">:user-name</span><span class="w"> </span><span class="n">coll-users</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">item</span><span class="w"> </span><span class="n">items</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nf">get-something</span><span class="w"> </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Obviously, this is not the case for infinite collections or collections that fetch their data from network. Turning them into vectors would occupy too many resources or saturate bandwidth.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; never vec/doall this</span><span class="w">
</span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">file</span><span class="w"> </span><span class="p">(</span><span class="nf">s3/get-files-seq</span><span class="w"> </span><span class="n">...</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">process-file</span><span class="w"> </span><span class="n">file</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h2 id="clojurespec">Clojure.spec</h2>

<p>Writing function definitions with <code class="language-plaintext highlighter-rouge">fdef</code> is a good habit. Using the <a href="https://github.com/jeaye/orchestra">Orchestra library</a> you can enable instrumentation for the whole project while testing it. The only thing that deserves to be mentioned here is to keep the specs in a separate file. When functions mix with their <code class="language-plaintext highlighter-rouge">fdef</code>s, the code becomes noisy and difficult to read.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/fdef</span><span class="w"> </span><span class="n">process-user</span><span class="w">
  </span><span class="no">:args</span><span class="w"> </span><span class="p">(</span><span class="nf">s/cat</span><span class="w"> </span><span class="no">:user</span><span class="w"> </span><span class="no">::user</span><span class="w">
               </span><span class="no">:profile</span><span class="w"> </span><span class="no">::profile</span><span class="w">
               </span><span class="no">:flag?</span><span class="w"> </span><span class="n">boolean?</span><span class="p">)</span><span class="w">
  </span><span class="no">:ret</span><span class="w"> </span><span class="nb">map?</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-user</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="n">profile</span><span class="w"> </span><span class="n">flag?</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h2 id="types--records">Types &amp; Records</h2>

<p>Always provide a constructor for a <code class="language-plaintext highlighter-rouge">deftype</code> or <code class="language-plaintext highlighter-rouge">defrecord</code> definition. It must be a function with a docstring that accepts only the required slots and initiates a class. Without a constructor that’s unclear how to initiate it, what slots are required and so on.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">SomeComponent</span><span class="w">
    </span><span class="p">[</span><span class="n">host</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">on-error</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-component</span><span class="w"> </span><span class="p">[</span><span class="n">host</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">on-error</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">map-&gt;SomeComponent</span><span class="w"> </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="n">host</span><span class="w">
                       </span><span class="no">:port</span><span class="w"> </span><span class="n">port</span><span class="w">
                       </span><span class="no">:on-error</span><span class="w"> </span><span class="n">on-error</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>When declaring a component with <code class="language-plaintext highlighter-rouge">defrecord</code>, divide its slots into three groups: initial arguments, the inner state and dependencies. Use comments to split them off:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">SomeComponent</span><span class="w">
    </span><span class="p">[</span><span class="c1">;; init</span><span class="w">
     </span><span class="n">host</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="n">on-error</span><span class="w">

     </span><span class="c1">;; runtime</span><span class="w">
     </span><span class="n">state</span><span class="w">

     </span><span class="c1">;; deps</span><span class="w">
     </span><span class="n">cache</span><span class="w"> </span><span class="n">db</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Without grouping, it’s difficult to guess what is what.</p>

<h2 id="named-sections">Named sections</h2>

<p>Avoid using wide commented sections in your file like the following below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; --------------------------
;; -------- Handlers --------
;; --------------------------
</code></pre></div></div>

<p>or</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;
;; &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt; Routes &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;
;; &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;
</code></pre></div></div>

<p>They consume space but do nothing. The very presence of such sections proves the file should have been split on two or three. For example, <code class="language-plaintext highlighter-rouge">routing.clj</code>, <code class="language-plaintext highlighter-rouge">handlers.clj</code>, <code class="language-plaintext highlighter-rouge">server.clj</code> and so on. People who put sections will leave the project one day. Other programmers most likely will push the new stuff to the end of a file skipping all that sectioning.</p>

<p>Needless to say, non-ASCII characters like check marks, fat dots and similar are strictly prohibited in sections as they attract too much attention.</p>

<h2 id="comments">Comments</h2>

<p>Comments are fine when used thriftily. Consider a comment as the last resort to deliver your intentions to the reader. In rare cases, the logic is complicated and full of tricks indeed so you have to leave a hint for other developers. It’s quite annoying to realize that a previous developer knew something extraordinary about the logic but didn’t let you know.</p>

<p>Long comments are another extreme. They rot in time and no one reads them. Don’t pollute the code with long explanations of why it made such and such nor what must be done next. Create an issue or a document and dump all your mind there, but not in the code. A link to that document or its short name like “FOO-123” is enough.</p>

<h2 id="trailing-spaces">Trailing spaces</h2>

<p>Your code must be free from trailing spaces. If you use Emacs, add the following code to the config file:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">add-hook</span><span class="w"> </span><span class="ss">'before-save-hook</span><span class="w"> </span><span class="ss">'delete-trailing-whitespace</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>It drops the trailing spaces every time you save a file.</p>

<h2 id="commented-code-and-dev-sections">Commented code and dev sections</h2>

<p>There cannot be an excuse for having commented lines in your code:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">some-function</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="c1">;; The old version of that function</span><span class="w">
</span><span class="c1">;; (defn some-function [a b c d]</span><span class="w">
</span><span class="c1">;;   ...)</span><span class="w">
</span></code></pre></div></div>

<p>Whenever you see it, drop it immediately. People who’re interested will find it in the git history. The only exception is a dev section at the bottom of a file wrapped into a <code class="language-plaintext highlighter-rouge">comment</code> macro:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">comment</span><span class="w">

  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">-db</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/connect</span><span class="w"> </span><span class="s">"localhost"</span><span class="w"> </span><span class="mi">5432</span><span class="p">))</span><span class="w">

  </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">-row</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/execute</span><span class="w"> </span><span class="n">-db</span><span class="w"> </span><span class="s">"select 1"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>This code, though never compiled, still can be evaluated in REPL. Having long dev sections is controversial: they become stale in time, they rely on personal credentials and so on. Keep them short.</p>

<h2 id="tests">Tests</h2>

<p>The standard <code class="language-plaintext highlighter-rouge">clojure.test</code> framework is good enough for all kinds of testing: unit, integration, smoke and so on. There hardly can be a reason to drive the tests with another third-party library. Often, people just don’t know how to organize their tests properly. Invest your time in <code class="language-plaintext highlighter-rouge">clojure.test</code>, especially fixtures.</p>

<p>Name your tests with a <code class="language-plaintext highlighter-rouge">test-</code> prefix to distinguish them from ordinary functions in the table of contents of a file (when using <code class="language-plaintext highlighter-rouge">imenu</code> or similar in Emacs):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-user-auth-ok</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-user-auth-fails</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The same about fixtures: use the <code class="language-plaintext highlighter-rouge">fix-</code> or <code class="language-plaintext highlighter-rouge">fixture-</code> prefix to stress this is a fixture but not a normal function.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fixture-prepare-db</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">insert-the-data</span><span class="w"> </span><span class="n">*db*</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">delete-the-data</span><span class="w"> </span><span class="n">*db*</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Tests must be placed in a separate directory, usually test in the root of a project. Don’t follow the Python approach when each module has a test one next to it in the same directory:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user.clj
user_test.clj
order.clj
order_test.clj
</code></pre></div></div>

<p>Tagging tests is a good practice to optimize the CI pipeline. For example, first you run unit tests that don’t require an environment:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein <span class="nb">test</span> :unit
<span class="c"># or</span>
lein <span class="nb">test</span> <span class="c"># default selector</span>
</code></pre></div></div>

<p>If everything went fine, bootstrap Docker and run integration tests.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up -d
lein test :integration
</code></pre></div></div>

<p>Here is how selectors look in code:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="o">^</span><span class="no">:unit</span><span class="w"> </span><span class="n">test-some-pure-function</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="o">^</span><span class="no">:integration</span><span class="w"> </span><span class="n">test-some-db-logic</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>A hint: instead of marking each test in a namespace, mark just the namespace so its tags are applied to each test:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="o">^</span><span class="no">:unit</span><span class="w"> </span><span class="n">project.pure-function-tests</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="o">^</span><span class="no">:integration</span><span class="w"> </span><span class="n">project.system-test</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Avoid using <code class="language-plaintext highlighter-rouge">with-redefs</code> macro in the tests as most likely it indicates problems. The less you monkey-patch in a test session, the better and more stable your code is. If the code you’re testing needs a file, prepare that file in a fixture and then delete it. If it needs a database, MQ, Kafka, cache, or whatever — run it in docker-compose and aim the settings to “localhost”. If a test reaches some HTTP API, make a fixture that runs a local Ring server that serves JSON from a file.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-local-http</span><span class="w">
  </span><span class="p">[[</span><span class="n">port</span><span class="w"> </span><span class="n">verb-&gt;path-&gt;response</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">handler</span><span class="o">#</span><span class="w">
         </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
           </span><span class="p">(</span><span class="nf">get-response-from-the-mapping</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">

         </span><span class="n">server</span><span class="o">#</span><span class="w">
         </span><span class="p">(</span><span class="nf">jetty/run-jetty</span><span class="w"> </span><span class="n">handler</span><span class="o">#</span><span class="p">)]</span><span class="w">

     </span><span class="p">(</span><span class="nf">try</span><span class="w">
       </span><span class="o">~@</span><span class="n">body</span><span class="w">
       </span><span class="p">(</span><span class="nf">finally</span><span class="w">
         </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="n">server</span><span class="o">#</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-some-api</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-local-http</span><span class="w"> </span><span class="p">[</span><span class="mi">8080</span><span class="w"> </span><span class="p">{</span><span class="no">:get</span><span class="w"> </span><span class="p">{</span><span class="s">"/v1/users"</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">}}}]</span><span class="w">
    </span><span class="p">(</span><span class="nf">run-function-that-calls-the-api</span><span class="w"> </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>All of these are much better than a dull usage of <code class="language-plaintext highlighter-rouge">with-redefs</code>. It gives you only a vision that the tests have passed whereas local HTTP and Docker prove it.</p>

<h2 id="coreasync">Core.async</h2>

<p>Before introducing <code class="language-plaintext highlighter-rouge">clojure.core.async</code> to the project, first ensure you’ve tried simpler solutions like <code class="language-plaintext highlighter-rouge">agent</code>s, <code class="language-plaintext highlighter-rouge">pmap</code>, thread pool executors and so on. Bringing async to the scene changes the paradigm of data processing so delay this step while it’s possible.</p>

<p>Core.async should never be a part of a library. If the library processes messages, let your consumers decide which bus type to use. Use dependency injection pattern: your code relies on an instance of <code class="language-plaintext highlighter-rouge">IBus</code> protocol with <code class="language-plaintext highlighter-rouge">send-</code> and <code class="language-plaintext highlighter-rouge">get-message</code> abstract methods. Then provide a sub-library which extends the protocol with <code class="language-plaintext highlighter-rouge">core.async</code>. Some of your clients may use <code class="language-plaintext highlighter-rouge">manifold</code>, Kafka or whatever they want for the bus rather than <code class="language-plaintext highlighter-rouge">core.async</code>.</p>

<h2 id="amazonica">Amazonica</h2>

<p>This library is widely used to reach the AWS cloud. When adding it to the project, always specify directly what subparts of SDK you need. Otherwise, about 100 jars (!) will be downloaded to your machine. It would also happen every time you build the project on CI, so be careful with Amazonica dependencies.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">amazonica</span><span class="w"> </span><span class="s">"0.3.156"</span><span class="w">
                </span><span class="no">:exclusions</span><span class="w"> </span><span class="p">[</span><span class="n">com.amazonaws/aws-java-sdk</span><span class="w">
                             </span><span class="n">com.amazonaws/amazon-kinesis-client</span><span class="w">
                             </span><span class="n">com.amazonaws/dynamodb-streams-kinesis-adapter</span><span class="p">]]</span><span class="w">
               </span><span class="p">[</span><span class="n">com.amazonaws/aws-java-sdk-core</span><span class="w"> </span><span class="s">"1.11.968"</span><span class="p">]</span><span class="w">
               </span><span class="p">[</span><span class="n">com.amazonaws/aws-java-sdk-s3</span><span class="w"> </span><span class="s">"1.11.968"</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<p>Although the readme file of Amazonica mentions that case, it’s placed almost at the end of the file so no one reaches it. That’s sad.</p>

<h2 id="libraries">Libraries</h2>

<p>Whenever you start a new project, use the standard, well-known libraries. These are Ring, HTTP-kip, JDBC.next, Migratus and so on. Don’t invent your own routing, ORM or template system, encryption library or whatever else. If a company develops their own framework, one day they must publish it and let the community decide whether it’s useful or not.</p>

    
<div class="prev-next">

    <div class="prev-next-left">
    
        <p><small><a href="/whos-guilty/">&larr; Кто виноват</a></small></p>
    
    </div>

    <div class="prev-next-mid">
    </div>

    <div class="prev-next-right">
    
        <p><small><a href="/post-2022/">Как я провел 2022 год &rarr;</a></small></p>
    
    </div>

</div>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>





<center>
    
    Комментарии
    
    
</center>



<div id="comments">
  
    <div id="comment-1670253755482" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Happy reader 20730,
            5th Dec 2022,
            <a href="#comment-1670253755482">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Thanks for sharing, it is another great writing!</p>

<p>Some remarks from me:</p>

<blockquote>
  <p>Both our software and hardware are developed such that it’s easier to scroll the text down rather than to the right.</p>
</blockquote>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">some.ns</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">clojure.java.io</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">io</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>The total width &lt; 80 characters, so it is 
not a valid point to me.
But I always wanted to know why some people prefer another way of formatting.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="n">user</span><span class="w">
  </span><span class="p">(</span><span class="nf">e/error!</span><span class="w"> </span><span class="s">"User not found"</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="n">user-id</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>It violates</p>

<blockquote>
  <p>Don’t use one-letter aliases even for the built-in modules like clojure.string or clojure.walk</p>
</blockquote>

<p>typo:</p>

<p><code class="language-plaintext highlighter-rouge">did’t</code> -&gt; <code class="language-plaintext highlighter-rouge">didn't</code></p>

<p><code class="language-plaintext highlighter-rouge">(add-hook 'before-save-hook 'delete-trailing-whitespace)</code></p>

<p>In Markdown trailing spaces are significant.</p>
</div>
    </div>
  
    <div id="comment-1670269963286" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            5th Dec 2022,
            <a href="#comment-1670269963286">link</a>
            
          </em>
        </small>
      </p>
      <div><blockquote>
  <p>The total width &lt; 80 characters, so it is not a valid point to me</p>
</blockquote>

<p>Well, that’s completely up to you of course. Personally I’d say even 80 characters is pretty long as I often split my editor’s window on two columns so the text gets truncated.</p>

<blockquote>
  <p>e/error! violates…</p>
</blockquote>

<p>Yes, but sometimes that’s OK</p>

<blockquote>
  <p>In Markdown trailing spaces are significant</p>
</blockquote>

<p>That’s a terrible feature of Markdown and I would never use it.</p>

<blockquote>
  <p>typo …</p>
</blockquote>

<p>will fix, thank you!</p>

</div>
    </div>
  
    <div id="comment-1670321579521" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Max P,
            6th Dec 2022,
            <a href="#comment-1670321579521">link</a>
            
          </em>
        </small>
      </p>
      <div><p>s/our software and hardware/our software and hardware and human anatomy/</p>
</div>
    </div>
  
    <div id="comment-1670354825491" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            The Alchemist,
            6th Dec 2022,
            <a href="#comment-1670354825491">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Learned quite a few nuggets here.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  {:pre [(vector? events) (int? limit) (string? notice)]}
</code></pre></div></div>

<p>I thought you had to use <code class="language-plaintext highlighter-rouge">(and)</code> in <code class="language-plaintext highlighter-rouge">:pre</code> and <code class="language-plaintext highlighter-rouge">:post</code> sections.  This way makes it a lot easier.</p>

<p>Also, thank you for “map hell” suggestions. Applies to Ruby, Ruby, etc. as well.</p>
</div>
    </div>
  
</div>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/en/clojure-guide/">
    <input required name="captcha" type="hidden" value="5 &#215; 7">

    <div class="block">
        <span class="comment-form-label"><small>5 &#215; 7 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="https://t.me/igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
