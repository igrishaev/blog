<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Введение в веб-разработку на Clojure. Часть I</title>
  <meta name="description" content="(This is my attempt to compose a book about Clojure. I decided to start with aweb development section to see how far I could go. It’s in Russian because here...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-book-web-1/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Введение в веб-разработку на Clojure. Часть I</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2019-03-20T00:00:00+00:00">
        Mar 20, 2019
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/web/" rel="tag">web</a>, <a href="/tag/programming/" rel="tag">programming</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>(This is my attempt to compose a book about Clojure. I decided to start with a
web development section to see how far I could go. It’s in Russian because here
Clojure isn’t popular and its popularity across developers is low. I hope I’ll
translate this in English one day.)</em></p>

<h2>

    Содержание

</h2>

<ul id="toc-item-clj-book-web">
  <li><a href="#основы-http" id="toc-item-clj-book-web-основы-http">Основы HTTP</a></li>
  <li><a href="#возвращаясь-к-clojure" id="toc-item-clj-book-web-возвращаясь-к-clojure">Возвращаясь к Clojure</a></li>
  <li><a href="#подробней-о-запросах-и-ответах" id="toc-item-clj-book-web-подробней-о-запросах-и-ответах">Подробней о запросах и ответах</a>    <ul>
      <li><a href="#структура-ответа" id="toc-item-clj-book-web-структура-ответа">Структура ответа</a></li>
    </ul>
  </li>
  <li><a href="#маршрутизация" id="toc-item-clj-book-web-маршрутизация">Маршрутизация</a>    <ul>
      <li><a href="#наивный-подход" id="toc-item-clj-book-web-наивный-подход">Наивный подход</a></li>
      <li><a href="#compojure" id="toc-item-clj-book-web-compojure">Compojure</a></li>
      <li><a href="#продвинутые-возможности" id="toc-item-clj-book-web-продвинутые-возможности">Продвинутые возможности</a></li>
      <li><a href="#роутинг-с-bidi" id="toc-item-clj-book-web-роутинг-с-bidi">Роутинг с Bidi</a></li>
      <li><a href="#выбор-между-compojure-и-bidi" id="toc-item-clj-book-web-выбор-между-compojure-и-bidi">Выбор между Compojure и Bidi</a></li>
    </ul>
  </li>
  <li><a href="#middleware" id="toc-item-clj-book-web-middleware">Middleware</a>    <ul>
      <li><a href="#параметры-запроса" id="toc-item-clj-book-web-параметры-запроса">Параметры запроса</a></li>
      <li><a href="#cookie" id="toc-item-clj-book-web-cookie">Cookie</a></li>
      <li><a href="#сессии" id="toc-item-clj-book-web-сессии">Сессии</a></li>
      <li><a href="#json" id="toc-item-clj-book-web-json">JSON</a></li>
      <li><a href="#собственные-middleware" id="toc-item-clj-book-web-собственные-middleware">Собственные middleware</a>        <ul>
          <li><a href="#wrap-headers-kw" id="toc-item-clj-book-web-wrap-headers-kw">wrap-headers-kw</a></li>
          <li><a href="#wrap-request-id" id="toc-item-clj-book-web-wrap-request-id">wrap-request-id</a></li>
          <li><a href="#wrap-current-user" id="toc-item-clj-book-web-wrap-current-user">wrap-current-user</a></li>
        </ul>
      </li>
      <li><a href="#прерывание-стека" id="toc-item-clj-book-web-прерывание-стека">Прерывание стека</a></li>
      <li><a href="#middleware-вне-стека" id="toc-item-clj-book-web-middleware-вне-стека">Middleware вне стека</a></li>
      <li><a href="#все-вместе" id="toc-item-clj-book-web-все-вместе">Все вместе</a></li>
    </ul>
  </li>
</ul>

<p>В этой главе мы рассмотрим азы разработки на Clojure под
веб-платформу. Поговорим о том, как устроен протокол HTTP и как передавать по
нему данные. Рассмотрим, какие абстракции использует Clojure над протоколом,
чтобы сделать разработку быстрой и удобной.</p>

<p class="draft-warn">Внимание! Вы читаете черновик к книге <a href="/clojure-in-prod/">“Clojure на производстве”</a>. Для
книги я переписывал его много раз, но в блоге осталась старая версия. Здесь она
для истории, а вам я рекомендую купить книжку.</p>

<p>Каждый год компания Cognitect <a href="http://blog.cognitect.com/blog/2017/1/31/clojure-2018-results">опрашивает</a>
Clojure-разработчиков. Среди прочих вопросов встречается о том, в какой области
вы работаете? В 2010 году веб-разработкой занимались 50% опрошенных, то есть
каждый второй. К 2018 году эта цифра выросла до 82%. Это уже четыре человека из
пяти.</p>

<p>Развитие веба не связано напрямую с Clojure. Похожую динамику показывают
ежегодные опросы <a href="https://insights.stackoverflow.com/survey/2018/">StackOverflow</a>. Согласно им, все больше разработчиков
переходит из смежных областей в веб.</p>

<p>Справедливо утверждать, что если вы найдете работу на Clojure, то скорее всего
это будет веб-приложение. Речь необязательно идет о сайте компании. Иногда такие
сайты даже бывают статичными, то есть состоят из набора HTML-файлов. Но
веб-приложение — это не только текст с картинками. В общем значении это передача
и обработка данных по протоколу HTTP.</p>

<p>Напомним, протокол изначально предназначен для передачи HTML-разметки. Но
удивительным образом подошел для обмена данными. Для этого даже не пришлось
менять стандарт. Причина кроется в его изящном дизайне, простоте и гибкости.</p>

<p>Прежде чем перейти к Clojure, давайте освежим в памяти устройство протокола. Из
каких частей он состоит и по каким правилам сервер его обрабатывает. Это важно,
потому что языки и фреймворки меняются, а протокол нет.</p>

<!-- more -->

<h2 id="основы-http">Основы HTTP</h2>

<p>HTTP это протокол, который работает поверх TCP/IP. Протокол в широком смысле —
это соглашение о том, в каком порядке передавать данные. Протоколы обычно
зафиксированы в официальных документах. Для HTTP такой документ называется <a href="https://tools.ietf.org/html/rfc2616">RFC
2616</a>. Разработчики браузеров и фреймворков должны сверяться с этим
документом во время работы.</p>

<p>HTTP удобен тем, что это текст. Разработчику не нужно декодировать байты, чтобы
понять семантику происходящего. Протокол не исключает передачу бинарных данных,
но основные его части все же представлены текстом.</p>

<p>Различают HTTP-запрос и ответ. Оба состоят из трех частей: первая строка,
заголовки и тело.</p>

<p>Первая (или стартовая) строка содержит самую важную информацию о запросе или
ответе. Формат строки различается для запроса и ответа. Для запроса это метод,
путь и версия, для ответа — статус, сообщение и версия.</p>

<p>Заголовки — это пары ключ-значение. В современных фреймворках они, как правило,
выражены словарем. Заголовки содержат дополнительные сведения о запросе или
ответе. Например, заголовок Content-Type сообщает, как следует трактовать тело
запроса. Был ли это XML- или JSON-документ? Программа проверяет заголовок и
читает содержимое должным образом.</p>

<p>После заголовков следует тело. Телом может быть что угодно — текст, данные в
виде “поле=значение”, JSON-документ, картинка, фильм, электронное
письмо. Стандарт предусматривает смешанный тип, т.н. multipart-encoding. Тело
такого запроса раздроблено на ячейки, в каждом из которых живет свое
содержимое. Например, текст, картинка, снова текст, двоичный файл.</p>

<p>Несколько примеров HTTP-запросов и ответов. Именно в таком виде они передаются
по сети. Это запрос к главной странице Google, поисковой терм — сlojure:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/search?q=clojure</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">google.com</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">en-us</span>
<span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip, deflate</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)</span>
<span class="s">(blank line)</span>
</code></pre></div></div>

<p>Пример POST-запроса с передачей JSON-документа:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">POST</span> <span class="nn">/api/users/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">example.com</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/json</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)</span>

<span class="p">{</span><span class="w">
  </span><span class="nl">"username"</span><span class="p">:</span><span class="w"> </span><span class="s2">"John"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"city"</span><span class="p">:</span><span class="w"> </span><span class="s2">"NY"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Ответ на такой запрос:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Tue, 19 Mar 2019 15:57:11 GMT</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">Nginx</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">close</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/json</span>

<span class="p">{</span><span class="w">
  </span><span class="nl">"code"</span><span class="p">:</span><span class="w"> </span><span class="s2">"CREATED"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"A user has been created successfully"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Легко увидеть, как изящно устроен протокол. Данные в нем располагаются по
убыванию важности. Прочитав только первую строку запроса, клиент и сервер готовы
принять решение о том, что делать дальше.</p>

<p>Рассмотрим сценарий: в запросе указаны метод и путь <code class="language-plaintext highlighter-rouge">GET /about</code>, но такой
страницы не существует. Сервер может проверить это заранее, например, сверив
путь с конфигурацией маршрутов. Когда маршрута нет, сервер вернет ответ со
статусом 404. Не придется читать тело запроса, что существенно ускорит работу
сервера.</p>

<p>Получив ответ, клиент прочитает статус 404 из первой строки. Такой ответ
трактуется как ошибочный. Логика клиента может быть такова, что в случае ошибки
читать тело ответа не нужно. Это облегчит работу клиента.</p>

<p>Чтение и разбор содержимого это дорогая операция. Современные фреймворки
пытаются исключить случаи, когда чтение происходит зря. Например, по заголовку
<code class="language-plaintext highlighter-rouge">Content-Type</code> мы определяем, стоит ли читать тело. Наше приложение работает
только с JSON, поэтому для значения <code class="language-plaintext highlighter-rouge">text/xml</code> вернем ошибку. Аналогично с
заголовком <code class="language-plaintext highlighter-rouge">Content-Length</code>, где содержится длина тела в байтах. Если значение
больше заданного лимита, сервер отклонит запрос до чтения тела.</p>

<p>Центральные параметры запроса это метод и путь. Путь указывает на определенный
ресурс на сервере. Иногда сервер трактует путь как файл относительно заданной
директории. Например, <code class="language-plaintext highlighter-rouge">/images/map.jpg</code> означает вернуть такой файл из
директории <code class="language-plaintext highlighter-rouge">/var/www/static</code>. Но чаще всего приложение обрабатывает путь
согласно внутренней логике. Ответом приложения может быть не только файл, но и
js-скрипт, HTML-разметка или JSON-документ.</p>

<p>Метод запроса означает действие, которые мы намерены выполнить над
ресурсом. Основные методы это GET, POST, PUT и DELETE. Их семантика в том же
порядке — прочитать, создать, обновить, удалить ресурс. Так, запрос <code class="language-plaintext highlighter-rouge">POST
/users/</code> означает создать пользователя, а <code class="language-plaintext highlighter-rouge">GET /users/1</code> — чтение пользователя
под номером 1.</p>

<p>Главный параметр ответа это статус — целое положительное число. Статусы
группируют по старшему разряду. Значения с 200 до 299 (или 2хх) считаются
положительными. Они означают, что сервер успешно обработал запрос.</p>

<p>Значения в группе 3хх связаны с перенаправлением на другую страницу. Как
правило, в заголовке Location сервер сообщает путь, по которому следует
обратиться. Современные браузеры и HTTP-клиенты достаточно умны, чтобы
автоматически послать второй запрос по новому адресу. Так, при запросе страницы
<code class="language-plaintext highlighter-rouge">http://yandex.ru</code> вы получите пустой документ с заголовком <code class="language-plaintext highlighter-rouge">Location:
https://yandex.ru</code> (безопасное соединение). Но браузер переключит страницу сам.</p>

<p>Статусы из группы 4хх означают ошибку на стороне клиента. Чаще всего это 404 —
страница не найдена. На ошибочные данные сервер отвечает 400 — Bad
request. Когда нет прав на просмотр документа, клиент получит код 403.</p>

<p>Статусы из группы 5хх сигнализируют об ошибке на стороне сервера или полной его
недоступности. Это деление на ноль, недоступность базы данных, недостаток места
на диске.</p>

<p>Принято считать, что ответ со статусом вне диапазона 2хх означает
ошибку. Большинство HTTP-клиентов запрограммированы на выброс исключения в таких
случаях. Строго говоря, это верно только на высоком, абстрактном уровне. С точки
зрения протокола ответ 404 Not Found такой же правильный, как и 200 OK.</p>

<p>Дополнительные операции над ресурсом используют другие, более редкие
методы. Например, HEAD — получить только краткие сведения об объекте. Сервис
Amazon S3 в ответ на HEAD-запрос отдает только статус и заголовки. В них указаны
тип файла и размер, контрольная сумма, дата последнего изменения. В данном
случае HEAD-запрос предпочтительней GET. Метаданные могут храниться в особом
хранилище отдельно от файла. Доступ к такому хранилищу обычно быстрее, чем к
файлу на диске.</p>

<p>Подход “метод-ресурс” со временем вырос в то, что сегодня называется
<a href="https://www.restapitutorial.com/">REST</a>. Последователи REST выделяют бизнес-сущности и CRUD-операции
над ними (Create, Read, Update, Delete). Считается хорошим подход, когда
сущность определяется через путь, например <code class="language-plaintext highlighter-rouge">/users/1</code>, а операция —
методом. Если это создание или изменение сущности, данные читаются из тела,
обычно JSON-документа. Мы не будем задерживаться на REST, потому что это всего
лишь свод рекомендаций, не идеальный и не единственный.</p>

<p>Отметим, что HTTP не предусматривает строгое соблюдение этих
рекомендаций. Разработчик вправе обрабатывать запросы и ответы так, как удобно в
данном случае. Например, принимать только POST-запросы с данными в теле. Или
только GET с параметрами из строки запроса. Верную стратегию определяют бизнес,
инструменты или потребители сервиса.</p>

<h2 id="возвращаясь-к-clojure">Возвращаясь к Clojure</h2>

<p>Современные фреймворки строят абстракции над HTTP-протоколом. Разработчику не
требуется читать данные из сокета и выполнять разбор запроса, ровно как и писать
в сокет байты ответа. Эту задачу берет на себя фреймворк и сервер.</p>

<p>Взамен разработчик получает набор классов, чтобы с их помощью выразить
бизнес-логику приложения. Типичный веб-проект на Python или Java это комбинация
нескольких классов. Как правило, это <code class="language-plaintext highlighter-rouge">Application</code> — главная сущность
проекта. Класс <code class="language-plaintext highlighter-rouge">Router</code> определяет, на какой обработчик переключить входящий
запрос — <code class="language-plaintext highlighter-rouge">Request</code>. Обработчик — это класс <code class="language-plaintext highlighter-rouge">Handler</code> с методами <code class="language-plaintext highlighter-rouge">.onGet</code>,
<code class="language-plaintext highlighter-rouge">.onPost</code> и тд. Ожидается, что он вернет экземпляр класса <code class="language-plaintext highlighter-rouge">Response</code>.</p>

<p>По такому принципу устроены все промышленные веб-фреймворки: Django, Rails,
Symfony. Названия классов и их композиция различаются, но суть остается
прежней. Это приложение, маршрутизатор, обработчик, запрос и ответ. Проблема в
том, что каждый фреймворк моделирует собственные классы, которые несовместимы
между собой в рамках языка.</p>

<p>Рассмотрим язык Python и фреймворки Django и Flask. Оба следуют той же
структуре. Так, запрос в Django представлен классом <code class="language-plaintext highlighter-rouge">django.http.HttpRequest</code>, а
во Flask — <code class="language-plaintext highlighter-rouge">flask.Request</code>. Даже беглого взгляда достаточно, чтобы увидеть,
насколько они отличаются. У классов разные методы и поля. То, что есть в первом
классе, отсутствует во втором. Использовать <code class="language-plaintext highlighter-rouge">flask.Request</code> в проекте на Django
не представляется возможным.</p>

<p>Это приводит к тому, что проект увязает в архитектуре фреймворка. Переезд на
другой фреймворк обходится с трудом. Хорошие практики предписывают разделять
проект на слои. Слой транспорта отвечает за ввод и вывод данных по протоколу
HTTP. Слой логики исполняет внутренний код, ничего не зная о HTTP. Согласно
такому принципу, логика не зависит от транспорта, и последний может быть изменен
в любой момент. Но на практике это справедливо не всегда. Порой мы вынуждены
сделать слишком много за короткое время. Нам не дают исправить поспешные
решения, и плохой код остается в проекте навсегда.</p>

<p>В Clojure другой подход.</p>

<p>Разработчик <a href="https://www.booleanknot.com/">Джеймс Ривз</a> (James Reeves) известен своим вкладом в
экосистему Clojure. Он разработал 60 библиотек для самых разных задач. Нет
такого проекта на Clojure, который бы не использовал его наработки.</p>

<p>Заслуга Джеймса в том, что он стандартизировал веб-разработку для Clojure на
заре этого языка. Вместо того, чтобы писать фреймворк под сиюминутные нужды, он
придумал, как сделать удобно всем.</p>

<p>Джеймс предложил несколько простых идей. Первая — если приложение принимает
запрос и возвращает ответ, то резонно выразить его функцией. Действительно,
приложения бывают сколь угодно сложным. Они полагаются на сторонние сервисы,
машинное обучение, учитывают сотню фактов о пользователе. Но они принимают
запрос и возвращают ответ, поэтому на абстрактном уровне это функция.</p>

<p>Скептики могут заметить, что мысль не нова. Действительно, в том же Django
обработчик запроса может быть не классом, а функцией. Разница в том, что
отдельный обработчик — это еще не приложение. Ему не хватает маршрутизатора,
middleware и других абстракций. Поэтому в мире Django или Flask выразить
обработчик функцией — всего лишь приятная возможность фреймворка.</p>

<p>Но Clojure устроена так, что маршрутизатор — это тоже функция, которая принимает
запрос, определяет нужный обработчик и возвращает ответ. Middleware это тоже
функция, которая принимает функцию-обработчик и возвращают новый обработчик с
дополненной логикой. Каждую тяжелую абстракцию (классы <code class="language-plaintext highlighter-rouge">Application</code>, <code class="language-plaintext highlighter-rouge">Router</code>,
<code class="language-plaintext highlighter-rouge">Handler</code>) в мире Clojure принято заменять функцией. Это удобно, потому что в
отличии от классов функции компонуются.</p>

<p>Вторая идея Джеймса в том, чтобы зафиксировать структуру запроса и
ответа. Должны быть документы (не код, а именно документы), где описаны поля
этих структур и их семантика. Это напоминает спецификацию протокола HTTP.</p>

<p>Спецификация упрощает разработку и переносимость кода. Два веб-проекта на
Clojure обязаны принимать и отдавать одинаковые структуры данных. Разработчик
очередного фреймворка должен учитывать спецификацию. Если фреймворк следует
стандартам, проще привлечь на свою сторону сообщество.</p>

<p>Описанные выше идеи выражены в проекте Ring. Сегодня это стандарт веб-разработки
в Clojure. Репозиторий содержит спецификацию запроса и ответа и базовый код для
обработки этих структур. Плюс основные middleware, запуск Jetty-сервера и
документация. Удивительно, как мало кода понадобилось проекту, чтобы попасть на
компьютер каждому Clojure-разработчику.</p>

<p>Со временем появился термин “Ring-совместимость”. Его придерживаются все
современные Clojure-фреймворки. Типичное Ring-приложение запускается на многих
платформах: Jetty, Netty, Immutant и др. без изменений в коде.</p>

<p>Библиотека Ring разбита на отдельные части, чтобы установить только
необходимое. Перечислим компоненты, что будем использовать ниже:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ring-core</code> — базовая функциональность: параметры, разбор тела, куки, сессии,
и тд;</li>
  <li><code class="language-plaintext highlighter-rouge">ring-jetty-adapter</code> — запуск полноценного веб-сервера из функции-приложения.</li>
</ul>

<p>Свое первое веб-приложение вы напишете даже без библиотеки. Вот оно:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">uri</span><span class="w"> </span><span class="n">request-method</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="s">"Content-Type"</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"You requested %s %s"</span><span class="w">
                   </span><span class="p">(</span><span class="nb">name</span><span class="w"> </span><span class="n">request-method</span><span class="p">)</span><span class="w">
                   </span><span class="n">uri</span><span class="p">)}))</span><span class="w">
</span></code></pre></div></div>

<p>Приложение извлекает путь и метод из запроса и формирует ответ. Его статус
положительный — 200. Мы выставили один заголовок с типом документа “простой
текст”. Поле <code class="language-plaintext highlighter-rouge">:body</code> содержит строку, которую мы построили функцией format.</p>

<p>Поскольку app это функция, вызовем ее с различными запросами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">app</span><span class="w"> </span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get</span><span class="w"> </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/index.html"</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="n">,</span><span class="w">
 </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="s">"Content-Type"</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="n">,</span><span class="w">
 </span><span class="no">:body</span><span class="w"> </span><span class="s">"You requested get /index.html"</span><span class="p">}</span><span class="w">

</span><span class="p">(</span><span class="nf">app</span><span class="w"> </span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:post</span><span class="w"> </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/users"</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="n">,</span><span class="w">
 </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="s">"Content-Type"</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="n">,</span><span class="w">
 </span><span class="no">:body</span><span class="w"> </span><span class="s">"You requested post /users"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Работает. Но пока что это структуры данных, и не ясно, что будет в
браузере. Запустим приложение как HTTP-сервер.</p>

<p>Сервер это отдельная сущность. Он связывает структуры данных с сетевым
вводом-выводом. Сервер принимает приложение, некоторые дополнительные параметры
и запускает в фоне сложный процесс. Он слушает указанный порт и считывает
запросы клиента. Из бинарных данных сервер восстанавливает структуру
запроса. Затем, в отдельном треде, вызывает функцию-приложение с этим
запросом. Результатом будет структура ответа. Сервер преобразует ответ в
байтовый поток и записывает в удаленный порт клиента. Этот цикл повторяется для
каждого запроса.</p>

<p>Добавим в проект зависимости:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ring/ring-core</span><span class="w"> </span><span class="s">"1.7.1"</span><span class="p">]</span><span class="w">
</span><span class="p">[</span><span class="n">ring/ring-jetty-adapter</span><span class="w"> </span><span class="s">"1.7.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Пример запуска сервера:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.adapter.jetty</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">run-jetty</span><span class="p">]])</span><span class="w">
</span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">true</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Здесь происходит следующее. Мы импортировали в текущее пространство функцию
<code class="language-plaintext highlighter-rouge">run-jetty</code>. Она принимает два параметра — функцию-приложение и словарь
параметров. Опция <code class="language-plaintext highlighter-rouge">join?</code> определяет, будет ли заблокирован текущий тред до
конца работы сервера. Если передать false, сервер будет запущен в фоне. Чтобы
остановить, нужно сохранить его в переменную и вызвать метод <code class="language-plaintext highlighter-rouge">.stop</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">server</span><span class="w">
  </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w">
                  </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; after a while</span><span class="w">
</span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Если флаг был <code class="language-plaintext highlighter-rouge">true</code>, как в первом случае, то главный поток повиснет до конца
работы сервера. Придется либо завершить программу, либо нажать <code class="language-plaintext highlighter-rouge">Ctrl-C</code>.</p>

<p>Во время работы сервера откройте браузер по адресу http://127.0.0.1:8080/. Вы
увидите строку из примера выше. Укажите произвольный путь, например <code class="language-plaintext highlighter-rouge">/hello</code>,
<code class="language-plaintext highlighter-rouge">/path/to/file.txt</code>. Ответ сервера изменится.</p>

<h2 id="подробней-о-запросах-и-ответах">Подробней о запросах и ответах</h2>

<p>В предыдущем примере мы написали приложение, которые печатает метод и путь
запроса. Это важные, но не единственные его поля. Запрос содержит порт и адрес
сервера, строку запроса, тип протокола, заголовки и тело. Уточним, что запрос
это неизменяемый словарь, ключи которого keywords (кейворды или ключевые слова,
в других языках — теги). <a href="https://github.com/ring-clojure/ring/blob/master/SPEC">Полная спецификация</a> запроса и ответа лежит
в репозитории на Гитхабе.</p>

<p>Обратим внимание на поля <code class="language-plaintext highlighter-rouge">:headers</code> и <code class="language-plaintext highlighter-rouge">:body</code>.</p>

<p>Заголовки это неизменяемый словарь, но его ключи не кейворды, а строки. Такой
словарь не работает с destructuring assignment. В примере ниже host получит
значение <code class="language-plaintext highlighter-rouge">nil</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">some-handler</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">headers</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">host</span><span class="p">]}</span><span class="w"> </span><span class="n">headers</span><span class="p">]</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы извлечь заголовки правильно, используйте <code class="language-plaintext highlighter-rouge">get</code> со строкой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">headers</span><span class="w"> </span><span class="s">"host"</span><span class="p">)</span><span class="w">
</span><span class="mf">127.0</span><span class="n">.0.1</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что имя заголовка всегда в нижнем регистре. С точки зрения HTTP, оба
написания <code class="language-plaintext highlighter-rouge">Content-Type</code> и <code class="language-plaintext highlighter-rouge">content-type</code> верны. Сервер принудительно сводит
заголовки к нижнему регистру, чтобы избежать неоднозначности.</p>

<p>Значения заголовков тоже строки. Даже если стандарт HTTP определяет типы
некоторых заголовков, Ring не пытается вывести их. Например, заголовок
<code class="language-plaintext highlighter-rouge">Content-Length</code> передает длину тела в байтах. Современные фреймворки приводят
его к числу и помещают в отдельное поле запроса. По умолчанию Ring не делает
чего-то подобного, но такой функционал легко добавить.</p>

<p>За ключами-строками стоит проблема. Clojure спроектирована так, что почти всегда
ключи словаря это кейворды. Легко забыть о том, что у заголовков они строки. Так
появляются ошибки, когда разработчик деструктурирует заголовки и получает <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>Можно обработать словарь заголовков, заменив тип ключей. Для одного случая это
нормально. Но если так делает каждый обработчик, это плохая идея. Правильно
сделать так, чтобы каждая функция получала запрос с уже исправленными
заголовками. Эта техника называется Middleware, и мы рассмотрим ее ниже.</p>

<p>Поле запроса <code class="language-plaintext highlighter-rouge">:body</code> опционально. Вспомним, что согласно HTTP тела может и не
быть. При попытке считать body проверяйте его на <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>Обратите внимание на тип body. Это не строка, а входящий поток —
<code class="language-plaintext highlighter-rouge">java.io.InputStream</code>. Поток — это источник данных, который можно прочесть
только раз. По умолчанию Ring не читает поток. Это остается на усмотрение
разработчика.</p>

<p>Вспомним, что чтение и разбор тела это сложная и небезопасная операция. По
заголовкам следует определить тип документа и его длину, прочитать нужное число
байт и восстановить документ в структуру (JSON, XML, etc). Результат каждого
шага следует проверять по разным критериям. Чтобы получить из <code class="language-plaintext highlighter-rouge">Content-Length</code>
число, мы должны быть готовы к исключению во время разбора строки. Но результат
-42 тоже неверный, потому что число байт в потоке не может быть отрицательным.</p>

<p>Технически возможно послать серверу JSON-документ, но указать <code class="language-plaintext highlighter-rouge">Content-Type:
text/xml</code>. Тот, кто это сделал, не обязательно злоумышленник. Это может быть
ошибка в коде на стороне клиента. Сервер должен быть готов к подобному сценарию.</p>

<p>Легче всего считать тело в строку функцией <code class="language-plaintext highlighter-rouge">slurp</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">handler</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">content</span><span class="w">
             </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="nb">slurp</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">process-content</span><span class="w"> </span><span class="n">content</span><span class="p">))</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Но в современном вебе уже не работают с текстом. Мы работаем с данными —
словарями и объектами. Позже рассмотрим, как Ring переводит байты в данные и
наоборот.</p>

<h3 id="структура-ответа">Структура ответа</h3>

<p>Ответ Ring устроен проще. Это неизменяемый словарь, в котором только три поля:
<code class="language-plaintext highlighter-rouge">:status</code>, <code class="language-plaintext highlighter-rouge">:headers</code> и <code class="language-plaintext highlighter-rouge">:body</code>.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:status</code> — целое положительное число. От статуса зависит успех запроса. Мы
рассмотрели семантику статуса в начале главы.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:headers</code> — заголовки ответа. В отличии от заголовков запроса, ключи и
значения не обязательно строки. Вариант ниже корректен:</p>
  </li>
</ul>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">302</span><span class="w">
 </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-length</span><span class="w"> </span><span class="mi">0</span><span class="w">
           </span><span class="no">:location</span><span class="w"> </span><span class="s">"/new/page.html"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Поле <code class="language-plaintext highlighter-rouge">:body</code>, как и в запросе, опционально. В простом случае это строка, но
может быть файлом, ресурсом или потоком. Позже мы рассмотрим интересные сценарии
и техники, связанные с телом ответа.</p>

<h2 id="маршрутизация">Маршрутизация</h2>

<p>Мы запустили приложение и наблюдали его из браузера. На любой запрос оно выдает
текст с незначительными отличиями. Это проблема. Невозможно поддерживать
приложение, в котором все запросы сходятся в одну точку. Правильно будет
написать отдельный обработчик для каждой бизнес-задачи. Затем как-то
распределить по ним входящие запросы. Это называется маршрутизатор или роутинг.</p>

<p>Вспомним, что в мире Clojure и Ring нет отдельной сущности-роутера. Это будет
функция, которая принимает обработчики (хендлеры) и возвращает
функцию-приложение. Такая функция принимает запрос и по методу и пути подбирает
нужный обработчик. Затем вызывает его с запросом и возвращает ответ.</p>

<p>Сказанное означает, что на верхнем уровне у нас по-прежнему функция. Она
принимает словарь запроса и возвращает словарь ответа. Одинаковый принцип на
всех уровнях.</p>

<p>Рассмотрим тривиальный случай. Вообразим, что адресу “/” мы бы хотели видеть
название сайта, а по “/hello” — приветствие. Все другие адреса возвращают <code class="language-plaintext highlighter-rouge">404
Page not found</code>. Определим обработчики:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-index</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"Learning Web for Clojure"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-hello</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"Hi there and keep trying!"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-404</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"No such a page."</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Готово. Каждый такой обработчик можно запустить как сервер и проверить в
браузере. Осталось связать их в единое целое.</p>

<h3 id="наивный-подход">Наивный подход</h3>

<p>Сделаем самое простое, что приходит в голову. Напишем обработчик, который
вручную определяет нужный маршрут. Достаточно проверить путь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">uri</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">uri</span><span class="w">
      </span><span class="s">"/"</span><span class="w">      </span><span class="p">(</span><span class="nf">page-index</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="s">"/hello"</span><span class="w"> </span><span class="p">(</span><span class="nf">page-hello</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">page-404</span><span class="w"> </span><span class="n">request</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Ответ такой функции зависит от запроса, а именно его пути. Запустите новое
приложение в браузере и проверьте результат для разных адресов. Хоть это и
наивный перебор, но работает.</p>

<p>Недостатки этой функции очевидны. Мы не учитываем метод запроса. “GET /users” и
“POST /users” различны по смыслу. Наша реализация сравнивает пути в лоб без
учета их параметров. С точки зрения правильного роутинга запросы “GET /users/1”
и “GET /users/99” сходятся в один обработчик, но с разным параметром id.</p>

<p>Общий недостаток в том, что код зашумлен. Такую функцию трудно
поддерживать. Хотелось бы описать маршруты правилами, то есть декларативно.</p>

<p>Эти и другие проблемы решены в отдельных Clojure-библиотеках. Мы рассмотрим две
из них: Compojure и Bidi. Каждая библиотека решает задачу роутинга по-своему, их
подходы ортогональны.</p>

<h3 id="compojure">Compojure</h3>

<p>Библиотека <a href="https://github.com/weavejester/compojure/">Compojure</a> предлагает макросы для описания
маршрутов. Макросы устроены так, что их набор похож на таблицу правил. Добавим
зависимость в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">compojure</span><span class="w"> </span><span class="s">"1.6.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Вот как выглядит приложение на Compojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">compojure.core</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">GET</span><span class="w"> </span><span class="n">defroutes</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">defroutes</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/"</span><span class="w">      </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-index</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/hello"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-hello</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="n">page-404</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Это гораздо лучше той каши, что мы написали вначале.</p>

<p>Разберемся, что получили на выходе. Переменная app — это функция, которая
принимает запрос. Обратим внимание, что app объявлена не через <code class="language-plaintext highlighter-rouge">def</code> или <code class="language-plaintext highlighter-rouge">defn</code>,
а особенным макросом. Мы поговорим о макросах в отдельной главе. Пока что
скажем, что <code class="language-plaintext highlighter-rouge">defroutes</code> делает две вещи: создает функцию-роутер и связывает ее с
переменной через <code class="language-plaintext highlighter-rouge">defn</code>. Это обвязка, чтобы писать меньше кода.</p>

<p>Макрос принимает набор правил. Правило это форма вида (метод, путь, запрос,
выражение). Первые два правила созданы макросом GET. Читать их следует так: если
метод запроса GET и путь “/”, то для запроса request верни (page-index request).</p>

<p>Правило компилируется в функцию, которая принимает запрос. В начале работы такая
функция проверяет, действительно ли метод и путь запроса совпадают с
заданными. Если да, то функция вычислит выражение и вернет его результат, в
нашем случае <code class="language-plaintext highlighter-rouge">(page-index request)</code>.</p>

<p>Если запрос не удовлетворяет критериям, то правило-функция вернет nil. Это
значит, что следует попробовать следующее правило, и так далее. Макрос defroutes
автоматизирует эти действия. Он оборачивает правила в особый цикл. На каждом
шаге макрос берет очередное правило, применяет к нему запрос и оценивает
результат. Первое отличное от nil значение станет ответом к текущему запросу.</p>

<p>Что будет, если не подошло ни одно правило? Такое вполне возможно. Тогда
приложение вернет nil, и это вызовет ошибку на уровне сервера. Nil не может быть
ответом на запрос, потому что не ясен его смысл.</p>

<p>Чтобы избежать nil, в конец правил добавляют еще одно, такое, что вернет
правильный ответ независимо от запроса. В нашем случае это функция page-404. Ее
результат всегда одинаков. Так мы гарантируем, что даже если запрос не подошел
первым двум правилам, последнее сработает обязательно.</p>

<p>Так работает роутинг на Compojure. Мы пишем обработчики запросов в отдельных
модулях. Затем импортируем их в модуль с роутингом. С помощью макросов GET, POST
и т.д. мы оборачиваем их в правила. Правило возвращает функцию, которая
проверяет, что запрос соответствует критериям. Если да, то результатом будет
вызов обработчика с запросом.</p>

<h3 id="продвинутые-возможности">Продвинутые возможности</h3>

<p>Выше мы обозначили проблему: правила “GET /users/1” и “GET /users/99” это один и
тот же обработчик, но с параметром. Вот как описать такой путь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/users/:id"</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">page-user</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, в пути двоеточие перед id, а третий параметр заключен в
квадратные скобки. Такой синтаксис означает, что часть с двоеточием следует
трактовать как параметр. Compojure поместит его в поле запроса
params. Обработчик <code class="language-plaintext highlighter-rouge">page-user</code> должен извлечь его следующим образом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-user</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:params</span><span class="w"> </span><span class="no">:id</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">user-id</span><span class="p">)</span><span class="w">
          </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">fname</span><span class="w"> </span><span class="n">lname</span><span class="p">]}</span><span class="w"> </span><span class="n">user</span><span class="p">]</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"User %s is %s %s"</span><span class="w">
                     </span><span class="n">user-id</span><span class="w"> </span><span class="n">fname</span><span class="w"> </span><span class="n">lname</span><span class="p">)})))</span><span class="w">
</span></code></pre></div></div>

<p>В данном случае предположим, что функция <code class="language-plaintext highlighter-rouge">get-user-by-id</code> возвращает словарь
пользователя по его номеру. Из словаря мы извлекаем имя и фамилию, формируем
строку и возвращаем ответ.</p>

<p>Compojure решает проблему вложенных путей. Предположим, приложение показывает и
редактирует товары. По адресу “/content/order/1/view” открывается карточка
товара для просмотра. Страница “/content/order/1/edit” выводит форму
редактирования этого товара. Чтобы сохранить товар, нужно отправить поля формы
по тому же пути, но методом POST.</p>

<p>Очевидно, правила пересекаются. Чтобы избежать повторов, используем макрос context:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">context</span><span class="w"> </span><span class="s">"/content/order/:id"</span><span class="w"> </span><span class="p">[</span><span class="n">order-id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w">  </span><span class="s">"/view"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">order-view</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">context</span><span class="w"> </span><span class="s">"/edit"</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">(</span><span class="nf">GET</span><span class="w">  </span><span class="s">"/"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">order-form</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">POST</span><span class="w"> </span><span class="s">"/"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">order-save</span><span class="w"> </span><span class="n">request</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Каждое правило под макросом context наследует параметры запроса. Это значит,
обработчики order-view, order-form и order-save получат параметр <code class="language-plaintext highlighter-rouge">:order-id</code> из
<code class="language-plaintext highlighter-rouge">:params</code>.</p>

<p>До сих пор в качестве выражения в правилах мы указывали что-то вроде
<code class="language-plaintext highlighter-rouge">(some-handler request)</code>. Бывает, что ответ по данному пути заранее известен,
поэтому нет смысла выносить его в отдельную функцию. Пусть выражение будет
готовым ответом. Рассмотрим это на примере healthcheck-обработчика.</p>

<p>Современные приложения часто запускают в контейнерах и облачных сервисах.  Чтобы
узнать, работает приложение или нет, специальная служба периодически опрашивает
его. Стандартный способ сделать это — послать приложению GET-запрос по адресу
“/health” и проверить статус. Тело и заголовки ответа не играют роли.</p>

<p>Чтобы не создавать лишний обработчик <code class="language-plaintext highlighter-rouge">(page-health request)</code>, поместим ответ в
тело:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ANY</span><span class="w"> </span><span class="s">"/health"</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="s">"ok"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Однако, можно сделать еще проще. В Compojure предусмотрен случай, когда
выражение это строка. Compojure трактует такую строку как тело положительного
ответа:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ANY</span><span class="w"> </span><span class="s">"/health"</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="s">"ok"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h3 id="роутинг-с-bidi">Роутинг с Bidi</h3>

<p>Библиотека <a href="https://github.com/juxt/bidi">Bidi</a> решает проблему роутинга иным способом. Compojure
предлагает макросы, чтобы описать правила и сделать по ним перебор. Bidi
опирается на данные — списки и словари. Сценарий роутинга в Bidi состоит из
нескольких шагов.</p>

<p>На первом этапе объявить особое дерево маршрутов. Это дерево — комбинация
векторов и словарей по определенным правилам. В листьях дерева поместить теги —
уникальные метки для обозначения листа. Особая функция принимает это дерево и
запрос. Функция пытается понять, на какую ветвь дерева ложиться запрос. Если
таковая нашлась, результатом будет тег ветки и, возможно, параметры
пути. Например, <code class="language-plaintext highlighter-rouge">{:route :show-user, :route-params: {:id 1}}</code>.</p>

<p>На втором этапе написать middleware — промежуточный обработчик запроса. Такой
middleware принимает запрос, добавляет в него тег и передает дальше по цепочке.</p>

<p>На третьем этапе — объявить обработчик запроса. Но это будет не функция, а
мультиметод. Его функция-диспачер возвращает тег. Метод <code class="language-plaintext highlighter-rouge">:default</code> возвращает
ответ 404, <code class="language-plaintext highlighter-rouge">:show-user</code> — страницу пользователя, и так далее.</p>

<p>На первый взгляд схема кажется сложной. Но однажды настроив, ее легко
расширять. Чтобы сервер подхватил новый путь, достаточно поместить в дерево
нужную ветку и расширить мультиметод.</p>

<p>Перепишем на Bidi все то, что сделали на Compojure. Добавьте в проект
зависимость:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">bidi</span><span class="w"> </span><span class="s">"2.1.5"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Начнем с дерева маршрутов. Вариант с page-index, page-hello и page-404 будет выглядеть так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">routes</span><span class="w">
  </span><span class="p">[</span><span class="s">"/"</span><span class="w"> </span><span class="p">{</span><span class="s">""</span><span class="w">      </span><span class="no">:page-index</span><span class="w">
        </span><span class="s">"hello"</span><span class="w"> </span><span class="no">:page-hello</span><span class="w">
        </span><span class="n">true</span><span class="w">    </span><span class="no">:not-found</span><span class="p">}])</span><span class="w">
</span></code></pre></div></div>

<p>Проверим, как работает матчинг пути по этому дереву. Функция match-route
принимает маршруты и путь и возвращает словарь с тегом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">bidi.bidi</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">bidi</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">bidi/match-route</span><span class="w"> </span><span class="n">routes</span><span class="w"> </span><span class="s">"/hello"</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:handler</span><span class="w"> </span><span class="no">:page-hello</span><span class="p">}</span><span class="w">

</span><span class="p">(</span><span class="nf">bidi/match-route</span><span class="w"> </span><span class="n">routes</span><span class="w"> </span><span class="s">"/test"</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:handler</span><span class="w"> </span><span class="no">:not-found</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Ответ функции следует объединить со словарем запроса. Чтобы сделать это за один
шаг, воспользуемся функцией match-route*. Это альтернативная версия match-route,
которая принимает словарь-накопитель.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w">
      </span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get</span><span class="w">
       </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/test"</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">bidi/match-route*</span><span class="w"> </span><span class="n">routes</span><span class="w"> </span><span class="p">(</span><span class="no">:uri</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get</span><span class="w">
 </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/test"</span><span class="w">
 </span><span class="no">:handler</span><span class="w"> </span><span class="no">:not-found</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Видим, что <code class="language-plaintext highlighter-rouge">match-route*</code> вернула переданный запрос, но добавила в него поле
handler. Перенесем код выше в middleware. Это функция, которая принимает
обработчик запроса и возвращает его альтернативную версию. Такой обработчик,
получив запрос, сперва добавит к нему поле handler и вызовет исходный обработчик
с новым запросом.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-handler</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">uri</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
          </span><span class="n">request*</span><span class="w"> </span><span class="p">(</span><span class="nf">bidi/match-route*</span><span class="w">
                    </span><span class="n">routes</span><span class="w"> </span><span class="n">uri</span><span class="w"> </span><span class="n">request</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">request*</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Мы еще не касались техники middleware, но вынуждены применить ее на данном
этапе.  Ниже мы рассмотрим во деталях, как устроены middleware и почему так
важны.</p>

<p>Проверим <code class="language-plaintext highlighter-rouge">wrap-handler</code> на скорую руку. Будем считать, что обработчик запроса
это стандартная функция identity. Она всегда возвращает переданный в нее
аргумент:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="nf">wrap-handler</span><span class="w"> </span><span class="nb">identity</span><span class="p">)</span><span class="w">
 </span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get</span><span class="w">
  </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/hello?foo=42"</span><span class="p">})</span><span class="w">

</span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get,</span><span class="w">
 </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/hello?foo=42"</span><span class="n">,</span><span class="w">
 </span><span class="no">:handler</span><span class="w"> </span><span class="no">:page-hello</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Конечный обработчик запроса будет мультиметодом. Его функция-диспатчер просто
<code class="language-plaintext highlighter-rouge">:handler</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmulti</span><span class="w"> </span><span class="n">multi-handler</span><span class="w">
  </span><span class="no">:handler</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">multi-handler</span><span class="w"> </span><span class="no">:page-index</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"Learning Web for Clojure"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">multi-handler</span><span class="w"> </span><span class="no">:page-hello</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"Learning Web for Clojure"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">multi-handler</span><span class="w"> </span><span class="no">:not-found</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"No such a page."</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Теперь обернем <code class="language-plaintext highlighter-rouge">multi-handler</code> в middleware. Это и будет финальное приложение.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-handler</span><span class="w"> </span><span class="n">multi-handler</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запустите веб-сервер и проверьте результат в браузере.</p>

<p>Это был простой вариант роутинга на Bidi. Рассмотрим пример с заказами:
просмотр, редактирование и сохранение.</p>

<p>Новое дерево выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">routes</span><span class="w">
  </span><span class="p">[</span><span class="s">"/"</span><span class="w"> </span><span class="p">{[</span><span class="s">"content/order/"</span><span class="w"> </span><span class="no">:id</span><span class="p">]</span><span class="w">
        </span><span class="p">{</span><span class="s">"/view"</span><span class="w"> </span><span class="p">{</span><span class="no">:get</span><span class="w">  </span><span class="no">:page-view</span><span class="p">}</span><span class="w">
         </span><span class="s">"/edit"</span><span class="w"> </span><span class="p">{</span><span class="no">:get</span><span class="w">  </span><span class="no">:page-form</span><span class="w">
                  </span><span class="no">:post</span><span class="w"> </span><span class="no">:page-save</span><span class="p">}}}])</span><span class="w">
</span></code></pre></div></div>

<p>В этой версии листья уже не теги, а словари. Ключ такого словаря — метод
HTTP-запроса, а значение — тег. Запрос “GET /content/order/1/edit” разрешается в
тег <code class="language-plaintext highlighter-rouge">:page-form</code>, а POST с таким же адресом — в <code class="language-plaintext highlighter-rouge">:page-save</code>. При прохождении
через wrap-handler запрос получит поле route-params. Для нашего случая это будет
словарь <code class="language-plaintext highlighter-rouge">{:id "1"}</code>.</p>

<p>Вот так бы мог выглядеть обработчик <code class="language-plaintext highlighter-rouge">page-edit</code>. Получаем словарь заказа по его
id. Если заказ найден, рисуем HTML страницу с формой редактирования. Если нет,
отдаем 404 и сообщение об ошибке.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">multi-handler</span><span class="w"> </span><span class="no">:page-edit</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">order-id</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">[</span><span class="no">:route-params</span><span class="w"> </span><span class="no">:id</span><span class="p">])</span><span class="w">
        </span><span class="n">order</span><span class="w"> </span><span class="p">(</span><span class="nf">get-order-by-id</span><span class="w"> </span><span class="n">order-id</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">order</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
       </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/html"</span><span class="p">}</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">render-order-form</span><span class="w"> </span><span class="n">order</span><span class="p">)}</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w">
       </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/html"</span><span class="p">}</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="s">"&lt;h1&gt;Order not found&lt;/h1&gt;"</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<h3 id="выбор-между-compojure-и-bidi">Выбор между Compojure и Bidi</h3>

<p>Автору приходилось работать с роутингом обоих типов. По субъективным ощущениям,
с Compojure легче начать. У библиотеки достойная документация с
примерами. Compojure написал тот же разработчик, что и Ring. Проекты близки и
дополняют друг друга.</p>

<p>Дерево маршрутов Bidi сложно для понимания. Оно многословно и не
интуитивно. Легко допустить ошибку, перепутать вектор и словарь. С другой
стороны, логика на мультиметодах несет преимущества. Код становится линейным,
более организованным, приложение легче наращивать.</p>

<p>Если вы начинающий Clojure-разработчик или проект небольшой, выбирайте
Compojure. Когда проект сложный со множеством эндпоинтов, рассмотрите переезд на
Bidi.</p>

<h2 id="middleware">Middleware</h2>

<p>Выше мы упоминали про middleware и даже кинули пробный шар — написали
wrap-route. В этом разделе мы разберем все вопросы о middleware и лучших
практиках по работе с ними. Автор считает этому тему самой важной в главе.</p>

<p>В переводе с английского Middleware значит промежуточный слой, середина. В
программировании под middleware понимают код, который обрабатывает данные между
посредниками. Обработка данных это приведение типов, добавление новых полей,
проверка прав доступа.</p>

<p>Паттерн “декоратор” это частный случай middleware. Декоратор это функция А,
которая принимает функцию B и возвращает функцию C. Говорят, что A декорирует
B. Результат декорирования это C. В ходе исполнения функция C вызывает B, но с
изменениями. Например, корректирует входные или выходные данные B.</p>

<p>Приведем примеры простых декораторов. with-echo добавляет к функции побочные
эффекты: печатает аргументы и результат.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">with-echo</span><span class="w">
  </span><span class="p">[</span><span class="n">func</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">println</span><span class="w"> </span><span class="s">"The args are"</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"The result is"</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w">
      </span><span class="n">result</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">With-catch</code> оборачивает целевую функцию в форму <code class="language-plaintext highlighter-rouge">try/catch</code>. Если во время
работы выброшено исключение, результатом будет его объект.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">with-catch</span><span class="w">
  </span><span class="p">[</span><span class="n">func</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="n">e</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Мы уже рассматривали структуру Ring-запроса. Возможно, читатель заметил, что в
нем нет полей, с которыми он работал в других языках. Например, классы
<code class="language-plaintext highlighter-rouge">django.http.HttpRequest</code> и <code class="language-plaintext highlighter-rouge">flask.Request</code> в Python содержат поля <code class="language-plaintext highlighter-rouge">.params</code> или
<code class="language-plaintext highlighter-rouge">.values</code>. Это словари, полученные из адресной строки или тела запроса.</p>

<p>Почему в стандарте Ring нет столь важных вещей? Потому что не каждое приложение
в них нуждается. Фреймворк предоставляет только базовую информацию о
запросе. Остальные данные могут быть получены из исходных.</p>

<p>Представим, что на каждый запрос Ring парсит строку параметров и тело. Это
удобно разработчику, но резко снижает производительность сервера. Нет гарантии,
что параметры строки пригодятся в запросе. Но сервер потратит время и память на
их обработку. Еще хуже с обработкой тела. Вспомним, что это дорогая
операция. Возможен сценарий, когда сервер прочитал огромный JSON-документ, но
внутри обработчика выяснилось, что у пользователя нет прав на запись. Эту
проверку следовало выполнить раньше!</p>

<p>Как мы помним, обработчик запроса в Ring это функция, которая принимает запрос и
возвращает ответ. Техника middleware как нельзя лучше подходит, чтобы добавить
промежуточную логику. Параметры запроса, сессии, куки, права доступа — все это
функция, которая возвращает функцию.</p>

<p>Вам не придется писать все middleware с нуля. Ring уже содержит основные из
них. Остается только применить их к приложению. Рассмотрим некоторые middleware
и принципы их работы.</p>

<h3 id="параметры-запроса">Параметры запроса</h3>

<p>Стандарт HTTP разрешает передавать данные в адресной строке. Это пары вида
“name=John&amp;city=NY” после знака вопроса. Удобно, когда параметры доступны в виде
словаря. В нашем случае это была бы структура <code class="language-plaintext highlighter-rouge">{:name "John" :city "NY"}</code>.</p>

<p>Аналогично с параметрами из тела запроса. Их передают в теле по разным
причинам. В основном это ограничение на длину и проблемы безопасности. Длина
адресной строки ограничена 2048 байтами, в то время как на тело запроса
ограничений нет. Пароли и адреса почты небезопасно передавать в адресной строке,
потому что они остаются в логах и истории браузера.</p>

<p>Функция wrap-params из модуля ring.middleware.params меняет функцию-обработчик
следующим образом. Переданный в нее запрос дополняется тремя полями:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">:query-params</code> — словарь параметров адресной строки;</li>
  <li><code class="language-plaintext highlighter-rouge">:form-params</code> — словарь данных из тела запроса;</li>
  <li><code class="language-plaintext highlighter-rouge">:params</code> — их комбинированная версия.</li>
</ul>

<p>Пусть <code class="language-plaintext highlighter-rouge">app</code> — ваше веб-приложение. Чтобы получить его обернутую версию,
достаточно вызвать wrap-params c app. Результат будет финальным приложением. На
жаргоне разработчиков это называется “врапнуть” (анг. wrap — обернуть).</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.params</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-params</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">final-app</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-params</span><span class="w"> </span><span class="n">app</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы не запутаться в именах, придерживайтесь правил. Не обернутое приложение
называйте <code class="language-plaintext highlighter-rouge">app-naked</code> или <code class="language-plaintext highlighter-rouge">app-raw</code> (голое, сырое), а финальное просто <code class="language-plaintext highlighter-rouge">app</code>.</p>

<p>Доработайте веб-приложение из примера выше так, чтобы оно учитывало параметры
строки. Например, чтобы имя того, кого приветствовать, можно было задать
параметром who: /hello?who=John.</p>

<p>Подсказка: добраться до параметра who можно так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-hello</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">who</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">[</span><span class="no">:params</span><span class="w"> </span><span class="s">"who"</span><span class="p">])]</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>или так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-hello</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">who</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:params</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="s">"who"</span><span class="p">))]</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что ключи <code class="language-plaintext highlighter-rouge">:params</code> это строки. Это нормально, но Clojure
всячески поощряет нас, когда ключи словаря кейворды. Исправим это. В поставке
Ring есть особое middleware, которое приводит поле <code class="language-plaintext highlighter-rouge">:params</code> к удобному
виду. Это <code class="language-plaintext highlighter-rouge">wrap-keyword-params</code> из модуля <code class="language-plaintext highlighter-rouge">ring.middleware.keyword-params</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.keyword-params</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-keyword-params</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-keyword-params</span><span class="w"> </span><span class="p">(</span><span class="nf">wrap-params</span><span class="w"> </span><span class="n">app-naked</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Мы подошли к новой проблеме: когда врапперов много, от них возникает
шум. Типичное приложение включает десять-пятнадцать middleware:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-something-else</span><span class="w">
    </span><span class="p">(</span><span class="nf">wrap-current-user</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-session</span><span class="w">
        </span><span class="p">(</span><span class="nf">wrap-keyword-params</span><span class="w">
          </span><span class="p">(</span><span class="nf">wrap-params</span><span class="w"> </span><span class="n">app-naked</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Это кашу невозможно поддерживать. Представьте, что требуется добавить еще один
враппер где-то в середине. Это каскадно сдвинет элементы ниже. Чтобы победить
сложность, сделаем структуру линейной. Применим стрелочный оператор:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">app-naked</span><span class="w">
      </span><span class="n">wrap-params</span><span class="w">
      </span><span class="n">wrap-keyword-params</span><span class="w">
      </span><span class="n">wrap-session</span><span class="w">
      </span><span class="n">wrap-current-user</span><span class="w">
      </span><span class="n">wrap-something-else</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Такая форма напоминает обычный список, поэтому ее легко поддерживать.</p>

<p>Запись в стрелочном виде имеет особенность. Не заглядывая в следующее
предложение, догадайтесь, в каком порядке будут выполнены middleware? Правильный
ответ: снизу вверх для запроса и сверху вниз для ответа. Это может показаться
странным, но становится очевидным при мысленном разборе.</p>

<p>Сперва запрос зайдет в <code class="language-plaintext highlighter-rouge">wrap-something-else</code>. Код внутри него вызовет
обработчик, который получен из <code class="language-plaintext highlighter-rouge">wrap-current-user</code>. Обработчик внутри него –
результат <code class="language-plaintext highlighter-rouge">wrap-session</code>, и так далее. Вершиной подъема станет
<code class="language-plaintext highlighter-rouge">app-naked</code>. Структура ответа начнет опускаться по стеку вниз. Сначала он
пройдет через <code class="language-plaintext highlighter-rouge">wrap-params</code> и <code class="language-plaintext highlighter-rouge">wrap-keyword-params</code>. Эти два middleware не
изменяют ответ и просто возвращают его. <code class="language-plaintext highlighter-rouge">Wrap-session</code> и <code class="language-plaintext highlighter-rouge">wrap-current-user</code>,
возможно, допишут в него новые заголовки. Последним сработает
<code class="language-plaintext highlighter-rouge">wrap-something-else</code>. Цикл запроса и ответа пройден.</p>

<p>Цепочку middleware следует рассматривать как восхождение в гору и спуск с
нее. Другой аналогией может быть пузырек, который всплывает и опускается (не
имеет отношения к сортировке пузырьком).</p>

<p>По тому же принципу устроены middleware в Django, промышленном
Python-фреймворке. Хоть в Django их роль играют не функции, а классы, их порядок
обхода такой же.</p>

<p>Порядок middleware порой критичен. Некоторые из них опираются на данные, которые
подготовили предыдущие middleware. Рассмотрим уже знакомые <code class="language-plaintext highlighter-rouge">wrap-params</code> и
<code class="language-plaintext highlighter-rouge">wrap-keyword-params</code>. Последний отыскивает в запросе поле params и меняет тип
ключей. Подразумевается, что params был подготовлен
<code class="language-plaintext highlighter-rouge">wrap-keyword-params</code>. Поэтому <code class="language-plaintext highlighter-rouge">wrap-keyword-params</code> ставят строго после
<code class="language-plaintext highlighter-rouge">wrap-params</code>.</p>

<p>Посмотрим на форму <code class="language-plaintext highlighter-rouge">(def app...)</code> выше. В нее закралась ошибка. Запрос
поднимается снизу вверх, поэтому <code class="language-plaintext highlighter-rouge">wrap-keyword-params</code> сработает раньше. Он
попытается найти поле params в запросе, но безуспешно. Следом сработает
<code class="language-plaintext highlighter-rouge">wrap-params</code>. Он заполнит это поле словарем из адресной строки. В результате
params будет словарем с ключами-строками. Следует поменять wrap-params и
<code class="language-plaintext highlighter-rouge">wrap-keyword-params</code> местами.</p>

<p>Неверный порядок middleware стоит часов отладки. Но есть трюк. Если два и более
middleware идут в строгой последовательности, можно “схлопнуть” их в одно
целое. Стандартная функция comp принимает произвольное число функций и
возвращает супер-функцию, которая последовательно применяет их к
аргументу. Определим умный враппер параметров:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">wrap-params+</span><span class="w">
  </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">wrap-keyword-params</span><span class="w"> </span><span class="n">wrap-params</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Плюс на конце означает, что это улучшенная версия обычного wrap-params. Теперь
заменим в стеке <code class="language-plaintext highlighter-rouge">wrap-params</code> и <code class="language-plaintext highlighter-rouge">wrap-keyword-params</code> на <code class="language-plaintext highlighter-rouge">wrap-params+</code>. Цепочка
middleware станет короче, а логика параметров соберется в отдельном месте.</p>

<p>Перечислим другие полезные middleware. Мы не будем останавливаться на детальном
описании каждого. Это скорее индекс, к которому можно обратиться в случае
надобности.</p>

<h3 id="cookie">Cookie</h3>

<p>В стандарте HTTP куки — это маленькие кусочки информации. Между сервером и
браузером особое соглашение о том, как хранить и передавать их. Если сервер
выставил куки, браузер запоминает их для этого сайта. В следующий раз браузер
отправит куки на сервер автоматически. Так продолжается до тех пор, пока сервер
не удалит куки или истечет их срок жизни.</p>

<p>Простейший случай, когда нужны куки — определить, был ли уже пользователь на
сайте. При первом визите приложение ищет в запросе куки с именем visited. Если
значение не установлено, сервер выставляет заголовок вроде:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set-Cookie: visited=true;
</code></pre></div></div>

<p>В последующих запросах браузер отправит это значение на сервер
самостоятельно. Приложение проверяет: если <code class="language-plaintext highlighter-rouge">visited true</code>, значит пользователь
уже был на сайте. Такие проверки влияют на показ рекламы, всплывающие окна,
попапы с обновлениями.</p>

<p>Технически куки — это один длинный заголовок, где значения и атрибуты разделены
специальными точками с запятой. Middleware wrap-cookie значительно облегчает
работу с куки. Во время запроса заголовок преображается в словарь в поле
<code class="language-plaintext highlighter-rouge">:cookies</code>. Чтобы сообщить клиенту новые куки, добавьте поле <code class="language-plaintext highlighter-rouge">:cookies</code> в
ответ. Из такого словаря образуется заголовок <code class="language-plaintext highlighter-rouge">Set-Cookie</code>.</p>

<p>Напишем простую страничку, которая определяет, видим ли мы ее в первый раз.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.cookies</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-cookies</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-seen</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">seen-path</span><span class="w"> </span><span class="p">[</span><span class="no">:seen</span><span class="w"> </span><span class="no">:value</span><span class="p">]</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">cookies</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="n">seen?</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">cookies</span><span class="w"> </span><span class="n">seen-path</span><span class="p">)</span><span class="w">
        </span><span class="n">cookies</span><span class="w"> </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="n">cookies</span><span class="w"> </span><span class="n">seen-path</span><span class="w"> </span><span class="n">true</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:cookies</span><span class="w"> </span><span class="n">cookies</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">seen?</span><span class="w">
             </span><span class="s">"Already seen"</span><span class="w">
             </span><span class="s">"The first time you see it"</span><span class="p">)</span><span class="w"> </span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">page-seen</span><span class="w">
      </span><span class="n">wrap-cookies</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запустите приложение в браузере. После обновления страницы надпись изменится на
“Already seen”. Обратите внимание, что даже после перезагрузки сервера ответ
по-прежнему будет “Already seen”, потому что флаг хранится в браузере. Только
очистив куки вы снова увидите “The first time you see it”. Для полноты
эксперимента откройте приватную вкладку или другой браузер.</p>

<p>Куки тесно связаны с безопасностью. Даже если вам понятны технические детали,
убедитесь, что куки защищены от кражи и не раскрывают секретные данные (пароли,
ключи доступа). В этом разделе мы не обсуждаем тему веб-безопасности. Она
слишком обширна для этой главы и заслуживает отдельной книги.</p>

<h3 id="сессии">Сессии</h3>

<p>Стандарт HTTP не предполагает связи между двумя запросами. Считается, что два
запроса с соседних компьютеров разницей в пять минут связаны так же, как с
разных континентов разницей в год. Но сразу с рождения веба разработчики
нарушили стандарт. Понадобилось хранить состояние конкретного пользователя. Даже
если компьютеры за одним столом, сервер должен различать их. Это назвали сессией
или сеансом.</p>

<p><code class="language-plaintext highlighter-rouge">Wrap-session</code> это довольно сложное middleware. Оно дополняет запрос полем
<code class="language-plaintext highlighter-rouge">:session</code>, в котором словарь. Его ключи — поля сессии. Чтобы обновить сессию,
следует положить ее новую версию в ответ по аналогии с <code class="language-plaintext highlighter-rouge">:cookie</code>. Middleware
различает <code class="language-plaintext highlighter-rouge">nil</code> и факт отсутствия сессии в ответе. Если поле <code class="language-plaintext highlighter-rouge">:session</code> <code class="language-plaintext highlighter-rouge">nil</code>, вся
сессия удаляется. Если ключа нет, ничего не происходит.</p>

<p>Сессия это абстрактное понятие, поэтому различают бэкенды сессии. Это разные
способы хранить значения физически. Сессия может храниться в памяти, на диске, в
базе данных, Memcached/Redis или даже куках. При выборе бэкенда важно учитывать,
способен ли он работать на нескольких машинах одновременно. Что получится, если
каждый запрос сработает на случайно выбранной из десяти машин?</p>

<p>Если сессия хранится в памяти приложения, то на каждой машине будет ее разная
версия. Это чревато странным поведением и трудной отладкой. Аналогично с файлами
— машины не делят их между собой. А вот база данных или Redis это общее
хранилище. Оно гарантирует актуальность сессии для всех клиентов.</p>

<p>Интересно, что сессия на базе куки тоже работает на множестве машин. На каждый
запрос браузер передает и получает полную сессию в HTTP-заголовках. В этом
случае сессия хранится на клиенте. Но если пользователь очистит куки или
запустит другой браузер, сессия будет утеряна.</p>

<p>В стандартной поставке Ring сессия хранится в памяти или куках. Хранилище
определяется настройками wrap-session. Ring закладывает необходимые абстракции,
чтобы хранить сессию в базе или key-value системах типа Redis.</p>

<p>Рассмотрим пример со счетчиком посещений. Будем считать, сколько раз
пользователь зашел на наш сайт. Для простоты храним сессию в памяти.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.session</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-session</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-counter</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">session</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="n">session</span><span class="w"> </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="n">session</span><span class="w"> </span><span class="no">:counter</span><span class="w"> </span><span class="p">(</span><span class="nf">fnil</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">0</span><span class="p">))]</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:session</span><span class="w"> </span><span class="n">session</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Seen %s time(s)"</span><span class="w"> </span><span class="p">(</span><span class="no">:counter</span><span class="w"> </span><span class="n">session</span><span class="p">))}))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">page-counter</span><span class="w">
      </span><span class="n">wrap-session</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запустите app в веб-сервере и откройте браузер. Обновляйте страницу, и счетчик в
сообщении возрастет с каждым просмотром. Ради интереса проделайте то же самое в
другом браузере. Это будет вторая сессия, которая не зависит от
первой. Поскольку данные хранится в памяти, они будут утеряны при перезагрузке
сервера.</p>

<p>Упражнение: в примере выше мы считаем просмотры для всего сайта. Сделайте так,
чтобы счетчик работал в рамках страниц. Например, главная страница <code class="language-plaintext highlighter-rouge">/</code>
просмотрена пять раз, а справка <code class="language-plaintext highlighter-rouge">/help</code> — три раза. Параметры командной строки
не влияют на подсчет.</p>

<h3 id="json">JSON</h3>

<p>Формат JSON предназначен для передачи данных. Среду прочих его достоинств —
типы, вложенность и совместимость с JavaScript.</p>

<p>JSON различает базовые типы данных — числа, строки, логический тип. Это выгодно
отличает его от параметров адресной строки или XML, где все значения строки.</p>

<p>Формат предусматривает основные коллекции — массив и словарь — и их произвольную
вложенность. В разное время были попытки передать вложенные данные в адресной
строке. Общий подход был в том, чтобы ключ содержал путь внутри
структуры. Например, если в данных несколько адресов, а у каждого адреса
несколько строк (line 1, line 2, etc), то получается что-то вроде:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>address[0].line[0].value=SomeStreet
</code></pre></div></div>

<p>Требовалось писать и поддерживать код для работы с такими парами. Каждый
фреймворк нес на борту собственный модуль, чтобы упаковывать и восстанавливать
коллекции. К счастью, сегодня с этим покончено. Сегодня только старые системы
передают коллекции через командную строку.</p>

<p>JSON совместим с JavaScript. Если передать такой документ в функцию <code class="language-plaintext highlighter-rouge">eval</code>, она
вернет данные — комбинацию списков и словарей.</p>

<p>Все это способствовало тому, чтобы JSON стал главным способом передать данные в
интернете.</p>

<p>Ring предлагает набор middleware для JSON. Они вынесены в отдельный пакет для
удобства разработки. Добавим в проект зависимость:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ring/ring-json</span><span class="w"> </span><span class="s">"0.4.0"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>wrap-json-response облегчает возврат JSON-данных. Это middleware проверяет поле
ответа <code class="language-plaintext highlighter-rouge">:body</code>. Если это коллекция (вектор, словарь), то middleware заменяет его
на кодированную строку и выставляет заголовок <code class="language-plaintext highlighter-rouge">Content-Type: application/json</code>.</p>

<p>Рассмотрим пример:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.json</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-json-response</span><span class="p">]])</span><span class="w">


</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-data</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:some</span><span class="w"> </span><span class="p">{</span><span class="no">:json</span><span class="w"> </span><span class="p">[</span><span class="s">"data"</span><span class="p">]}}})</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">page-data</span><span class="w">
      </span><span class="n">wrap-json-response</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Более сложный пример. Если пользователь нашелся, возвращаем его модель. Если
нет, то структуру ошибки.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-data</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:params</span><span class="w"> </span><span class="no">:id</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">user-id</span><span class="p">)]</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="n">user</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:error_code</span><span class="w"> </span><span class="s">"MISSING_USER"</span><span class="w">
              </span><span class="no">:error_message</span><span class="w"> </span><span class="s">"No such a user"</span><span class="w">
              </span><span class="no">:error_data</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="n">user-id</span><span class="p">}}})))</span><span class="w">
</span></code></pre></div></div>

<p>Для входящего JSON-документа в библиотеке два middleware. Это <code class="language-plaintext highlighter-rouge">wrap-json-body</code> и
<code class="language-plaintext highlighter-rouge">wrap-json-params</code>. На фазе запроса оба проверяют, что заголовок <code class="language-plaintext highlighter-rouge">Content-Type</code>
содержит <code class="language-plaintext highlighter-rouge">application/json</code>. Если да, они парсят тело с учетом возможных
исключений. При ошибке разбора ответ будет 400 “JSON body malformed”.</p>

<p>Разница между <code class="language-plaintext highlighter-rouge">wrap-json-body</code> и <code class="language-plaintext highlighter-rouge">wrap-json-params</code> в том, куда они складывают
полученные данные.</p>

<p><code class="language-plaintext highlighter-rouge">Wrap-json-body</code> заменяет поле <code class="language-plaintext highlighter-rouge">:body</code> запроса на полученную структуру данных. В
примере ниже обработчик <code class="language-plaintext highlighter-rouge">page-body</code> извлекает имя и город пользователя из
<code class="language-plaintext highlighter-rouge">:body</code>. Тело запроса уже не входящий поток, а структура данных, о чем заботится
<code class="language-plaintext highlighter-rouge">wrap-json-body</code>. Обратите внимание, middleware принимает опциональные
параметры. Флаг <code class="language-plaintext highlighter-rouge">:keywords? true</code> Означает, что ключи словарей должны быть
приведены к кейвордам.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.json</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-json-body</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-body</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">body</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">username</span><span class="w"> </span><span class="n">city</span><span class="p">]}</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">create-user</span><span class="w"> </span><span class="n">username</span><span class="w"> </span><span class="n">city</span><span class="p">)</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:code</span><span class="w"> </span><span class="s">"CREATED"</span><span class="w">
            </span><span class="no">:message</span><span class="w"> </span><span class="s">"User created"</span><span class="p">}}))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">page-body</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-json-body</span><span class="w"> </span><span class="p">{</span><span class="no">:keywords?</span><span class="w"> </span><span class="n">true</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы отправить JSON-запрос к серверу, понадобится специальная программа. Это
может быть утилита cURL или графическое приложение Postman. Пример с cURL:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="se">\</span>
  <span class="nt">--header</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">--request</span> POST <span class="se">\</span>
  <span class="nt">--data</span> <span class="s1">'{"username":"John","city":"NY"}'</span> <span class="se">\</span>
  http://localhost:8080/
</code></pre></div></div>

<p>Вариант с <code class="language-plaintext highlighter-rouge">wrap-json-params</code> Отличается тем, где хранится структура данных. Это
middleware заносит данные в поле <code class="language-plaintext highlighter-rouge">:json-params</code>. В дополнение, если данные были
словарем, они вливаются в поле <code class="language-plaintext highlighter-rouge">:params</code>. Это поле, как мы помним, используются
другими врапперами, например, <code class="language-plaintext highlighter-rouge">wrap-params</code>.</p>

<p>Таким образом, <code class="language-plaintext highlighter-rouge">:params</code> выступает универсальным аккумулятором
параметров. Продвинутое API может быть устроено так, что клиент вправе
передавать данные удобным ему способом. Например, GET-запросом с параметрами
строки, если это данные для чтения. POST с переменными в теле, чтобы изменять
сущности. Или POST с JSON-телом, если данные с глубокой вложенностью.</p>

<p>Вспомним, что params это словарь с ключам-строками. По этой причине
<code class="language-plaintext highlighter-rouge">wrap-json-params</code> сохраняет строки в ключах, чтобы слияние прошло
правильно. Чтобы исправить ключи <code class="language-plaintext highlighter-rouge">:params</code> на кейворды, используйте уже знакомое
нам <code class="language-plaintext highlighter-rouge">wrap-keyword-params</code>. Оно должно быть ниже <code class="language-plaintext highlighter-rouge">wrap-json-params</code> по стеку.</p>

<p>Разработчики не случайно выделяют поле <code class="language-plaintext highlighter-rouge">:json-params</code>. Тело JSON-документа не
обязательно словарь, это может быть массив. Такую структуру невозможно влить в
<code class="language-plaintext highlighter-rouge">:params</code>. Документ помещают в <code class="language-plaintext highlighter-rouge">:json-params</code>, и если это словарь, объединяют с
<code class="language-plaintext highlighter-rouge">:params</code>.</p>

<p>Продемонстрируем сказанное на примере. Передаем данные гибридно: <code class="language-plaintext highlighter-rouge">username</code> в
теле JSON-документа и <code class="language-plaintext highlighter-rouge">city</code> в параметрах строки. Обратите внимание на стек
middleware. Сперва мы парсим параметры строки, затем тело документа. Оба словаря
накапливаются в <code class="language-plaintext highlighter-rouge">:params</code>. Затем, уже после их накопления, исправляем тип
ключей.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.json</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-json-params</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-params</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">params</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">username</span><span class="w"> </span><span class="n">city</span><span class="p">]}</span><span class="w"> </span><span class="n">params</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">create-user</span><span class="w"> </span><span class="n">username</span><span class="w"> </span><span class="n">city</span><span class="p">)</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:code</span><span class="w"> </span><span class="s">"CREATED"</span><span class="w">
            </span><span class="no">:message</span><span class="w"> </span><span class="s">"User created"</span><span class="p">}}))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">page-params</span><span class="w">
      </span><span class="n">wrap-keyword-params</span><span class="w">
      </span><span class="n">wrap-json-params</span><span class="w">
      </span><span class="n">wrap-params</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Пример обращения к серверу:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="se">\</span>
  <span class="nt">--header</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">--request</span> POST <span class="se">\</span>
  <span class="nt">--data</span> <span class="s1">'{"username":"John"}'</span> <span class="se">\</span>
  http://localhost:8080/?city<span class="o">=</span>NY
</code></pre></div></div>

<h3 id="собственные-middleware">Собственные middleware</h3>

<p>До сих пор мы использовали сторонние врапперы. Это те, что идут в поставке Ring
и смежных библиотек. Но рано или поздно вам потребуются собственные. Обычно их
накапливают в модуле с именем <code class="language-plaintext highlighter-rouge">&lt;projectname&gt;.middleware</code>. Рассмотрим примеры из
реальных проектов.</p>

<h4 id="wrap-headers-kw">wrap-headers-kw</h4>

<p>Этот простой враппер меняет ключи заголовков со строковых на кейворды. Полезно,
когда приложение часто обращается к заголовкам.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w">
 </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.walk</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">keywordize-keys</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-headers-kw</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w">
      </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:headers</span><span class="w"> </span><span class="n">keywordize-keys</span><span class="p">)</span><span class="w">
      </span><span class="n">handler</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h4 id="wrap-request-id">wrap-request-id</h4>

<p>В протоколе HTTP запрос и ответ не связаны друг с другом. Порой трудно понять, к
какому запросу относится тот или иной ответ и наоборот. Важно, чтобы система
могла их сопоставить. Например, была серия ответов с кодом 500, но какие именно
запросы вызвали ошибку?</p>

<p>Для этого ввели заголовок <code class="language-plaintext highlighter-rouge">X-Request-Id</code>. Если клиент не передал идентификатор
запроса, мы назначаем ему случайный. Тот же идентификатор возвращаем в
ответе. Все записи в лог содержат этот идентификатор.</p>

<p>Обратите внимание, что мы обращаемся к заголовкам как к ключевым словам. Мы
ожидаем, что <code class="language-plaintext highlighter-rouge">wrap-headers-kw</code> был выше по стеку.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="ss">'java.util.UUID</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-request-id</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">uuid</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">[</span><span class="no">:headers</span><span class="w"> </span><span class="no">:x-request-id</span><span class="p">])</span><span class="w">
                   </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">UUID/randomUUID</span><span class="p">)))]</span><span class="w">
      </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w">
          </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="p">[</span><span class="no">:headers</span><span class="w"> </span><span class="no">:x-request-id</span><span class="p">]</span><span class="w"> </span><span class="n">uuid</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="no">:request-id</span><span class="w"> </span><span class="n">uuid</span><span class="p">)</span><span class="w">
          </span><span class="n">handler</span><span class="w">
          </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="p">[</span><span class="no">:headers</span><span class="w"> </span><span class="no">:x-request-id</span><span class="p">]</span><span class="w"> </span><span class="n">uuid</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Мы храним идентификатор не только в заголовках, но и на уровне запроса в поле
<code class="language-plaintext highlighter-rouge">:request-id</code>. Для записи в лог мы будем часто обращаться к нему. Поэтому
вынесем в отдельную переменную вместе с другими полями в начале функции:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">some-handler</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">params</span><span class="w"> </span><span class="n">request-id</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"Request id: %s"</span><span class="w"> </span><span class="n">request-id</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h4 id="wrap-current-user">wrap-current-user</h4>

<p>Этот враппер определяет текущего пользователя системы. Стратегия в том, что в
запросе содержится идентификатор пользователя. В данном случае мы ищем его в
сессии. Если идентификатор найден, читаем модель пользователя и присоединяем к
запросу. Ожидается, что функция <code class="language-plaintext highlighter-rouge">get-user-by-id</code> знает, как извлекать данные о
пользователе. Чаще всего это запрос к базе данных.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-current-user</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:session</span><span class="w"> </span><span class="no">:user-id</span><span class="p">)</span><span class="w">
          </span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">user-id</span><span class="w">
                 </span><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">user-id</span><span class="p">))]</span><span class="w">
      </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w">
          </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="no">:user</span><span class="w"> </span><span class="n">user</span><span class="p">)</span><span class="w">
          </span><span class="n">handler</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Условно говоря, хранить <code class="language-plaintext highlighter-rouge">user-id</code> в сессии безопасно. Сессия подписана секретным
ключом, поэтому только сервер может менять ее значения. Не допускайте, чтобы
<code class="language-plaintext highlighter-rouge">user-id</code> передавался в параметрах командной строки.</p>

<h3 id="прерывание-стека">Прерывание стека</h3>

<p>Выше мы рассмотрели непрерывную цепочку middleware, где каждое звено передает
управление следующему. Но логика middleware не всегда линейна. Бывает, цепочку
необходимо разорвать. Например, еще на уровне middleware мы определили, что
пользователь не имеет прав к данному ресурсу. Продолжать цепочку по обычному
пути не имеет смысла. Наоборот, мы должны как можно скорее вывалиться из стека.</p>

<p>Стандартные врапперы из примеров выше работают на условиях. Так,
<code class="language-plaintext highlighter-rouge">wrap-json-params</code> читает тело только в том случае, если заголовок
<code class="language-plaintext highlighter-rouge">Content-Type</code> установлен в <code class="language-plaintext highlighter-rouge">application/json</code>. Если в нем что-то другое, он
оставит поток нетронутым. При разборе JSON-документа ловится возможное
исключение. Такое возможно, если документ сформирован с ошибками или поврежден
при передачи. В таком случае <code class="language-plaintext highlighter-rouge">wrap-json-params</code> не продолжает цепочку. Он
возвращает ответ с текстом “JSON body malformed”. Ни одно middleware ниже по
стеку не сработает.</p>

<p>Рассмотрим частный случай с проверкой доступа. Предположим, приложение доступно
только авторизованным пользователям. Мы уже определили текущего пользователя в
<code class="language-plaintext highlighter-rouge">wrap-current-user</code>. То middleware только определяет пользователя, но не
ограничивает доступ. Добавим ниже по стеку другое:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-auth-user-only</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="no">:user</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">403</span><span class="w">
       </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="s">"Please sign in to see that page."</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь все middleware ниже <code class="language-plaintext highlighter-rouge">wrap-auth-user-only</code> не сработает если пользователь
не авторизован.</p>

<p>Вспомним, цепочку middleware можно представить как восхождение и спуск с
горы. Если один из элементов терпит неудачу, мы как будто срезаем
верхушку. Словно добрались до середины, столкнулись с проблемой и повернули
обратно. Общее правило: чем раньше мы обнаружим проблему, тем меньше потратим
сил. Поэтому более общие проверки мы ставим выше по стеку.</p>

<p>Еще один вариант middleware с развилкой это перехват ошибок. Это критически
важный обработчик. Вы не найдете его в стандартных библиотеках, потому что
логика работы с ошибками меняется от проекта к проекту. Мы просто копируем такой
middleware из прошлого проекта с небольшими изменениями.</p>

<p>Что случится, если при обработке запроса выброшено исключение? Не существует
четких правил на этот счет. Каждый сервер или фреймворк обрабатывает исключения.</p>

<p>Один сервер покажет в браузере стек-трейс. Другой сервер вернет HTML-страницу с
отладочной информацией. Разработчики третьего посчитали, что выводить стек-трейс
небезопасно. Исключение пишут в лог, а в ответе статус 500 и фраза “Internal
Server Error”.</p>

<p>Хорошо, когда разработчик сам определяет, что делать с исключениями. Ниже
простое middleware, которое перехватывает потенциальную ошибку, пишет ее в лог и
возвращает ответ-заглушку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-exception</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">uri</span><span class="w">
                      </span><span class="n">request-method</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nf">log/errorf</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"Error, method %s, path %s"</span><span class="w">
                      </span><span class="n">request-method</span><span class="w"> </span><span class="n">uri</span><span class="p">)</span><span class="w">
          </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">500</span><span class="w">
           </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
           </span><span class="no">:body</span><span class="w"> </span><span class="s">"Sorry, please try later."</span><span class="p">})))))</span><span class="w">
</span></code></pre></div></div>

<p>В примере выше <code class="language-plaintext highlighter-rouge">log/errorf</code> это макрос для записи ошибок. Он принимает объект
исключения, шаблон и параметры. Мы хотим знать, какие были метод и путь запроса,
поэтому записываем их тоже. Это значительно облегчит анализ логов в будущем.</p>

<p>Чем выше <code class="language-plaintext highlighter-rouge">wrap-exception</code> расположено в стеке, тем меньше шансов возникнуть не
пойманному исключению. В идеале оно стоит на вершине цепочки, чтобы
гарантированно ловить все исключения.</p>

<p>Порой даже используют стратегию двойного перехвата. Дело в том, что ошибки в
разных частях системы заслуживают разного подхода. Например, нам важно знать все
об ошибках в бизнес-логике. Если пользователь не смог создать сущность на
сервере, мы обязаны записать дату, номер пользователя, имя модуля и функции,
данные, которые вызвали ошибку. Возможно, этот случай запишут сразу в несколько
журналов. Но проблемы при чтении JSON-документа нас интересуют меньше. Это
техническая проблема, не связанная с бизнесом.</p>

<p>Чтобы разделять бизнес- и технические проблемы, на границах стека middleware
расставляют разные wrap-exception. Самое нижнее оборачивает непосредственно
app-naked. Оно отлавливает исключения в бизнес-логике. Такую ошибку обрабатывают
подробно, во всех деталях. На вершине стека другая, облегченная версия
wrap-exception. Его задача — ловить мелкие ошибки, связанные с предварительной
обработкой запроса. По большей части это для того, чтобы возвращать адекватный
ответ пользователю.</p>

<h3 id="middleware-вне-стека">Middleware вне стека</h3>

<p>Интересен сценарий, когда middleware должно оказать эффект только на запросы по
определенному пути. Вернемся к wrap-auth-user-only. В чем его недостаток? Если
включить его в стек, анонимный пользователь не увидит ни одну
страницу. Абсолютно любой запрос будет отклонен со статусом 403. Главная
страница, контактные данные, форма входа — все страницы недоступны. В этом нет
никакого смысла.</p>

<p>Очевидно, <code class="language-plaintext highlighter-rouge">wrap-auth-user-only</code> должен перекрывать только некоторое подмножество
запросов. Например, тех, что начинаются с <code class="language-plaintext highlighter-rouge">/account</code>: <code class="language-plaintext highlighter-rouge">/account/cart</code>,
<code class="language-plaintext highlighter-rouge">/account/orders</code> и т.д. Место <code class="language-plaintext highlighter-rouge">wrap-auth-user-only</code> не в общем стеке, а ниже —
на уровне роутинга.</p>

<p>Дальнейшая реализация зависит от того, как мы строим маршруты. В Compojure есть
особое middleware под названием wrap-routes. Оно принимает правило и другое
middleware. Если правило накладывается на текущий запрос, то целевой обработчик
оборачивается в переданное middleware. Столь сложная логика нужна, чтобы не
вызывать middleware, пока запрос не совпадет с правилом.</p>

<p>Вынесем семейство маршрутов для аккаунта в отдельную ветку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defroutes</span><span class="w"> </span><span class="n">account-routes</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-context</span><span class="w"> </span><span class="s">"/account"</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/profile"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">account-profile</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/orders"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">account-orders</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/cart"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">account-cart</span><span class="w"> </span><span class="n">request</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Обернем аккаунты в маршрутах верхнего уровня:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defroutes</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-index</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/help"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-help</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-routes</span><span class="w"> </span><span class="n">account-routes</span><span class="w"> </span><span class="n">wrap-auth-user-only</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь <code class="language-plaintext highlighter-rouge">wrap-auth-user-only</code> сработает только для обработчиков
<code class="language-plaintext highlighter-rouge">account-profile</code>, <code class="language-plaintext highlighter-rouge">account-orders</code> и <code class="language-plaintext highlighter-rouge">account-cart</code>.</p>

<h3 id="все-вместе">Все вместе</h3>

<p>Middleware, которое принимает middleware — довольно крутая абстракция. Если вы
действительно поняли, как это работает и почему именно так — примите
поздравления. Это серьезный рубеж.</p>

<p>Пожалуй, это все, что можно сказать о middleware. Небольшое обобщение: все, что
мы проделали выше работает на функциях. Типичное middleware это функция, которая
принимает функцию и возвращает функцию. Middleware — универсальный строительный
материал.</p>

<p>Цепочку middleware называют стеком. Во время запроса мы движемся по стеку снизу
вверх, во время ответа — сверху вниз. Такой обход можно сравнить с восхождением
в гору. Каждое middleware может прервать цепочку в зависимости от
обстоятельств. Легче всего выразить стек с помощью стрелочного оператора. Это
экономит скобки и делает структуру наглядней.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментарии</center>

<div id="comments">
  
    <div id="comment-4386582032" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Mikhail Kirillov,
            20th Mar 2019,
            <a href="#comment-4386582032">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Очень круто и полезно!</p>
</div>
    </div>
  
    <div id="comment-4386741132" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Mike Ananev,
            20th Mar 2019,
            <a href="#comment-4386741132">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Иван, здорово.<br />Хотел бы отметить, что после bidi появился очень крутой router от Metosin <a href="https://github.com/metosin/reitit" rel="nofollow noopener" title="https://github.com/metosin/reitit">https://github.com/metosin/...</a><br />У этого роутера есть ряд ключевых преимуществ: высочайшая скорость, возможность работы как с ring так и интерцепторами, очень хороший вывод ошибок.<br />Посмотреть их отчет с графиками можно тут <a href="#" rel="nofollow noopener" title="#">https://metosin.github.io/reitit/performance.html</a></p>
</div>
    </div>
  
    <div id="comment-4386783689" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            20th Mar 2019,
            <a href="#comment-4386783689">link</a>
            , <a href="#comment-4386741132">parent</a>
          </em>
        </small>
      </p>
      <div><p>Да, попадался пост о нем в planet Clojure. Но роуты на векторах как-то не заходят...</p>
</div>
    </div>
  
    <div id="comment-4387089710" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            anonymous,
            20th Mar 2019,
            <a href="#comment-4387089710">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Для деструктуризации мапы со строковыми ключами можно использовать {:strs [...]}.</p>
</div>
    </div>
  
    <div id="comment-4387097156" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            20th Mar 2019,
            <a href="#comment-4387097156">link</a>
            , <a href="#comment-4387089710">parent</a>
          </em>
        </small>
      </p>
      <div><p>Ого, не знал!!!</p>
</div>
    </div>
  
    <div id="comment-4387118787" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Иван,
            20th Mar 2019,
            <a href="#comment-4387118787">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Отличный пост! Несколько опечаток: Этозначит :cookei :cookes</p>
</div>
    </div>
  
    <div id="comment-4393785933" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Tim Arbaev,
            25th Mar 2019,
            <a href="#comment-4393785933">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Очень доходчиво написано, спасибо!</p>
</div>
    </div>
  
    <div id="comment-4393816641" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            25th Mar 2019,
            <a href="#comment-4393816641">link</a>
            , <a href="#comment-4387118787">parent</a>
          </em>
        </small>
      </p>
      <div><p>Мерси, поправил.</p>
</div>
    </div>
  
    <div id="comment-4431554205" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Максим,
            20th Apr 2019,
            <a href="#comment-4431554205">link</a>
            
          </em>
        </small>
      </p>
      <div><blockquote>все промышленные веб-фреймворки: Django, Rails, Symphony.</blockquote>
<p> Мелкая опечаточка -- Symfony вместо Symphony</p>
<p></p>
<blockquote>Названия классов и их композиция различаются, но суть остается прежней. Это приложение, маршрутизатор, обработчик, запрос и ответ. Проблема в том, что каждый фремворк моделирует собственные классы, которые несовместимы между собой в рамках языка.</blockquote>
<p>В общем cлучае это верно, но в PHP во всех топовых фреймворках уже во всю внедряется стандарт PSR, в частности для работы c HTTP это PSR-7 Request/Response, для Middleware это PSR-15. Может кому будет интересно, ну или чтобы просто запомнил народ, что не все так "по-обезьянне в этой "надстройке над html"". В самом Symfony, который и задал моду этим абстракциям остались свои Request/Response и из-за обратной совместимости выпилить не могут, но сделали компоненту Request Bridge :) Да, не все гладко как всегда.</p>
<p>Все современные микрофреймворки и Laravel работают с единым, очень много самых популярных решений уже их поддерживают, я не про реквесты, а в целом про некие общие решения, например PSR-3 для логгера.</p>
</div>
    </div>
  
    <div id="comment-4465422764" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Dumitru Pletosu,
            16th May 2019,
            <a href="#comment-4465422764">link</a>
            , <a href="#comment-4386783689">parent</a>
          </em>
        </small>
      </p>
      <div><p>Роуты на векторах хорошо идут в миксе с систем вроде <a href="https://github.com/weavejester/integrant" rel="nofollow noopener" title="https://github.com/weavejester/integrant">Integrant</a>.  Data driven all the way down.</p>
<p>В итоге получается что-то подобное <a href="https://github.com/dimovich/roll#example" rel="nofollow noopener" title="https://github.com/dimovich/roll#example">этому</a>.</p>
</div>
    </div>
  
    <div id="comment-4519297415" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Antony,
            28th Jun 2019,
            <a href="#comment-4519297415">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Спасибо!<br />Пару замечаний по коду</p>
<p><code>(def app<br /><br />  (-&gt; page-body<br /><br />      wrap-json-body {:keywords? true})) ;; здесь не хватает скобок</code></p>
<p>……</p>
<p>      <code>(-&gt; request<br /><br />          (assoc-in [:headers :x-request-id] uuid)<br /><br />          (assoc :request-id uuid)<br /><br />          handler<br /><br />          (assoc-in [:headers :x-request-id] uuid))))) ;; кажется эта строка лишняя</code></p>
</div>
    </div>
  
    <div id="comment-4519528307" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            28th Jun 2019,
            <a href="#comment-4519528307">link</a>
            , <a href="#comment-4519297415">parent</a>
          </em>
        </small>
      </p>
      <div><p>Спасибо. В первом случае поправил, а во втором норм: заголовок X-Request-ID добавляется и к запросу, и к ответу.</p>
</div>
    </div>
  
    <div id="comment-4566853468" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Незнакомец,
            5th Aug 2019,
            <a href="#comment-4566853468">link</a>
            
          </em>
        </small>
      </p>
      <div><p>небольшая опечатка, вот так не компилиться [ring-jetty-adapter "1.7.1"] на clojars вот так <a href="https://clojars.org/ring/ring-jetty-adapter" rel="nofollow noopener" title="https://clojars.org/ring/ring-jetty-adapter">[ring/ring-jetty-adapter "1.7.1"]</a></p>
</div>
    </div>
  
    <div id="comment-4567642827" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            6th Aug 2019,
            <a href="#comment-4567642827">link</a>
            , <a href="#comment-4566853468">parent</a>
          </em>
        </small>
      </p>
      <div><p>Верно, поправил. Спасибо.</p>
</div>
    </div>
  
    <div id="comment-4606637770" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Aleksei Permiakov,
            6th Sep 2019,
            <a href="#comment-4606637770">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Спасибо, отличная статья! Единственное вызвало некоторую путаницу "верх" и "низ" стека.<br />Я так понимаю, wrap-exception нужно ставить как можно дальше от app-naked чтобы гарантированно ловить все исключения?</p>
</div>
    </div>
  
    <div id="comment-4607443093" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            7th Sep 2019,
            <a href="#comment-4607443093">link</a>
            , <a href="#comment-4606637770">parent</a>
          </em>
        </small>
      </p>
      <div><p>Насчет "вверх и вниз" напрашивается иллюстрация, согласен. Да, wrap-exception должен стоять как можно дальше от целевого приложения, чтобы поймать ошибки в других middleware.</p>
</div>
    </div>
  
    <div id="comment-4616397021" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            antonymous,
            15th Sep 2019,
            <a href="#comment-4616397021">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Большущее спасибо за Ваш труд! Крайне полезен!</p>
<p></p>
<blockquote>:headers — заголовки ответа. В отличии от заголовков запроса, ключи и значения не обязательно строки. Вариант ниже корректен:</blockquote>
<p><br />Почему-то у меня это не работает:<br /><code><br />java.lang.ClassCastException: class clojure.lang.Keyword cannot be cast to class java.lang.String (clojure.lang.Keyword is in unnamed module of loader 'app'; java.lang.String is in module java.base of loader 'bootstrap')<br />at ring.util.servlet$set_headers.invokeStatic(servlet.clj:73)<br /></code><br />Приходится все keywords переделывать на строки.</p>
<p>А вот в композиции зависимых оберток у Вас порядок их следования перепутан:<br /></p>
<blockquote><br />(def wrap-params+<br />  (comp wrap-keyword-params wrap-params))<br /></blockquote>
<p></p>
<p>Из (source comp) следует равенство ((comp f g) x) = (f (g x)).<br />Обычная, не-стрелочная, запись прямо повторяет его правую часть:<br /><code><br />(defn wrap-params+<br />  [handler]                         ; x<br />  (wrap-params                      ; (f<br />    (wrap-keyword-params handler))) ; (g x))<br /></code></p>
<p>Следовательно, должно быть <br /><code><br />(def wrap-params+<br />  (comp wrap-params wrap-keyword-params))<br /></code></p>
</div>
    </div>
  
    <div id="comment-4617598884" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            16th Sep 2019,
            <a href="#comment-4617598884">link</a>
            , <a href="#comment-4616397021">parent</a>
          </em>
        </small>
      </p>
      <div><p>Насколько я помню, функции, переданные в comp, вычисляются cправа налево. Например, ((comp str inc) 0) даст "1". Сначала мы должны распарсить параметры, а потом перевести их в ключи. Если расположить эти функции справа налево, получится (comp wrap-keyword-params wrap-params).</p>
</div>
    </div>
  
    <div id="comment-4623509699" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            antonymous,
            21st Sep 2019,
            <a href="#comment-4623509699">link</a>
            , <a href="#comment-4617598884">parent</a>
          </em>
        </small>
      </p>
      <div><p>Да! Только композиция middleware (оберток) — это не то же самое, что композиция функций, применяемых каждой из оберток к запросу/ответу.</p>
</div>
    </div>
  
    <div id="comment-4624402834" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            22nd Sep 2019,
            <a href="#comment-4624402834">link</a>
            , <a href="#comment-4623509699">parent</a>
          </em>
        </small>
      </p>
      <div><p>Почему? Это то же самое, только в разном виде.</p>
</div>
    </div>
  
    <div id="comment-4624581661" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            antonymous,
            22nd Sep 2019,
            <a href="#comment-4624581661">link</a>
            , <a href="#comment-4624402834">parent</a>
          </em>
        </small>
      </p>
      <div><p>Думаю, потому что стек. Цепочка оберток уже естественным образом инвертирована. Посмотрите на не-стрелочную запись:<br /><code>(def app (mw1 (mw2 (mw3 h))))</code><br />При вычислении функции app функции-обертки будут применяться от последней к первой: mw3, затем mw2, затем mw1.<br />Функция comp также инвертирует порядок следования аргументов по сравнении с порядоком их применения:<br /><code>((comp f g) x) = (f (g x))</code><br />Накладывая друг на друга две инверсии, Вы "выравниваете" порядок применения до неправильного.</p>
</div>
    </div>
  
    <div id="comment-4719422159" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Antony,
            10th Dec 2019,
            <a href="#comment-4719422159">link</a>
            , <a href="#comment-4519528307">parent</a>
          </em>
        </small>
      </p>
      <div><p>вернулся к прочтению, прошел все заново, спасибо еще раз за труд)<br />есть несколько замечаний, странно что в прошлый раз не обратил внимания</p>
<p>:content-type, будет выдавать 500ю ошибку и «clojure.lang.Keyword cannot be cast to java.lang.String», поэтому нужно использовать «Content-Type» до применения wrap-headers-kw</p>
<p>в том числе при отлове исключений, все что внутри ловим, а сам wrap-exeption возвращая не стринговый кей в заголовках, вызывает 500-ю со всем стектрейсом, т.к. видимо и сам jetty завязан на стринговые заголовки.</p>
<p><code><br />{:status 500<br />:headers {:content-type "text/plain"} ;; «Content-Type»<br />:body "Sorry, please try later."}<br /></code><br />поэтому сам wrap-headers-kw так же вызывает 500-ю ошибку, если не сделать обратное преобразование заголовков в стринги<br /><code><br />(defn wrap-headers-kw<br />[handler]<br />(fn [req]<br />(-&gt; req<br />(update :headers keywordize-keys)<br />handler<br />(update :headers stringify-keys)))) ;; &lt;-<br /></code></p>
<p>из не сразу очевидных моментов понял, wrap-headers-kw <br />нужно применять после мидлвар ринга т.к. по умолчанию они так же <br />используют стринговые кеи из :headers<br /> --------<br /><code><br />(let [seen-path [:seen :value] ;; скорее «seen», т.к. кеи в куках тоже стринговые<br />{:keys [cookies]} request<br />seen? (get-in cookies seen-path)<br />cookies (assoc-in cookies seen-path true)]<br /></code></p>
<p>в этом предложении пропущено слово:<br />«Что получится, если каждый запрос на случайно выбранной из десяти машин?» каждый запрос что сделает  ?</p>
<p>спасибо)</p>
</div>
    </div>
  
    <div id="comment-4749589956" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            8th Jan 2020,
            <a href="#comment-4749589956">link</a>
            , <a href="#comment-4719422159">parent</a>
          </em>
        </small>
      </p>
      <div><p>Насчет wrap-headers-kw -- да, его нужно применить до того, как приступать к заголовкам. Пропущенное слово поправил. Другие замечания проверю в репле. Спасибо за вклад!</p>
</div>
    </div>
  
    <div id="comment-4785973774" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            6th Feb 2020,
            <a href="#comment-4785973774">link</a>
            , <a href="#comment-4719422159">parent</a>
          </em>
        </small>
      </p>
      <div><p>Не могли бы вы написать свои имя и фамилию для упоминания в книге? Можно в личку ivan@grishaev.me</p>
</div>
    </div>
  
    <div id="comment-4790483097" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            10th Feb 2020,
            <a href="#comment-4790483097">link</a>
            , <a href="#comment-4624581661">parent</a>
          </em>
        </small>
      </p>
      <div><p>Был неправ! В middleware же обратный порядок, поэтому правильно (comp wrap-params wrap-keyword-params), как вы писали.</p>
</div>
    </div>
  
</div>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-book-web-1/">
    <input required name="captcha" type="hidden" value="3 &#215; 7">

    <div class="block">
        <span class="comment-form-label"><small>3 &#215; 7 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
