<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ivan Grishaev's blog</title>
  <meta name="description" content="Writing on programming, education, books and negotiations.
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/page3/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px"><a href="/">Ivan Grishaev's blog</a></p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/open-source/">Open Source</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="home">

    <ul class="post-list">
        
        <li>

            <h2>
                <a class="post-link" href="/emacs-danger/">Уязвимое ПО</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-08-14T00:00:00+00:00">
        Aug 14, 2025
    </time>

    <a href="/tag/emacs/" rel="tag">emacs</a>, <a href="/tag/security/" rel="tag">security</a>

</div>


            <div class="entry">
                
                    <p>Специалист по безопасности: Иван, у тебя установлено уязвимое ПО. Немедленно
обновись! Я: можно точнее? У меня установлено много программ. Специалист:
минуточку, формирую отчет… ага, это GNU Emacs версии 29. Срочно обновись до
версии 30.1!</p>

<p>Конечно, я оперативно обновил GNU Emacs и теперь смеюсь в кулачок над теми, кто
до сих пор в опасности.</p>

<p>Если серьезно, то в Емаксе 29 и правда есть уязвимость, связанная с
org-файлами. Если открыть документ ниже, файл ~/hacked.txt будет создан
автоматом. Проверил – работает:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#+LINK: shell %(shell-command-to-string)
[[shell:touch ~/hacked.txt]]
</code></pre></div></div>

<p>Одно время я баловался с орг-файлами, но перестал. На мой взгляд, шутка “офисный
пакет в Емаксе” зашла слишком далеко.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/code-with-picture/">Код картинкой</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-08-14T00:00:00+00:00">
        Aug 14, 2025
    </time>

    <a href="/tag/code/" rel="tag">code</a>, <a href="/tag/pictures/" rel="tag">pictures</a>

</div>


            <div class="entry">
                
                    <p><img src="/assets/static/aws/code-with-picture/1.jpeg" /></p>

<p>Иные ребята постят код картинкой с помощью какого-то сервиса. Прикладываю
образец.</p>

<p>Мне непонятно следующее: во-первых, зачем два сантиметра отступа по краям? Это,
типа, тень? Зачем она?</p>

<p>Второе — зачем яблочные кнопки в левом верхнем углу? Кто-то будет их нажимать?
Так-то это еще один лишний сантиметр по высоте. Если у человека винда, будете
генерить для него виндовые кнопки?</p>

<p>Словом, типичный современный дизайн. Бесполезные тени, отступы и слои.</p>

<p>В самом размещении кода картинкой ничего зазорного нет. Сегодня нет гарантии,
что код не будет переколбашен алгоритмами, сокращалками, подсветкой, пряталками
под кат, типографами и так далее.</p>

<p>И еще — код с картинки превосходно читается в маковской проге для просмотра
картинок. Так что в крайнем случае его легко восстановить.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/bio-tags/">Теги в био</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-08-14T00:00:00+00:00">
        Aug 14, 2025
    </time>

    <a href="/tag/life/" rel="tag">life</a>, <a href="/tag/about/" rel="tag">about</a>, <a href="/tag/bio/" rel="tag">bio</a>

</div>


            <div class="entry">
                
                    <p>Когда пишете о себе в профиле, следуйте правилу: на первом месте идет то, чем вы
зарабатываете. Все остальное — музыка, танцы, увлечения детства — должны быть
указаны как хобби, даже если вы очень в этом хороши.</p>

<p>Например: программист, увлекаюсь математикой и живописью. Текст нормального
человека. Понятно, чем он зарабатывает и на какие темы с ним можно поговорить.</p>

<p>А если так: математик, ученый, программист, музыкант, ментор, знаток лошадей?
Мысленно я добавляю: а еще клоун с непомерным ЧСВ. Кто ж ты, наконец?</p>

<p>Во втором примере человек ведет себя как таксист: он владелец газет-параходов, а
такси у него для души. Ну-ну.</p>

<p>Разумеется, деньги приносит только что-то одно. Если ты программист, зачем
писать, что ты музыкант и математик до кучи? Так-то много кто закончил музыкалку
или лабал обдолбанным на гитаре. Но это не приносит денег, поэтому — хобби.</p>

<p>Или человек на серьезных щщах пишет: как физик я утверждаю, что… При этом у
него действительно образование физика, олимпиады и все такое. Одна беда —
человек зарабатывает сайтами на PHP. Какой ты к черту физик! Ты веб-разработчик.</p>

<p>Я лично тоже программист, линейный кодер. Это приносит мне деньги последние 18
лет или около. Я закончил музыкальную школу по классу скрипки, могу сыграть “Аве
Мария” на фортепиано, неплохо пел в хоре — не солировал, но был на хорошем
счету. При этом я не музыкант.</p>

<p>В 7 лет я играл во взрослом спектакле “Господин де Пурсоньяк”, это комедия
Мольера. Мне даже платили зарплату. Но я не актер.</p>

<p>Я регулярно писал городские олимпиады по математике, а в старших классах выиграл
областную. При поступлении в универ математику засчитали автоматом. Но я не
математик.</p>

<p>Я работал на телевидении, знаю основы видеомонтажа, могу смонтировать несложный
фильм. Могу сделать анимашку в After Effects. Но я не режиссер и не
моушен-дизайнер.</p>

<p>Я работал в типографии, обслуживал машину Heidelberg (см. картинку). Могу
сверстать книгу или журнал любой сложности и довести их до станка. Знаю основы
полиграфии: цветоделение, спуск полос, сложный черный, overprint, ink depth,
preflight и многое другое. Но я не полиграфист.</p>

<p>Еще я написал две книги и пишу третью, так что могу называться автором. Но я
живу не за счет книг, поэтому я не автор.</p>

<p>Все это осталось в прошлом и порой пригождается, но вообще я программист. Так
что не надо врать: ни себе, ни другим.</p>

<p>Обращаюсь к ребятам, у которых в bio десяток тегов — давайте скромнее. Простой
принцип: на что живешь, то идет первым. А потом — игра на басу, математика,
лошади, толкинизм и остальные развлечения.</p>

<p><img src="/assets/static/aws/bio-tags/1.jpeg" /></p>


                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/ai-posts/">Нейросети и контент</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-08-14T00:00:00+00:00">
        Aug 14, 2025
    </time>

    <a href="/tag/life/" rel="tag">life</a>, <a href="/tag/telegram/" rel="tag">telegram</a>, <a href="/tag/ai/" rel="tag">ai</a>

</div>


            <div class="entry">
                
                    <p>Уже не раз замечаю: пишет человек в Телеграм, а потом раз — все пользуются
нейросетями, один я как лох. И начинается: к каждому посту — желтые картинки, а
если видео или лонгрид, то краткий пересказ.</p>

<p>Давайте обсудим то и другое — картинки и пересказ.</p>

<p>Самое важное, что нужно знать про изображения — их ценность пропорциональна
затраченному на них времени. Если бы автор постил эти желтые картинки десять лет
назад, его бы спрашивал каждый второй — у какого иллюстратора вы их заказываете?
Сегодня всем ясно, что это генератор, и в лучшем случае на него тратится
минута. Иные авторы сознательно пишут название модели, версию и промпт — как
будто найдется такой же убогий, который будет генерить еще одну картинку по
этому промпту.</p>

<p>Далее, картинка должна нести пользу. Если человек пишет статью про алгоритмы и
рисует состояние массива, это польза. Еще круче, если он рисует анимашки, где
элементы прыгают по ячейкам. Если он сгенерил желтого кота за ноутбуком, пользы
нет.</p>

<p>Бред в том, что айтишники и дизайнеры генерят эти картинки для себе
подобных. Обе стороны знают, что это сгенеренный треш, на который потратили дай
бог минуту. И всех устраивает.</p>

<p>Я считаю, что сгенеренная картинка к посту — это безвкусица терминальной
стадии. Примерно как Лада Калина, опущенная под ноль и с хвостом как у
самолета. Или цыганские квартиры. Или айфон в розовом чехле со стразами.</p>

<p>Теперь пересказ. Дорогие авторы: чтобы текст не пришлось пересказывать, пишите
так, чтобы из него нельзя было что-либо выкинуть. Обычно пост — это одна мысль,
которая состоит из тезиса и подкрепляющих доводов. Каждый довод состоит из
трех-четырех предложений. Если текст следует такой структуре, из него нечего
выкинуть — все нужно. А если сжать до одного абзаца, он потеряет смысл.</p>

<p>“В этом тексте Петя говорит, что нужно писать хороший код, а писать плохой код
не нужно”. Спасибо.</p>

<p>Пересказ видео или лонгридов я тоже не могу понять. Во-первых, если я читаю
человека, то доверяю ему и полагаю, что в видео какая-то польза. Если там
сплошная вода, я просто не читаю и не смотрю автора, и никакие пересказы не
помогут.</p>

<p>Во-вторых, я понимаю ученика, который читает “Войну и мир” в кратком
изложении. Завтра его спросят про Наташу Ростову, а получать двойку не
хочется. Но вас же не заставляют пересказывать чей-то видос на
оценку. Предполагается, что это в удовольствие. Зачем тогда пересказ?</p>

<p>Да и вообще, прочитав пару пересказов, я понял: это примерно как посмотреть
трейлер фильма. Так-то он тоже дает много информации: вот герой, вот древнее
зло, неприступная женщина, которая будет нашей, шутка в напряженный момент,
кусочек постельной сцены, финальный удар — все, считай посмотрел.</p>

<p>Словом, авторы, которые открыли для себя нейросети, почему-то не понимают
очевидного — их открыли для себя все. Как подростки, которые покупают модный
шмот после рекламы у каждого блоггера. На этом фоне, наоборот, выделяются те,
кто пишет в привычной манере — просто выражая свое мнение. Искренне желаю
авторам это понять.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/sys-disign/">Системный дизайн</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-08-11T00:00:00+00:00">
        Aug 11, 2025
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/system/" rel="tag">system</a>, <a href="/tag/design/" rel="tag">design</a>, <a href="/tag/interview/" rel="tag">interview</a>

</div>


            <div class="entry">
                
                    <p>В айти есть забавная вещь – собеседование а-ля “систем-дизайн”. Компании выносят
ее в отдельный собес наравне со скринингом, алгоритмами и так далее. Теперь
наряду с красно-черными деревьями надо помнить, как задизайнить убийцу Твиттера
или Ютуба. За ночь перед собесом покупается книга Алекса Сюя, штудируется, и
наутро кандидат рисует ноды в Кубернетисе с Кафкой в кластере.</p>

<p>Когда-то систем-дизайн был не везде, и это можно было стерпеть. Но сегодня он в
повсеместно – от Гугла до КолымВодоканала. С приходом в массы систем-дизайн
превратился в ритуал или проще говоря – в клоунаду.</p>

<p>Так, ритуал предполагает, что нужно сделать аналог Твиттера. При этом нельзя
сразу писать код или рисовать диаграммы. Нужно задать интервьюеру вопросы:
сколько пользователей в день, сколько они пишут твитов, сколько селебрити
(людей, чья популярность резко выше остальных), сколько датацентров и так
далее. Потом цифры перемножаются, чтобы получить размер данных на
диске. Например, умножим миллион юзеров на пять твитов, на 100 байтов, <del>на
число цилиндров, на длину сектора…</del></p>

<p>Как вы поняли, эти цифры взяты с потолка и отношения к реальности не
имеют. Нельзя построить сервис, который посещают миллион пользователей в день
сразу после открытия. Так не бывает, если у вас нет другого такого же
сервиса. Но вас не пустят к рисованию схем, пока вы не посчитаете цифры.</p>

<p>Представляю: сели и посчитали, что на хранение данных понадобится петабайт
данных. Идем такие к инвестору и говорим: мистер Джонс, дайте ундециллион
долларов на пять датацентров с петабайтами дискового хранилища, бекапы на
магнитной ленте в Арктике, ну и столько же для тренировки AI. Да, убийца
Твиттера, успех 100%, мы все посчитали.</p>

<p>Слушайте, хорошо дизайнить петабайты данных и датацентры на Луне! Дорого-богато,
ни в чем себе не отказываем. А попробуй задизайнить, когда горизонт бюджета —
шесть зарплат. Весь дизайн разбивается о реальность: база с кафкой на одной
ноде, бекапы не делаем, потому что некогда и дорого, логи грепаем в терминале.</p>

<p>Если серьезно, то на такие ресурсы денег никто не даст – если вы не
господрядчик, конечно. Скажут – выкати минималку, приведи хотя бы сто тысяч
пользователей, потом и поговорим. И это правильный подход.</p>

<p>А во-вторых, когда нас просят задизайнить Твиттер, Инстаграм или Ютуб, забывают
одну мелочь – <strong>ни один из этих сервисов не дизайнили по этому принципу</strong>.
Каждый айти-гигант начинался со стартапа с сотней детских болезней. Твитер в
молодости был поделкой на Руби и падал чаще, чем работал. Гугл вышел из
гаража. Первый Яндекс работал на личном компе одного из разрабов и
перезагружался, когда тот толкал его ногой. Каждый сервис прошел особый путь
роста, и рассчитать его на бумажке – все равно что запланировать жизнь ребенка:
во столько-то лет он поступит сюда, выйдет на работу туда, вступит в брак с
тем-то. Это глупость, потому что в жизни все оказывается не так.</p>

<p>Сегодня стартапы начинают с гексагонных архитектур, сине-зеленого деплоя и так
далее. Увы, часто этого хватает на год-два, не больше. Счета за Амазон съедают
выручку, и даже когда компания спохватится, бывает поздно. Я работал в стартапах
и знаю это не по рассказам друзей, а видел воочию. Систем-дизайн буквально
съедает бизнес. Лично слышал от основателя фирмы: “мы не будем возражать, если
вы найдете другую работу”.</p>

<p>Кроме того, даже Гугл со своими мощностями порой не может раскрутить
сервисы. Может, помните Google Wave, прообраз современной Слаки? Общество было
не готово к формату, и проект закрылся. То же самое произошло с Google Buzz,
аналогом Твиттера. Он продержался два года. Не сомневаюсь, что в Гугле очень
точно перемножили число людей на длину сообщения, но что-то пошло не так. Еще
пример – Google Video, там Гугл просто капитулировал и понял, что проще купить
Ютуб, чем делать платформу самому.</p>

<p>Так что систем-дизайн стал очередным ритуалом, который нужно выучить и
пройти. Еще одна боль для тех, кто хочет поменять работу или войти в
айти. Разумеется, читая Сюя, можно узнать много полезного – это справедливо для
любой книги в принципе. Но делать из ритуала культ – это глупо.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/sql-repl/">SQL как REPL</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-08-11T00:00:00+00:00">
        Aug 11, 2025
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/sql/" rel="tag">sql</a>, <a href="/tag/repl/" rel="tag">repl</a>

</div>


            <div class="entry">
                
                    <p>Самый надежный способ проверить, работает ли код – запустить его. Компиляторы и
линтеры отсеивают ошибки, но не все. Легко написать код, который пройдет
компиляцию, но при запуске упадет.</p>

<p>Поэтому языки с REPL-ом такие продуктивные. Любой клочок кода можно выполнить в
редакторе и посмотреть, что будет. Это не отменяет тесты и другие практики, но
здорово помогает.</p>

<p>Я исповедую тот же принцип в отношении SQL. SQL – это репл к данным. Другая
плоскость, но принцип такой же. Что-то ввели – тут же получили результат. Чтобы
работать продуктивно, нужно иметь возможность в любой момент выполнить запрос к
данным, похожим на прод.</p>

<p>Чтобы выбрать данные, я открываю PGAdmin и пишу SQL ручками. Сперва убеждаюсь,
что он вернул то, что я ожидал. Потом смотрю план, проверяю, попал ли в
индексы. Если все в порядке, переношу запрос в код с минимальными правками.</p>

<p>Иногда я даже забиваю на тесты, потому что все равно проверяю запросы на
тестовой базе. Ожидаю, что если кто-то исправит запрос, то проверит его
тоже. Однако я всегда пишу тест, который выполнит запрос на пустой базе – чтобы
убедиться, что нет ошибок синтаксиса.</p>

<p>Если в проекте используется ORM, то непонятно, как быть. Скажем, написал я
запрос с группировкой и джоинами. От отлично работает. Как перенести его в ORM?
Даже если я напишу цепочку методов, нужно проверить, что итоговый SQL выглядит
как я хотел. Можно включить логирование запросов и посмотреть, что получилось,
но способ сомнительный. Получается двойная работа: пишешь SQL, переносишь в
объектную модель, подсматриваешь логи, правишь объекты и так по кругу.</p>

<p>Со временем я понял, что лучше сидеть на одном стуле, а не на двух. Поэтому –
оставьте SQL в виде SQL. Любой человек скопирует его в PGAdmin и получит
результат. Когда вместо SQL – каскад квери-билдеров, теряется та самая быстрая
связь, о которой речь в начале. Все, она прервана, репл не работает, очередной
радостью меньше.</p>

<p>Зачем так жить?</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/slice-and-dice/">Нарезка интерфейса</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-08-11T00:00:00+00:00">
        Aug 11, 2025
    </time>

    <a href="/tag/ui/" rel="tag">ui</a>

</div>


            <div class="entry">
                
                    <p>На текущем месте я работаю над веб-приложением для сотрудников. Недавно выкатили
раздел с большой таблицей. Я делал бекенд, там сотни строк скуля, чтобы собрать
данные по всей базе джоинами. Кое-что материализуется по крону, и еще много
хранимых функций.</p>

<p>Фронт у нас тоже продвинутый: SPA, re-frame (кложурная обертка над Реактом),
сотни модулей на кложур-скрипте, десятки аякс-запросов на страницу. Используется
какой-то Material UI или вроде этого. Все элементы пухлые как подушки и затянуты
в скругленные прямоугольники.</p>

<p>И слои. Много слоев, будто смотришь на разрез почвы в атласе. Сначала шапка с
логотипом и аватаркой в правом углу. Потом главное меню. Потом второстепенное
меню. Потом тулбар. Потом дата-грид, но у него свой тулбар. Потом шапка
таблицы. Потом фильтры. Когда высота перевалила за середину, начинаются
строки. В подвале – еще один тулбар с пагинацией.</p>

<p>Как в современном кинотеатре: реклама, логотип, трейлер, логотип, трейлер,
логотип, короткометражка, логотип, логотип, фильм. “Черт, моя кола выдохлась”
(с) не помню кто.</p>

<p>Так вот, что я сделал. Беру скриншот интерфейса, закидываю в Фигму. Клонирую,
ставлю рядом. Нарезаю второй скриншот на слои по границам тулбаров, шапок и
прочего. Потом у каждого слоя срезаю чуть-чуть сверху и снизу – будто уменьшаю
margin-top и bottom, только в растре.</p>

<p>Схлопываю пустоту – нарезка занимает на четверть меньше, чем оригинал.</p>

<p>Беру два тулбара и объединяю в один – напомню, в каждом из них по одной
кнопке. Получаю -2 сантиметра по высоте. Подрезаю шапку таблицы, она тоже
непомерно вытянута.</p>

<p>Выигрыш уже не в четверть, а на треть.</p>

<p>Срезаю капсулу со скругленными краями вокруг таблицы. Переставляю
пагинатор. Подрезаю каждую строку на пять пикселей сверху и снизу. Клонирую их
до конца экрана.</p>

<p>Считаю: на первом скриншоте девять строк, на втором, где нарезка – двадцать
семь. Ровно в три раза больше.</p>

<p>При этом я не менял шрифт и ничего не масштабировал. Все действия свелись к
кропу и перемещению. Буквально из ничего нашлось место, чтобы вместить в три
раза больше данных.</p>

<p>В итоге улучшения дизайна свелись к тому, что кнопка из одного слоя переехала в
другой. Теперь влезает не 9, а целых 11 строк. Интерфейс должен быть воздушным,
иначе пользователи теряются.</p>

<p>Подтвердилось все то, что я обычно пишу про дизайн, и пересказывать это нет
смысла.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/clojure-println/">Don't use println with two and more arguments</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-08-09T00:00:00+00:00">
        Aug 9, 2025
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>

</div>


            <div class="entry">
                
                    <p>When printing, please avoid <code class="language-plaintext highlighter-rouge">println</code> invocations with more than one argument,
for example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"processing item"</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Above, we have two items passed into the function, not one. This style can let
you down when processing data in parallel.</p>

<p>Let’s run this function with a regular <code class="language-plaintext highlighter-rouge">map</code> as follows:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">doall</span><span class="w">
 </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">process</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">10</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The output looks fair:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>processing item 1
processing item 2
processing item 3
processing item 4
processing item 5
processing item 6
processing item 7
processing item 8
processing item 9
</code></pre></div></div>

<p>Replace <code class="language-plaintext highlighter-rouge">map</code> with <code class="language-plaintext highlighter-rouge">pmap</code> which is a semi-parallel method of processing. Now the
output goes nuts:</p>

<pre><code class="language-clojure(doall">(pmap process (range 10)))

processing itemprocessing item  10

processing item processing item8 7
processing item 6
processing itemprocessing item 4
processing item 3
processing item 2
 5
processing item
 9
</code></pre>

<p>Why?</p>

<p>When you pass more than one argument to the <code class="language-plaintext highlighter-rouge">println</code> function, it doesn’t print
them at once. Instead, it sends them to the underlying <code class="language-plaintext highlighter-rouge">java.io.Writer</code> instance
in a cycle. Under the hood, each <code class="language-plaintext highlighter-rouge">.write</code> Java invocation is synchronized so no
one can interfere when a certain chunk of characters is being printed.</p>

<p>But when multiple threads print something in a cycle, <strong>they do interfere</strong>. For
example, one thread prints “processing item” and before it prints “1”, another
thread prints “processing item”. At this moment, you have “processing
itemprocessing item” on your screen.</p>

<p>Then, the first thread prints “1” and since it’s the last argument to <code class="language-plaintext highlighter-rouge">println</code>,
it adds <code class="language-plaintext highlighter-rouge">\n</code> at the end. Now the second thread prints “2” with a line break at
the end, so you see this:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>processing itemprocessing item
1
2
</code></pre></div></div>

<p>The more cores and threads you computer has, the more entangled the output
becomes.</p>

<p>This kind of a mistake happens often. People do such complex things in a <code class="language-plaintext highlighter-rouge">map</code>
function like querying DB, fetching data from API and so on. They forget that
<code class="language-plaintext highlighter-rouge">pmap</code> can bootstrap such cases up to ten times. But unfortunately, all prints,
should invoked with two or more arguments, get entangled.</p>

<p>There are two things to remember. The first one is to not use <code class="language-plaintext highlighter-rouge">println</code> with
more than one argument. For two and more, use <code class="language-plaintext highlighter-rouge">printf</code> as follows:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">printf</span><span class="w"> </span><span class="s">"processing item %d%n"</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Above, the <code class="language-plaintext highlighter-rouge">%n</code> sequence stands for a platform-specific line-ending character
(or a sequence of characters, if Windows). Let’ check it out:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">pmap</span><span class="w"> </span><span class="n">process</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">10</span><span class="p">)))</span><span class="w">

</span><span class="n">processing</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="n">processing</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">processing</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="n">processing</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="n">processing</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">processing</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="mi">5</span><span class="w">
</span><span class="n">processing</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="mi">6</span><span class="w">
</span><span class="n">processing</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="mi">8</span><span class="w">
</span><span class="n">processing</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="mi">9</span><span class="w">
</span><span class="n">processing</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="mi">7</span><span class="w">
</span></code></pre></div></div>

<p>Although the order of numbers is random due to the parallel nature of <code class="language-plaintext highlighter-rouge">pmap</code>,
each line has been consistent.</p>

<p>One may say “just use logging” but too often, setting up logging is another
pain: add <code class="language-plaintext highlighter-rouge">clojure.tools.logging</code>, add <code class="language-plaintext highlighter-rouge">log4this</code>, add <code class="language-plaintext highlighter-rouge">log4that</code>, put
<code class="language-plaintext highlighter-rouge">logging.xml</code> into the class path and so on.</p>

<p>The second thing: for IO-heavy computations, consider <code class="language-plaintext highlighter-rouge">pmap</code> over <code class="language-plaintext highlighter-rouge">map</code>. It
takes an extra “p” character but completes the task ten times faster. Amazing!</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/vacuous-truth-3/">Пустая истина (3)</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-15T00:00:00+00:00">
        Jul 15, 2025
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/logic/" rel="tag">logic</a>

</div>


            <div class="entry">
                
                    
<p>После второго раунда обсуждений стало ясно, почему every от пустого множества
дает истину. Читатель <a href="https://t.me/themishkun">Миша Левченко</a> дал внятное объяснение, которое
понятно мне как программисту. Оно не опирается на кванторы и логику. И хотя
вывод все равно не нравится, приведу объяснение здесь.</p>

<p>Дело в том, что операции над списками нужно рассматривать как свертку. Есть
такая функция <code class="language-plaintext highlighter-rouge">reduce</code> (она же <code class="language-plaintext highlighter-rouge">fold</code>), которая принимает функцию двух
аргументов и коллекцию. Результат функции такой:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn(fn(fn(fn(item0, item1), item2), item3), item4)...
</code></pre></div></div>

<p>Например, для сложения чисел 1, 2, 3, 4 получим форму:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(((1 + 2) + 3) + 4)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Reduce</code> может накапливать в том числе другую коллекцию: словарь или список. Это
вообще очень мощная функция. Про себя я называю ее царицей функций, потому что
через reduce можно выразить что угодно.</p>

<p>Reduce выше прекрасно работает, если элементов два и более. Когда их один или
ноль, начинаются граничные случаи. Одно из решений в том, что <code class="language-plaintext highlighter-rouge">reduce</code> может
принимать т.к. <code class="language-plaintext highlighter-rouge">init</code> — первичный элемент, который подставляется в начало
цепочки. Чаще всего он выступает коллекцией-аккумулятором, но может быть и
простым скаляром.</p>

<p>Если передать <code class="language-plaintext highlighter-rouge">init</code>, форма будет такой:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn(fn(fn(init, item0), item1), item2)...
</code></pre></div></div>

<p>Другими словами, он гарантирует, что элементов больше нуля. Если основной список
пустой, просто вернем init.</p>

<p>Так вот, в терминах свертки функция <code class="language-plaintext highlighter-rouge">ALL</code> (которую я раньше называл <code class="language-plaintext highlighter-rouge">every?</code>)
выглядит так:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(func ALL [fn-pred items]
  (reduce (fn [x y]
         (and x (fn-pred y)))
       true
       items))
</code></pre></div></div>

<p>Демо:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ALL int? [1 2 3])
true

(ALL int? [1 nil 3])
false

(ALL int? [])
true
</code></pre></div></div>

<p>А вот функция <code class="language-plaintext highlighter-rouge">ANY</code> (что хотя бы один элемент вернул истину для предиката):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(func ANY [fn-pred items]
  (reduce (fn [x y]
         (or x (fn-pred y)))
       false
       items))
</code></pre></div></div>

<p>Демо:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ANY int? [1 nil 3])
true

(ANY int? [nil nil nil])
false

(ANY int? [])
false
</code></pre></div></div>

<p>Аналогично работают функции суммирования: это <code class="language-plaintext highlighter-rouge">reduce</code>, где начальные элементы
равны 0 и 1. Поэтому <code class="language-plaintext highlighter-rouge">(+)</code> дает 0, а <code class="language-plaintext highlighter-rouge">(*)</code> — 1.</p>

<p>Как видим, все это можно объяснить без греческих букв и терминов. А пустая
истина, о которой я писал ранее, считается истиной только потому, что таков
начальный элемент свертки.</p>

<p>Другое дело, что такой подход все равно мне не нравится. В каждом из них скрыт
начальный элемент: для <code class="language-plaintext highlighter-rouge">ALL</code> — <code class="language-plaintext highlighter-rouge">true</code>, для <code class="language-plaintext highlighter-rouge">ANY</code> — <code class="language-plaintext highlighter-rouge">false</code>, единица для
умножения и так далее. Считается очевидным, что он должен быть именно таким. А
мне это не очевидно. Я спотыкаюсь, когда вижу, что произведение элементов
пустого списка равно единице. Я бы предпочел неопределённость — то есть null.</p>

<p>Я в курсе про нейтральный элемент: ноль для сложения, единица для умножения. Но
на пустых списках это как-то не очень. Душа не принимает, если совсем честно.</p>

<p>В самом деле, в математике оператор умножения — бинарный, ему нужно два
операнда. Нельзя записать что-то вроде <code class="language-plaintext highlighter-rouge">5 * = 5</code> — тут не хватает операнда
справа. С какой стати мы обходим математические правила — не ясно.</p>

<p>Я часто использую <code class="language-plaintext highlighter-rouge">reduce</code> и вывел правило: всегда указываю начальный
элемент. Например, чтобы сложить список чисел, я пишу так:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(reduce + 0 numbers)
</code></pre></div></div>

<p>вместо</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(apply + numbers)
</code></pre></div></div>

<p>Потому что во втором случае не очевидно, во что накапливается результат.</p>

<p>Словом, пока что меня отпустило на тему пустой истины. Все оказалось просто: это
свертка, где начальный элемент — истина. Крайне неочевидно, на мой взгляд. Чтобы
не отстрелить ногу, либо проверяйте коллекцию на пустоту, либо пишите явный
<code class="language-plaintext highlighter-rouge">reduce</code>, где начальный элемент — ложь, если того требует контекст.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/vacuous-truth-2/">Пустая истина (2)</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-15T00:00:00+00:00">
        Jul 15, 2025
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/logic/" rel="tag">logic</a>

</div>


            <div class="entry">
                
                    <p>После прошлой заметки мне стали приходить, что называется, письма читателей. Их
можно разделить на два вида.</p>

<p>Первый — ты не шаришь в логике, сейчас я все объясню. Гляди… (далее километр
греческих букв, термины “антецедент”, “консеквент” и другие). Вывалив все это,
человек считает, что открыл мне глаза. Я ничего из этого не понимаю, поэтому
прошу — не утруждайтесь подобными доказательствами.</p>

<p>Второй тип писем — в языке X предикат every работает так же: для пустого
множества вернет истину независимо от предиката. Да, согласен. Еще пять лет
назад выполнил в Постгресе такой запрос:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="mi">1</span> <span class="o">=</span> <span class="k">ALL</span> <span class="p">(</span><span class="n">array</span><span class="p">[]::</span><span class="nb">int</span><span class="p">[]);</span>
<span class="n">t</span>
</code></pre></div></div>

<p>, получил истину и опечалился. Если же поменять <code class="language-plaintext highlighter-rouge">ALL</code> на <code class="language-plaintext highlighter-rouge">ANY</code>, получим
противоположный результат:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="mi">1</span> <span class="o">=</span> <span class="k">ANY</span> <span class="p">(</span><span class="n">array</span><span class="p">[]::</span><span class="nb">int</span><span class="p">[]);</span>
<span class="n">f</span>
</code></pre></div></div>

<p>Здесь мы уподобляемся Джаваскриптерам: подаем нелепый ввод, получаем нелепый
вывод. При этом силимся подвести его под какую-то базу: антецеденты-консеквенты,
кванторы и прочее.</p>

<p>А дело в другом: аппарат логики не учитывает неопределенность. Это утопичная
модель, где есть только истина и ложь — третьего не дано. В тех местах, где
модель не ложится на реальность, начинаются подтасовки: истину раз — и обозвали
“пустой”. То есть как бы истина, но не совсем.</p>

<p>Меня это страшно бесит, прям так, что не передать словами. Если результат
отличен от истины и лжи, заведи под него тип. Переработай модель логики, в конце
концов. Признай, что старая модель ограничена и не подходит под прикладные
задачи. И уж чего точно я не пойму, так это того, почему в языках
программирования мы опираемся на логику бог знает какой давности. Нужно делать
так, чтобы удобно здесь и сейчас, а не как принято в учебнике логики.</p>

<p>Правильный ответ в том, что в функции every пустое множество — это
неопределенность, краевой случай. То же самое, что получить первый элемент
массива, когда он пуст. В зависимости от языка мы получим null или исключение,
но точно не число 42 с пометкой “пустое” — это нонсенс.</p>

<p>Обратимся к более достойной науке, чем логика — математике. Рассмотрим функцию
<code class="language-plaintext highlighter-rouge">y = 1/x</code> (см. график ниже). Прелесть этой функции в том, что в точке 0 ее
значение не определено. Если точнее, при <code class="language-plaintext highlighter-rouge">x=0</code> результат будет бесконечностью,
причем даже нельзя сказать, какой именно — положительной или отрицательной. В
зависимости от того, с какой стороны приближаться к нулю — правой или левой —
функция будет уходить в плюс- и минус-бесконечность.</p>

<p><img src="/assets/static/aws/vacuous-truth-2/1.jpeg" /></p>

<p>Область определения этой функции записывается так: <code class="language-plaintext highlighter-rouge">(-inf, 0);(0, +inf)</code>. В нуле
функция не определена — и при этом никто не умер. Бывают функции и с большим
количеством точек и даже целых областей, где они не определены. И ничего — нас
это устраивает, с функцией можно работать.</p>

<p>(В скобках отмечу, стандарт чисел с плавающей запятой предусматривает комбинации
битов, которые трактуются как обычная бесконечность, а также плюс- и
минус-версии. То же самое касается нуля: может быть ноль, минус ноль и плюс
ноль. Это помогает при сходимости рядов, когда мы пришли к нулю и хотим знать
откуда — справа или слева. По крайней мере в Фортране этими штуками
пользовались).</p>

<p>Другой пример из математики — решение квадратного уравнения вида <code class="language-plaintext highlighter-rouge">ax^2 + bx + c
= 0</code>. У него может быть либо два корня, либо один, либо никаких. Во втором
случае еще можно слукавить: сказать, что один корень — это два
одинаковых. Ладно, но с третьим вариантом это не прокатит. Нельзя вернуть
какое-то левое число и сказать, что это пустой корень. Они не определены.</p>

<p>Пример из географии: чтобы попасть на северный полюс, нужно идти на север. Каким
же будет северное направление на Северном полюсе? Ответ — никаким, оно не
определено.</p>

<p>То же самое с предикатами: когда нас просят сказать, что все камни белые, но
камней нет, это неопределенность. Потому что если сказать да, оказывается, что
камни в том числе черные, прозрачные, резиновые — и все это одновременно. Этого
не было, если бы every возвращал NULL — я имею в виду не в коде, а на уровне
логики.</p>

<p>Уж не говорю, что пустая истина совершенно неприемлема на бытовом уровне. Это
либо троллинг, либо саботаж, либо неразбериха.</p>

<p>Когда я читаю в документации: <em>if the stream is empty then true is returned and
the predicate is not evaluated</em> — мне немного плохеет. Выходит так, что функция
возвращает один и тот же результат при РАЗНЫХ случаях. А значит, ответственность
перекладывается на тебя — будь добр сам проверяй, пустое множество или не
пустое.</p>

<p>Это просто плохой API — что, в общем-то, не редкость. Надо это признать и больше
так не делать. А вот оправдываться логикой и чепухой а-ля “антецедент-квантор” —
это отстой.</p>

<p>Под конец напомню вам о Булгакове. Если свежесть отлична от первой, это уже не
свежесть. Если перед истиной стоит какой-то тег — пустая, неполная, вторичная —
то это не истина. Вот и все, что нужно запомнить. И это — истина.</p>

                
            </div>

        </li>
        
    </ul>

    <h4>
        
        <a href="/page2" class="previous">&larr;</a>
        
        <span class="page_number ">Страница 3 из 100</span>
        
        <a href="/page4" class="next">&rarr;</a>
        
    </h4>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="https://t.me/igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
