<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ivan Grishaev's blog</title>
  <meta name="description" content="Writing on programming, education, books and negotiations.
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/page3/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="home">

    <ul class="post-list">
        
        <li>

            <h2>
                <a class="post-link" href="/htmx/">HTMX</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-17T00:00:00+00:00">
        Jul 17, 2023
    </time>

    <a href="/tag/htmx/" rel="tag">HTMX</a>, <a href="/tag/web/" rel="tag">web</a>, <a href="/tag/frontend/" rel="tag">frontend</a>, <a href="/tag/ui/" rel="tag">ui</a>, <a href="/tag/react.js/" rel="tag">react.js</a>

</div>


            <div class="entry">
                
                    <p><em>Этот пост — попытка объединить заметки об HTMX в Телеграме во что-то
целостное. Написать статью о нем за один подход не вышло, поэтому пришлось по
частям.</em></p>

<p><a href="https://htmx.org/">HTMX</a> — это библиотека для серверного рендера HTML. От
современных React и Vue она отличается тем, что не хранит состояние на клиенте и
не занимается рендером на JavaScript. Она посылает запрос к серверу и получает
кусок HTML — в особых случаях несколько кусков, — которые вставляет в нужное
место DOM.</p>

<p>При всей примитивности этого подхода у него есть сторонники, и их число
растет. Я тоже склоняюсь к серверному рендеру и хочу написть о нем подробнее.</p>

<p>Htmx — не единственная в своей области библиотека. Есть еще HotWire, LiveView и
другие. Под HTMX я имею в виду не конкретную библиотеку, а серверный рендер в
принципе; просто HTMX звучит короче.</p>

<p><strong>Первая заметка</strong> об HTMX касалась числа запросов на сервер. Порой говорят: HTMX
требует больше запросов, потому что забирает состояние с сервера. А в
React-приложении ты выгреб состояние и хранишь на клиенте — улыбаешься.</p>

<p>Это неправда. Когда в HTMX открываешь диалог, происходит один — и только один —
запрос. Когда открывается диалог в приложении на Vue, происходит 14, — прописью,
четырнадцать — запросов. Буквально на днях я правил фронтенд по работе, и там
был именно такой случай. Цифры я взял какие есть, без преувеличений.</p>

<p>Другой пример: дашбоард сайта <a href="https://www.usemultiplier.com/">Use Multiplier</a>
совершает 235 запросов. Если отфильтровать по слову “graphql”, останется 35
запросов. Выходит, JavaScript-разработчикам нужно 35 сетевых сессий, чтобы
построить документ. Не многовато ли?</p>

<p>Что же выгодней: один запрос или их десятки?</p>

<p>В такие минуты искренне желаю, чтобы фронтендеров заменил HTMX. Они делают
интернет хуже: больше запросов, больше трафика, больше расход CPU, дольше время
ожидания. Таким разработчикам не место в профессии.</p>

<p><strong>Вторая мысль</strong> об HTMX такая: часто говорят, что это “хайп” (в кавычках,
потому что не люблю это слово). Очередная вещь, которая пройдёт зенит и уйдёт из
повестки.</p>

<p>Это не так. HTMX — это не очередная JS-поделка, снискавшая популярность. HTMX и
его аналоги — это протест. Отказ от того, что предлагает индустрия для
разработки приложений в браузере. Протест — по определению более сильная вещь,
чем хайп, потому что в его основе идея.</p>

<p>В этом году исполняется 10 лет с публикации исходного кода React.js. У Реакта и
аналогов было достаточно времени, чтобы показать себя. Результаты есть, но не
ошеломительные. Да, по сравнению с Backbone.js делать интерфейс стало проще,
однако рано или поздно все сводится к одному: проект тонет в каше из
компонентов, а состояние разбросано, как субстанция, попавшая на вентилятор.</p>

<p>Сейчас работаю с Vue, и чтобы добавить новый диалог, нужно поправить 18
файлов. Такая структура явно говорит о проблемах, но никого это не
волнует. Отрефакторить это невозможно, потому что поедет все. Только переписать
на новый фреймворк, что обязательно состоится, когда бизнес купят или команда
фронтендеров уйдет в полном составе.</p>

<p>За эти десять лет мы получили одно — возросшую сложность разработки. Современный
сайт обязательно содержит пачку npm-модулей, их сборщик, компоненты на React/Vue
и бог знает что еще. В каждой фирме эту кухню готовят по-разному; вся она
глючная и хрупкая.</p>

<p>Еще печальней, что фронтендеры, получив инструменты, не научились ими
пользоваться. Фронтам нужно 35 запросов Graphql на страницу; 14 запросов на
открытие диалога. Одна и та же сущность запрашивается по пять раз. Это полная
капитуляция, расписка непригодности разработчика. Если нужно 35 запросов на
страницу, в команде не думают о качестве, а просто закрывают тикеты. Это просто
данность.</p>

<p>За это время я видел только одну удобную обертку над React — это кложурный
re-frame. В нем скрыли острые углы Реакта и свели разработку к простому
принципу: база, подписка, событие. Просто настолько, что дальше уже
невозможно. Конечно, и на re-frame можно сделать проект неподдерживаемым, но
кривая сложности у него более покатая.</p>

<p>HTMX и его аналоги — это отказ от всего, описанного выше. Это отказ от хрупких
npm/js-артефактов. Это отказ от команды фронтендеров, которым платят 10-20 тысяч
долларов в месяц — на эту сумму можно купить тысячи машин в облаке. Это отказ от
сложности коммуникаций, когда бекенд выкатил фичу, а фронты доберутся до нее
через месяц. Это отказ от двух источников правды — сервера и состояния на
клиенте — в пользу одного. И много от чего другого отказ.</p>

<p>Поэтому я верю, что HTMX и схожие проекты с нами надолго. Эпоха Реакта и
реактивного интерфейса проходит. Результаты есть, но они обходятся слишком
дорого. Время нового подхода.</p>

<p><strong>Третья мысль</strong> об HTMX касается его роли в прошлом. Мысль о том, что HTMX
появился недавно и поэтому хайп — ошибочна. На самом деле серверный рендер
существует давно, и некоторые его используют. До сих пор о нём было мало
разговоров, потому что в центре внимания Реакт — и сумасшедшие деньги, которые
вливал в него производитель. Не только на зарплату разработчикам, но и
поддержку, связи с сообществом, конференции, митапы и прочее.</p>

<p>Серверный рендер по существу очень прост. Сервер выдает HTML, который
вставляется в нужное место DOM. Кустарная реализация занимает не более ста
строк, поэтому неудивительно, что серверный рендер тихо делает свою работу — без
кричащих статей на Hacker News, звезд на Гитхабе и остального.</p>

<p>Другое дело, что кустарное решение учитывает только свои нюансы, поэтому нужен
общий знаменатель. Так и появились проекты HTMX и аналоги.</p>

<p>Не каждый знает, что серверный рендер был одно время в Твиттере. Первые 20
твитов грузились как часть страницы, а при скролле выгребались куски HTML, в
которых были новые 20 твитов и так далее. Хорошо это помню, потому что у меня
был пет-проект по парсингу Твиттера. С HTML было относительно удобно: распарсил,
прошелся Xpath-селекторами и готово. Серверный рендер в Твиттере ввели после
того, как люди стали массово жаловаться на клиентский рендер — он был столь
ужасен, что пара вкладок раскручивала вентиляторы на полную.</p>

<p>Пользуясь случаем, скажем отдельное спасибо фронтендерам за это.</p>

<p>Кроме Твиттера, серверный рендер использовал ваш покорный слуга. Было это 13 лет
назад в Чите, в славной компании <a href="https://e-sbyt.ru/">ООО Энергосбыт</a>. Возле
моего кабинета стоял терминал для показа каких-то роликов. Я решил сделать из
него облегченную версию личного кабинета без авторизации. Вводишь лицевой счет и
номер квартиры и видишь задолженность и показания счетчиков. Можно передать
текущие показания. Принять деньги, увы, было нельзя из-за отсутствия
купюроприемника.</p>

<p>Интерфейс терминалов — это обычный Хром, запущенный с ключом <code class="language-plaintext highlighter-rouge">--kiosk</code> (по
крайней мере раньше он так назывался). В режиме киоска браузер растягивается на
весь экран, прячет курсор и противится попыткам свернуть его или открыть
системные менюшки. Беда в том, что если во время запроса обрывалась связь, Хром
показывал страницу “Oh no!” с диназавром, и нужно было нажать кнопку
“Обновить”. Сейчас Хром обновляет ее по таймауту, а тогда нет.</p>

<p>Ясное дело, я не мог бегать каждый час к терминалу смотреть, все ли с ним в
порядке. Нужно, чтобы все работало на аяксе, но одна мысль об этом бросала в
ужас. На дворе 2009 год, никаких реактов нет и в помине. jQuery в зените
популярности, развивается Backbone.js — попытка навертеть MVT-фреймворк поверх
jQuery. Окинув этот зоопарк, я решил задачу проще: на каждый запрос отвечал
куском HTML, который вставлялся в центральный элемент на странице. Это было
неоптимально, потому что в обновлении нуждались не все элементы, но разницы не
было.</p>

<p>В итоге я контролировал все на сервере, а клиент был минимально
прост. Разработка заняла неделю, и вскоре терминал стоял в самом проходном месте
города. Им пользовались, все было хорошо. Ради интереса представил разработку
сегодня: npm/yarn, React/Vue, папка node_modules, хрупкие сборки и конечно
компоненты, компоненты, компоненты. Команда фронтендеров, недели и месяцы
работы. Неподдерживаемый результат в конце, смена команды и переписывание.</p>

<p>Вот почему я уверен в своей правоте: я пробовал и знаю. Серверный рендер — это
просто и быстро. Да, есть недостатки, и порой без клиентского кода не
обойдешься. Но ни Реакт, ни Вуй даже близко не приблизились в плане скорости и
удобства к серверному рендеру.</p>

<p><strong>Четвертый пост</strong> об HTMX касается его не очевидных недостатков. Прочитав текст
выше, кто-то может решить, что HTMX — это избавление от всех бед фронтенда. К
сожалению, это не так. Ниже я перечислю, какие трудности вас ждут при переходе
на HTMX.</p>

<p>Прежде всего, HTMX не подходит крайне динамичным страницам — картам, редакторам
текста, играм. Их объединяет сложное состояние, которое меняется даже не клику,
а по движению курсора или прокрутке. Опрашивать сервер с такой частотой будет
тяжело, хотя и возможно: в HTMX есть поддержка веб-сокетов. Всё зависит от
условий задачи, но для сложного состояния HTMX будет скорее проблемой.</p>

<p>Второй момент — с HTMX усложняется серверный рендер. Раньше вы отдавали данные
клиенту, а как он их выводил, вас не касалось. А теперь вы за это в ответе.</p>

<p>Предположим, вы достали из базы число покупок пользователя. Чтобы вывести фразу
“У вас X покупок”, нужно учесть случаи:</p>

<ul>
  <li>
    <p>X равно нулю или NULL, и тогда фраза будет “у вас нет покупок”;</p>
  </li>
  <li>
    <p>учесть множественность: “1 покупка” и “N покупок”;</p>
  </li>
  <li>
    <p>для второго случая учесть склонения: “3 покупки, 5 покупок, 21 покупка”.</p>
  </li>
</ul>

<p>Нужно писать функции, таблицы склонений, стемминг и остальное. Что-то есть в
библиотеках, но без их адаптации не обойтись.</p>

<p>Еще интересней даты и форматы чисел, валют. Раньше ты выплюнул JSON с Unix
timestamp, и остальное тебя не касается. А теперь, перед тем как рендерить,
нужно узнать локаль пользователя — из запроса, кук или сессии — и передать ее во
все подобные функции. Это усложняет процесс.</p>

<p>Положа руку на сердце, гораздо удобней отдать JSON, не заморачиваясь с
рендером. Но потом, когда фронтендер уйдет или заболеет, ты полезешь в его код и
увидишь, какой же там ад. И что лучше бы это был серверный рендер.</p>

<p>HTMX усложняет обработку ошибок. Если что-то пошло не так, нужно вывести
сообщение внутри элемента или в отдельной области при помощи техники OOB — out
of boundaries. Это когда сервер возвращает несколько HTML-элементов, и они
вставляются в разные места страницы. Кроме того, можно задать реакцию на
неудачный AJAX-запрос на уровне библиотеки. Я не буду подробно все расписывать,
скажу лишь, что об обработке ошибок в HTMX нужно думать с самого начала и
придерживаться одного подхода. Иначе будет разброд и шатание.</p>

<p>Тесты. Одно дело тестировать JSON, другое – HTML. Его нужно парсить, обходить
проблемы склонений и форматов, применять рекулярки и XPath. Все это менее
удобно, чем данные в JSON. Схемы – ваш лучший друг в случае с JSON, а какие
схемы могут быть в HTML?</p>

<p>Последний и наиболее важный недостаток — это двойной API. Как правило, бекенд
предоставляет апишку не только сайту, но и мобильному приложению и третьим
фирмам. Удобно, когда бекенд — это чистое API, и все это понимают.</p>

<p>Теперь вы приходите к начальству с предложением сделать HTMX-апишку для
серверного рендера. А зачем? — спросит начальство. На бекенде у нас
REST/GraphQL, пусть сайт и ходит к нему через API. Этот довод почти невозможно
проломить, потому что все сходится: бекенд общается с миром через JSON, у каждой
платформы свой клиент. Что можно ответить?</p>

<p>Пожалуй, то, что команда фрондендеров дорогая, а их труд тяжело
поддерживать. Скажем, чтобы сделать динамический сайт, кроме дизайнера нужно как
минимум два фронтендера: один идет вперед, другой чинит баги. В случае с
бекендом достаточно одного человека, который бы поддерживал HTMX-апишку. Это и
дешевле, и надежней, потому что бекенд покрыт тестами и не такой хрупкий.</p>

<p>Поэтому не в каждой фирме дадут добро на серверный рендер. Протащить его в прод
— та еще задача.</p>

<p><strong>Пятая заметка</strong> об HTMX касается важного момента — источника правды. Должно
быть, после недостатков серверного рендера кто-то приуныл. Чтобы восстановить
баланс, поговорим о решающем плюсе HTMX, который не видно на первый взгляд.</p>

<p>Для начала вспомним React и Vue. Сильно упрощая, можно сказать, что их работа
сводится к следующему. Мы переносим состояние с сервера на клиент и показываем в
браузере. В теории нам не нужно беспокоится от отрисовке: реактивные фреймворки
делают это за нас, когда мы изменяем состояние.</p>

<p>Звучит хорошо, но таким образом мы завязаны на состоянии. Каждый, кто немного
программировал, знает, что самое сложное — контролировать состояние. Поэтому так
популярны Advent of Code и похожие задачи: для программистов это своего рода
отдых. В них почти нет состояния: тебе дают одну структуру данных, и ее нужно
переколбасить в другую. Нет базы, Кафки, Редиса и всего этого.</p>

<p>Задачи из AoC решают на растах-хаскелях, потому что писать на них чистые
преобразования — почти физическое удовольствие. Но приходит утро, и программист
идет на работу, где его ждут кровавые Джава и Питон.</p>

<p>Так вот, состояние на клиенте влечет сложность уже самим появлением. За ним
нужно следить и синхронизировать его с сервером. Если вам кажется это простым,
вы ошибаетесь. Бывает, сервер не может вернуть данные в одном запросе, и нужно
слать их несколько. Бывает, одни и те же данные нужны компонентам А и Б, но их
писали разные люди, и одинаковые запросы идут параллельно без проверки на
дублирование. Последее я вижу постоянно: одну и ту же сущность выгребают по пять
раз просто потому, что она нужна всем, а разработчики не договорились.</p>

<p>Давно я читал в интернете: отдайте клиенту его данные, и пусть делает что
хочет. Это не работает хотя бы из-за размера данных. Представим, вы активно
пишете на каком-нибудь Твиттере или StackOverflow. За три года у вас скопилось
10 тысяч заметок. Вы хотите вывалить их клиенту при загрузке страницы? А заодно
его друзей, рекомендации и прочее?</p>

<p>Хорошо, будем выгружать порциями по 100 штук. Выгрузили — сохранили на клиенте —
отрисовали. Спрашивается, почему эту цепочку нельзя сократить — нарисовать без
сохранения? Ведь состояние быстро протухает: написал комментарий, поскроллил,
сменил фильтры, критерии сортировки, и все — пора лезть на сервер за новыми
данными.</p>

<p>Все это мартышкин труд. Вы никогда не угадаете, что конкретно нужно клиенту в
текущий момент. Выгружать все — дорого и долго. Остается запрашивать данные
точечно: последние 10 статей, последние 50 комментариев. А если порции данных
небольшие, зачем их хранить, если можно просто показать? Так мы уберем
состояние, из-за которого одни сложности.</p>

<p>Ликвидация состояния — важный шаг вперед: управлять клиентом становится
проще. Помните аналогию с Advent of Code и функциональными языками? С HTMX я
испытал похожие чувства. Да, оказывается, так можно: отдаешь HTML, который без
какого-либо состояния отображается на клиенте.</p>

<p>Резюмируя, можно сказать, что HTMX сводится к одному плюсу — ликвидации
состояния на клиенте. Пусть каждый решает сам, но для меня это самое важное. Нет
состояния — берем. Ради этой фичи я согласен на все минусы, о которых сказал
раньше.</p>

<p><strong>Шестая заметка</strong> об HTMX касается дизайна. Возможно, кто-то решил, что HTMX —
это когда фронтендеров увольняют, а суровые бекендеры берут дизайн в свои руки —
с предсказуемым результатом. Может, где-то практикуют подобное, но я это не
одобряю, и вот почему.</p>

<p>Действительно, многим фронтендерам нужно дать пинка под зад. Например за то, что
заставляют браузеры жечь трафик и процессор почем зря. Как мы выяснили, чтобы
страница была динамичной, чаще всего фронтендер не нужен — можно вернуть HTML с
сервера и вставить в DOM. Но остается вопрос с дизайном.</p>

<p>В компании должен быть человек, отвечающий за дизайн всего: не только сайта, но
и логотипа, буклетов, визиток и остального. Кто-то думает, что дизайн — это
верстка в программе, но это не так. Дизайн — это точка, где клиент соприкасается
с продуктом, и дизайнер отвечает за эту точку в целом.</p>

<p>В компаниях, где процесс налажен правильно, он протекает так. Дизайнер делает
макет в Фигме или иной программе. В ней указаны состояния страницы и сценарии
перехода. Например, при нажатии на кнопку “добавить в корзину” четко указано,
какие элементы изменятся и на что.</p>

<p>Верстальщик или фронтендер (в классическом понимании этого слова) переносит
дизайн в статичный HTML. Если это продвинутый верстальщик, он вынесет изменяемые
элементы в отдельные файлы, которые импортируются шаблонной системой вроде
Jinja2. Получается набор статичных страниц, но у каждой из них есть структура.</p>

<p>Бекендеры принимают нарезанный HTML и оживляют его на сервере. При этом им
запрещена любая отсебятина. Если бизнес-процесс не вписывается в дизайн, все
трое — дищайнер, верстальщик, бекендер — собираются и решают, что
исправить. Исправления вносятся во все три источника: дизайн, верстку, бекенд.</p>

<p>При таком подходе принцип HTMX остается в силе. Бекендеры не выдумывают дизайн
на ходу, они действуют в рамках, которые ставит им дизайнер. Верстальщик служит
промежуточным звеном между дизайном и его реализацией на бекенде.</p>

<p>В грамотных фирмах есть процесс сдачи сайта дизайнеру. Сайт не выкатят в прод,
пока дизайнер не убедится, что верстальщик перенес дизайн в HTML без ошибок, а
программисты оживили его без косяков.</p>

<p>Так был устроен процесс в Wargaming, где я когда-то работал. И хотя там были
свои косяки, мне кажется он единственно верным. Что ещё в нем хорошего — он не
привязан к конкретным технологиям, и HTMX отлично на него ложится.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/hdmi/">HDMI в тренде</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-14T00:00:00+00:00">
        Jul 14, 2023
    </time>

    <a href="/tag/hdmi/" rel="tag">hdmi</a>, <a href="/tag/tv/" rel="tag">tv</a>

</div>


            <div class="entry">
                
                    <p><img src="/assets/static/aws/hdmi/1.jpeg" /></p>

<p>Раз в полгода телевизор докладывает, что сегодня в тренде… порт HDMI 1. При
этом ни в один из HDMI портов ничего не воткнуто. Откуда он это берет? Неужели
настоящие данные, собранные с устройств — люди играют в приставки, смотрят
пиратки с ноутбуков?</p>

<p>Этот порт, как говорит телевизор, “недавно в…”. Очень полезные сведения. Еще
бы понять, что значит “в…”. Калека-дизайнер оставил квадрат пустым, а на текст
выделил сотую часть. Не влезло, но ничего: обрежем и добавим многоточие.</p>

<p>Забавно, как текут абстракции: в понимании телевизора порт HDMI — это
приложение, поэтому участвует в трендах. Напоминает одну игру, где можно было
чинить лошадь гаечным ключом. А что, транспорт, значит можно чинить.</p>

<p>Проблема “умных” вещей в том, что они пытаются быть умнее, чем есть на самом
деле. Нет-нет и вылезет какая-то тупизна, от которой нет слов. Только вздохнёшь
и идёшь дальше.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/neuro-daub/">Нейромазня</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-01T00:00:00+00:00">
        Jul 1, 2023
    </time>

    <a href="/tag/ai/" rel="tag">ai</a>, <a href="/tag/daub/" rel="tag">daub</a>, <a href="/tag/pictures/" rel="tag">pictures</a>, <a href="/tag/cat/" rel="tag">cat</a>

</div>


            <div class="entry">
                
                    <p>Что ж, мы дожили до момента, когда нейросеть по запросу рисует кота-хакера за
компьютером. Потрачены усилия, сделан прорыв, взяты рубежи.</p>

<p><img src="/assets/static/aws/daub/1.jpg" /></p>

<p>Верю, что доживу до момента, когда нейросеть объяснит, зачем мне этот кот. В какой текст его вставить, к чему подавать и что им объяснить.</p>

<p>Потому что сейчас не понятно: на что этот кот? Зачем? Какую мысль он несет? Ладно кот, но все эти картинки туда же: ни малейшей идеи, чем они могут быть полезны.</p>

<p>Чувак пишет статью о четвертом измерении и ставит такое:</p>

<p><img src="/assets/static/aws/daub/2.jpg" /></p>

<p>Какой-то алмаз, в нем пузыри, блики, крошки, капли смолы, планеты.</p>

<p>Другая картинка: вензеля, стекла, то ли башня, то ли корабль. Что это вообще?</p>

<p><img src="/assets/static/aws/daub/3.jpg" /></p>

<p>Конечно, у женщин осиная талия и шестой размер груди. И нет трусов. По улице
только такие и ходят.</p>

<p><img src="/assets/static/aws/daub/4.jpg" /></p>

<p>Никто не может сказать, какой смысл несут эти картинки? Что они добавляют в текст? Что потеряет текст, если их убрать? Хорошая иллюстрация несет смысловую нагрузку, помогает понять то, что трудно описать словами. Делает акцент на особых случаях, когда что-то отличается от повседневного.</p>

<p>Как вы уже поняли, ничего полезного в нейромазне нет. Это мусор, который заполняет интернет, и нет от него спасения.</p>

<p>Пара ссылок про иллюстрации:</p>

<ul>
  <li><a href="https://maximilyahov.ru/blog/all/image-shit/">Почему ваша картинка к статье — говно (грубая версия)</a></li>
  <li><a href="https://maximilyahov.ru/blog/all/illustrated-decorated/">Иллюстрация или декорация</a></li>
</ul>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/indesign-list/">Списки в In Design</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-01T00:00:00+00:00">
        Jul 1, 2023
    </time>

    <a href="/tag/indesign/" rel="tag">indesign</a>, <a href="/tag/ui/" rel="tag">ui</a>

</div>


            <div class="entry">
                
                    <p><img src="/assets/static/aws/indesign-list/1.jpeg" /></p>

<p>Опять Индизайн. Уж наверное, если сделали длинный список, нужно упорядочить его
по алфавиту, нет? Секунд двадцать искал пункт Units в подвале, а он еще до
середины находится. Интересно, что глаз скользит по списку, замечает Units, и
тут же теряет, потому что мозг ожидает его не там. Сущее издевательство.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/remote-nuance/">Удаленка, но есть нюанс</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-06-25T00:00:00+00:00">
        Jun 25, 2023
    </time>

    <a href="/tag/remote/" rel="tag">remote</a>, <a href="/tag/work/" rel="tag">work</a>, <a href="/tag/nuance/" rel="tag">nuance</a>

</div>


            <div class="entry">
                
                    <p>Удаленная работа за рубежом имеет несколько преимуществ перед обычной
офисной. Кроме очевидных, связанных оплатой — в валюте и выше рынка — я бы
отметил автономность и самостоятельность. Ты как будто мини-фирма: сам себя
продаешь, оформляешь, ведешь расчеты, платишь налоги. Претендуя на удалённую
вакансию, конкурируешь не с тремя разработчиками из твоего города, а со всеми
разработчиками смежных часовых поясов. Победа в такой борьбе значит больше.</p>

<p>Есть, однако, и недостаток удаленной работы, о котором не пишут. Будучи
удаленщиком, ты не будешь принимать решений. Вам просто не дадут полномочий. Вы
будете делать только то, что скажет начальство и тимлид. Чтобы что-то внедрить
или переделать, понадобится много сил — гораздо больше, чем у того, кто сидит в
офисе и регулярно видится с начальством.</p>

<p>Не нужно подробно описывать, почему так происходит. В любой группе людей
коммуникация первична. Какие бы средства связи нас ни окружали — телефоны, Zoom,
очки реальности, — общаться лицом к лицу проще. Поэтому сотрудник, который пьет
кофе с боссом и ходит с ним в курилку, получит его расположение. Даже если
офисный сотрудник что-то делает не так, его проще похлопать по плечу и наставить
на путь истинный — в отличие от удаленщика, который появляется на экране раз в
сутки.</p>

<p>Будет неверно говорить о всех разработчиках, но мой опыт подтверждает сказанное
выше. Где бы я ни работал, повторяется одно и то же. Если на горизонте
появляется интересная задача, ее проработка достается тому, кто в тесном
контакте с руководством. Это, кстати, не гарантирует навыков в разработке;
гораздо чаще я вижу что-то вроде обратной зависимости.</p>

<p>Может быть, вы пошли на обед, обдумывая новый сервис. В это время тимлид и
коллега из офиса тоже пошли в “Жареный жир” и славно поболтали. К возвращению в
офис уже все решено, формальности обговорены. На следующий день на созвоне вы
излагаете свое видение сервиса, не зная, что в этом нет смысла. Вас вежливо
выслушают и скажут, что решение отличное и его приберегут для будующих
проектов. А пока что Джон уже приступил к разработке, и мы с нетерпением ждем.</p>

<p>Сделав черновик, Джон с пафосом презентует его фирме, после чего его роль
выполнена. Он уходит в другую команду или приступает к проработке нового
проекта. Дальше наступает рутина удаленщика — поддержка этого чуда. Ваш выход!
Моментально находятся краевые случаи, которые Джон не предусмотрел, недостаток
тестов, банальные баги. Ты их чинишь. Дни становятся неделями, месяцами,
годами. Когда проект заработает стабильно, вас перебросят на поддержку новой
сырой поделки.</p>

<p>Бывают, конечно, и маленькие победы: путем рефакторинга удается заменить
самописный треш на библиотеку или, наоборот, отказаться от жирной библиотеки в
пользу десятка строк. Если в фирме совсем все плохо, правильные решения говорят
лучше тысячи слов. К примеру, нормальное тестирование, которое можно развернуть
локально, не прибегая к удаленным машинам; линтинг, внутренний гайд разработки и
прочее.</p>

<p>Кто-то подумает, что пост носит жалобный характер, но это не так. Со временем я
понял, что, во-первых, навозну кучу разгребая, что-то да найдешь. Совершенно
точно поймешь, как не надо делать. Роль поддержки освобождает от тесного общения
с начальством — а это много митингов и поездок в офис. Свободное время можно
потратить на блог, книгу, опен-сорс, семью.</p>

<p>Все мои годы удаленки — это поддержка чужих решений. Да, что-то делал и внедрял,
но в гораздо меньших пропорциях. В одной фирме я пробыл 3.5 года, и это был
самый длинный период работы на одном месте. При этом только на четвертый год мне
доверили делать важную функциональность почти самостоятельно. Почти — потому что
и в этом случае были жесткие рамки в плане технологий и фреймворка, местами
неудачные.</p>

<p>Вот, пожалуй, что нужно держать в уме, собираясь на удаленку. Да, она сделает
вас самостоятельным и пробивным, да, вы будете получать больше коллег из
яндексов и сберов. Но чтобы обсуждать ключевые вопросы, чтобы принимать решения,
нанимать, руководить — будьте добры в офис.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/indesign-startup/">Запуск InDesign</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-06-19T00:00:00+00:00">
        Jun 19, 2023
    </time>

    <a href="/tag/video/" rel="tag">video</a>, <a href="/tag/adobe/" rel="tag">adobe</a>, <a href="/tag/indesign/" rel="tag">indesign</a>

</div>


            <div class="entry">
                
                    <p>Готовлю книжку к печати и поэтому вынужден иметь дело с Адобом. Избежать этого
шага невозможно — некоторые программы заменить нечем. Несмотря на то, что в
адобовских программах я работаю буквально 20 лет, поминутно матерюсь из-за их
косяков. Покажу серьезный прокол, который заслуживает отдельного поста.</p>

<p>Перед вами видео, где я запускаю Индизайн. Обратите внимание, что приложение
стартует быстро: буквально пару секунд занимает сплеш-скрин, а дальше
распахивается окно. Это, кстати, не заслуга Адоба: просто в процессе записи я
несколько раз открывал и закрывал его, и поэтому оно прогрето. Холодный запуск
будет медленней.</p>

<video controls="">
  <source src="/assets/static/aws/indesign/1.mp4" type="video/mp4" />
</video>

<p>Но дело не в этом. После того, как окно распахнется на весь экран, программа
вступает во вторую фазу: загружает внутренний экран с последними файлами и
рекламой новых фич. Эта загрузка длится десять
секунд. <strong>Целых. Десять. Секунд.</strong> Пока он не просрется, не видно последних
файлов и кнопок создания нового документа.</p>

<p>В итоге сидишь и тупишь в пустоту, пока что-то там не загрузится. Однако если
нажать Ctrl+O, откроется диалог выбора файла. Выходит, программа прекрасно
работает, даже если главный экран не загрузился! Если выбрать в диалоге файл с
проектом, он откроется мгновенно. Можно не ждать эти 10 секунд, а открыть файл
ручками и работать. Это подтверждает второе видео:</p>

<video width="1280" height="720" controls="">
  <source src="/assets/static/aws/indesign/2.mp4" type="video/mp4" />
</video>

<p>Такие вот интересные программы Адоба.</p>

<p>Чем-то это напоминает современные веб-приложения: программа загрузилась, но это
присказка, не сказка. Мы только загрузили скрипты, далее они выгребут свое
дерьмо с серверов и только затем покажут приложение. На телевизорах такое
постоянно: первый прогрес-бар показывает загрузку приложения на уровне ОС, а
приложение запускает второй прогресс-бар для загрузки своего барахла.</p>

<p>Печально, что эту ерунду нельзя объединить в один шаг, потому что как
пользователю мне эти фазы до одного места: один хрен программа не
работает. Вдвойне печальней, что это зараза переходит на десктоп.</p>

<p>Подозреваю, что упомянутый главный экран — ничто иное, как Хром + Node.js +
React. Это видно по косвенным признакам: он похож на Слак и прочие поделки,
которые не могут быть отрисованы частично, а только целиком. Возможно, скрипты
ломятся в сеть, но блокируются из-за санкций или бог знает чего. Ожидание в 10
секунд похоже на таймаут, заданный при отправке HTTP-запроса. Спасибо, что хотя
бы выставили его: по умолчанию он равен 30 секунд.</p>

<p>Странно, что последние файлы отображаются внутри браузера, хотя никак не связаны
с ним. Это банальная глупость, деградация разработки. Надо сказать, я не
удивлен. В Адобе много что делают на Node.js, например дашборд, из которого
ставятся приложения. Я как-то шарился по папкам и нашел ворох скриптов. Плюс
часто выскакивает диалог с текстом “приложение node хочет доступ к такому-то
сертификату.”</p>

<p>В сотый раз повторю тезис: сапожник без сапог. Фирма, которая тридцать лет пишет
настольные программы под Винду и Мак, не может нормально показать последние
файлы. Для загрузки приложений делается поделка па Хроме и Js, глючная и
тормозная. Деградация софта в угоду менеджменту: сделать тяп-ляп, но зато быстро
и получить повышение.</p>

<p>Хочется верить, что индустрия печати пересядет с иглы Адоба на что-то другое, но
пока что просвета не видно.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/en/clojure-debug/">Avoid code you cannot debug</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-06-13T00:00:00+00:00">
        Jun 13, 2023
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/debugging/" rel="tag">debugging</a>

</div>


            <div class="entry">
                
                    <p>This is a small tip I’d like to share with Clojure programmers.</p>

<p><strong>In a project, avoid code you cannot debug.</strong> It’s simple: if you can put a
tag like <code class="language-plaintext highlighter-rouge">#debug</code> or similar somewhere in the middle, run a test and hang in a
debugging session, you’re good. But if you cannot, you’ll be in trouble one day.</p>

<p>Thus, any kind of DSL or yet another “smart” solution is a source of potential
problems. Take Meander, for example. Imagine I have a map like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
 </span><span class="no">:address</span><span class="w"> </span><span class="p">{</span><span class="no">:city</span><span class="w"> </span><span class="s">"Chita"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>and I want it to become this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
 </span><span class="no">:city</span><span class="w"> </span><span class="s">"Chita"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>With Meander, I would write:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">m/match</span><span class="w">
  </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:address</span><span class="w"> </span><span class="p">{</span><span class="no">:city</span><span class="w"> </span><span class="s">"Chita"</span><span class="p">}}</span><span class="w">
  </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="n">?name</span><span class="w"> </span><span class="no">:address</span><span class="w"> </span><span class="p">{</span><span class="no">:city</span><span class="w"> </span><span class="n">?city</span><span class="p">}}</span><span class="w">
  </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="n">?name</span><span class="w"> </span><span class="no">:city</span><span class="w"> </span><span class="n">?city</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>and it works fine. But one day, my datasource suddenly returns a user without an
address:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:address</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w">
</span><span class="c1">;; or just {:name "Ivan"}</span><span class="w">
</span></code></pre></div></div>

<p>which is completely fine because a user might have no address associated with
them. By passing that map into <code class="language-plaintext highlighter-rouge">m/match</code>, I expect it to return <code class="language-plaintext highlighter-rouge">{:name "Ivan"
:city nil}</code> but no: there will be an exception:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">m/match</span><span class="w">
   </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:address</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="n">?name</span><span class="w"> </span><span class="no">:address</span><span class="w"> </span><span class="p">{</span><span class="no">:city</span><span class="w"> </span><span class="n">?city</span><span class="p">}}</span><span class="w">
   </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="n">?name</span><span class="w"> </span><span class="no">:city</span><span class="w"> </span><span class="n">?city</span><span class="p">})</span><span class="w">

</span><span class="n">Unhandled</span><span class="w"> </span><span class="n">clojure.lang.ExceptionInfo</span><span class="w">
   </span><span class="n">non</span><span class="w"> </span><span class="n">exhaustive</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="n">match</span><span class="w">
   </span><span class="p">{}</span><span class="w">
</span></code></pre></div></div>

<p>The line “non exhaustive pattern match” tells nothing to me nor the ex-data
does. The message is fuzzy, there is no context, the ex-data has nothing useful
(it’s an empty map). Having such an entry in logs or Sentry would not help you
in a bit.</p>

<p>Moreover, you cannot debug it. The <code class="language-plaintext highlighter-rouge">m/match</code> macro expands into a huge block of
code. Debugging it somewhere in the middle would be quite challenging.</p>

<p>Now compare it with a plain function that splits the data step by step:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-user</span><span class="w"> </span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="w">

  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="n">username</span><span class="w"> </span><span class="no">:name</span><span class="w">
         </span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">address</span><span class="p">]}</span><span class="w">
        </span><span class="n">entry</span><span class="w">

        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">city</span><span class="p">]}</span><span class="w">
        </span><span class="n">address</span><span class="p">]</span><span class="w">

    </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="n">username</span><span class="w">
     </span><span class="no">:city</span><span class="w"> </span><span class="n">city</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>First, it works with both maps:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">remap-user</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">})</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="n">,</span><span class="w"> </span><span class="no">:city</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w">

</span><span class="p">(</span><span class="nf">remap-user</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:address</span><span class="w"> </span><span class="p">{</span><span class="no">:city</span><span class="w"> </span><span class="s">"Chita"</span><span class="p">}})</span><span class="w">
</span><span class="n">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="n">,</span><span class="w"> </span><span class="no">:city</span><span class="w"> </span><span class="s">"Chita"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Second, I can always put a debugging tag into that function and observe the
local variables, the state and even run some expressions. With Meander, it’s
just impossible or only possible with certain effort.</p>

<p>Third, if a city is required, I’d put something like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="n">city</span><span class="w"> </span><span class="s">"The city is missing"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>and get a clear exception I want.</p>

<p>Vast Meander patterns are completely unmaintainable. Pass something weird and
you’ll get a “non exhaustive pattern match” message with no idea about what went
wrong.</p>

<p>Finally, debugging is crucial. If you cannot hang in the middle of execution and
observe the state, that’s bad. Most Clojure programmers believe it’s a special
language liberating you from debugging errors, but it’s not true. Debugging has
not gone anywhere even with such a great language as Clojure.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/yt-pause/">Пауза в Ютубе</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-06-12T00:00:00+00:00">
        Jun 12, 2023
    </time>

    <a href="/tag/youtube/" rel="tag">youtube</a>, <a href="/tag/video/" rel="tag">video</a>, <a href="/tag/subtitles/" rel="tag">subtitles</a>, <a href="/tag/pause/" rel="tag">pause</a>

</div>


            <div class="entry">
                
                    <p>Не помню, чтобы кто-то жаловался вот на что. Когда ставишь Ютуб на паузу,
появляется доселе невидимый бар управления, который ложится аккурат на субтитры.</p>

<p>Речь идет о субтитрах в обучающих роликах, в основном языковых. Но это может
быть доклад, митап или сцена из фильма.</p>

<p><img src="/assets/static/aws/yt-pause/1.jpg" /></p>

<p>Со своими субтитрами Ютуб решил ловко: в момент паузы они приподнимаются. Но не
могут же сдвинуться буквы на видео! Частично проблему можно решить, изменив
размеры окна, но это уловки для бедных.</p>

<p>Спрашивается, почему бы не вынести кнопки в отдельную полосу? Да, они займут
место, ну и что? Почему проблему интерфейса рашают за счет контента? Почему
интерфейс налазит на видео, вместо того чтобы быть снизу?</p>

<p>То есть Гугл решил: внизу видео что-то не нужное, поставим туда кнопки. А там,
на минуточку, бывает текст, и его даже порой читают. Например я.</p>

<p>В других сервисах бывает еще хуже. Поставил на паузу — и появляются темные
градиенты, жирные блямбы, выезжают скрытые кнопки, рекомендации и все прочее. Я
просто хочу что-то рассмотреть или прочитать, почему мне мешают? Дизайнер,
добавь в угол экрана две белые палочки — знак паузы. И не в центр, потому что в
центре самое нужное, а в угол. Этого хватит. Но нет, нужно загадить как можно
больше пространства.</p>

<p>Кстати, один из способов решить эту проблему — <a href="/youtube-desktop/">смотреть Ютуб в VLC</a>, о чем
я писал раньше. Слегка экстремально, но проблемы субтитров нет.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/pdf-correct/">Корректура в PDF</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-06-10T00:00:00+00:00">
        Jun 10, 2023
    </time>

    <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/pdf/" rel="tag">pdf</a>

</div>


            <div class="entry">
                
                    <p>Если кто не знает, откуда столько ненависти к PDF, сейчас объясню.</p>

<p>У PDF одно назначение — просмотр и печать документов. Это конечный артефакт,
который получают при компиляции проекта — будь то Индизайн, Латех, что
угодно. Править PDF после его получения — это то же самое, что править байтики в
exe-файле, вместо того, чтобы поправить код.</p>

<p>Один раз <a href="/preview/">я даже писал</a> про возможности Preview по работе с PDF, но все это уловки
для бедных, когда нет исходника.</p>

<p>Тезис о том, что с PDF нельзя работать как с документом, подтверждает следующий
опыт: <strong>середина 2023 года, тридцать лет с момента появления PDF — и не найти
программы, которая бы работала с ним без ошибок</strong>.</p>

<p>Если конкретно, то я готовлю вторую книгу к печати. Заказал корректуру, говорю:
готов распечатать и прислать любой службой за мой счет. Нет, берем только
PDF. Ладно, выслал, получил обратно с комментариями.</p>

<p>Теперь самое интересное. Внос правок сводится к шагам: перешел к очередному
комментарию, поправил исходник, удалил коммент. Что же пошло не так? А вот что.</p>

<p>Preview на Mac M1 не может удалить некоторые комментарии. Те, что с типом
Highlight — да, а Note — нет. Специально проверил, старый Preview на Интеле
может, но поведение неочевидно. В целом работа с аннотациями в Preview глючная:
коммент может висеть еще долго после удаления. Иногда фокус смещается
произвольно и удаляется не тот коммент.</p>

<p>Не все это можно передать в картинках, но например: слева у комментария есть
опция удаления, а справа у Note — нет.</p>

<p><img src="/assets/static/aws/pdf/1.jpeg" /></p>

<p>Для демонстрации других косяков нужно записывать гифки, к чему я не готов.</p>

<p>Вы скажете — браузер. Не вопрос, открыл в Хроме, а там такое:</p>

<p><img src="/assets/static/aws/pdf/2.jpeg" /></p>

<p>Плюс комменты нельзя удалять, read-only.</p>

<p>Может, Акробат наше все? Ну, уже сам факт, что установка требует sudo, внушает опасения. Ладно, поставил. Документ не открывается перетаскиванием в программу — только File -&gt; Open, только хардкор. Удаление комментов работает, но если скопировать текст из PDF, получим такое:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Âòîðàÿ ãëàâà ïîñâÿùåíà ðåëÿöèîííûì áàçàì äàííûõ,
</code></pre></div></div>

<p>Словом, кто вносил корректуру, тот в цирке не смеется.</p>

<p>Повторю тезис из начала заметки: любая работа с PDF — это боль по
определению. Он специально сделан так, чтобы правки были максимально
затруднены. Бинарный формат, девять редакций, адское легаси. Любая программа,
которая предлагает редактирование PDF — это н…балово. Оно работает только в
примитивных случаях, а как что-то серьезней — сплошная беда.</p>

<p>Поэтому, кстати, я считаю, что корректор, который не работает с бумагой — это
слабый корректор. Хороший как минимум не должен ее избегать.</p>

<p><strong>UPD</strong></p>

<p>Продолжение заметки. Добрые люди подсказали два варианта: PDF Expert и Master
PDF Editor. Первая не обслуживает пользователей из России, но ставится из
brew. Оказалось, она не работает без облачной учетной записи. Попап закрывает
интерфейс, хоть усрись, но создай учетку. Скриншот не сохранил, прогу удалил.
Поставил Master PDF Editor, на первый взгляд все отлично. Посидел два часа,
вносил корректуру. Сохранил файл и перекинул на другой комп. Открываю, а там:</p>

<p><img src="/assets/static/aws/pdf/3.jpeg" /></p>

<p>Знаете, это уже не смешно. Похоже, на вопрос из прошлой заметки — есть ли в
природе программа, которая работает с PDF без ошибок — ответ все-таки
отрицательный.</p>

<p>Эту работу я как-нибудь доделаю, но она стоила много нервов. <em>Очень, очень много
нервов.</em></p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/strings-80/">Строки по 80</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-06-08T00:00:00+00:00">
        Jun 8, 2023
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/git/" rel="tag">git</a>

</div>


            <div class="entry">
                
                    <p>Иной айтишник нет-нет да пожалуется на разбиение строк по 80 символов. Считаю
нужным прояснить ситуацию.</p>

<p>Коротко: если это текст в системе контроля версий — код, readme или вроде того —
он должен быть разбит. Не обязательно по 80 символов, можно 90, 100
или 120. Главное выбрать число и следовать ему.</p>

<p>Обыватель думает, что число 80 связано с перфокартой. Да, на них действительно
было столько дырок, потому что 80 символов умещалось в терминале. Но дело не
только в этом. Откройте любую книгу и посчитайте число знаков в строке. Их будет
от 60 до 80, в среднем 65. Почему?</p>

<p>Ответ никак не связан с перфокартой. Эти 65-70 знаков в сочетании с 10 шрифтом
дают строку длиной 12 см. В свою очередь 12 см — та длина, которую глаз читает
на комфортном расстоянии без поворота головы.</p>

<p>Как-то так:</p>

<p><img src="/assets/static/aws/strings80/1.jpeg" /></p>

<p>Откройте любой журнал. Две колонки по 50 символов, потому что шрифт
меньше. Сделайте в одну — никто не прочтет.</p>

<p>Теперь я растянул редактор на всю ширину. Как это читать? Вы будете крутить
головой, как лошадь на привязи:</p>

<p><img src="/assets/static/aws/strings80/2.png" /></p>

<p>А так нормально:</p>

<p><img src="/assets/static/aws/strings80/3.png" /></p>

<p>Тут влетает бунтарь с криками: как так, за меня решили, задели хрупкие чувства!
Дайте свободу, я сам настрою. Мне не жалко, но есть проблема: редактор
приходится ужимать до такого состояния:</p>

<p><img src="/assets/static/aws/strings80/4.png" /></p>

<p>У меня так-то 400 файлов открыто, и под каждый менять размер окна — не много ль
чести? Можно вынести файл в отдельное окно, но опять же — заморочки.</p>

<p>Далее — конфликты. Если параграф не нарезан на строки по 80 символов, исправить
конфликты невозможно. Пожалуйста, прочтите это предложение еще раз: <strong>исправить
конфликты невозможно</strong>. Без нарезки параграф — это единая строка, и если Вася
исправил букву в начале, а Петя — в конце, это конфликт. Пишите претензии
создателям Git, CSV и другим системам контроля версий. Их рабочая единица —
строка, и других не предвидится.</p>

<p>Подобные конфликты решаются вручную и больше никак. Продвинутые тузлы подсветят
изменения внутри строки, но что-то сложнее пары опечаток решить невозможно. У
нас уже было такое: вместе с коллегой поправили документацию в markdown. В итоге
я откатил свои правки и накладывал повторно на его мердж. Спасибо, больше не
надо.</p>

<p>Наконец, в хорошем редакторе проблема нарезки не стоит в принципе. <code class="language-plaintext highlighter-rouge">C-x f</code> задает
ширину колонки, <code class="language-plaintext highlighter-rouge">M-q</code> поджимает текущий абзац. Чтобы поджать весь документ, жмем
<code class="language-plaintext highlighter-rouge">C-x h</code> и <code class="language-plaintext highlighter-rouge">M-q</code>. Занимает секунду.</p>

<p>Кстати, принцип, когда подряд идущие строки объединяются в параграф, а пустая
строка отбивает параграфы, придумали не в markdown. Это сделал Кнут для своего
TeX, за что ему честь и хвала.</p>

<p>Вот, пожалуй, все, что нужно знать про нарезку строк.</p>

                
            </div>

        </li>
        
    </ul>

    <h4>
        
        <a href="/page2" class="previous">&larr;</a>
        
        <span class="page_number ">Страница 3 из 65</span>
        
        <a href="/page4" class="next">&rarr;</a>
        
    </h4>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
