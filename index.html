<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ivan Grishaev's blog</title>
  <meta name="description" content="Writing on programming, education, books and negotiations.
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px"><a href="/">Ivan Grishaev's blog</a></p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/open-source/">Open Source</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="home">

    <ul class="post-list">
        
        <li>

            <h2>
                <a class="post-link" href="/vacuous-truth-3/">Пустая истина (3)</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-15T00:00:00+00:00">
        Jul 15, 2025
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/logic/" rel="tag">logic</a>

</div>


            <div class="entry">
                
                    
<p>После второго раунда обсуждений стало ясно, почему every от пустого множества
дает истину. Читатель <a href="https://t.me/themishkun">Миша Левченко</a> внятное объяснение, которое понятно
мне как программисту. Оно не опирается на кванторы и логику. И хотя вывод все
равно не нравится, приведу объяснение здесь.</p>

<p>Дело в том, что операции над списками нужно рассматривать как свертку. Есть
такая функция <code class="language-plaintext highlighter-rouge">reduce</code> (она же <code class="language-plaintext highlighter-rouge">fold</code>), которая принимает функцию двух
аргументов и коллекцию. Результат функции такой:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn(fn(fn(fn(item0, item1), item2), item3), item4)...
</code></pre></div></div>

<p>Например, для сложения чисел 1, 2, 3, 4 получим форму:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(((1 + 2) + 3) + 4)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Reduce</code> может накапливать в том числе другую коллекцию: словарь или список. Это
вообще очень мощная функция. Про себя я называю ее царицей функций, потому что
через reduce можно выразить что угодно.</p>

<p>Reduce выше прекрасно работает, если элементов два и более. Когда их один или
ноль, начинаются граничные случаи. Одно из решений в том, что <code class="language-plaintext highlighter-rouge">reduce</code> может
принимать т.к. <code class="language-plaintext highlighter-rouge">init</code> — первичный элемент, который подставляется в начало
цепочки. Чаще всего он выступает коллекцией-аккумулятором, но может быть и
простым скаляром.</p>

<p>Если передать <code class="language-plaintext highlighter-rouge">init</code>, форма будет такой:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn(fn(fn(init, item0), item1), item2)...
</code></pre></div></div>

<p>Другими словами, он гарантирует, что элементов больше нуля. Если основной список
пустой, просто вернем init.</p>

<p>Так вот, в терминах свертки функция <code class="language-plaintext highlighter-rouge">ALL</code> (которую я раньше называл <code class="language-plaintext highlighter-rouge">every?</code>)
выглядит так:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(func ALL [fn-pred items]
  (reduce (fn [x y]
         (and x (fn-pred y)))
       true
       items))
</code></pre></div></div>

<p>Демо:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ALL int? [1 2 3])
true

(ALL int? [1 nil 3])
false

(ALL int? [])
true
</code></pre></div></div>

<p>А вот функция <code class="language-plaintext highlighter-rouge">ANY</code> (что хотя бы один элемент вернул истину для предиката):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(func ANY [fn-pred items]
  (reduce (fn [x y]
         (or x (fn-pred y)))
       false
       items))
</code></pre></div></div>

<p>Демо:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ANY int? [1 nil 3])
true

(ANY int? [nil nil nil])
false

(ANY int? [])
false
</code></pre></div></div>

<p>Аналогично работают функции суммирования: это <code class="language-plaintext highlighter-rouge">reduce</code>, где начальные элементы
равны 0 и 1. Поэтому <code class="language-plaintext highlighter-rouge">(+)</code> дает 0, а <code class="language-plaintext highlighter-rouge">(*)</code> — 1.</p>

<p>Как видим, все это можно объяснить без греческих букв и терминов. А пустая
истина, о которой я писал ранее, считается истиной только потому, что таков
начальный элемент свертки.</p>

<p>Другое дело, что такой подход все равно мне не нравится. В каждом их них скрыт
начальный элемент: для <code class="language-plaintext highlighter-rouge">ALL</code> — <code class="language-plaintext highlighter-rouge">true</code>, для <code class="language-plaintext highlighter-rouge">ANY</code> — <code class="language-plaintext highlighter-rouge">false</code>, единица для
умножения и так далее. Считается очевидным, что он должен быть именно таким. А
мне это не очевидно. Я спотыкаюсь, когда вижу, что произведение элементов
пустого списка равно единице. Я бы предпочел неопределённость — то есть null.</p>

<p>Я в курсе про нейтральный элемент: ноль для сложения, единица для умножения. Но
на пустых списках это как-то не очень. Душа не принимает, если совсем честно.</p>

<p>В самом деле, в математике оператор умножения — бинарный, ему нужно два
операнда. Нельзя записать что-то вроде <code class="language-plaintext highlighter-rouge">5 * = 5</code> — тут не хватает операнда
справа. С какой стати мы обходим математические правила — не ясно.</p>

<p>Я часто использую <code class="language-plaintext highlighter-rouge">reduce</code> и вывел правило: всегда указываю начальный
элемент. Например, чтобы сложить список чисел, я пишу так:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(reduce + 0 numbers)
</code></pre></div></div>

<p>вместо</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(apply + numbers)
</code></pre></div></div>

<p>Потому что во втором случае не очевидно, во что накапливается результат.</p>

<p>Словом, пока что меня отпустило на тему пустой истины. Все оказалось просто: это
свертка, где начальный элемент — истина. Крайне неочевидно, на мой взгляд. Чтобы
не отстрелить ногу, либо проверяйте коллекцию на пустоту, либо пишите явный
<code class="language-plaintext highlighter-rouge">reduce</code>, где начальный элемент — ложь, если того требует контекст.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/vacuous-truth-2/">Пустая истина (2)</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-15T00:00:00+00:00">
        Jul 15, 2025
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/logic/" rel="tag">logic</a>

</div>


            <div class="entry">
                
                    <p>После прошлой заметки мне стали приходить, что называется, письма читателей. Их
можно разделить на два вида.</p>

<p>Первый — ты не шаришь в логике, сейчас я все объясню. Гляди… (далее километр
греческих букв, термины “антецедент”, “консеквент” и другие). Вывалив все это,
человек считает, что открыл мне глаза. Я ничего из этого не понимаю, поэтому
прошу — не утруждайтесь подобными доказательствами.</p>

<p>Второй тип писем — в языке X предикат every работает так же: для пустого
множества вернет истину независимо от предиката. Да, согласен. Еще пять лет
назад выполнил в Постгресе такой запрос:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="mi">1</span> <span class="o">=</span> <span class="k">ALL</span> <span class="p">(</span><span class="n">array</span><span class="p">[]::</span><span class="nb">int</span><span class="p">[]);</span>
<span class="n">t</span>
</code></pre></div></div>

<p>, получил истину и опечалился. Если же поменять <code class="language-plaintext highlighter-rouge">ALL</code> на <code class="language-plaintext highlighter-rouge">ANY</code>, получим
противоположный результат:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="mi">1</span> <span class="o">=</span> <span class="k">ANY</span> <span class="p">(</span><span class="n">array</span><span class="p">[]::</span><span class="nb">int</span><span class="p">[]);</span>
<span class="n">f</span>
</code></pre></div></div>

<p>Здесь мы уподобляемся Джаваскриптерам: подаем нелепый ввод, получаем нелепый
вывод. При этом силимся подвести его под какую-то базу: антецеденты-консеквенты,
кванторы и прочее.</p>

<p>А дело в другом: аппарат логики не учитывает неопределенность. Это утопичная
модель, где есть только истина и ложь — третьего не дано. В тех местах, где
модель не ложится на реальность, начинаются подтасовки: истину раз — и обозвали
“пустой”. То есть как бы истина, но не совсем.</p>

<p>Меня это страшно бесит, прям так, что не передать словами. Если результат
отличен от истины и лжи, заведи под него тип. Переработай модель логики, в конце
концов. Признай, что старая модель ограничена и не подходит под прикладные
задачи. И уж чего точно я не пойму, так это того, почему в языках
программирования мы опираемся на логику бог знает какой давности. Нужно делать
так, чтобы удобно здесь и сейчас, а не как принято в учебнике логики.</p>

<p>Правильный ответ в том, что в функции every пустое множество — это
неопределенность, краевой случай. То же самое, что получить первый элемент
массива, когда он пуст. В зависимости от языка мы получим null или исключение,
но точно не число 42 с пометкой “пустое” — это нонсенс.</p>

<p>Обратимся к более достойной науке, чем логика — математике. Рассмотрим функцию
<code class="language-plaintext highlighter-rouge">y = 1/x</code> (см. график ниже). Прелесть этой функции в том, что в точке 0 ее
значение не определено. Если точнее, при <code class="language-plaintext highlighter-rouge">x=0</code> результат будет бесконечностью,
причем даже нельзя сказать, какой именно — положительной или отрицательной. В
зависимости от того, с какой стороны приближаться к нулю — правой или левой —
функция будет уходить в плюс- и минус-бесконечность.</p>

<p><img src="/assets/static/aws/vacuous-truth-2/1.jpeg" /></p>

<p>Область определения этой функции записывается так: <code class="language-plaintext highlighter-rouge">(-inf, 0);(0, +inf)</code>. В нуле
функция не определена — и при этом никто не умер. Бывают функции и с большим
количеством точек и даже целых областей, где они не определены. И ничего — нас
это устраивает, с функцией можно работать.</p>

<p>(В скобках отмечу, стандарт чисел с плавающей запятой предусматривает комбинации
битов, которые трактуются как обычная бесконечность, а также плюс- и
минус-версии. То же самое касается нуля: может быть ноль, минус ноль и плюс
ноль. Это помогает при сходимости рядов, когда мы пришли к нулю и хотим знать
откуда — справа или слева. По крайней мере в Фортране этими штуками
пользовались).</p>

<p>Другой пример из математики — решение квадратного уравнения вида <code class="language-plaintext highlighter-rouge">ax^2 + bx + c
= 0</code>. У него может быть либо два корня, либо один, либо никаких. Во втором
случае еще можно слукавить: сказать, что один корень — это два
одинаковых. Ладно, но с третьим вариантом это не прокатит. Нельзя вернуть
какое-то левое число и сказать, что это пустой корень. Они не определены.</p>

<p>Пример из географии: чтобы попасть на северный полюс, нужно идти на
сервер. Каким же будет северное направление на Северном полюсе? Ответ — никаким,
оно не определено.</p>

<p>То же самое с предикатами: когда нас просят сказать, что все камни белые, но
камней нет, это неопределенность. Потому что если сказать да, оказывается, что
камни в том числе черные, прозрачные, резиновые — и все это одновременно. Этого
не было, если бы every возвращал NULL — я имею в виду не в коде, а на уровне
логики.</p>

<p>Уж не говорю, что пустая истина совершенно неприемлема на бытовом уровне. Это
либо троллинг, либо саботаж, либо неразбериха.</p>

<p>Когда я читаю в документации: <em>if the stream is empty then true is returned and
the predicate is not evaluated</em> — мне немного плохеет. Выходит так, что функция
возвращает один и тот же результат при РАЗНЫХ случаях. А значит, ответственность
перекладывается на тебя — будь добр сам проверяй, пустое множество или не
пустое.</p>

<p>Это просто плохой API — что, в общем-то, не редкость. Надо это признать и больше
так не делать. А вот оправдываться логикой и чепухой а-ля “антецедент-квантор” —
это отстой.</p>

<p>Под конец напомню вам о Булгакове. Если свежесть отлична от первой, это уже не
свежесть. Если перед истиной стоит какой-то тег — пустая, неполная, вторичная —
то это не истина. Вот и все, что нужно запомнить. И это — истина.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/vacuous-truth-1/">Пустая истина (1)</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-15T00:00:00+00:00">
        Jul 15, 2025
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/logic/" rel="tag">logic</a>

</div>


            <div class="entry">
                
                    <p>Расскажу, как однажды погорел на забавной вещи под названием “пустая
истина”. Это было лет пять назад, когда я ничего про это не знал.</p>

<p>Значит, смотрите: когда мускулистые греки работали над логикой, они ввели в том
числе предикаты. Например, белый? – это предикат. Если применить его к любому
предмету, получим истину или ложь.</p>

<p>Также греки придумали пакетную версию предикатов, батч, так сказать. Это
супер-предикаты “каждый из”, “любой из”, “ни один из”. Все они принимают другой
предикат и множество объектов. Далее они редьюсят множество логических
результатов в один (простите за функциональные термины).</p>

<p>Если на столе три белых камня, то выражение “все камни – белые” вернет
истину. Если один – тоже истину. Если сто белых и один черный – ложь. А что
случится, если камней нет? Греки почесали бороды и сказали – будет тоже истина,
только назовем ее пустой.</p>

<p>В результате: если на столе нет камней, выражение “все камни – белые” будет
истинно. Таким же истинным будет выражение “все камни – черные”, в крапинку и
полоску. Все камни обладают какими угодно свойствами одновременно. Одна беда –
их нет.</p>

<p>На мой взгляд, греки подложили нам свинью. Истина, как известно, одна – не
бывает двух разных истин. Когда вводят истину с какой-то характеристикой,
получается черт знает что. Вроде бы это истина, но какая-то другая, что требует
особого обращения с ней.</p>

<p>Напоминает диалог Булгакова об осетрине второй свежести: голубчик, это вздор!
Свежесть бывает только одна – первая, она же последняя. Если осетрина второй
свежести, значит, она тухлая.</p>

<p>Знал же человек!</p>

<p>Интересно, что греческая вторая свежесть, тьфу, пустая истина идеально ложится
на быдлокод! Это при том, что программировать греки не умели.</p>

<p>Предположим, нужно написать функцию, которая принимает предикат и список
объектов. Функция возвращает истину, если предикат справедлив для каждого
элемента. Вот как выглядит самая тупая реализация:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func is_every(fn_pred, items):
  for item in items:
    if not fn_pred(item):
      return false;
  return true;
</code></pre></div></div>

<p>Все просто: бежим по списку, как только предикат вернул ложь, мы тоже возвращаем
ложь. Если прошли по всем элементам, значит, лжи ни разу не было, и мы
возвращаем истину. Если список пуст, мы благополучно пропустим цикл и перейдем к
выражению с истиной.</p>

<p>Как это связано с моей работой? Несколько лет назад в Exoscale я делал систему
прав доступа, аналог IAM в Амазоне. Из базы читались разрешения, и нужно было
проверить, что каждое из них совпадает с политикой ресурса. Для этого я вызывал
кложурную функцию <code class="language-plaintext highlighter-rouge">every?</code>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(every? policy-match? permissions)
</code></pre></div></div>

<p>Оказалось, Рич Хикки знал эти штучки, и для пустого множества <code class="language-plaintext highlighter-rouge">every?</code>
возвращает истину. Это легко проверить:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(every? int? [1 2 3])
true

(every? int? [1 "a" 3])
false

(every? int? [])
true
</code></pre></div></div>

<p>Вышло так, что если у пользователя вообще не было прав, то список был пуст и
every? возвращала истину. В результате пользователь, который не имел доступа ни
к чему, имел доступ ко всему – из-за моих бедных знаний в этой области.</p>

<p>С тех пор у меня отпечаталось в подкорке, что перед <code class="language-plaintext highlighter-rouge">every?</code> должна быть
проверка на пустоту. Пустая истина может трактоваться как угодно, но мне нужна
точность.</p>

<p>Второе – я не согласен с греками. Видимо, они еще не знали про NULL и
неопределенность, плохо понимали троичную логику. Увы, наш мир сложнее, чем
<code class="language-plaintext highlighter-rouge">true</code> и <code class="language-plaintext highlighter-rouge">false</code>, есть нуллы и другие досадные вещи. Но нужно жить с ними, а не
сводить к каким-то сомнительным истинам.</p>

<p>Кстати, пустая истина позволяет сказать жене: все мои любовницы – брюнетки. Если
у вас нет любовниц, это тоже будет истиной. Разве что придется потратить время
на объяснение, но ничего. Истина дороже.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/google-prices/">Подорожание Google Workspace</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-15T00:00:00+00:00">
        Jul 15, 2025
    </time>

    <a href="/tag/google/" rel="tag">google</a>, <a href="/tag/ai/" rel="tag">ai</a>

</div>


            <div class="entry">
                
                    <p>Гугл пишет, что поднимет цену на подписку Google Workspace. Это для тех, кто
привязял домен к Гуглу и тем самым создал мини-организацию из одного
человека. Правда, со временем я открыл учетки для других членов семьи, включая
маму, потому что никто не помнит пароль, да и пройдет авторизацию Гугла сегодня
не каждый. Так что сейчас в моей организации пять человек.</p>

<p>Интересна причина роста цен — это внедрение AI и некие фичи:</p>

<blockquote>
  <p>The updated subscription pricing reflects the significant added AI value, as
well as the many new features we have introduced and are launching to Google
Workspace editions</p>
</blockquote>

<p>В тот момент я подумал: Гугл напоминает российский Газпром. Потому что все
развлечения Газпрома оплачивает потребитель — покупку футбольных клубов,
километры списанных труб, бонусы менеждеров. За все это платит простолюдин,
неважно какие успехи рапортует Газпром по телевизору.</p>

<p>То же самое с Гуглом — казалось бы, он и так гребет деньги лопатой за рекламу;
собирает и продает личные данные; везде где можно предлагает платный Gemini. И
все равно этого мало, поэтому пусть заплатит потребитель.</p>

<p>Тем чудикам, которые топят за ИИ, советую подумать: на ровном месте мы получили
прибавку к цене только потому, что компания внедряет ИИ. Такая вот новая
нормальность.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/github-buttons/">Кнопки в Гитхабе</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-15T00:00:00+00:00">
        Jul 15, 2025
    </time>

    <a href="/tag/ui/" rel="tag">ui</a>, <a href="/tag/github/" rel="tag">github</a>

</div>


            <div class="entry">
                
                    <p>У Гитхаба странный интерфейс — посмотрите на картинки ниже.</p>

<p>Первая картинка: я хочу смержить пул-реквест. Нажимаю кнопку Squash and merge,
ожидаю, что произойдет то, что написано на кнопке — логично же?</p>

<p><img src="/assets/static/aws/github-buttons/1.jpeg" /></p>

<p>Но мерджа не происходит. Вместо этого появляется форма с двумя полями, а кнопка
Confirm squash and merge проваливается ниже. Как у Чуковского: “и подушка как
лягушка ускакала от меня”. Нужно мотать вниз и жать ее еще раз.</p>

<p><img src="/assets/static/aws/github-buttons/2.jpeg" /></p>

<p>Вот эти убегающие кнопки — бич Гитхаба. Вроде нажал, а всплыло что-то
другое. Кстати, после мерджа обычно я удаляю ветку, и кнопка Delete branch
оказывается на 10 сантиметров ВЫШЕ. То есть сначала нажал кнопку на высоте X,
потом X+10 см, потом снова X-10 см.  Дизайнеру Гитхаба это норм — не жмет, не
чешется.</p>

<p>Вы, конечно, скажете: надо запросить описание коммита. Ну вот ниже на картинке
есть форма комментариев — она статична и не появляется по клику. Можно сделать
такой же статичный инбокс для мерджа. Еще лучше — сделать так, чтобы кнопка не
уплывала вниз, а оставалась на месте, при этом поле повляется ПОД ней. Чаще
всего я ничего не пишу, поэтому просто нажал бы кнопку еще раз.</p>

<p>Решений может быть много, но то, что сейчас — крайне неудачно.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/toy-parser/">Игрушечный парсер</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-05T00:00:00+00:00">
        Jul 5, 2025
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/clojure/" rel="tag">clojure</a>

</div>


            <div class="entry">
                
                    
<p>Месяц назад я помогал одной студентке с домашней работой по Кложе. Да, я тоже
удивился: есть вуз, где на первом курсе пишут парсеры на этом языке. Сомневаюсь,
что у студентов что-то останется в голове: после интенсива Кложи их перебросили
на Пролог, и в чем замысел такого обучения — загадка.</p>

<p>Тем не менее была домашка, которую нужно было сделать. Я помогал с двумя
заданиями: написать комбинаторные парсеры для разбора постфиксной и инфиксной
нотаций. Я всегда любил парсеры, и хоть не силен в них, не прочь что-нибудь
распарсить своими силами.</p>

<p>Так что если вы студент(ка) и пишете парсеры, <a href="https://github.com/igrishaev/toy-parser">загляните в репозиторий</a>.</p>

<p>Там простой модуль с комментариями и базовыми парсерами. Также есть два модуля
demo1 и demo2. В одном пример с префиксной нотацией, во втором — с
инфиксной. Второй пример интересен тем, что там используется рекурсивный парсер,
и поэтому нужны конструкции declare и var.</p>

<p>Эти парсеры в высшей степени просты, и по-хорошему им нужна доработка. Скажем, в
случае ошибки возвращать не nil, а сообщение о том, что пошло не так. Это
сделано нарочно, чтобы акцент остался на главном: парсинге и комбинации
парсеров.</p>

<p>Если будут вопросы, пишите.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/support-jira/">Поддежка и Джира</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-05T00:00:00+00:00">
        Jul 5, 2025
    </time>

    <a href="/tag/support/" rel="tag">support</a>, <a href="/tag/jira/" rel="tag">jira</a>

</div>


            <div class="entry">
                
                    <p>Как-то раз я общался с поддержкой крупного сервиса. У них что-то поплыло,
консоль залита кровью, все ответы — 500. В углу виджет поддержки, и я пишу:
ребята, у вас все плохо. Хром такой-то, вот скриншот.</p>

<p>Сотрудник отвечает: ах, спасибо, что известили, сейчас поправим. Скажите, какой
у вас хром? Я говорю, вот же написал: версия 100500.42. Он такой — отлично,
считайте уже сделали.</p>

<p>Через минуту: еще одна деталь, какая у вас операционная система? Мак,
говорю. Отлично, чиним в поте лица.</p>

<p>Через минуту: а какая версия системы? 14 с копейками. Спасибо, уже патчим прод.</p>

<p>Через минуту: какая у вас часовая зона? Тут я слегка разозлился и ответил, что
хватит приседать на уши. На что сотрудник ответил, что ему нужно заполнить тикет
в Джире: там 20 полей, и все обязательны. Уже заполнили 6, осталось 14. Без
заполнения он не сможет создать заявку, и она не пойдет программистам. И вообще
ничего не будет.</p>

<p>Конечно, ничего я заполнять не стал и закрыл окно. Все это рассказал затем,
чтобы вы знали, как иной раз работает поддержка. Нет ответа на вопрос — нечего
ввести в поле — нет заявки — нет проблемы.</p>

<p>Вот и отлично!</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/poor-io/">Неэффективный ввод и вывод</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-05T00:00:00+00:00">
        Jul 5, 2025
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/io/" rel="tag">io</a>

</div>


            <div class="entry">
                
                    <p>Мое частое замечание к коду — неэффективный ввод-вывод. Примеры:</p>

<ul>
  <li>
    <p>чтобы пройтись по строкам файла, человек читает его в память целиком и
разбивает символами <code class="language-plaintext highlighter-rouge">\r\n</code>. Рано или поздно прилетает CSV на 5 гигабайт, и
машине становится плохо.</p>
  </li>
  <li>
    <p>То же самое с джейсоном: есть стрим, но разработчик читает его в гигантскую
строку, а потом парсит ее.</p>
  </li>
  <li>
    <p>Нужно записать в файл 100 тысяч строк? Человек джойнит их разделителем,
получает километровую строку и пишет в файл.</p>
  </li>
  <li>
    <p>Различные кодирования — base64, gzip и другие — делаются также: данные
читаются в память целиком, из них получается результат тоже в памяти.</p>
  </li>
  <li>
    <p>При загрузке файла в S3 он целиком читается в байтовый массив, затем массив
передается в запрос.</p>
  </li>
</ul>

<p>При этом разработчик обмазывает код вызовами gc в надежде, что это поможет.</p>

<p>Сколько подобных ошибок я исправил — не перечесть. В числе прочего был сервис,
который падал от недостатка памяти, хотя ее было выделено запредельное
количество. Оказалось, разработчик делал все из списка выше. Он получал огромные
файлы, читал их в память, парсил, кодировал в JSON и gzip, используя строки и
массивы. Когда код падал от OOM, он поднимал лимиты в облаке.</p>

<p>Это лишний раз подтверждает: сколько памяти ни дай, плохой код сожрет ее всю.</p>

<p>А решение простое — байтовые и символьные потоки. Ту же Джаву можно ругать за
многое, но в ней очень хорошие потоки (абстрактные классы <code class="language-plaintext highlighter-rouge">Input-</code> и
<code class="language-plaintext highlighter-rouge">OutputStream</code>, <code class="language-plaintext highlighter-rouge">Reader</code> и <code class="language-plaintext highlighter-rouge">Writer</code>). У них много наследников, каждый из которых
делает свою работу. Например, буферизирующий поток, который сглаживает
неравномерность сети и файлов. Потоки для сжатия, когда пишешь в него, а данные
сжимаются в полете. Потоки, связанные с файлами, сокетами или
устройствами. Потоки с подсчетом текущей строки и символа, потоки-пайпы (piped)
для “переливания” данных между тредами — всего этого навалом.</p>

<p>Легко найти сторонние потоки для подсчета MD5 и других хешей. Например, пишешь в
условный <code class="language-plaintext highlighter-rouge">MD5OutputStream</code>, и хеш считается в полете. В конце вызываешь
.getHash, и готово.</p>

<p>Часто задача решается тем, что нужно построить стек потоков и скормить ему
данные. Это труднее, чем прочитать файл в память и разбить на строки. Но не
придется чинить в пятницу вечером.</p>

<p>Уделите время потокам ввода-вывода. Это прям очень полезная вещь.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/no-calls/">У заказчика праздник</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-05T00:00:00+00:00">
        Jul 5, 2025
    </time>

    <a href="/tag/work/" rel="tag">work</a>, <a href="/tag/life/" rel="tag">life</a>

</div>


            <div class="entry">
                
                    <p>Когда у заказчика праздник — это праздник для меня, потому что я могу поработать
спокойно. Нет созвонов и трескотни в чатах. Даже если заглушено все что можно,
шум настигает все равно.</p>

<p>Заметил, что важно само ощущение того, что тебя никто не беспокоит. Так сказать,
предвкушение тихого дня. Бывает, в такой день делаешь то, что собирался
неделями.</p>

<p>Сегодня как раз такой случай. У заказчика выходной, и я сделал то, что долго
планировал. Формально никто не мешал сделать это в обычные дни, но уверенность в
том, что никто не потревожит, дала прилив сил.</p>

<p>Честное слово, нам нужны дни, когда нет ни созвонов, ни чатов, ни почты. Дни,
когда можно поработать в полном отрыве от команды и вечером написать, как много
сделал.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/no-calls-2/">Австралийское время</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2025-07-05T00:00:00+00:00">
        Jul 5, 2025
    </time>

    <a href="/tag/work/" rel="tag">work</a>, <a href="/tag/australia/" rel="tag">australia</a>

</div>


            <div class="entry">
                
                    <p>Несколько раз я упоминал про один австралийский стартап. При всех минусах
кодовой базы у него было и преимущество: разница во времени с
заказчиком. Пересечение было совсем небольшим, буквально два-три часа. День
начинался с созвона, мне давали задачу, мы ее обсуждали. Потом народ из
Австралии шел ужинать, и день был полностью моим. Без созвонов, чатов и
обсуждений. При этом я всегда имел две активных задачи, чтобы в случае зависания
одной переключиться на другую. Утром я докладывал, что сделал вчера, и все были
довольны.</p>

<p>Много воды с тех пор утекло, но порой я скучаю по такому формату. Разница с
заказчиком в час-два означает, что ты не делишь с ним головные боли и причуды:
планинги, ретро, спринты, тимбилдинги, уведомления в Тимс. Иной раз хочется,
чтобы ничего этого не было. Чтобы был только git pull и git push, ну и
зарплата. А на тимбилдинге и без меня обойдутся.</p>

<p>Это так, минутка малодушия. Вздохнул и пошел дальше.</p>

                
            </div>

        </li>
        
    </ul>

    <h4>
        
        <span class="page_number ">Страница 1 из 97</span>
        
        <a href="/page2" class="next">&rarr;</a>
        
    </h4>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="https://t.me/igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
