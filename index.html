<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ivan Grishaev's blog</title>
  <meta name="description" content="Writing on programming, education, books and negotiations.
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="home">

    <ul class="post-list">
        
        <li>

            <h2>
                <a class="post-link" href="/en/pg-docs/02/">PG docs, part 2</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-08-31T00:00:00+00:00">
        Aug 31, 2023
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/postgres/" rel="tag">postgres</a>, <a href="/tag/sql/" rel="tag">sql</a>

</div>


            <div class="entry">
                
                    <p><strong>ToC</strong></p>

<ul>
  <li><a href="/en/pg-docs/01/">About &amp; Installation</a></li>
  <li><a href="/en/pg-docs/02/">The Client</a></li>
</ul>

<p>In this chapter, we’ll discuss how to reach Postgres using the Client library.</p>

<ul>
  <li><a href="#basic-usage">Basic usage</a></li>
  <li><a href="#queries">Queries</a></li>
  <li><a href="#execute">Execute</a></li>
  <li><a href="#prepared-statements">Prepared Statements</a></li>
  <li><a href="#processing-result-with-fn-result">Processing result with :fn-result</a></li>
  <li><a href="#column-names">Column names</a></li>
  <li><a href="#column-duplicates">Column duplicates</a></li>
  <li><a href="#reducers-and-bundles">Reducers and bundles</a>
    <ul>
      <li><a href="#java">Java</a></li>
      <li><a href="#kebab-keys">Kebab-keys</a></li>
      <li><a href="#matrix">Matrix</a></li>
      <li><a href="#index-by">Index by</a></li>
      <li><a href="#group-by">Group by</a></li>
      <li><a href="#key-value">Key-value</a></li>
      <li><a href="#custom-reducers">Custom reducers</a></li>
    </ul>
  </li>
  <li><a href="#transactions">Transactions</a>
    <ul>
      <li><a href="#always-rollback">Always Rollback</a></li>
      <li><a href="#read-only">Read-only</a></li>
      <li><a href="#isolation-level">Isolation level</a></li>
      <li><a href="#manual-transactions-and-status-check">Manual transactions and status check</a></li>
    </ul>
  </li>
  <li><a href="#configuration">Configuration</a></li>
  <li><a href="#authorization">Authorization</a></li>
  <li><a href="#cloning-a-connection">Cloning a connection</a></li>
  <li><a href="#cancelling-a-query">Cancelling a query</a></li>
  <li><a href="#notices">Notices</a></li>
  <li><a href="#thread-safety">Thread safety</a></li>
  <li><a href="#debugging">Debugging</a></li>
</ul>

<!-- tocstop -->

<h2 id="basic-usage">Basic usage</h2>

<p>Here is a brief example of using the client library:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">scratch</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">pg.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">pg</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">config</span><span class="w">
  </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
   </span><span class="no">:port</span><span class="w"> </span><span class="mi">5432</span><span class="w">
   </span><span class="no">:user</span><span class="w"> </span><span class="s">"test"</span><span class="w">
   </span><span class="no">:password</span><span class="w"> </span><span class="s">"test"</span><span class="w">
   </span><span class="no">:database</span><span class="w"> </span><span class="s">"test"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">pg/with-connection</span><span class="w"> </span><span class="p">[</span><span class="n">conn</span><span class="w"> </span><span class="n">config</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">pg/query</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"select 1 as one"</span><span class="p">))</span><span class="w">

</span><span class="c1">;; [{:one 1}]</span><span class="w">
</span></code></pre></div></div>

<p>First, you import the <code class="language-plaintext highlighter-rouge">pg.client</code> namespace which brings the top-level API functions to interact with Postgres. The <code class="language-plaintext highlighter-rouge">config</code> map above specifies the minimal configuration;
it might have more fields which we will explore in a separate section.</p>

<p>The <code class="language-plaintext highlighter-rouge">with-connection</code> macro establishes a new connection, binds it to the <code class="language-plaintext highlighter-rouge">conn</code>
symbol, and executes the body. The connection is closed afterward, even if an
exception pops up.</p>

<p>Technically you can open and terminate a connection manually like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">pg/connect</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w">
      </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">pg/query</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"select 1 as one"</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">pg/terminate</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
  </span><span class="n">data</span><span class="p">)</span><span class="w">

</span><span class="c1">;; [{:one 1}]</span><span class="w">
</span></code></pre></div></div>

<p>but it’s not recommended. Also, since the <code class="language-plaintext highlighter-rouge">Connection</code> object implements
<code class="language-plaintext highlighter-rouge">java.io.Closeable</code>, it’s possible to use it in <code class="language-plaintext highlighter-rouge">with-open</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">with-open</span><span class="w"> </span><span class="p">[</span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">pg/connect</span><span class="w"> </span><span class="n">config</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">pg/query</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"select 1 as one"</span><span class="p">))</span><span class="w">

</span><span class="c1">;; [{:one 1}]</span><span class="w">
</span></code></pre></div></div>


                    <p><a href="/en/pg-docs/02/">Read more &rarr;</a></p>
                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/en/pg-docs/01/">PG docs, part 1</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-08-28T00:00:00+00:00">
        Aug 28, 2023
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/postgres/" rel="tag">postgres</a>, <a href="/tag/sql/" rel="tag">sql</a>

</div>


            <div class="entry">
                
                    <p><em>TL;DR: I’m writing a Postgres driver in pure Clojure. In general, works! Now I
proceed with the most miserable part of the project: writing documentation. I
decided to do it step by step and share it on my blog.</em></p>

<p><strong>ToC</strong></p>

<ul>
  <li><a href="/en/pg-docs/01/">About &amp; Installation</a></li>
  <li><a href="/en/pg-docs/02/">The Client</a></li>
</ul>

<h2 id="about">About</h2>

<p><a href="https://github.com/igrishaev/pg">This project</a> is a set of libraries related to the <a href="https://www.postgresql.org/">PostgreSQL</a>
database. The primary library called <code class="language-plaintext highlighter-rouge">pg-client</code> is a driver for Postgres
written in pure Clojure. By purity I mean, neither JDBC nor any other
third-party Java libraries are involved. Everything is driven by a TCP socket
and implementation of the Posrgres Wire protocol. Fun!</p>

<p>Besides the client, the project provides such various additions as a connection
pool (see <code class="language-plaintext highlighter-rouge">pg-pool</code>). The <code class="language-plaintext highlighter-rouge">pg-types</code> library holds the encoding and decoding
logic which determines how to write and read Clojure data from and into the
database. You can use this library separately in pair with JDBC.next and <code class="language-plaintext highlighter-rouge">COPY</code>
for efficient data transcoding in binary format.</p>

<p>The question you would probably ask is, why would create a Postgres client from
scratch? JDBC has been around for decades, and there are also good
<code class="language-plaintext highlighter-rouge">clojure.java.jdbc</code> and <code class="language-plaintext highlighter-rouge">jdbc.next</code> wrappers on top of it?</p>

<p>The answer is: that although these two libraries are amazing, they don’t
disclose all Postgres features. JDBC is an abstraction whose main goal is to
satisfy all the DB engines. A general library that works with MS SQL, MySQL, and
Postgres at the same time would reduce the variety of features each backend is
capable of.</p>


                    <p><a href="/en/pg-docs/01/">Read more &rarr;</a></p>
                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/book2-anounce/">Анонс второй книги</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-08-01T00:00:00+00:00">
        Aug 1, 2023
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>

</div>


            <div class="entry">
                
                    <p><img src="/assets/static/aws/clj-book2/IMG_2527.jpeg" /></p>

<p>Вышел второй том “Сlojure на производстве” — продолжение первой книги. Без той
помпы, что в прошлый раз, когда я каждую неделю выкладывал апдейты, фото
черновиков и прочее. На всё это не хватает времени, плюс хочется меньше пафоса.</p>

<p>В книге три главы, черновые версии которых я выкладывал в блоге. Это
<a href="/clj-zippers-1/">зипперы</a>, <a href="/clj-jdbc-1/">базы данных</a> и
<a href="/clj-repl-part-1/">REPL</a>. Всё это можно прочесть здесь на сайте, но каждую
главу я многократно улучшил. Кроме банальных опечаток, изменилась структура, а
примеры стали убедительней.</p>

<p>Книжка выполнена в том же стиле и манере повествования. Текст чередуется с
кодом, каждый тезис подтверждается примером. Длинный код разбит на части с
пояснением, что происходит. Код “подсвечен” с помощью градаций серого и
начертания. Ссылки, коих много по тексту, вынесены в QR-коды на поля.</p>

<p>Твёрдая обложка, B5, 364 страницы. Форматы для мобильных устройств появятся
позже. Издано в ДМК-Пресс тиражом в 100 экземпляров. Двадцать из них — мои,
полученные в качестве гонорара, и я готов разослать их читателям.</p>

<p>Все подробности – где купить, открывок, галерея – указаны <a href="/clojure-in-prod-2/">на странице
книги</a>.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/node-js/">Node.js</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-28T00:00:00+00:00">
        Jul 28, 2023
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/javascript/" rel="tag">javascript</a>, <a href="/tag/vue/" rel="tag">vue</a>

</div>


            <div class="entry">
                
                    <p>Удивляюсь, до чего же хрупок этот Node.js. Месяц назад я делал фронт на Vue, и
настало время кое-что поправить. Обновляю пакеты, запускаю билд — сотня
ошибок. Мудрил так и сяк, пока коллега не сказал — удали node_modules и все
заработает.</p>

<p>Вот это “удали” меня поражает. Вместо того, чтобы решить корень проблемы, решают
симптомы. Подумаешь не работает! Просто начни с чистого листа. Ситуация КРИЧИТ о
системной проблеме, но никому нет дела. В платформу вливают огромные деньги, ей
пользуются миллионы, и никто не может это починить.</p>

<p>Была б моя воля, я бы посадил разработчиков Node.js за компы и сказал: чини, но
без удаления файлов. Найди источник проблемы и реши его. За удаление — пытка
током на месте. И тогда бы все починили.</p>

<p>Помню, была та же беда в проекте с React Native, только хуже. Проект перестал
собираться, и я по привычке удалил node_modules. Оказалось, в его недрах лежат
бинарники для устройства, которые генерируется на старте. При повторной
установке этот шаг пропускается, и где взять эти бинарники — неизвестно. На
StackOverflow так и пишут — перед удалением скопируй такие-то файлы в папочку,
иначе будешь плакать. Плакал я, конечно, уже после того, как это прочел.</p>

<p>Вы, наверное, подумали, что после удаления node_modules все заработало? Это было
бы слишком просто. Я получил другие непонятные ошибки, и коллега предположил,
что моя версия Node.js слишком высока. Проверили — да, у него 16, у меня 20. Но
ведь месяц назад все работало на версии 20! Мало того, что за месяц случились
такие изменения, так эти клоуны не оставили обратную совместимость! Не иначе как
цирком с клоунами эту ситуацию назвать нельзя.</p>

<p>В целом Node.js вызывает ощущение, что убираешь какашки за годовалым
ребенком. Те, у кого есть дети, знают, о чем я говорю. Когда делаешь это
постоянно, ощущения притупляются, и можно спокойно чистить говно, жуя
бутерброд. Разница в том, что к двум годам проблема с туалетом уходит, а с семи
лет ребенок уже поддерживает чистоту сам.</p>

<p>Node.js, напротив, обречен срать под себя как инвалид. Если через восемь лет за
ним нужно чистить какие-то папки, то, похоже, проблема не уйдет никогда. Бог с
ним, пусть живет как хочет. Но непонятно, зачем с этим работать, и что в голове
у людей, которые добровольно идут в разработку на Node.js.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/paysys/">Платежные системы</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-26T00:00:00+00:00">
        Jul 26, 2023
    </time>

    <a href="/tag/life/" rel="tag">life</a>, <a href="/tag/payment-systems/" rel="tag">payment-systems</a>

</div>


            <div class="entry">
                
                    <p>У платежных систем одна тонкость. Ты регистрируешься, подтверждаешь почту и
телефон, прикладываешь скан паспорта и селфи, крутишь головой перед камерой,
высылаешь все вплоть до анализов мочи — с тем, чтобы узнать: нужная функция
недоступна в твоей стране.</p>

<p>Конечно, недоступна временно. Подпишись и мы пришлем уведомление. Уже вот-вот,
буквально завтра.</p>

<p>Удалить аккаунт? Не можем: по такому-то закону данные хранятся пять лет, чтобы
выдать по требованию властей.</p>

<p>Уже сто раз такое было, но вот опять — потратил полчаса на отрытие PayPal в
другой стране, чтобы узнать, что там он ничего не умеет.</p>

<p>Регистрируясь в похожих системах, сперва нужно гуглить по словам “Service in
Country limitations”.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/cosplay/">Косплей</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-26T00:00:00+00:00">
        Jul 26, 2023
    </time>

    <a href="/tag/life/" rel="tag">life</a>, <a href="/tag/cosplay/" rel="tag">cosplay</a>

</div>


            <div class="entry">
                
                    <p>Почему-то люди не понимают: если нашел себе кумира, повторяй его поступки, а не
внешность и поведение. Потому что иначе выходит косплей — костюмированное шоу.</p>

<p>Если нравится Стив Джобс, сделай Айфон. Если Павел Дуров — сделай соцсеть с той
стеной, которую считаешь нужной. Если Лапенко — сними смешной ролик. Но не
повторяй внешность или стиль общения в интернете. Это ужасно.</p>

<p>Точто так же не стоит повторять стиль жизни. Не надо вставать в пять утра,
принимать контрастный душ, ходить босиком и медитировать. В мире полно людей,
которые медитируют и не едят мяса, но не достигли ничего.</p>

<p>Между великими людьми вообще нет связи. Все они были молодыми и старыми,
сатанистами и христианами, бабниками и девственниками. Связи нет никакой. Когда
кто-то читает десять правил знаменитости, я не понимаю — зачем? Ведь известность
из них не следует.</p>

<p>Доводилось видеть человека, который косплеил Дурова: челка, плащ до колен, все
черное, взгляд мимо камеры. Он делал стартап, и было забавно видеть его за
работой. Не знаю, чем кончилась его затея, но судя по всему — ничем.</p>

<p>Все это сказано цитатой о Стиве Джобсе. У Стива были две половины: одна —
редкостный засранец, вторая — редкостный гений. Из-за второй половины ему
прощали первую. Сегодня много людей косят под Стива, но у них получается первая
половина — засранца.</p>

<p>Начинайте со второй половины.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/as-x/">Как в X</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-26T00:00:00+00:00">
        Jul 26, 2023
    </time>

    <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/coding/" rel="tag">coding</a>

</div>


            <div class="entry">
                
                    <p>Совершенно ужасная вещь — писать на яыке X как в Y. Например, в Питоне как на
Хаскеле, а в JavaScript — как в Кложе. Придумать какие-нибудь “элегантные
объекты” и тыкать людям, что они живут неправильно.</p>

<p>Чемпионом в этой области является Питон. Из-за его гибкости на нем можно
косплеить любой язык — хоть Хаскел, хоть Кобол. Скажем, выражение ниже можно
сделать рабочим:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">items</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">...]</span>
</code></pre></div></div>

<p>Для этого пишут особый класс <code class="language-plaintext highlighter-rouge">List</code> с метаклассом, у которого реализован метод
<code class="language-plaintext highlighter-rouge">__getitem__</code>. В нем проверяется, что если второй элемент — класс <code class="language-plaintext highlighter-rouge">Ellipsis</code>, то
возвращается ленивый список от 1 до бесконечности.</p>

<p>Для Питона созданы сотни библиотек, которые косплеят другие языки — Хаскель,
Скалу и другие. Я тоже отметился: написал либу с <a href="https://github.com/igrishaev/f">лаконичным названием f</a>, где
собраны плюшки Кложи: стрелочные операторы, мультиметоды и всякие мелочи.</p>

<p>Все это замечательно, если бы не одна деталь: оно никому не сдалось. До перехода
в Кложу я работал с Питоном семь лет и ни разу не видел, чтобы использовались
функциональные поделки. Промышленные проекты на Питоне — это скучный ООП-код без
map/reduce, монад и алгебраических типов. В точности так, как это видит
создатель языка.</p>

<p>Точно так же в Кложе никто не использует монады. Уже в седьмой раз я устраиваюсь
кложуристом и не вижу их в проде (и это хорошо).</p>

<p>В текущем проекте на Кложе беда — его начинали люди, которые знали ее синтаксис,
но не идиомы. Другими словами, они знали, что вместо <code class="language-plaintext highlighter-rouge">1 + 2</code> надо писать <code class="language-plaintext highlighter-rouge">(+ 1 2)</code>,
но не знали, как устроить работу с базой, компоненты, тесты и окружение.</p>

<p>Кажется, это были рубисты. Я не держал свечку, но это сквозит в коде. Чуваки
написали свою ORM, которая матчит базу с REST — кривую и глючную. Для
конфигурации используют переменные среды, и это тоже треш и содомия. Компоненты
и система убоги. Позже в фирму пришли люди опытом на Кложе. Они либо обходят
легаси — ходят в базу напрямую, используют свои решения, — либо прибегают к нему
с легким отвращением.</p>

<p>Идиома “писать на X как в Y” — это проигрыш по определению. В любом виде. Это
билет в один конец, и он всегда одинаков. Вы пишете “как надо”, но потом
уходите, и другие с трудом приводят код в нужное русло. Не всегда удается
сделать это полностью — иной раз авгиевы конюшни столь полны, что переделывать
слишком дорого, и с этим как-то живут.</p>

<p>Легковестные агенты из Эрланга в Кложе. Элегантные объекты в Джаве. Монады
вместо исключений в Питоне. Да, интересно, да, ярко. Но бесполезно.</p>

<p>Если идеи по-настоящему сильны, их нужно выразить в новом языке. Не устраивает
чистый C — появляется C++. Не устраивают древние диалекты Лиспа — появляется
Кложа. Не нравится бородатый Эрланг — пишут Эликсир.</p>

<p>На любом языке надо писать так, как в нем принято. На Руби — как в Руби, а не в
Кложе. На Кложе — как принято в Кложе, а не в Руби.</p>

<p>Чем раньше это поймешь, тем скорее на тебя снизойдет благодать.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/3-hours/">Три часа</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-26T00:00:00+00:00">
        Jul 26, 2023
    </time>

    <a href="/tag/movies/" rel="tag">movies</a>, <a href="/tag/life/" rel="tag">life</a>

</div>


            <div class="entry">
                
                    <p>Хорошо, если бы режиссерам кто-нибудь объяснил: три часа для фильма — это много.</p>

<p>Что бы ты ни добавил, какой бы сюжет ни закрутил, какую бы графику ни навертел —
получится затянуто.</p>

<p>Все трехчасовые фильмы, на которые я ходил, были затянуты. <a href="/movies/">“Однажды в
Голливуде”</a> — затянуто, занудно. “Довод” — затянуто, занудно. Нелепые
сцены, ответвления сюжета. <a href="/avatar2/">Второй “Аватар”</a> — затянуто, одно да
потому.</p>

<p>На “Дюну” и что-то другое кассовое я не пошел, потому что научен опытом. Взяли
любимую игру детства и поставили в трейлер Pink Floyd — искушение было сильно,
но нет. Три часа — это знак, что режиссер не смог упокавать образы во что-то
емкое и решил проблему количеством, а не качеством.</p>

<p>Три часа — это чересчур для формата фильма. Полтора-два — в самый раз. Все, что
выше этого, второстепенно и отвлекает от главного.</p>

<p>Сейчас все кричат про Оппенгеймера, но три часа — увы, я пас. О жизни великого
человека можно рассказать и за полтора часа, а три-четыре снимайте для фанатов —
пусть смотрят режиссерскую версию отдельным сеансом.</p>

<p>Разбухшие фильмы — такая же проблема, как и разбухший софт. Почему об этой
проблеме не говорят — загадка.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/htmx/">HTMX</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-17T00:00:00+00:00">
        Jul 17, 2023
    </time>

    <a href="/tag/htmx/" rel="tag">HTMX</a>, <a href="/tag/web/" rel="tag">web</a>, <a href="/tag/frontend/" rel="tag">frontend</a>, <a href="/tag/ui/" rel="tag">ui</a>, <a href="/tag/react.js/" rel="tag">react.js</a>

</div>


            <div class="entry">
                
                    <p><em>Этот пост — попытка объединить заметки об HTMX в Телеграме во что-то
целостное. Написать статью о нем за один подход не вышло, поэтому пришлось по
частям.</em></p>

<p><a href="https://htmx.org/">HTMX</a> — это библиотека для серверного рендера HTML. От
современных React и Vue она отличается тем, что не хранит состояние на клиенте и
не занимается рендером на JavaScript. Она посылает запрос к серверу и получает
кусок HTML — в особых случаях несколько кусков, — которые вставляет в нужное
место DOM.</p>

<p>При всей примитивности этого подхода у него есть сторонники, и их число
растет. Я тоже склоняюсь к серверному рендеру и хочу написть о нем подробнее.</p>

<p>Htmx — не единственная в своей области библиотека. Есть еще HotWire, LiveView и
другие. Под HTMX я имею в виду не конкретную библиотеку, а серверный рендер в
принципе; просто HTMX звучит короче.</p>

<p><strong>Первая заметка</strong> об HTMX касалась числа запросов на сервер. Порой говорят: HTMX
требует больше запросов, потому что забирает состояние с сервера. А в
React-приложении ты выгреб состояние и хранишь на клиенте — улыбаешься.</p>

<p>Это неправда. Когда в HTMX открываешь диалог, происходит один — и только один —
запрос. Когда открывается диалог в приложении на Vue, происходит 14, — прописью,
четырнадцать — запросов. Буквально на днях я правил фронтенд по работе, и там
был именно такой случай. Цифры я взял какие есть, без преувеличений.</p>

<p>Другой пример: дашбоард сайта <a href="https://www.usemultiplier.com/">Use Multiplier</a>
совершает 235 запросов. Если отфильтровать по слову “graphql”, останется 35
запросов. Выходит, JavaScript-разработчикам нужно 35 сетевых сессий, чтобы
построить документ. Не многовато ли?</p>

<p>Что же выгодней: один запрос или их десятки?</p>

<p>В такие минуты искренне желаю, чтобы фронтендеров заменил HTMX. Они делают
интернет хуже: больше запросов, больше трафика, больше расход CPU, дольше время
ожидания. Таким разработчикам не место в профессии.</p>

<p><strong>Вторая мысль</strong> об HTMX такая: часто говорят, что это “хайп” (в кавычках,
потому что не люблю это слово). Очередная вещь, которая пройдёт зенит и уйдёт из
повестки.</p>

<p>Это не так. HTMX — это не очередная JS-поделка, снискавшая популярность. HTMX и
его аналоги — это протест. Отказ от того, что предлагает индустрия для
разработки приложений в браузере. Протест — по определению более сильная вещь,
чем хайп, потому что в его основе идея.</p>

<p>В этом году исполняется 10 лет с публикации исходного кода React.js. У Реакта и
аналогов было достаточно времени, чтобы показать себя. Результаты есть, но не
ошеломительные. Да, по сравнению с Backbone.js делать интерфейс стало проще,
однако рано или поздно все сводится к одному: проект тонет в каше из
компонентов, а состояние разбросано, как субстанция, попавшая на вентилятор.</p>

<p>Сейчас работаю с Vue, и чтобы добавить новый диалог, нужно поправить 18
файлов. Такая структура явно говорит о проблемах, но никого это не
волнует. Отрефакторить это невозможно, потому что поедет все. Только переписать
на новый фреймворк, что обязательно состоится, когда бизнес купят или команда
фронтендеров уйдет в полном составе.</p>

<p>За эти десять лет мы получили одно — возросшую сложность разработки. Современный
сайт обязательно содержит пачку npm-модулей, их сборщик, компоненты на React/Vue
и бог знает что еще. В каждой фирме эту кухню готовят по-разному; вся она
глючная и хрупкая.</p>

<p>Еще печальней, что фронтендеры, получив инструменты, не научились ими
пользоваться. Фронтам нужно 35 запросов Graphql на страницу; 14 запросов на
открытие диалога. Одна и та же сущность запрашивается по пять раз. Это полная
капитуляция, расписка непригодности разработчика. Если нужно 35 запросов на
страницу, в команде не думают о качестве, а просто закрывают тикеты. Это просто
данность.</p>

<p>За это время я видел только одну удобную обертку над React — это кложурный
re-frame. В нем скрыли острые углы Реакта и свели разработку к простому
принципу: база, подписка, событие. Просто настолько, что дальше уже
невозможно. Конечно, и на re-frame можно сделать проект неподдерживаемым, но
кривая сложности у него более покатая.</p>

<p>HTMX и его аналоги — это отказ от всего, описанного выше. Это отказ от хрупких
npm/js-артефактов. Это отказ от команды фронтендеров, которым платят 10-20 тысяч
долларов в месяц — на эту сумму можно купить тысячи машин в облаке. Это отказ от
сложности коммуникаций, когда бекенд выкатил фичу, а фронты доберутся до нее
через месяц. Это отказ от двух источников правды — сервера и состояния на
клиенте — в пользу одного. И много от чего другого отказ.</p>

<p>Поэтому я верю, что HTMX и схожие проекты с нами надолго. Эпоха Реакта и
реактивного интерфейса проходит. Результаты есть, но они обходятся слишком
дорого. Время нового подхода.</p>

<p><strong>Третья мысль</strong> об HTMX касается его роли в прошлом. Мысль о том, что HTMX
появился недавно и поэтому хайп — ошибочна. На самом деле серверный рендер
существует давно, и некоторые его используют. До сих пор о нём было мало
разговоров, потому что в центре внимания Реакт — и сумасшедшие деньги, которые
вливал в него производитель. Не только на зарплату разработчикам, но и
поддержку, связи с сообществом, конференции, митапы и прочее.</p>

<p>Серверный рендер по существу очень прост. Сервер выдает HTML, который
вставляется в нужное место DOM. Кустарная реализация занимает не более ста
строк, поэтому неудивительно, что серверный рендер тихо делает свою работу — без
кричащих статей на Hacker News, звезд на Гитхабе и остального.</p>

<p>Другое дело, что кустарное решение учитывает только свои нюансы, поэтому нужен
общий знаменатель. Так и появились проекты HTMX и аналоги.</p>

<p>Не каждый знает, что серверный рендер был одно время в Твиттере. Первые 20
твитов грузились как часть страницы, а при скролле выгребались куски HTML, в
которых были новые 20 твитов и так далее. Хорошо это помню, потому что у меня
был пет-проект по парсингу Твиттера. С HTML было относительно удобно: распарсил,
прошелся Xpath-селекторами и готово. Серверный рендер в Твиттере ввели после
того, как люди стали массово жаловаться на клиентский рендер — он был столь
ужасен, что пара вкладок раскручивала вентиляторы на полную.</p>

<p>Пользуясь случаем, скажем отдельное спасибо фронтендерам за это.</p>

<p>Кроме Твиттера, серверный рендер использовал ваш покорный слуга. Было это 13 лет
назад в Чите, в славной компании <a href="https://e-sbyt.ru/">ООО Энергосбыт</a>. Возле
моего кабинета стоял терминал для показа каких-то роликов. Я решил сделать из
него облегченную версию личного кабинета без авторизации. Вводишь лицевой счет и
номер квартиры и видишь задолженность и показания счетчиков. Можно передать
текущие показания. Принять деньги, увы, было нельзя из-за отсутствия
купюроприемника.</p>

<p>Интерфейс терминалов — это обычный Хром, запущенный с ключом <code class="language-plaintext highlighter-rouge">--kiosk</code> (по
крайней мере раньше он так назывался). В режиме киоска браузер растягивается на
весь экран, прячет курсор и противится попыткам свернуть его или открыть
системные менюшки. Беда в том, что если во время запроса обрывалась связь, Хром
показывал страницу “Oh no!” с диназавром, и нужно было нажать кнопку
“Обновить”. Сейчас Хром обновляет ее по таймауту, а тогда нет.</p>

<p>Ясное дело, я не мог бегать каждый час к терминалу смотреть, все ли с ним в
порядке. Нужно, чтобы все работало на аяксе, но одна мысль об этом бросала в
ужас. На дворе 2009 год, никаких реактов нет и в помине. jQuery в зените
популярности, развивается Backbone.js — попытка навертеть MVT-фреймворк поверх
jQuery. Окинув этот зоопарк, я решил задачу проще: на каждый запрос отвечал
куском HTML, который вставлялся в центральный элемент на странице. Это было
неоптимально, потому что в обновлении нуждались не все элементы, но разницы не
было.</p>

<p>В итоге я контролировал все на сервере, а клиент был минимально
прост. Разработка заняла неделю, и вскоре терминал стоял в самом проходном месте
города. Им пользовались, все было хорошо. Ради интереса представил разработку
сегодня: npm/yarn, React/Vue, папка node_modules, хрупкие сборки и конечно
компоненты, компоненты, компоненты. Команда фронтендеров, недели и месяцы
работы. Неподдерживаемый результат в конце, смена команды и переписывание.</p>

<p>Вот почему я уверен в своей правоте: я пробовал и знаю. Серверный рендер — это
просто и быстро. Да, есть недостатки, и порой без клиентского кода не
обойдешься. Но ни Реакт, ни Вуй даже близко не приблизились в плане скорости и
удобства к серверному рендеру.</p>

<p><strong>Четвертый пост</strong> об HTMX касается его не очевидных недостатков. Прочитав текст
выше, кто-то может решить, что HTMX — это избавление от всех бед фронтенда. К
сожалению, это не так. Ниже я перечислю, какие трудности вас ждут при переходе
на HTMX.</p>

<p>Прежде всего, HTMX не подходит крайне динамичным страницам — картам, редакторам
текста, играм. Их объединяет сложное состояние, которое меняется даже не клику,
а по движению курсора или прокрутке. Опрашивать сервер с такой частотой будет
тяжело, хотя и возможно: в HTMX есть поддержка веб-сокетов. Всё зависит от
условий задачи, но для сложного состояния HTMX будет скорее проблемой.</p>

<p>Второй момент — с HTMX усложняется серверный рендер. Раньше вы отдавали данные
клиенту, а как он их выводил, вас не касалось. А теперь вы за это в ответе.</p>

<p>Предположим, вы достали из базы число покупок пользователя. Чтобы вывести фразу
“У вас X покупок”, нужно учесть случаи:</p>

<ul>
  <li>
    <p>X равно нулю или NULL, и тогда фраза будет “у вас нет покупок”;</p>
  </li>
  <li>
    <p>учесть множественность: “1 покупка” и “N покупок”;</p>
  </li>
  <li>
    <p>для второго случая учесть склонения: “3 покупки, 5 покупок, 21 покупка”.</p>
  </li>
</ul>

<p>Нужно писать функции, таблицы склонений, стемминг и остальное. Что-то есть в
библиотеках, но без их адаптации не обойтись.</p>

<p>Еще интересней даты и форматы чисел, валют. Раньше ты выплюнул JSON с Unix
timestamp, и остальное тебя не касается. А теперь, перед тем как рендерить,
нужно узнать локаль пользователя — из запроса, кук или сессии — и передать ее во
все подобные функции. Это усложняет процесс.</p>

<p>Положа руку на сердце, гораздо удобней отдать JSON, не заморачиваясь с
рендером. Но потом, когда фронтендер уйдет или заболеет, ты полезешь в его код и
увидишь, какой же там ад. И что лучше бы это был серверный рендер.</p>

<p>HTMX усложняет обработку ошибок. Если что-то пошло не так, нужно вывести
сообщение внутри элемента или в отдельной области при помощи техники OOB — out
of boundaries. Это когда сервер возвращает несколько HTML-элементов, и они
вставляются в разные места страницы. Кроме того, можно задать реакцию на
неудачный AJAX-запрос на уровне библиотеки. Я не буду подробно все расписывать,
скажу лишь, что об обработке ошибок в HTMX нужно думать с самого начала и
придерживаться одного подхода. Иначе будет разброд и шатание.</p>

<p>Тесты. Одно дело тестировать JSON, другое – HTML. Его нужно парсить, обходить
проблемы склонений и форматов, применять рекулярки и XPath. Все это менее
удобно, чем данные в JSON. Схемы – ваш лучший друг в случае с JSON, а какие
схемы могут быть в HTML?</p>

<p>Последний и наиболее важный недостаток — это двойной API. Как правило, бекенд
предоставляет апишку не только сайту, но и мобильному приложению и третьим
фирмам. Удобно, когда бекенд — это чистое API, и все это понимают.</p>

<p>Теперь вы приходите к начальству с предложением сделать HTMX-апишку для
серверного рендера. А зачем? — спросит начальство. На бекенде у нас
REST/GraphQL, пусть сайт и ходит к нему через API. Этот довод почти невозможно
проломить, потому что все сходится: бекенд общается с миром через JSON, у каждой
платформы свой клиент. Что можно ответить?</p>

<p>Пожалуй, то, что команда фрондендеров дорогая, а их труд тяжело
поддерживать. Скажем, чтобы сделать динамический сайт, кроме дизайнера нужно как
минимум два фронтендера: один идет вперед, другой чинит баги. В случае с
бекендом достаточно одного человека, который бы поддерживал HTMX-апишку. Это и
дешевле, и надежней, потому что бекенд покрыт тестами и не такой хрупкий.</p>

<p>Поэтому не в каждой фирме дадут добро на серверный рендер. Протащить его в прод
— та еще задача.</p>

<p><strong>Пятая заметка</strong> об HTMX касается важного момента — источника правды. Должно
быть, после недостатков серверного рендера кто-то приуныл. Чтобы восстановить
баланс, поговорим о решающем плюсе HTMX, который не видно на первый взгляд.</p>

<p>Для начала вспомним React и Vue. Сильно упрощая, можно сказать, что их работа
сводится к следующему. Мы переносим состояние с сервера на клиент и показываем в
браузере. В теории нам не нужно беспокоится от отрисовке: реактивные фреймворки
делают это за нас, когда мы изменяем состояние.</p>

<p>Звучит хорошо, но таким образом мы завязаны на состоянии. Каждый, кто немного
программировал, знает, что самое сложное — контролировать состояние. Поэтому так
популярны Advent of Code и похожие задачи: для программистов это своего рода
отдых. В них почти нет состояния: тебе дают одну структуру данных, и ее нужно
переколбасить в другую. Нет базы, Кафки, Редиса и всего этого.</p>

<p>Задачи из AoC решают на растах-хаскелях, потому что писать на них чистые
преобразования — почти физическое удовольствие. Но приходит утро, и программист
идет на работу, где его ждут кровавые Джава и Питон.</p>

<p>Так вот, состояние на клиенте влечет сложность уже самим появлением. За ним
нужно следить и синхронизировать его с сервером. Если вам кажется это простым,
вы ошибаетесь. Бывает, сервер не может вернуть данные в одном запросе, и нужно
слать их несколько. Бывает, одни и те же данные нужны компонентам А и Б, но их
писали разные люди, и одинаковые запросы идут параллельно без проверки на
дублирование. Последее я вижу постоянно: одну и ту же сущность выгребают по пять
раз просто потому, что она нужна всем, а разработчики не договорились.</p>

<p>Давно я читал в интернете: отдайте клиенту его данные, и пусть делает что
хочет. Это не работает хотя бы из-за размера данных. Представим, вы активно
пишете на каком-нибудь Твиттере или StackOverflow. За три года у вас скопилось
10 тысяч заметок. Вы хотите вывалить их клиенту при загрузке страницы? А заодно
его друзей, рекомендации и прочее?</p>

<p>Хорошо, будем выгружать порциями по 100 штук. Выгрузили — сохранили на клиенте —
отрисовали. Спрашивается, почему эту цепочку нельзя сократить — нарисовать без
сохранения? Ведь состояние быстро протухает: написал комментарий, поскроллил,
сменил фильтры, критерии сортировки, и все — пора лезть на сервер за новыми
данными.</p>

<p>Все это мартышкин труд. Вы никогда не угадаете, что конкретно нужно клиенту в
текущий момент. Выгружать все — дорого и долго. Остается запрашивать данные
точечно: последние 10 статей, последние 50 комментариев. А если порции данных
небольшие, зачем их хранить, если можно просто показать? Так мы уберем
состояние, из-за которого одни сложности.</p>

<p>Ликвидация состояния — важный шаг вперед: управлять клиентом становится
проще. Помните аналогию с Advent of Code и функциональными языками? С HTMX я
испытал похожие чувства. Да, оказывается, так можно: отдаешь HTML, который без
какого-либо состояния отображается на клиенте.</p>

<p>Резюмируя, можно сказать, что HTMX сводится к одному плюсу — ликвидации
состояния на клиенте. Пусть каждый решает сам, но для меня это самое важное. Нет
состояния — берем. Ради этой фичи я согласен на все минусы, о которых сказал
раньше.</p>

<p><strong>Шестая заметка</strong> об HTMX касается дизайна. Возможно, кто-то решил, что HTMX —
это когда фронтендеров увольняют, а суровые бекендеры берут дизайн в свои руки —
с предсказуемым результатом. Может, где-то практикуют подобное, но я это не
одобряю, и вот почему.</p>

<p>Действительно, многим фронтендерам нужно дать пинка под зад. Например за то, что
заставляют браузеры жечь трафик и процессор почем зря. Как мы выяснили, чтобы
страница была динамичной, чаще всего фронтендер не нужен — можно вернуть HTML с
сервера и вставить в DOM. Но остается вопрос с дизайном.</p>

<p>В компании должен быть человек, отвечающий за дизайн всего: не только сайта, но
и логотипа, буклетов, визиток и остального. Кто-то думает, что дизайн — это
верстка в программе, но это не так. Дизайн — это точка, где клиент соприкасается
с продуктом, и дизайнер отвечает за эту точку в целом.</p>

<p>В компаниях, где процесс налажен правильно, он протекает так. Дизайнер делает
макет в Фигме или иной программе. В ней указаны состояния страницы и сценарии
перехода. Например, при нажатии на кнопку “добавить в корзину” четко указано,
какие элементы изменятся и на что.</p>

<p>Верстальщик или фронтендер (в классическом понимании этого слова) переносит
дизайн в статичный HTML. Если это продвинутый верстальщик, он вынесет изменяемые
элементы в отдельные файлы, которые импортируются шаблонной системой вроде
Jinja2. Получается набор статичных страниц, но у каждой из них есть структура.</p>

<p>Бекендеры принимают нарезанный HTML и оживляют его на сервере. При этом им
запрещена любая отсебятина. Если бизнес-процесс не вписывается в дизайн, все
трое — дищайнер, верстальщик, бекендер — собираются и решают, что
исправить. Исправления вносятся во все три источника: дизайн, верстку, бекенд.</p>

<p>При таком подходе принцип HTMX остается в силе. Бекендеры не выдумывают дизайн
на ходу, они действуют в рамках, которые ставит им дизайнер. Верстальщик служит
промежуточным звеном между дизайном и его реализацией на бекенде.</p>

<p>В грамотных фирмах есть процесс сдачи сайта дизайнеру. Сайт не выкатят в прод,
пока дизайнер не убедится, что верстальщик перенес дизайн в HTML без ошибок, а
программисты оживили его без косяков.</p>

<p>Так был устроен процесс в Wargaming, где я когда-то работал. И хотя там были
свои косяки, мне кажется он единственно верным. Что ещё в нем хорошего — он не
привязан к конкретным технологиям, и HTMX отлично на него ложится.</p>

                
            </div>

        </li>
        
        <li>

            <h2>
                <a class="post-link" href="/hdmi/">HDMI в тренде</a>
            </h2>

            
<div class="post-meta">

    <time class="post-time"
          datetime="2023-07-14T00:00:00+00:00">
        Jul 14, 2023
    </time>

    <a href="/tag/hdmi/" rel="tag">hdmi</a>, <a href="/tag/tv/" rel="tag">tv</a>

</div>


            <div class="entry">
                
                    <p><img src="/assets/static/aws/hdmi/1.jpeg" /></p>

<p>Раз в полгода телевизор докладывает, что сегодня в тренде… порт HDMI 1. При
этом ни в один из HDMI портов ничего не воткнуто. Откуда он это берет? Неужели
настоящие данные, собранные с устройств — люди играют в приставки, смотрят
пиратки с ноутбуков?</p>

<p>Этот порт, как говорит телевизор, “недавно в…”. Очень полезные сведения. Еще
бы понять, что значит “в…”. Калека-дизайнер оставил квадрат пустым, а на текст
выделил сотую часть. Не влезло, но ничего: обрежем и добавим многоточие.</p>

<p>Забавно, как текут абстракции: в понимании телевизора порт HDMI — это
приложение, поэтому участвует в трендах. Напоминает одну игру, где можно было
чинить лошадь гаечным ключом. А что, транспорт, значит можно чинить.</p>

<p>Проблема “умных” вещей в том, что они пытаются быть умнее, чем есть на самом
деле. Нет-нет и вылезет какая-то тупизна, от которой нет слов. Только вздохнёшь
и идёшь дальше.</p>

                
            </div>

        </li>
        
    </ul>

    <h4>
        
        <span class="page_number ">Страница 1 из 64</span>
        
        <a href="/page2" class="next">&rarr;</a>
        
    </h4>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
