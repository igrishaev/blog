<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Реляционные базы данных в Clojure</title>
  <meta name="description" content="    Содержание">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-db/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img id="avatar" src="/assets/static/avatar.jpg" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod-2/">Книга «Clojure на производстве», второй том</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Реляционные базы данных в Clojure</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2021-10-13T00:00:00+00:00">
        Oct 13, 2021
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/databases/" rel="tag">databases</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<h2>

    Содержание

</h2>

<ul id="toc-item-pg-to-datomic">
  <li><a href="#реляционные-базы-данных" id="toc-item-pg-to-datomic-реляционные-базы-данных">Реляционные базы данных</a>    <ul>
      <li><a href="#запросы" id="toc-item-pg-to-datomic-запросы">Запросы</a></li>
      <li><a href="#доступ-из-clojure" id="toc-item-pg-to-datomic-доступ-из-clojure">Доступ из Clojure</a></li>
      <li><a href="#знакомство-с-clojurejavajdbc" id="toc-item-pg-to-datomic-знакомство-с-clojurejavajdbc">Знакомство с clojure.java.jdbc</a></li>
      <li><a href="#основы-clojurejavajdbc" id="toc-item-pg-to-datomic-основы-clojurejavajdbc">Основы clojure.java.jdbc</a>        <ul>
          <li><a href="#чтение" id="toc-item-pg-to-datomic-чтение">Чтение</a></li>
          <li><a href="#вставка" id="toc-item-pg-to-datomic-вставка">Вставка</a></li>
          <li><a href="#обновление" id="toc-item-pg-to-datomic-обновление">Обновление</a></li>
          <li><a href="#удаление" id="toc-item-pg-to-datomic-удаление">Удаление</a></li>
          <li><a href="#выполнение" id="toc-item-pg-to-datomic-выполнение">Выполнение</a></li>
          <li><a href="#практика" id="toc-item-pg-to-datomic-практика">Практика</a></li>
        </ul>
      </li>
      <li><a href="#подробнее-о-запросах" id="toc-item-pg-to-datomic-подробнее-о-запросах">Подробнее о запросах</a>        <ul>
          <li><a href="#sql-инъекции" id="toc-item-pg-to-datomic-sql-инъекции">SQL-инъекции</a></li>
          <li><a href="#атаки-с-union" id="toc-item-pg-to-datomic-атаки-с-union">Атаки с UNION</a></li>
          <li><a href="#кавычки" id="toc-item-pg-to-datomic-кавычки">Кавычки</a></li>
          <li><a href="#подготовленные-выражения" id="toc-item-pg-to-datomic-подготовленные-выражения">Подготовленные выражения</a></li>
        </ul>
      </li>
      <li><a href="#результат-запроса" id="toc-item-pg-to-datomic-результат-запроса">Результат запроса</a>        <ul>
          <li><a href="#массивы" id="toc-item-pg-to-datomic-массивы">Массивы</a></li>
          <li><a href="#ключи" id="toc-item-pg-to-datomic-ключи">Ключи</a></li>
          <li><a href="#ленивость" id="toc-item-pg-to-datomic-ленивость">Ленивость</a></li>
        </ul>
      </li>
      <li><a href="#транзакции" id="toc-item-pg-to-datomic-транзакции">Транзакции</a></li>
      <li><a href="#jdbc-спека-с-состоянием" id="toc-item-pg-to-datomic-jdbc-спека-с-состоянием">JDBC-спека с состоянием</a>        <ul>
          <li><a href="#пул-соединений" id="toc-item-pg-to-datomic-пул-соединений">Пул соединений</a></li>
        </ul>
      </li>
      <li><a href="#sqlite" id="toc-item-pg-to-datomic-sqlite">SQLite</a>        <ul>
          <li><a href="#база-в-памяти" id="toc-item-pg-to-datomic-база-в-памяти">База в памяти</a></li>
        </ul>
      </li>
      <li><a href="#сложные-типы" id="toc-item-pg-to-datomic-сложные-типы">Сложные типы</a>        <ul>
          <li><a href="#организация-кода" id="toc-item-pg-to-datomic-организация-кода">Организация кода</a></li>
          <li><a href="#поддержка-json" id="toc-item-pg-to-datomic-поддержка-json">Поддержка JSON</a></li>
          <li><a href="#запись-json" id="toc-item-pg-to-datomic-запись-json">Запись JSON</a></li>
          <li><a href="#проблема-nil-в-json" id="toc-item-pg-to-datomic-проблема-nil-в-json">Проблема nil в JSON</a></li>
          <li><a href="#типизированные-записи" id="toc-item-pg-to-datomic-типизированные-записи">Типизированные записи</a></li>
        </ul>
      </li>
      <li><a href="#проблемы-sql" id="toc-item-pg-to-datomic-проблемы-sql">Проблемы SQL</a>        <ul>
          <li><a href="#шаблоны" id="toc-item-pg-to-datomic-шаблоны">Шаблоны</a></li>
          <li><a href="#выражения" id="toc-item-pg-to-datomic-выражения">Выражения</a></li>
          <li><a href="#построители" id="toc-item-pg-to-datomic-построители">Построители</a></li>
          <li><a href="#служебные-функции" id="toc-item-pg-to-datomic-служебные-функции">Служебные функции</a></li>
          <li><a href="#логирование-и-форматирование" id="toc-item-pg-to-datomic-логирование-и-форматирование">Логирование и форматирование</a></li>
          <li><a href="#расширения" id="toc-item-pg-to-datomic-расширения">Расширения</a></li>
          <li><a href="#сырой-sql" id="toc-item-pg-to-datomic-сырой-sql">Сырой SQL</a></li>
          <li><a href="#повторное-использование-запросов" id="toc-item-pg-to-datomic-повторное-использование-запросов">Повторное использование запросов</a></li>
          <li><a href="#аналоги" id="toc-item-pg-to-datomic-аналоги">Аналоги</a></li>
          <li><a href="#промежуточный-итог" id="toc-item-pg-to-datomic-промежуточный-итог">Промежуточный итог</a></li>
        </ul>
      </li>
      <li><a href="#структура-и-группировка" id="toc-item-pg-to-datomic-структура-и-группировка">Структура и группировка</a>        <ul>
          <li><a href="#выборка-по-слоям" id="toc-item-pg-to-datomic-выборка-по-слоям">Выборка по слоям</a></li>
          <li><a href="#ручная-группировка" id="toc-item-pg-to-datomic-ручная-группировка">Ручная группировка</a></li>
          <li><a href="#порядок-записей" id="toc-item-pg-to-datomic-порядок-записей">Порядок записей</a></li>
          <li><a href="#итог" id="toc-item-pg-to-datomic-итог">Итог</a></li>
        </ul>
      </li>
      <li><a href="#группировка-в-базе" id="toc-item-pg-to-datomic-группировка-в-базе">Группировка в базе</a></li>
      <li><a href="#миграции" id="toc-item-pg-to-datomic-миграции">Миграции</a>        <ul>
          <li><a href="#migratus" id="toc-item-pg-to-datomic-migratus">Migratus</a></li>
          <li><a href="#несколько-запросов-в-миграции" id="toc-item-pg-to-datomic-несколько-запросов-в-миграции">Несколько запросов в миграции</a></li>
          <li><a href="#миграции-с-профилями" id="toc-item-pg-to-datomic-миграции-с-профилями">Миграции с профилями</a></li>
          <li><a href="#параметры-подключения" id="toc-item-pg-to-datomic-параметры-подключения">Параметры подключения</a></li>
          <li><a href="#миграции-в-коде" id="toc-item-pg-to-datomic-миграции-в-коде">Миграции в коде</a></li>
          <li><a href="#программные-миграции" id="toc-item-pg-to-datomic-программные-миграции">Программные миграции</a></li>
          <li><a href="#ragtime" id="toc-item-pg-to-datomic-ragtime">Ragtime</a></li>
        </ul>
      </li>
      <li><a href="#nextjdbc" id="toc-item-pg-to-datomic-nextjdbc">Next.JDBC</a></li>
      <li><a href="#заключение" id="toc-item-pg-to-datomic-заключение">Заключение</a></li>
    </ul>
  </li>
</ul>

<h1 id="реляционные-базы-данных">Реляционные базы данных</h1>

<p><em>В этой главе мы поговорим о том, как работать с реляционными базами данных в Clojure. Бóльшую часть описания займет библиотека clojure.java.jdbc и дополнения к ней. Вы узнаете, какие проблемы встречаются в этой области и как их решают в Clojure.</em></p>

<p>В бекенд-разработке базы данных занимают центральное место. Если говорить упрощенно, то любая программа сводится к обработке данных. Конечно, они поступают не только из баз, но и сети и файлов. Однако в целом за доступ к информации отвечают именно базы данных — специальные программы, сложные, но с богатыми возможностями.</p>

<p>Базы данных, или сокращенно БД, бывают разных видов. Они различаются в архитектуре, способе хранения информации, типом связи с клиентом. Некоторые базы работают только на клиенте, то есть в рамках одного компьютера. Другие хранят только текст и оставляют типы на усмотрение клиента. Встречаются базы, где данные хранятся в оперативной памяти и пропадают после выключения.</p>

<p>Мы не ставим цель охватить как можно больше баз и способов работы с ними. Наоборот, сфокусируем внимание на том, что встретит вас в реальном проекте. Скорей всего это будет классическая реляционная база данных вроде PostgreSQL или MySQL. О них мы и будем говорить.</p>

<p>Реляционные базы данных называют так из за модели <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0">реляционной алгебры</a>. Это изящная математическая модель с набором операций, например выборкой, проекцией, декартовым произведением и другими. Из модели следуют строгие правила о том, как работает та или иная операция. Поэтому базы данных работают не спонтанно, а по четким алгебраическим правилам. Из этих правил следуют <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0">нормальные формы</a> (первая, вторая и третья), доказать которые можно аналитически, а не на глаз.</p>

<p>Мы будем учить реляционную алгебру с самых азов. Обратитесь к статье в Википедии или книгам, где она описана без привязки к конкретной БД.</p>

<p>Перейдем к понятиям, более привычным программисту. Базы хранят содержимое в таблицах. Запись в таблице называется кортежем и состоит из отдельных полей. Поля могут быть разного типа. Состав полей и их порядок одинаков в рамках таблицы. Не может быть так, что в первой записи два поля, а во второй три. Если нужно указать, что в поле нет значения, в него пишут специальное пустое, чаще всего NULL.</p>

<!-- more -->

<p>У записи есть особое поле, которое называют первичным ключом, Primary key. Ключ однозначно указывает запись в таблице. Не может быть двух записей с одинаковым ключом. Чаще всего роль ключа играет число с автонумерацией, но иногда это строка, например электронная почта или артикул товара.</p>

<p>В редких случаях ключ может быть составным, то есть определяться парой полей, например тип платежной системы и номер платежа. В этом случае мы допускаем, что в таблице могут быть несколько платежей от Stripe с разными номерами или платежи от Stripe и AppStore с одинаковым номером, но не то и другое вместе.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> gateway   | trx_no |
-----------+---------
 stripe    | 1      | ;; ok
 stripe    | 2      | ;; ok
 appstore  | 2      | ;; ok
 appstore  | 2      | ;; error
</code></pre></div></div>

<p>Внешним ключом называется поле, которые ссылается на первичный ключ другой таблицы. Для краткости его называют ссылкой (ref). Примером может быть поле <code class="language-plaintext highlighter-rouge">user_id</code> таблицы профилей, которое указывает на поле <code class="language-plaintext highlighter-rouge">id</code> таблицы пользователей.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">users</span><span class="p">(</span>
    <span class="n">id</span>   <span class="nb">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">profiles</span><span class="p">(</span>
    <span class="n">id</span>      <span class="nb">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">user_id</span> <span class="nb">integer</span> <span class="k">not</span> <span class="k">null</span> <span class="k">references</span> <span class="n">users</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="n">avatar</span>  <span class="nb">text</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Ссылка отличается от числа особыми свойствами: она гарантирует, что указанный пользователь действительно существует. Обычное число этой гарантии не дает. Говорят, что ссылки поддерживают целостность базы. Целостность означает, в базе нет ссылок на несуществующие записи.</p>

<p>Кроме целостности, внешний ключ поддерживает реакцию на удаление. По умолчанию нельзя удалить сущность, на которую кто-то ссылается. Однако можно задать правило, что связанная сущность тоже удаляется. Так, при удалении пользователя удалится и его профиль, ведь он не нужен в отрыве от пользователя. В другом случае ссылка на удаленную сущность станет NULL, если это разрешено в свойствах поля.</p>

<p>Из университета мы знаем, что связи бывают разных типов: один к одному или многим, многие ко многим. Профиль, который ссылается на пользователя — это связь один к одному. Несколько заказов у пользователя — один ко многим. Тип связи легко задать ограничением на поле ссылки. Если в таблице профилей сделать поле <code class="language-plaintext highlighter-rouge">user_id</code> уникальным, не получится создать два профиля одному пользователю. Связь “многие ко многим” строят через таблицу-мост со ссылками на другие таблицы. Чтобы сущности нельзя было соединить несколько раз, применяют составной первичный ключ из ссылок.</p>

<h2 id="запросы">Запросы</h2>

<p>База данных обращается с миром через <a href="https://en.wikipedia.org/wiki/SQL">SQL</a> (Structured Query Language) — структурированный язык запросов. Это текст, который описывает наши намерения — прочитать таблицу, добавить запись, обновить поле. Запросы имеют четкую структуру, которая чаще всего зависит от главного оператора. К ним относятся <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code> и другие команды.</p>

<p>Существуют несколько стандартов SQL, обозначенных годами, когда они были приняты: SQL’92, ‘99, ‘2003 и другие. Каждая база данных поддерживает стандарт определенного года включая предыдущие. Кроме стандарта базы предлагают расширения — возможности, которые не входят в него. При чтении документации обращайте внимание на но, относится ли конкретная возможность к стандарту или же это частное решение.</p>

<p>В аббревиатуре SQL последняя буква означает language, язык. Однако это не язык программирования, потому что на нем нельзя выразить алгоритм задачи. Говоря точнее, SQL не полон по Тьюрингу: вы не сможете построить SQL-выражение на нем самом. Поэтому сложные запросы строят при помощи полноценных (полных по Тьюрингу) языков, например Java, Python, Clojure.</p>

<p>Некоторые базы данных предлагают встроенные языки и операторы, чтобы это исправить. Так, в PostgreSQL доступен <a href="https://www.postgresql.org/docs/current/sql-do.html">блок DO</a>, где работают переменные, циклы и даже перехват исключений. Но это частное решение, которое не входит в стандарт.</p>

<h2 id="доступ-из-clojure">Доступ из Clojure</h2>

<p>Теперь когда мы освежили теорию, перейдем к практике — Clojure. По умолчанию язык не предлагает доступа к базам данных. Чтобы работать с ними, подключают библиотеку clojure.java.jdbc — тонкую обертку над JDBC. Так называется встроенный в Java пакет для реляционных баз данных.</p>

<p><a href="https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html">JDBC</a> (Java Database Connectivity) отсчитывает свой возраст с 1997 года. Главная задача JDBC — предоставить общий API для разных баз. Для этого JDBC устроен из нескольких слоев. Потребители используют общий API, который, в зависимости от типа базы, вызывает разные драйверы.</p>

<p>Драйверы служат для связи JDBC с бекендом. Каждый из них реализует бинарный протокол, по которому работает база. На сегодняшний день JDBC поддерживает все известные реляционные СУБД: PostgreSQL, MySQL, Oracle, SQLite и другие. Существуют драйверы для файловых хранилищ, например Excel, DBF, CSV.</p>

<p>Для работы с какой-либо базой вам понадобится драйвер к ней. Драйверы поставляются отдельно и должны быть объявлены в зависимостях проекта. JDBC автоматически находит и подключает драйвер; программисту не нужно заботиться об этом.</p>

<p>Перечислим основные сущности JDBC:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">DriverManager</code> — класс для управления драйвером конкретной БД. Получает соединение с базой, по которому в дальнейшем идет обмен данными.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PreparedStatement</code> — подготовленное выражение. Так называется запрос, который прошел стадию подготовки в базе и теперь может быть вызван с разными параметрами.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ResultSet</code> — источник, из которого читают результат запроса. Обычно приходит из метода <code class="language-plaintext highlighter-rouge">executeQuery</code> подготовленного выражения.</p>
  </li>
</ul>

<p>Следующий код на Java показывает, как подключиться к базе, выбрать записи из таблицы и вывести на экран. Задача сводится к созданию указанных классов и вызову их методов:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.sql.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JDBCExample</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">DB_URL</span> <span class="o">=</span> <span class="s">"jdbc:postgresql://127.0.0.1/test"</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">USER</span> <span class="o">=</span> <span class="s">"book"</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">PASS</span> <span class="o">=</span> <span class="s">"book"</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">QUERY</span> <span class="o">=</span> <span class="s">"SELECT * FROM users"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">{</span>

            <span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="no">DB_URL</span><span class="o">,</span> <span class="no">USER</span><span class="o">,</span> <span class="no">PASS</span><span class="o">);</span>
            <span class="nc">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">createStatement</span><span class="o">();</span>
            <span class="nc">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="no">QUERY</span><span class="o">);</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ID: "</span> <span class="o">+</span> <span class="n">rs</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="s">"id"</span><span class="o">));</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"First name: "</span> <span class="o">+</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"fname"</span><span class="o">));</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Last name: "</span> <span class="o">+</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"lname"</span><span class="o">));</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Email: "</span> <span class="o">+</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"email"</span><span class="o">));</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Age: "</span> <span class="o">+</span> <span class="n">rs</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="s">"age"</span><span class="o">));</span>
            <span class="o">}</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>В идеале при смене базы код остается прежним, а меняется только синтаксис SQL. И хотя это верно лишь отчасти, JDBC решает основную задачу — предлагает единый доступ к разным бекендам.</p>

<p>Похожий стандарт существует и в других языках, например в Python. Там он называется <a href="https://www.python.org/dev/peps/pep-0249/">DB API</a>. Его задача — обозначить минимальный набор правил, которым должен следовать драйвер. С этим требованием легче писать общий код для разных баз.</p>

<h2 id="знакомство-с-clojurejavajdbc">Знакомство с clojure.java.jdbc</h2>

<p>Из примера на Java видно, что даже простой запрос требует многих строк кода. В Clojure принято упрощать рутину, и библиотека <a href="https://github.com/clojure/java.jdbc">clojure.java.jdbc</a> создана именно для этого. Она создает тонкую обертку вокруг классов <code class="language-plaintext highlighter-rouge">DriverManager</code>, <code class="language-plaintext highlighter-rouge">PreparedStatement</code> и других, чтобы получить результат буквально парой строк. Добавьте библиотеку и драйвер PostgreSQL в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; project.clj</span><span class="w">
</span><span class="p">[</span><span class="n">org.clojure/java.jdbc</span><span class="w"> </span><span class="s">"0.7.8"</span><span class="p">]</span><span class="w">
</span><span class="p">[</span><span class="n">org.postgresql/postgresql</span><span class="w"> </span><span class="s">"42.1.3"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Предположим, сервер PostgreSQL развернут локально. Вот как выполнить в нему запрос:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgresql"</span><span class="w">
         </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"test"</span><span class="w">
         </span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
         </span><span class="no">:user</span><span class="w"> </span><span class="s">"book"</span><span class="w">
         </span><span class="no">:password</span><span class="w"> </span><span class="s">"book"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select 1 as value"</span><span class="p">)</span><span class="w">

</span><span class="p">({</span><span class="no">:value</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Мы объявили параметры подключения и передали в функцию <code class="language-plaintext highlighter-rouge">jdbc/query</code>. Запрос возвращает постоянное число, поэтому он сработает, даже если в базе нет таблиц.</p>

<p>Пока мы не ушли вперед, разберем, что произошло. Переменная <code class="language-plaintext highlighter-rouge">db</code> называется JDBC-спекой. Это словарь с различными полями: хостом, портом, пользователем и другими. Из него библиотека библиотека получает соединение с базой. По завершении запроса соединение закрывается. JDBC-спека принимает разные формы, и позже мы рассмотрим их.</p>

<p>Зависимость <code class="language-plaintext highlighter-rouge">[org.postgresql/postgresql "42.1.3"]</code> нужна для работы с PostgreSQL. Ее драйвер находится в репозитории Maven. Чтобы не распылять внимание на разные базы, остановим выбор на PostgreSQL до конца главы. В пользу PostgreSQL говорит зрелость и мощь проекта, его открытый код и бесплатный доступ. В России действует официальный вендор <a href="https://postgrespro.ru/">PostgresPro</a>. Их силами созданы полезные расширения, переведена документация на русский язык.</p>

<p>Тот факт, что мы используем именно PostgreSQL, JDBC поймет из поля <code class="language-plaintext highlighter-rouge">dbtype</code> со значением “postgresql”. Он автоматически загрузит драйвер, так что импортировать его в Clojure не нужно.</p>

<p>Чтобы запрос выполнился, должен работать локальный сервер PostgreSQL. Наиболее быстрый способ запустить его с нужными настройками — вызывать одноименный Docker-образ. Следующая команда:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-e</span> <span class="nv">POSTGRES_PASSWORD</span><span class="o">=</span>pass postgres
</code></pre></div></div>

<p>запустит сервер на локальном порту 5432. Имя базы, пользователь и пароль определяются переменными окружения; в примере выше пароль к базе будет “pass”. Запуск этого образа мы обсуждали в прошлой книге о Clojure, а именно в четвертой и седьмой главах. В случае трудностей изучите примеры оттуда.</p>

<p>Если все настроено правильно и вы увидели результат <code class="language-plaintext highlighter-rouge">jdbc/query</code>, примите поздравления. Первый этап пройден, и вы готовы двигаться дальше.</p>

<h2 id="основы-clojurejavajdbc">Основы clojure.java.jdbc</h2>

<p>Библиотека предлагает несколько функций для работы с базой. Рассмотрим наиболее важные из них.</p>

<h3 id="чтение">Чтение</h3>

<p>Чаще всего в коде используют <code class="language-plaintext highlighter-rouge">query</code> – функцию, которая выполняет запрос и возвращает результат. Она принимает jdbc-спеку и запрос. Последний может быть либо строкой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>, либо вектором, где первый элемент — запрос с подстановками, а остальные элементы — параметры. Подобную запись называют SQL-вектором.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from users where id = ?"</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Знаки вопроса означают подстановку; позже параметры становятся на их место. Ниже мы узнаем, в чем разница между значением в запросе и параметром. Кроме запроса, <code class="language-plaintext highlighter-rouge">query</code> принимает параметр, который указывает, как обработать результат. Эти тонкости мы тоже обсудим позже.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">get-by-id</code> предлагает быстрый доступ к записи по первичному ключу. Она ожидает имя таблицы и значение ключа. Например, если в таблице <code class="language-plaintext highlighter-rouge">users</code> первичный ключ называется <code class="language-plaintext highlighter-rouge">id</code>, то чтобы получить первого пользователя, выполним:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/get-by-id</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="s">"John"</span><span class="n">,</span><span class="w"> </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Smith"</span><span class="n">,</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="n">,</span><span class="w"> </span><span class="no">:age</span><span class="w"> </span><span class="mi">25</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Функция вернет либо одну запись, либо <code class="language-plaintext highlighter-rouge">nil</code>. Это важное отличие от <code class="language-plaintext highlighter-rouge">query</code>, результат которой всегда коллекция, в том числе для одной записи.</p>

<p>По умолчанию <code class="language-plaintext highlighter-rouge">get-by-id</code> считает, что первичный ключ называется <code class="language-plaintext highlighter-rouge">id</code>. Если это не так, укажите  его имя после значения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/get-by-id</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"account_id"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">find-by-keys</code> выполняет отбор по нескольким полям. Предположим, мы хотим выбрать пользователей с именем John и возрастом 25 лет. Для этого укажем в <code class="language-plaintext highlighter-rouge">find-by-keys</code> имя таблицы и словарь вида {поле =&gt; значение}:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/find-by-keys</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="no">:age</span><span class="w"> </span><span class="mi">25</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>База выполнит запрос:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span> <span class="k">WHERE</span> <span class="n">fname</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="k">AND</span> <span class="n">age</span> <span class="o">=</span> <span class="err">$</span><span class="mi">2</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'John'</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="s1">'25'</span>
</code></pre></div></div>

<p>Функция принимает любое число полей в словаре. Они соединяются оператором <code class="language-plaintext highlighter-rouge">AND</code>, потому что это наиболее частый случай. Для более тонкого отбора, например с помощью <code class="language-plaintext highlighter-rouge">OR</code>, функция не подойдет. Что делать в этом случае мы рассмотрим позже.</p>

<p>Заметим, что <code class="language-plaintext highlighter-rouge">find-by-keys</code> вернет список, даже если нашлась только одна запись. В некоторых случаях мы намеренно ищем только первую. Заведем функцию <code class="language-plaintext highlighter-rouge">find-first</code> с теми же аргументами, которая оборачивает результат в <code class="language-plaintext highlighter-rouge">first</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">find-first</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">filters</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/find-by-keys</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">filters</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>В этом случае результат будет либо первой записью, либо <code class="language-plaintext highlighter-rouge">nil</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">find-first</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="no">:age</span><span class="w"> </span><span class="mi">25</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="s">"John"</span><span class="n">,</span><span class="w"> </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Smith"</span><span class="n">,</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="n">,</span><span class="w"> </span><span class="no">:age</span><span class="w"> </span><span class="mi">25</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Это не оптимальное решение, потому что запрос к базе не содержит оператора <code class="language-plaintext highlighter-rouge">limit 1</code>. Без него база вернет все записи, лишние из которых отбрасываются на стороне Clojure. Доработайте <code class="language-plaintext highlighter-rouge">find-first</code> так, чтобы база возвращала одну запись силами SQL.</p>

<h3 id="вставка">Вставка</h3>

<p>Функция <code class="language-plaintext highlighter-rouge">insert!</code> добавляет запись в таблицу. Восклицательный знак на конце означает, что вызов меняет состояние. <code class="language-plaintext highlighter-rouge">Insert!</code> принимает таблицу, в которую происходит запись. Значения могут быть переданы в разном виде. Наиболее частый сценарий — словарь вида {поле =&gt; значение}, например:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
                         </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w">
                         </span><span class="no">:email</span><span class="w"> </span><span class="s">"ivan@test.com"</span><span class="w">
                         </span><span class="no">:age</span><span class="w"> </span><span class="mi">87</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Во втором варианте функция принимает списки полей и значений по отдельности. Их длины должны быть равны:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w">
              </span><span class="p">[</span><span class="no">:fname</span><span class="w"> </span><span class="no">:lname</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="no">:age</span><span class="p">]</span><span class="w">
              </span><span class="p">[</span><span class="s">"Andy"</span><span class="w"> </span><span class="s">"Stone"</span><span class="w"> </span><span class="s">"andy@test.com"</span><span class="w"> </span><span class="mi">33</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Оба вызова сводятся к подобному запросу:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="p">(</span> <span class="n">fname</span><span class="p">,</span> <span class="n">lname</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">age</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span><span class="p">,</span> <span class="err">$</span><span class="mi">4</span> <span class="p">)</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'Andy'</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="s1">'Stone'</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span> <span class="o">=</span> <span class="s1">'andy@test.com'</span><span class="p">,</span> <span class="err">$</span><span class="mi">4</span> <span class="o">=</span> <span class="s1">'33'</span>
</code></pre></div></div>

<p>Результат <code class="language-plaintext highlighter-rouge">insert!</code> отличается от типа базы. Большинство отвечает на <code class="language-plaintext highlighter-rouge">INSERT</code> списком первичных ключей, которые появились в результате вставки. Имена ключей тоже отличаются. MySQL вернет набор записей с полем <code class="language-plaintext highlighter-rouge">generated_key</code>. PostgreSQL вернет запись целиком из-за оператора <code class="language-plaintext highlighter-rouge">RETURNING *</code>. Драйвер JDBC добавит его в конец запроса автоматически.</p>

<p>Хотя <code class="language-plaintext highlighter-rouge">insert!</code> работает только с одной записью, он не оборачивает результат в <code class="language-plaintext highlighter-rouge">first</code>. В итоге вы получите список с одним словарем. Если новый ключ нужен для дальнейших действий, добраться до него можно так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">get-pk</span><span class="w">
      </span><span class="p">(</span><span class="nf">some-fn</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="no">:generated_key</span><span class="p">)</span><span class="w">

      </span><span class="n">fields</span><span class="w">
      </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
       </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w">
       </span><span class="no">:email</span><span class="w"> </span><span class="s">"ivan@test.com"</span><span class="w">
       </span><span class="no">:age</span><span class="w"> </span><span class="mi">87</span><span class="p">}</span><span class="w">

      </span><span class="n">db-result</span><span class="w">
      </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="n">fields</span><span class="p">)]</span><span class="w">

  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">db-result</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="n">get-pk</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h3 id="обновление">Обновление</h3>

<p>Функция <code class="language-plaintext highlighter-rouge">update!</code> обновляет таблицу. Она принимает JDBC-спеку, имя таблицы, словарь полей и <code class="language-plaintext highlighter-rouge">WHERE</code>-часть. Рассмотрим пример:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/update!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:age</span><span class="w"> </span><span class="mi">50</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="s">"id = ?"</span><span class="w"> </span><span class="mi">7</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Словарь <code class="language-plaintext highlighter-rouge">{:age 50}</code> означает новые значения полей. Их может быть больше одного, например, вместе с возрастом мы решили обновить имя и почту. Последний параметр функции — SQL-вектор, который будет добавлен к запросу после оператора <code class="language-plaintext highlighter-rouge">WHERE</code>. В примере выше <code class="language-plaintext highlighter-rouge">update!</code> порождает следующий запрос:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">users</span> <span class="k">SET</span> <span class="n">age</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="err">$</span><span class="mi">2</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'50'</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="s1">'7'</span>
</code></pre></div></div>

<p>В векторе может быть несколько условий, соединенных с помощью <code class="language-plaintext highlighter-rouge">AND</code> или <code class="language-plaintext highlighter-rouge">OR</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/update!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="s">"id = ? OR id = ?"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Что равнозначно:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">users</span> <span class="k">SET</span> <span class="n">email</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="err">$</span><span class="mi">2</span> <span class="k">OR</span> <span class="n">id</span> <span class="o">=</span> <span class="err">$</span><span class="mi">3</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'test@test.com'</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="s1">'1'</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span> <span class="o">=</span> <span class="s1">'3'</span>
</code></pre></div></div>

<p>SQL-вектор для <code class="language-plaintext highlighter-rouge">WHERE</code> обязательный: функцию нельзя вызвать без условия. Возникает вопрос, как выполнить <code class="language-plaintext highlighter-rouge">UPDATE</code> для всей таблицы? Редко, но случается, что мы хотим обновить все записи. Для этого передают вектор <code class="language-plaintext highlighter-rouge">["true"]</code>, что означает истину для каждой записи.</p>

<p>Предположим, в таблице пользователей создали колонку с признаком активности:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">is_active</span> <span class="nb">BOOLEAN</span> <span class="k">DEFAULT</span> <span class="k">false</span><span class="p">;</span>
</code></pre></div></div>

<p>Чтобы выставить истину всем пользователям, выполним:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/update!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:is_active</span><span class="w"> </span><span class="n">true</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="s">"true"</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Что равносильно:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">users</span> <span class="k">SET</span> <span class="n">is_active</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="k">WHERE</span> <span class="k">true</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'t'</span>
</code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">update!</code> возвращает список с одним числом. Оно означает число записей, которые были обновлены. Полезно добавить это число в лог:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">num-updated</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">jdbc/update!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:is_active</span><span class="w"> </span><span class="n">true</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="s">"true"</span><span class="p">])]</span><span class="w">
  </span><span class="p">(</span><span class="nf">log/infof</span><span class="w"> </span><span class="s">"%s records updated"</span><span class="w"> </span><span class="n">num-updated</span><span class="p">))</span><span class="w">

</span><span class="c1">;; 2021-07-05 09:47:19,581 INFO  my.module - 11 records updated</span><span class="w">
</span></code></pre></div></div>

<h3 id="удаление">Удаление</h3>

<p>Функция <code class="language-plaintext highlighter-rouge">delete!</code> удаляет записи из таблицы. Ее сигнатура похожа на <code class="language-plaintext highlighter-rouge">update!</code>: параметры подключения, имя таблицы и <code class="language-plaintext highlighter-rouge">WHERE</code>-часть. Вот как удалить пользователей старше 50 лет:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/delete!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">[</span><span class="s">"age &gt;= ?"</span><span class="w"> </span><span class="mi">50</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Итоговый запрос:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">users</span> <span class="k">WHERE</span> <span class="n">age</span> <span class="o">&gt;=</span> <span class="err">$</span><span class="mi">1</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'50'</span>
</code></pre></div></div>

<p>По аналогии с <code class="language-plaintext highlighter-rouge">update!</code>, в <code class="language-plaintext highlighter-rouge">WHERE</code> могут быть сложные условия с <code class="language-plaintext highlighter-rouge">AND</code> или <code class="language-plaintext highlighter-rouge">OR</code>. Результат функции — число удаленных записей.</p>

<h3 id="выполнение">Выполнение</h3>

<p>Еще одна важная функция называется <code class="language-plaintext highlighter-rouge">execute!</code>. Она выполняет любой запрос, отличный от <code class="language-plaintext highlighter-rouge">SELECT</code>. Особенность <code class="language-plaintext highlighter-rouge">SELECT</code> в том, что он возвращает результат, который нужно прочитать и обработать. Функция <code class="language-plaintext highlighter-rouge">execute!</code>, напротив, выполняет команду без чтения результата.</p>

<p>На роль команды без результата подходит создание индекса. Добавим индекс в таблицу пользователей по имени:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"create index users_fname on users(fname);"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Затем удалим его:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"drop index users_fname;"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Другой пример — очистить таблицы после прогона тестов. Специальная команда <code class="language-plaintext highlighter-rouge">TRUNCATE</code> делает это эффективней <code class="language-plaintext highlighter-rouge">DELETE</code>. Она учитывает несколько таблиц за раз и каскадную очистку: все таблицы, что ссылаются на перечисленные, тоже очищаются.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"truncate users cascade;"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Еще один сценарий для <code class="language-plaintext highlighter-rouge">execute!</code> — временно отключить триггеры на время тестов или миграций. Предположим, мы завели триггер на обновление пользователей. Чтобы не вызывать его в тестах, напишем фикстуру <code class="language-plaintext highlighter-rouge">:once</code>, которая отключит триггер перед прогоном:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"ALTER TABLE users DISABLE TRIGGER on_users_update"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>, а затем включит такой же командой с параметром <code class="language-plaintext highlighter-rouge">ENABLE</code>.</p>

<h3 id="практика">Практика</h3>

<p>Выше мы разобрали базовые CRUD-операции (Create, Read, Update, Delete) и служебную функцию <code class="language-plaintext highlighter-rouge">execute!</code>. Вместе они покрывают бóльшую часть задач, которые ждут вас производстве. Перед тем как идти вперед, отложите книгу и позанимайтесь, чтобы закрепить знания.</p>

<p>Создайте проект и подключите к нему библиотеку <code class="language-plaintext highlighter-rouge">clojure.java.jdbc</code>. Настройте локальную базу данных (в Docker или нативно) и подключитесь к ней. Создайте простую таблицу и опробуйте изученные действия: вставку, выборку, поиск, обновление, удаление. Добавьте индекс на некоторые поля. Проделайте все из Clojure, не прибегая к утилитам вроде pgAdmin, DataGrip и другим.</p>

<h2 id="подробнее-о-запросах">Подробнее о запросах</h2>

<p>Выше мы упоминали, что функция <code class="language-plaintext highlighter-rouge">query</code> принимает либо строку запроса, либо вектор с параметрами. Разберемся, в чем разница между подходами.</p>

<p>Представим, что нужно найти пользователя по известному <code class="language-plaintext highlighter-rouge">id</code>, например 13. Приведем варианты со строкой и вектором. В первом выражении значение 13 “вшито” в запрос, а во втором выступает параметром.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users where id = 13"</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from users where id = ?"</span><span class="w"> </span><span class="mi">13</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p><strong>Строгое правило:</strong> если запрос зависит от внешних условий, используйте второй вариант с параметрами. Подставлять значение в строку функциями <code class="language-plaintext highlighter-rouge">format</code> или <code class="language-plaintext highlighter-rouge">str</code> считается грубой ошибкой и влечет риски. На это есть две причины: SQL-инъекции и подготовленные выражения. Обе важны и нуждаются в объяснении.</p>

<h3 id="sql-инъекции">SQL-инъекции</h3>

<p>Инъекцией называют случай, когда в запрос попадает вредоносный текст. Это возможно при ручной подстановке параметров в шаблон. Пик инъекций пришелся на середину нулевых годов в эпоху расцвета PHP. Новый язык резко сократил порог входа в веб-разработку, и ей занялись в том числе те, кто не имел представлений о безопасности. В PHP типичный запрос выглядит так (пример взят из интернета):</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$user_id</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
<span class="nv">$query</span> <span class="o">=</span> <span class="nb">sprintf</span><span class="p">(</span><span class="s2">"SELECT * FROM users WHERE id = %s"</span><span class="p">,</span> <span class="nv">$user_id</span><span class="p">);</span>
<span class="nv">$result</span> <span class="o">=</span> <span class="nb">mysql_query</span><span class="p">(</span><span class="nv">$query</span><span class="p">);</span>
</code></pre></div></div>

<p>Разберемся, в чем проблема с выражением выше. Для начала перепишем его на Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user-id</span><span class="w"> </span><span class="mi">13</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"select * from users where id = %s"</span><span class="w"> </span><span class="n">user-id</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>До тех пор, пока в <code class="language-plaintext highlighter-rouge">user-id</code> находится число, запрос работает без ошибок. Но что если параметр приходит из адресной строки браузера? Предположим, кто-то исправил URL следующим образом:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://site.com/users?user-id=13+OR+TRUE
</code></pre></div></div>

<p>Хакер понимает, что перед 13 идет выражение <code class="language-plaintext highlighter-rouge">WHERE id = ...</code>. Идея в том, чтобы через оператор <code class="language-plaintext highlighter-rouge">OR</code> добавить условие, которое истинно всегда, например TRUE или 1=1. В результате даже если первое выражение ложно, второе будет истиной. Оператор OR сделает выбор в пользу второго, и запись попадет в выборку. В результате база вернет все записи таблицы без фильтра по <code class="language-plaintext highlighter-rouge">id</code>. Так вы раскроете чужие данные.</p>

<p>Изменим <code class="language-plaintext highlighter-rouge">user-id</code> на вредоносную строку и выполним запрос с форматированием. Получим все записи таблицы <code class="language-plaintext highlighter-rouge">users</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user-id</span><span class="w"> </span><span class="s">"13 OR TRUE"</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w">
  </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"select * from users where id = %s"</span><span class="w"> </span><span class="n">user-id</span><span class="p">))</span><span class="w">

</span><span class="c1">;; ({:id 1, ...}, {:id 2, ...}, ...)</span><span class="w">
</span></code></pre></div></div>

<p>В интернете популярен <a href="https://xkcd.com/327/">комикс xkcd</a> об SQL-инъекциях. Учитель спрашивает родителя, почему они назвали сына <code class="language-plaintext highlighter-rouge">Robert'; DROP TABLE students;</code>. Легко догадаться, что на сервере был следующий код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">fname</span><span class="w"> </span><span class="s">"Robert"</span><span class="w">
      </span><span class="n">query</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"select * from users where fname = '"</span><span class="w"> </span><span class="n">fname</span><span class="w"> </span><span class="s">"'"</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">query</span><span class="p">))</span><span class="w">

</span><span class="c1">;; select * from users where fname = 'Robert';</span><span class="w">
</span></code></pre></div></div>

<p>Если задать переменной <code class="language-plaintext highlighter-rouge">fname</code> то, что вписал в поле Роберт:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">fname</span><span class="w"> </span><span class="s">"Robert'; DROP TABLE users;--"</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>, запрос примет вид:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">fname</span> <span class="o">=</span> <span class="s1">'Robert'</span><span class="p">;</span> <span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">users</span><span class="p">;</span><span class="c1">--'</span>
</code></pre></div></div>

<p>Обратите внимание на двойной минус в конце. Он нужен для того, чтобы закомментировать последнюю одинарную кавычку. База данных отбросит ее и получит два запроса через точку с запятой. Если выполнить это выражение, сработает поиск по имени Robert, а затем из таблицы <code class="language-plaintext highlighter-rouge">users</code> удалятся все записи. Опробуйте трюк на локальной базе.</p>

<h3 id="атаки-с-union">Атаки с UNION</h3>

<p>Главная задача хакера не в том, чтобы удалить данные — их легко восстановить из резервной копии. Его цель — заполучить данные, к которым нет доступа. Рассмотрим тот же пример с поиском пользователя. На этот раз вместо <code class="language-plaintext highlighter-rouge">DROP TABLE</code> мы напишем другой вредоносный SQL, а именно объединение запроса с таким же, но без отбора. Для этого служит оператор <code class="language-plaintext highlighter-rouge">UNION</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">fname</span><span class="w"> </span><span class="s">"Robert' UNION select * from users--"</span><span class="w">
      </span><span class="n">query</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"select * from users where fname = '"</span><span class="w"> </span><span class="n">fname</span><span class="w"> </span><span class="s">"'"</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">query</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Результат:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">fname</span> <span class="o">=</span> <span class="s1">'Robert'</span> <span class="k">UNION</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span><span class="c1">--'</span>
</code></pre></div></div>

<p>Итоговый запрос вернет всех пользователей независимо от того, сколько их нашлось в первой части. Конечно, для подобных атак нужно знать структуру таблицы. Однако и эти данные можно получить SQL-инъекцией, добавив <code class="language-plaintext highlighter-rouge">UNION</code> с таблицами <code class="language-plaintext highlighter-rouge">information_schema.tables</code>, <code class="language-plaintext highlighter-rouge">pg_user</code> и другими. Таблицы из схемы <code class="language-plaintext highlighter-rouge">information_schema</code> хранят метаданные о других таблицах: их имена, состав и типы колонок. Если хакер доберется до этих сведений через инъекции, он узнает о базе все.</p>

<h3 id="кавычки">Кавычки</h3>

<p>Даже если переменная приходит от надежного источника, вы не застрахованы от проблем с кавычками. Например, библиотекарь добавляет книгу “Д’Артаньян и три мушкетёра”. На клавиатуре нет знака апострофа, поэтому после буквы Д сотрудник поставит верхнюю одинарную кавычку. В большинстве баз данных она служит для строковых литералов. При форматировании такой строки вы получите ошибку синтаксиса:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">book</span><span class="w"> </span><span class="s">"Д'Артаньян и три мушкетёра"</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">sql</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"insert into books (title) values ('%s')"</span><span class="w"> </span><span class="n">book</span><span class="p">))</span><span class="w">

</span><span class="c1">;; insert into books (title) values ('Д'Артаньян и три мушкетёра')</span><span class="w">
</span></code></pre></div></div>

<p>С точки зрения SQL строка заканчивается после Д, и дальше идет что-то ошибочное.</p>

<p>Подстановка параметров сводит на нет эти угрозы. Прежде всего JDBC следит за их типом. Если мы ожидаем поиск по числовому ID, то при передаче строки получим ошибку даже если строка содержит цифру. При этом ошибка возникнет до того, как запрос уйдет в базу:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from users where id = ?"</span><span class="w"> </span><span class="s">"1"</span><span class="p">])</span><span class="w">


</span><span class="n">Execution</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">(</span><span class="nf">PSQLException</span><span class="p">)</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">org.postgresql.core.v3.QueryExecutorImpl/receiveErrorResponse</span><span class="w"> </span><span class="p">(</span><span class="nf">QueryExecutorImpl.java</span><span class="no">:2476</span><span class="p">)</span><span class="nb">.</span><span class="w">
</span><span class="n">ERROR</span><span class="err">:</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="nb">not</span><span class="w"> </span><span class="n">exist</span><span class="err">:</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">character</span><span class="w"> </span><span class="n">varying</span><span class="w">
  </span><span class="n">Hint</span><span class="err">:</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="n">matches</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">types.</span><span class="w"> </span><span class="n">You</span><span class="w"> </span><span class="n">might</span><span class="w"> </span><span class="n">need</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">explicit</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">casts.</span><span class="w">
  </span><span class="n">Position</span><span class="err">:</span><span class="w"> </span><span class="mi">30</span><span class="w">
</span></code></pre></div></div>

<p>При подстановке строки драйвер экранирует опасные символы. В PostgreSQL для этого служит одинарная кавычка. Вот как безопасно выбрать из базы всех Д’Артаньянов (обратите внимание на двойную кавычку в параметре <code class="language-plaintext highlighter-rouge">$1</code>):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from users where fname = ?"</span><span class="w"> </span><span class="s">"Д'Артаньян"</span><span class="p">])</span><span class="w">

</span><span class="c1">;; select * from users where fname = $1</span><span class="w">
</span><span class="c1">;; parameters: $1 = 'Д''Артаньян'</span><span class="w">
</span></code></pre></div></div>

<p>Важно, что параметры доступны не в любом месте запроса. Например, нельзя задать параметром имя таблицы или состав полей. Поэтому запрос:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from ?"</span><span class="w"> </span><span class="s">"users"</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>не сработает из-за ошибки синтаксиса. А если вы хотите задать имена полей параметрами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select ?, ?, ? from users"</span><span class="w"> </span><span class="s">"id"</span><span class="w"> </span><span class="s">"fname"</span><span class="w"> </span><span class="s">"email"</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>, то вас ждет разочарование. Запрос вернет строки “id”, “fname” и “email”, а не значения одноименных полей. Чтобы строить запросы, где таблицы и поля зависят от условий, прибегают к специальным библиотекам. Позже мы рассмотрим наиболее популярные из них.</p>

<h3 id="подготовленные-выражения">Подготовленные выражения</h3>

<p>Вторая причина в пользу параметров в том, с ними база получит выигрыш в скорости. Следует помнить, что даже простой запрос выполняется поэтапно. Процесс напоминает компиляцию: выражение разбирают на лексемы и строят дерево. Например, строка <code class="language-plaintext highlighter-rouge">3 + 2 * 2</code> после разбора станет списком <code class="language-plaintext highlighter-rouge">(+ 3 (* 2 2))</code>, который проще выполнить благодаря структуре.</p>

<p>База данных тоже выполняет разбор и анализ запроса. На выходе получается так называемое Prepared Statement, подготовленное выражение. Это объектное представление запроса, который прошел анализ и теперь может быть выполнен. Предположим, поступил запрос на поиск пользователя по <code class="language-plaintext highlighter-rouge">id</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Схематично представим его в виде дерева на Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">:select</span><span class="w">
 </span><span class="no">:tables</span><span class="w"> </span><span class="p">[</span><span class="no">:users</span><span class="p">]</span><span class="w">
 </span><span class="no">:fields</span><span class="w"> </span><span class="p">[</span><span class="no">:id</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="no">:lname</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="no">:age</span><span class="p">]</span><span class="w">
 </span><span class="no">:where</span><span class="w"> </span><span class="p">[[</span><span class="no">:=</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="n">?</span><span class="p">]]</span><span class="w">
 </span><span class="no">:params</span><span class="w"> </span><span class="p">[</span><span class="no">:integer</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Смысловые части запроса разложены по полям. Обратите внимание, что вместо звёздочки следует явный список полей. Известно число параметров и их тип. Осталось вызвать подготовленное выражение с конкретным ID, чтобы получить результат.</p>

<p>Из структуры выше понятно, почему таблица не может быть параметром. Если бы она менялась динамически, пришлось бы каждый раз вычислять набор полей и их тип, что рушит идею Prepared Statement — сделать это единожды. Наоборот, подстановка чисел 5, 15 или 99 на место <code class="language-plaintext highlighter-rouge">id</code> не влечет перестройку выражения.</p>

<p>Покажем, как работать с подготовленными выражениями в Clojure. Чтобы создать его, вызывают функцию <code class="language-plaintext highlighter-rouge">jdbc/prepare-statement</code>. Первым параметром она ожидает открытое TCP-соединение с базой. Соединение получают функцией <code class="language-plaintext highlighter-rouge">jdbc/get-connection</code> из JDBC-спеки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/get-connection</span><span class="w"> </span><span class="n">db</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">prep-stmt</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/prepare-statement</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"select * from users where id = ?"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Второй аргумент <code class="language-plaintext highlighter-rouge">jdbc/prepare-statement</code> — произвольный запрос со знаками вопроса на месте параметров. В переменной <code class="language-plaintext highlighter-rouge">prep-stmt</code> окажется объект с типом <code class="language-plaintext highlighter-rouge">PreparedStatement</code>. Чтобы выполнить его, передайте в <code class="language-plaintext highlighter-rouge">jdbc/query</code> вектор, где первый элемент — подготовленное выражение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="n">prep-stmt</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>По аналогии напишем выражение для вставки пользователя и выполним его через <code class="language-plaintext highlighter-rouge">execute!</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">stmt-insert</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/prepare-statement</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"insert into users (fname, lname, age, email) values (?, ?, ?, ?)"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="n">stmt-insert</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="s">"Smith"</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s">"john@test.com"</span><span class="p">])</span><span class="w">
</span><span class="c1">;; (1)</span><span class="w">
</span></code></pre></div></div>

<p>Подготовленные выражения несут состояние, поэтому их нельзя объявлять на верхнем уровне модуля. Выражения адаптируют под систему, на которой основан проект. Если это Component, объявляют компонент, который зависит от базы. При запуске компонент создает выражения и записывает в слоты, а в момент остановки закрывает их.</p>

<p>Напишем подобный компонент. Для экономии места заполним только одно выражение для поиска пользователя по номеру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">UserManager</span><span class="w">
    </span><span class="p">[</span><span class="n">db</span><span class="w">
     </span><span class="n">conn</span><span class="w">
     </span><span class="n">stmt-get-by-id</span><span class="p">]</span><span class="w">

  </span><span class="n">component/Lifecycle</span><span class="w">

  </span><span class="p">(</span><span class="nf">start</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/get-connection</span><span class="w"> </span><span class="n">db</span><span class="p">)</span><span class="w">

          </span><span class="n">stmt-get-by-id</span><span class="w">
          </span><span class="p">(</span><span class="nf">jdbc/prepare-statement</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"select * from users where id = ?"</span><span class="p">)]</span><span class="w">

      </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w">
             </span><span class="no">:conn</span><span class="w"> </span><span class="n">conn</span><span class="w">
             </span><span class="no">:stmt-get-by-id</span><span class="w"> </span><span class="n">stmt-get-by-id</span><span class="p">)))</span><span class="w">

  </span><span class="p">(</span><span class="nf">stop</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="n">stmt-get-by-id</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Добавим протокол для действий с пользователями. Пока что в нем один метод поиска по ID:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defprotocol</span><span class="w"> </span><span class="n">IUserManager</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-by-id</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">id</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Расширим тип <code class="language-plaintext highlighter-rouge">UserManager</code> этим протоколом. В теле <code class="language-plaintext highlighter-rouge">get-by-id</code> вызываем функцию <code class="language-plaintext highlighter-rouge">jdbc/query</code>, при этом соединение и подготовленное выражение приходят из слотов записи.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IUserManager</span><span class="w">

</span><span class="p">(</span><span class="nf">get-by-id</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">[</span><span class="n">stmt-get-by-id</span><span class="w"> </span><span class="n">id</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>Компонент в действии:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user-mgr</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="n">db</span><span class="p">}</span><span class="w">
      </span><span class="n">map-&gt;UserManager</span><span class="w">
      </span><span class="n">component/start</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">get-by-id</span><span class="w"> </span><span class="n">user-mgr</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">get-by-id</span><span class="w"> </span><span class="n">user-mgr</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Запросы, выполненные через подготовленные выражения, работают быстрее обычных, потому что не требуют разбора. Для нагруженных проектов это может оказаться критично.</p>

<h2 id="результат-запроса">Результат запроса</h2>

<p>Рассмотрим, что предлагает библиотека для работы с ответом. По умолчанию функция <code class="language-plaintext highlighter-rouge">query</code> возвращает последовательность словарей. Структура каждого словаря одинакова: его ключи — поля выборки, приведенные к типу <code class="language-plaintext highlighter-rouge">Keyword</code>, а значения — то, что пришло для этого поля из базы. Пример с пользователями:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users"</span><span class="p">)</span><span class="w">

</span><span class="p">({</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
  </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w">
  </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
  </span><span class="no">:age</span><span class="w"> </span><span class="mi">42</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="no">:fname</span><span class="w"> </span><span class="s">"John"</span><span class="w">
  </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Smith"</span><span class="w">
  </span><span class="no">:email</span><span class="w"> </span><span class="s">"john@test.com"</span><span class="w">
  </span><span class="no">:age</span><span class="w"> </span><span class="mi">20</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">jdbc/query</code> оборачивает результат <code class="language-plaintext highlighter-rouge">ResultSet</code> в функцию <code class="language-plaintext highlighter-rouge">jdbc/result-set-seq</code>. Последняя приводит его к ленивой коллекции “кложурных” значений. Поскольку список словарей — наиболее удобная структура, именно этот способ задан по умолчанию. В особых случаях поведение <code class="language-plaintext highlighter-rouge">query</code> меняют так, чтобы получить данные в другом виде. Но прежде чем мы узнаем, как это сделать, вспомним, как устроен объект <code class="language-plaintext highlighter-rouge">ResultSet</code>.</p>

<p>Этот класс напоминает источник данных со внутренним указателем. По умолчанию указатель находится <em>до</em> первого элемента. У <code class="language-plaintext highlighter-rouge">ResultSet</code> несколько методов, чтобы сдвигать его, но самый простой называется <code class="language-plaintext highlighter-rouge">.next()</code>. Результат метода означает, удался ли сдвиг или нет (получим ложь, если достигли конца). Обход <code class="language-plaintext highlighter-rouge">ResultSet</code> сводится к шаблону:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">while</span><span class="w"> </span><span class="p">(</span><span class="nf">.next</span><span class="w"> </span><span class="n">rs</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">.getInt</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="s">"id"</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">.getString</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="s">"fname"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Методы <code class="language-plaintext highlighter-rouge">getInt</code>, <code class="language-plaintext highlighter-rouge">getString</code> и другие вернут значения поля по его имени (если вызваны со строкой) или индексу (с числом).</p>

<p>Так как указатель стоит до первого элемента, начальный вызов <code class="language-plaintext highlighter-rouge">.next</code> сдвигает его на первый. Это существенно упрощает код. Если бы указатель сразу стоял на первом элементе, пришлось бы обработать его до входа в цикл, а потом скопировать тот же код внутрь цикла, что выглядит неуклюже:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">.getInt</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="s">"id"</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">.getString</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="s">"fname"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">while</span><span class="w"> </span><span class="p">(</span><span class="nf">.next</span><span class="w"> </span><span class="n">rs</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">.getInt</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="s">"id"</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">.getString</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="s">"fname"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Методы <code class="language-plaintext highlighter-rouge">getInt</code> и <code class="language-plaintext highlighter-rouge">getString</code> выше говорят о том, что мы знаем структуру ответа заранее. Это не всегда так. Данные о полях можно получить из объекта <code class="language-plaintext highlighter-rouge">ResultSetMetaData</code>. Он возвращает состав полей, их имена и типы. С его помощью задают функцию, которая принимает очередной элемент <code class="language-plaintext highlighter-rouge">ResultSet</code> и переводит его в словарь.</p>

<p>Модуль <code class="language-plaintext highlighter-rouge">clojure.core</code> предлагает функцию <code class="language-plaintext highlighter-rouge">resultset-seq</code>, чтобы привести <code class="language-plaintext highlighter-rouge">ResultSet</code> к ленивой цепочке словарей. В свободное время изучите <a href="https://github.com/clojure/clojure/blob/clojure-1.10.1/src/clj/clojure/core.clj#L5702">ее код</a>: он занимает всего 13 строк.</p>

<p>По умолчанию <code class="language-plaintext highlighter-rouge">query</code> прогоняет ленивую выборку через <code class="language-plaintext highlighter-rouge">doall</code>. В результате все элементы <code class="language-plaintext highlighter-rouge">ResultSet</code> будут прочитаны. В зависимости от логики чтением можно управлять, например делать это отложено. При таком подходе требуется ручное закрытие объекта <code class="language-plaintext highlighter-rouge">ResultSet</code>. О ленивости и ее влиянии на результат мы скажем чуть позже.</p>

<p>Теперь когда мы знакомы с <code class="language-plaintext highlighter-rouge">ResultSet</code>, рассмотрим, в каком еще виде можно читать данные из базы.</p>

<h3 id="массивы">Массивы</h3>

<p>Список словарей удобен, но иногда требуется список векторов, например:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w"> </span><span class="s">"ivan@test.com"</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="s">"Smith"</span><span class="w"> </span><span class="s">"john@test.com"</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>Такая структура полезна для CSV-файлов. Их формат известен заранее, поэтому заголовок указывают однажды в начале файла. Библиотеки для записи CSV ожидают список именно векторов, а не словарей. Если мы выбрали из базы словари, нужно привести их к вектору, что означает лишнюю работу. Будет лучше, если функция <code class="language-plaintext highlighter-rouge">query</code> вернет данные в готовом виде.</p>

<p>Параметр <code class="language-plaintext highlighter-rouge">{:as-arrays? true}</code> в <code class="language-plaintext highlighter-rouge">query</code> означает, что элементы списка будут векторами. Первый ряд содержит имена колонок:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users"</span><span class="w"> </span><span class="p">{</span><span class="no">:as-arrays?</span><span class="w"> </span><span class="n">true</span><span class="p">})</span><span class="w">

</span><span class="p">[[</span><span class="no">:id</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="no">:lname</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="no">:age</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="mi">42</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w"> </span><span class="s">"ivan@test.com"</span><span class="w"> </span><span class="mi">87</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="s">"Smith"</span><span class="w"> </span><span class="s">"john@test.com"</span><span class="w"> </span><span class="mi">20</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>Предположим, мы хотим выгрузить пользователей в файл CSV. Для этого используем библиотеку <code class="language-plaintext highlighter-rouge">clojure.data.csv</code> и стандартный модуль IO:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; [clojure.data.csv :as csv]</span><span class="w">
</span><span class="c1">;; [clojure.java.io :as io]</span><span class="w">

</span><span class="p">(</span><span class="nb">with-open</span><span class="w"> </span><span class="p">[</span><span class="n">writer</span><span class="w"> </span><span class="p">(</span><span class="nf">io/writer</span><span class="w"> </span><span class="s">"users.csv"</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users"</span><span class="w"> </span><span class="p">{</span><span class="no">:as-arrays?</span><span class="w"> </span><span class="n">true</span><span class="p">})</span><span class="w">
       </span><span class="p">(</span><span class="nf">csv/write-csv</span><span class="w"> </span><span class="n">writer</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>В папке проекта вы найдете файл <code class="language-plaintext highlighter-rouge">users.csv</code>. Проверьте содержимое в табличном редакторе. Напишите универсальную функцию для выгрузки любой таблицы. Она принимает имя таблицы, путь к CSV-файлу и, по желанию, набор полей на тот случай, если нужны только некоторые из них.</p>

<p>Список векторов полезен не только для CSV, но и для матричных данных или работы со статистикой.</p>

<h3 id="ключи">Ключи</h3>

<p>По умолчанию JDBC приводит имена полей к типу <code class="language-plaintext highlighter-rouge">Keyword</code> одноименной функцией. Если в выборке было поле <code class="language-plaintext highlighter-rouge">user_name</code>, в словаре окажется ключ <code class="language-plaintext highlighter-rouge">:user_name</code>. Это именно то, что нужно в большинстве случаев, поскольку Clojure поощряет кейворды. Но и здесь порой нужна тонкая настройка.</p>

<p>Параметр <code class="language-plaintext highlighter-rouge">{:keywordize? false}</code> означает, нужно ли приводить поля к кейвордам. По умолчанию он истина, но если передать ложь, получим строки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users"</span><span class="w"> </span><span class="p">{</span><span class="no">:keywordize?</span><span class="w"> </span><span class="n">false</span><span class="p">})</span><span class="w">

</span><span class="p">({</span><span class="s">"id"</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="s">"fname"</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
  </span><span class="s">"lname"</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w">
  </span><span class="s">"email"</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
  </span><span class="s">"age"</span><span class="w"> </span><span class="mi">42</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="s">"id"</span><span class="w"> </span><span class="mi">3</span><span class="w">
  </span><span class="s">"fname"</span><span class="w"> </span><span class="s">"John"</span><span class="w">
  </span><span class="s">"lname"</span><span class="w"> </span><span class="s">"Smith"</span><span class="w">
  </span><span class="s">"email"</span><span class="w"> </span><span class="s">"john@test.com"</span><span class="w">
  </span><span class="s">"age"</span><span class="w"> </span><span class="mi">20</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Параметр удобно использовать в паре с <code class="language-plaintext highlighter-rouge">{:as-arrays? true}</code>. С ним имена таблиц станут строками, и в CSV-файле у заголовков не будет двоеточия.</p>

<p>В поле <code class="language-plaintext highlighter-rouge">:identifiers</code> передают функцию обработки имени поля. По умолчанию используется <code class="language-plaintext highlighter-rouge">clojure.string/lower-case</code>, то есть приведение к нижнему регистру. С ним поле <code class="language-plaintext highlighter-rouge">"VAL"</code> становится <code class="language-plaintext highlighter-rouge">:val</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select 1 as VAL"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; ({:val 1})</span><span class="w">
</span></code></pre></div></div>

<p>Вы можете передать функцию, которая оставляет регистр прежним или заменяет подчеркивание на дефис, чтобы получить <code class="language-plaintext highlighter-rouge">:user-name</code> из <code class="language-plaintext highlighter-rouge">"user_name"</code>.</p>

<p>Параметр <code class="language-plaintext highlighter-rouge">qualifier</code> задает пространство полям выборки. Например, если мы выбираем пользователей, удобно назначить им пространство :user, чтобы позже не перепутать с другими сущностями.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users"</span><span class="w"> </span><span class="p">{</span><span class="no">:qualifier</span><span class="w"> </span><span class="s">"user"</span><span class="p">}))</span><span class="w">

</span><span class="p">{</span><span class="no">:user/id</span><span class="w"> </span><span class="mi">2</span><span class="w">
 </span><span class="no">:user/fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
 </span><span class="no">:user/lname</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w">
 </span><span class="no">:user/email</span><span class="w"> </span><span class="s">"ivan@test.com"</span><span class="w">
 </span><span class="no">:user/age</span><span class="w"> </span><span class="mi">87</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Из того, что JDBC преобразует ключи к кейвордам, можно извлечь пользу. Когда в запросе участвует несколько таблиц с оператором <code class="language-plaintext highlighter-rouge">JOIN</code>, в результат попадают разные сущности. Чтобы одноименные поля не перемешивались, их наделяют префиксом, например, <code class="language-plaintext highlighter-rouge">user_</code> для пользователя и <code class="language-plaintext highlighter-rouge">profile_</code> для профиля:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">u</span><span class="p">.</span><span class="n">id</span>     <span class="k">AS</span> <span class="n">user_id</span><span class="p">,</span>
  <span class="n">u</span><span class="p">.</span><span class="n">fname</span>  <span class="k">AS</span> <span class="n">user_fname</span><span class="p">,</span>
  <span class="n">u</span><span class="p">.</span><span class="n">lname</span>  <span class="k">AS</span> <span class="n">user_lname</span><span class="p">,</span>
  <span class="n">p</span><span class="p">.</span><span class="n">avatar</span> <span class="k">AS</span> <span class="n">profile_avatar</span>
<span class="k">FROM</span> <span class="n">users</span> <span class="n">u</span>
<span class="k">JOIN</span> <span class="n">profiles</span> <span class="n">p</span> <span class="k">ON</span> <span class="n">p</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Работать с такими ключами в Clojure неудобно. Вместо префикса и подчеркиваний мы ожидаем пространства и дефис. Если назначить полям псевдонимы вида “сущность/поле”, получим нужные ключи. Однако псевдоним с косой чертой нужно взять в двойные кавычки, чтобы не нарушить синтаксис SQL:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">u</span><span class="p">.</span><span class="n">id</span>     <span class="k">AS</span> <span class="nv">"user/id"</span><span class="p">,</span>
  <span class="n">u</span><span class="p">.</span><span class="n">fname</span>  <span class="k">AS</span> <span class="nv">"user/fname"</span><span class="p">,</span>
  <span class="n">u</span><span class="p">.</span><span class="n">lname</span>  <span class="k">AS</span> <span class="nv">"user/lname"</span><span class="p">,</span>
  <span class="n">p</span><span class="p">.</span><span class="n">avatar</span> <span class="k">AS</span> <span class="nv">"profile/avatar"</span>
<span class="k">FROM</span> <span class="n">users</span> <span class="n">u</span>
<span class="k">JOIN</span> <span class="n">profiles</span> <span class="n">p</span> <span class="k">ON</span> <span class="n">p</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Вывод psql:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> user/id | user/fname | user/lname | profile/avatar
---------+------------+------------+----------------
       1 | Ivan       | Petrov     | kitten.jpg
</code></pre></div></div>

<p>Если передать запрос в <code class="language-plaintext highlighter-rouge">jdbc/query</code>, получим удобные ключи:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">({</span><span class="no">:user/id</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="no">:user/fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
  </span><span class="no">:user/lname</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w">
  </span><span class="no">:profile/avatar</span><span class="w"> </span><span class="s">"kitten.jpg"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Однако писать псевдонимы вручную для каждого поля долго. Кроме того, в Clojure приходится экранировать двойные кавычки, чтобы не вызвать ошибку синтаксиса. В результате запрос выглядит шумно и занимает много места:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"
select
u.id as \"user/id\",
u.fname as \"user/fname\",
...
"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Ниже мы узнаем, как исправить эти недостатки.</p>

<h3 id="ленивость">Ленивость</h3>

<p>По умолчанию результат <code class="language-plaintext highlighter-rouge">jdbc/query</code> не ленив, то есть полностью вычислен (realized в терминах Clojure). Он уже не зависит от соединения с базой и объекта <code class="language-plaintext highlighter-rouge">ResultSet</code>. Если точнее, из <code class="language-plaintext highlighter-rouge">ResultSet</code> получают ленивую последовательность, которая позже вычисляется с помощью <code class="language-plaintext highlighter-rouge">doall</code> (для списка словарей) или <code class="language-plaintext highlighter-rouge">vec</code> (когда <code class="language-plaintext highlighter-rouge">:as-arrays?</code> истина).</p>

<p>Ключ <code class="language-plaintext highlighter-rouge">:result-set-fn</code> определяет, что именно будет предпринято с ленивой коллекцией до того, как она вычислена. По умолчанию это функция <code class="language-plaintext highlighter-rouge">doall</code> или <code class="language-plaintext highlighter-rouge">vec</code> в зависимости от параметров. Предположим теперь, мы хотим получить истинно ленивый результат без вычисления. Очевидно, в поле <code class="language-plaintext highlighter-rouge">:result-set-fn</code> просится функция <code class="language-plaintext highlighter-rouge">identity</code>. Однако с ней запрос бросит исключение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users"</span><span class="w"> </span><span class="p">{</span><span class="no">:result-set-fn</span><span class="w"> </span><span class="nb">identity</span><span class="p">})</span><span class="w">

</span><span class="n">idError</span><span class="w"> </span><span class="n">printing</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">(</span><span class="nf">PSQLException</span><span class="p">)</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">org.postgresql.jdbc.PgResultSet/checkClosed</span><span class="w"> </span><span class="p">(</span><span class="nf">PgResultSet.java</span><span class="no">:2758</span><span class="p">)</span><span class="nb">.</span><span class="w">
</span><span class="n">This</span><span class="w"> </span><span class="n">ResultSet</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">closed.</span><span class="w">
</span></code></pre></div></div>

<p>Оно возникло потому, что после выполнения запроса JDBC закрывает объект <code class="language-plaintext highlighter-rouge">ResultSet</code>. При печати коллекции в REPL мы читаем данные из <code class="language-plaintext highlighter-rouge">ResultSet</code> уже после его закрытия, что приводит к ошибке.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">:result-set-fn</code> полезна в тех случаях, когда нужно обработать элементы по одному, не дожидаясь всего ответа. Часто это связано с операциями ввода-вывода. Представим, нужно записать выборку в файл. Будет неэффективно выгружать все данные в память и затем в файл — гораздо лучше читать записи по одной и сразу записывать. Даже если записей миллионы, мы не израсходуем память.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users"</span><span class="w">
            </span><span class="p">{</span><span class="no">:as-arrays?</span><span class="w"> </span><span class="n">true</span><span class="w">
             </span><span class="no">:keywordize?</span><span class="w"> </span><span class="n">false</span><span class="w">
             </span><span class="no">:result-set-fn</span><span class="w">
             </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">rows</span><span class="p">]</span><span class="w">
               </span><span class="p">(</span><span class="nb">with-open</span><span class="w"> </span><span class="p">[</span><span class="n">writer</span><span class="w"> </span><span class="p">(</span><span class="nf">io/writer</span><span class="w"> </span><span class="s">"users.csv"</span><span class="p">)]</span><span class="w">
                 </span><span class="p">(</span><span class="nf">csv/write-csv</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="n">rows</span><span class="p">)))})</span><span class="w">
</span></code></pre></div></div>

<p>В примере выше мы записываем ленивую коллекцию <code class="language-plaintext highlighter-rouge">rows</code> в файл, не дожидаясь чтения всего ответа. Подход оправдывает себя на больших выборках.</p>

<p>В редких случаях вам понадобится ручная работа с <code class="language-plaintext highlighter-rouge">ResultSet</code>. Доступ к нему предоставляет функция <code class="language-plaintext highlighter-rouge">jdbc/db-query-with-resultset</code>, которая принимает объект <code class="language-plaintext highlighter-rouge">ResultSet</code>. Делайте с ним что угодно, но помните: после выхода из функции он будет закрыт.</p>

<p>Как правило, работа с <code class="language-plaintext highlighter-rouge">ResultSet</code> сводится к итерации <code class="language-plaintext highlighter-rouge">(while (.next ...))</code> и чтению полей. Этот метод эффективней <code class="language-plaintext highlighter-rouge">result-set-fn</code>, потому что не производит ленивую коллекцию, которая потребляет ресурсы.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/db-query-with-resultset</span><span class="w">
 </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users"</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">ResultSet</span><span class="w"> </span><span class="n">rs</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">while</span><span class="w"> </span><span class="p">(</span><span class="nf">.next</span><span class="w"> </span><span class="n">rs</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="p">(</span><span class="nf">.getInt</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="s">"id"</span><span class="p">)</span><span class="w">
           </span><span class="n">fname</span><span class="w"> </span><span class="p">(</span><span class="nf">.getString</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="s">"fname"</span><span class="p">)</span><span class="w">
           </span><span class="n">lname</span><span class="w"> </span><span class="p">(</span><span class="nf">.getString</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="s">"lname"</span><span class="p">)]</span><span class="w">
       </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">fname</span><span class="w"> </span><span class="n">lname</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Выше мы просто печатаем данные на экран. На практике мы бы отправили их в сеть, в файл или поток.</p>

<h2 id="транзакции">Транзакции</h2>

<p>Чтобы изменения в базе были согласованы, нужны транзакции. Транзакция обещает, что в изменения не вмешается кто-то другой, и все они завершатся либо успехом, либо откатом к прежнему состоянию. Исключен третий нежелательный вариант, когда в базе остались частичные изменения.</p>

<p>Приведем типичные случаи с транзакциями. Это может быть сбор денег на проект (краудфандинг). Каждый раз, когда кто-то совершил платеж, итоговая сумма пересчитывается. Если делать это не в транзакции, можно пропустить платеж, который случился при пересчете, и итог будет неверным.</p>

<p>Даже если с базой работает один человек, транзакции необходимы. Представим органайзер фотографий. Каждая из них может быть в нескольких альбомах, иметь свои теги, ссылки на места и людей, запись в поисковом индексе. Теперь мы удаляем фотографию. Очистка должна произойти либо во всех таблицах, либо нигде. Представьте, что фотография не видна в альбоме, но появляется в поиске — это раздражает.</p>

<p>Технически транзакция означает, что два и более запроса окружены командами <code class="language-plaintext highlighter-rouge">BEGIN</code> и <code class="language-plaintext highlighter-rouge">COMMIT</code>. Приведем сеанс psql со вставкой данных в транзакции. В первый запрос мы добавили оператор <code class="language-plaintext highlighter-rouge">RETURNING</code>, чтобы получить созданный базой первичный ключ. Мы ссылаемся на него во втором запросе.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Ivan'</span><span class="p">,</span> <span class="s1">'ivan@test.com'</span><span class="p">)</span> <span class="n">RETURNING</span> <span class="n">id</span><span class="p">;</span>
<span class="c1">-- 59</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">profiles</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">avatar</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">59</span><span class="p">,</span> <span class="s1">'me.jpg'</span><span class="p">);</span>
<span class="k">COMMIT</span><span class="p">;</span>
</code></pre></div></div>

<p>Если хотя бы один запрос потерпит неудачу, <code class="language-plaintext highlighter-rouge">COMMIT</code> не сработает, и обе таблицы останутся нетронуты.</p>

<p>Рассмотрим, как управлять транзакциями в Clojure. Если выполнить два запроса в лоб:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Huan"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>, увидим в логах PostgreSQL следующие записи:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="p">(</span> <span class="n">fname</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span> <span class="err">$</span><span class="mi">1</span> <span class="p">)</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'Ivan'</span>
<span class="k">COMMIT</span>

<span class="k">BEGIN</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="p">(</span> <span class="n">fname</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span> <span class="err">$</span><span class="mi">1</span> <span class="p">)</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'Huan'</span>
<span class="k">COMMIT</span>
</code></pre></div></div>

<p>Каждый запрос оказался в отдельной транзакции, что вовсе не то, что мы ожидали. Так происходит потому, что функции на изменение (с восклицательным знаком на конце) принимают необязательный аргумент <code class="language-plaintext highlighter-rouge">:transaction?</code>. По умолчанию он истина, что значит выполнить запрос в отдельной транзакции. Если мы укажем ложь для этого флага:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:transaction?</span><span class="w"> </span><span class="n">false</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Huan"</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:transaction?</span><span class="w"> </span><span class="n">false</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>, транзакций не будет совсем:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="p">(</span> <span class="n">fname</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span> <span class="err">$</span><span class="mi">1</span> <span class="p">)</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'Ivan'</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="p">(</span> <span class="n">fname</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span> <span class="err">$</span><span class="mi">1</span> <span class="p">)</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'Huan'</span>
</code></pre></div></div>

<p>Другая причина, по которой у нас не выходит транзакция, в том, что запросы должны быть в рамках одного соединения. По умолчанию JDBC открывает новое соединение на запрос, что неэффективно и не дает управлять транзакциями. Мы должны открыть соединение, начать транзакцию и выполнить в нём все запросы. Код на Clojure должен быть обернут в <code class="language-plaintext highlighter-rouge">try/catch</code>, чтобы в случае исключения выполнить <code class="language-plaintext highlighter-rouge">ROLLBACK</code>. Если не было ошибок, выполнить <code class="language-plaintext highlighter-rouge">COMMIT</code>. В конце закрыть соединение.</p>

<p>Если каждый раз писать всё это вручную, обязательно допустим ошибку. Должна быть единая точка (макрос или функция), которая управляет процессом. Clojure предлагает макрос <code class="language-plaintext highlighter-rouge">with-db-transaction</code>. Он принимает JDBC-спеку, параметры транзакции и произвольный код. Коротко его логику можно описать так:</p>

<ul>
  <li>получить TCP-соединение из JDBC-спеки.</li>
  <li>Запомнить его параметры <code class="language-plaintext highlighter-rouge">autocommit</code>, <code class="language-plaintext highlighter-rouge">readonly</code> и другие.</li>
  <li>Выставить параметр <code class="language-plaintext highlighter-rouge">autocommit=false</code>.</li>
  <li>Связать соединение с символом из макроса.</li>
  <li>Выполнить тело макроса в блоке <code class="language-plaintext highlighter-rouge">let</code> с этой переменной. Запросы должны использовать новое соединение.</li>
  <li>Если не было исключений, вызвать <code class="language-plaintext highlighter-rouge">COMMIT</code>.</li>
  <li>В блоке <code class="language-plaintext highlighter-rouge">catch</code> вызвать <code class="language-plaintext highlighter-rouge">ROLLBACK</code> и повторно бросить исключение.</li>
  <li>В блоке <code class="language-plaintext highlighter-rouge">finally</code> вернуть соединению начальные параметры.</li>
</ul>

<p>Быстрая проверка макроса:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/with-db-transaction</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">})</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Huan"</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>На этот раз оба запроса окажутся в одной транзакции:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="p">(</span> <span class="n">fname</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span> <span class="err">$</span><span class="mi">1</span> <span class="p">)</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'Ivan'</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="p">(</span> <span class="n">fname</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span> <span class="err">$</span><span class="mi">1</span> <span class="p">)</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'Huan'</span>
<span class="k">COMMIT</span>
</code></pre></div></div>

<p>Свойства транзакции определяет первый параметр макроса. Это вектор, от которого ожидают по крайней мере два символа по принципу <code class="language-plaintext highlighter-rouge">let</code>. Первый символ — имя, с которым будет связано соединение с транзакцией. Второй символ указывает на текущую JDBC-спеку. Первым символом обычно указывают <code class="language-plaintext highlighter-rouge">tx</code> или <code class="language-plaintext highlighter-rouge">trx</code> – сокращение от transaction.</p>

<p>Типичная ошибка в работе с макросом — установить транзакцию, но пользоваться прежним соединением. В этом случае пользы от макроса нет.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/with-db-transaction</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">})</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Huan"</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Более сложный пример с записью в разные таблицы. Сперва создаем пользователя, затем профиль со ссылкой на него:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/with-db-transaction</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">

  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[{</span><span class="n">user-id</span><span class="w"> </span><span class="no">:id</span><span class="p">}]</span><span class="w">
        </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">})</span><span class="w">

        </span><span class="p">[{</span><span class="n">profile-id</span><span class="w"> </span><span class="no">:id</span><span class="p">}]</span><span class="w">
        </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="no">:profiles</span><span class="w"> </span><span class="p">{</span><span class="no">:user_id</span><span class="w"> </span><span class="n">user-id</span><span class="w"> </span><span class="no">:avatar</span><span class="w"> </span><span class="s">"cat.jpg"</span><span class="p">})]</span><span class="w">

    </span><span class="p">{</span><span class="no">:user/id</span><span class="w"> </span><span class="n">user-id</span><span class="w">
     </span><span class="no">:profile/id</span><span class="w"> </span><span class="n">profile-id</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Код вернет словарь с ключами новых сущностей. Для ясности мы добавили им пространства.</p>

<p>Третий элемент макроса принимает параметры транзакции. Он может отсутствовать, и тогда сработают параметры по умолчанию. Наиболее интересен ключ <code class="language-plaintext highlighter-rouge">:isolation</code>, уровень изоляции. Он определяет, как управлять данными в параллельных транзакциях, а именно на каком этапе каждой их них видны изменения другой.</p>

<p>Предположим, одновременно открыты две транзакции. Первая изменила запись, но еще не вызвала <code class="language-plaintext highlighter-rouge">COMMIT</code>. Вторая читает эту же запись. Получит ли она исходные данные или с изменениями? Что если первая транзакция вызвала <code class="language-plaintext highlighter-rouge">COMMIT</code>? Должна ли вторая увидеть эти изменения, ведь на момент <code class="language-plaintext highlighter-rouge">BEGIN</code> их не было?</p>

<p>Уровень изоляции управляет подобными случаями. Современные базы выделяют следующие уровни:</p>

<ul>
  <li>READ UNCOMMITTED</li>
  <li>READ COMMITTED</li>
  <li>REPEATABLE READ</li>
  <li>SERIALIZABLE</li>
</ul>

<p>Они следуют по нарастанию безопасности в работе с параллельными транзакциями. С уровнем READ UNCOMMITTED транзакции B доступны незавершенные изменения, сделанные в A. Возможно, они подлежат откату, потому полагаться на эти данные будет ошибочно.</p>

<p>Уровень READ COMMITTED означает, что транзакция B получит изменения из А, только если они зафиксированы. READ COMMITTED считается достаточным для большинства случаев и установлен по умолчанию в SQL Server и PostgreSQL.</p>

<p>Уровень REPEATABLE READ обеспечивает так называемое повторное чтение. С ним транзакция A запоминает состояние базы на момент BEGIN. Даже если другие транзакции внесли изменения, чтение данных в A вернет их прежнюю версию. Если А меняет записи, обновленные другими транзакциями, произойдет конфликт, и придется выполнить ее повторно или отказаться от изменений.</p>

<p>Максимальный уровень SERIALIZABLE гарантирует безопасность с транзакциями. Когда он включен, база выполняет транзакции так, словно они следуют одна за другой, а не параллельно.</p>

<p>Сказанное не значит, что нужно выставлять наивысший уровень SERIALIZABLE. Хоть он и решает ряд проблем, но замедляет обработку данных. Меняйте уровень изоляции только если четко понимаете, чем вас не устраивает текущий.</p>

<p>В этой главе мы не рассматриваем изоляцию в деталях. Ее изучение требует примеров с таблицами и параллельными запросами. Эта тема не касается Clojure, потому что не зависит языка программирования. Для быстрого знакомства прочтите <a href="https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">статью в Википедии</a>. Еще глубже материал изложен в документации PostgresPro, в том числе <a href="https://postgrespro.ru/docs/postgrespro/13/transaction-iso">на русском языке</a>. Самое детальное описание вы найдете в книге Егора Рогова <a href="https://dmkpress.com/catalog/computer/databases/978-5-93700-122-2/">“PostgreSQL изнутри”</a>. Автор горячо рекомендует эту книгу к прочтению.</p>

<p>Разберем, как задать уровень изоляции в Clojure. Макрос <code class="language-plaintext highlighter-rouge">with-db-transaction</code> принимает ключ <code class="language-plaintext highlighter-rouge">:isolation</code>. Его возможные значения — кейводы:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">:none</code></li>
  <li><code class="language-plaintext highlighter-rouge">:read-committed</code></li>
  <li><code class="language-plaintext highlighter-rouge">:read-uncommitted</code></li>
  <li><code class="language-plaintext highlighter-rouge">:repeatable-read</code></li>
  <li><code class="language-plaintext highlighter-rouge">:serializable</code></li>
</ul>

<p>Внутри макроса они транслируются в константы Java. Пример с уровнем SERIALIZABLE, заданным явно:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/with-db-transaction</span><span class="w">
  </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:isolation</span><span class="w"> </span><span class="no">:serializable</span><span class="p">}]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Если выполнить код, в логах PostgreSQL увидим записи:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SHOW</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span>
<span class="k">SET</span> <span class="k">SESSION</span> <span class="k">CHARACTERISTICS</span> <span class="k">AS</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">SERIALIZABLE</span>
<span class="k">BEGIN</span>
<span class="p">...</span>
<span class="k">COMMIT</span>
<span class="k">SET</span> <span class="k">SESSION</span> <span class="k">CHARACTERISTICS</span> <span class="k">AS</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">COMMITTED</span>
</code></pre></div></div>

<p>Макрос временно заменяет уровень изоляции на указанный. После фиксации транзакции или ее отката возвращается прежний уровень. Уровень по умолчанию можно задать в настройках базы данных. В этом случае не придется передавать ключ <code class="language-plaintext highlighter-rouge">:isolation</code> в макрос каждый раз.</p>

<h2 id="jdbc-спека-с-состоянием">JDBC-спека с состоянием</h2>

<p>В словаре, который принимают функции JDBC, нет состояния, и не ясно, откуда оно приходит. Это особенность библиотеки для Clojure: с базой можно работать как с состоянием, так и без него. Но чтобы код был эффективным, вы должны понимать, что происходит на нижнем уровне JDBC.</p>

<p>Под состоянием спеки понимают TCP-соединение, по которому клиент и база передают данные. В следующем словаре никакого соединения нет:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgresql"</span><span class="w">
         </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"test"</span><span class="w">
         </span><span class="n">...</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Если передать его в функцию <code class="language-plaintext highlighter-rouge">query</code>, произойдет следующее:</p>

<ul>
  <li>
    <p>из словаря библиотека построит JDBC URL — длинную строку, похожую на адрес страницы в интернете. Для конфигурации выше результат будет примерно таким: “jdbc:postgresql://127.0.0.1:5432/test”.</p>
  </li>
  <li>
    <p>По URL получим открытое TCP-соединение. Через него функция <code class="language-plaintext highlighter-rouge">query</code> отправит и получит данные.</p>
  </li>
  <li>
    <p>После выполнения <code class="language-plaintext highlighter-rouge">query</code> соединение закроется.</p>
  </li>
</ul>

<p>Аналогично устроены функции <code class="language-plaintext highlighter-rouge">update!</code>, <code class="language-plaintext highlighter-rouge">delete!</code> и другие. Все они сводятся к единой точке, где создается соединение, происходит обмен данных, затем оно закрывается.</p>

<p>Открывать соединение на каждый запрос расточительно. Чтобы использовать его повторно, JDBC предлагает макрос <code class="language-plaintext highlighter-rouge">with-db-connection</code>. Макрос связывает символ с копией спеки, в одном из полей которой находится соединение.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/with-db-connection</span><span class="w"> </span><span class="p">[</span><span class="n">conn</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"select 1"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Макрос добавляет соединение в спеку с ключом <code class="language-plaintext highlighter-rouge">:connection</code>. Функция, которая строит соединение по словарю, проверяет этот ключ. Если в нем уже есть соединение, функция вернет его же. Вместе это работает как кэш. Исследуем переменную <code class="language-plaintext highlighter-rouge">conn</code> и убедимся, что в ней заполнено поле <code class="language-plaintext highlighter-rouge">:connection</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/with-db-connection</span><span class="w"> </span><span class="p">[</span><span class="n">conn</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="n">conn</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgresql"</span><span class="w">
 </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"test"</span><span class="w">
 </span><span class="n">...</span><span class="w">
 </span><span class="no">:connection</span><span class="w"> </span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">org.postgresql.jdbc.PgConnection</span><span class="w"> </span><span class="mi">0</span><span class="n">x46b37678</span><span class="w"> </span><span class="s">"org.postgresql.jdbc.PgConnection@46b37678"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы оценить издержки на соединение с базой, напишем замер. Выполним примитивный запрос многократно, в первом случае — каждый раз с новым соединением, во втором — с одним и тем же.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">time</span><span class="w"> </span><span class="p">(</span><span class="nb">dotimes</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="mi">1000</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select 1"</span><span class="p">)))</span><span class="w">
</span><span class="c1">;; "Elapsed time: 19097.466607 msecs"</span><span class="w">

</span><span class="p">(</span><span class="nb">time</span><span class="w">
 </span><span class="p">(</span><span class="nf">jdbc/with-db-connection</span><span class="w"> </span><span class="p">[</span><span class="n">conn</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">dotimes</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="mi">1000</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"select 1"</span><span class="p">))))</span><span class="w">
</span><span class="c1">;; "Elapsed time: 1680.252291 msecs"</span><span class="w">
</span></code></pre></div></div>

<p>Разница в одиннадцать раз в пользу постоянного соединения. Очевидно, что первый вариант — соединение на запрос — подойдет только разовым скриптам. Для долгоиграющих систем нужно постоянное соединение. Это подводит нас к JDBC-спеке с состоянием.</p>

<p>Чтобы управлять спекой с минимальными усилиями, обратимся к библиотеке <code class="language-plaintext highlighter-rouge">Mount</code>. Мы познакомились с ней в первой книге в главе про системы. Объявим компонент, который при запуске открывает TCP-соединение и дописывает его в поле <code class="language-plaintext highlighter-rouge">:connection</code> спеки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">mount.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">mount</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">defstate</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">defstate</span><span class="w"> </span><span class="n">DB</span><span class="w">
  </span><span class="no">:start</span><span class="w">
  </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:connection</span><span class="w">
         </span><span class="p">(</span><span class="nf">jdbc/get-connection</span><span class="w"> </span><span class="n">db</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>В фазе остановки закрываем соединение и возвращаем исходную спеку без состояния:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="no">:stop</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">connection</span><span class="p">]}</span><span class="w"> </span><span class="n">DB</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">connection</span><span class="w">
      </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="n">connection</span><span class="p">))</span><span class="w">
    </span><span class="n">db</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Вызовем <code class="language-plaintext highlighter-rouge">(mount/start)</code>, чтобы включить компонент. Теперь каждый запрос к базе использует постоянное соединение, что быстрее:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">DB</span><span class="w"> </span><span class="s">"select 1"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h3 id="пул-соединений">Пул соединений</h3>

<p>У открытого соединения есть проблема: его легко потерять. Проведем эксперимент: когда компонент базы включен, перезапустите сервер базы данных. Компонент придет в негодность: при попытке выполнить запрос получим ошибку о том, что соединение закрыто.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Execution</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">(</span><span class="nf">PSQLException</span><span class="p">)</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">org.postgresql.jdbc.PgConnection/checkClosed</span><span class="w"> </span><span class="p">(</span><span class="nf">PgConnection.java</span><span class="no">:766</span><span class="p">)</span><span class="nb">.</span><span class="w">
</span><span class="n">This</span><span class="w"> </span><span class="n">connection</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">closed.</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы исправить компонент, придется перезапустить его — вручную вызвать функции <code class="language-plaintext highlighter-rouge">start</code> и <code class="language-plaintext highlighter-rouge">stop</code>, которые откроют новое соединение.</p>

<p>Сбои в сети случаются часто, и перезапускать компонент при потере соединения тяжело. Нужен механизм, который бы делал это за нас. Так работают пулы соединений, которые открывают их несколько за раз. Пул следит за обрывами связи и обновляет соединения. Он работает в отдельном потоке и не блокирует наши действия.</p>

<p>О пулах мы говорили в первой книге, поэтому приведем только пример. Подключите библиотеку HikariCP в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; [hikari-cp "2.8.0"]</span><span class="w">
</span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">hikari-cp.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">cp</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">cp/make-datasource</code> принимает конфигурацию пула и строит объект <code class="language-plaintext highlighter-rouge">DataSource</code>. Его записывают в словарь спеки с ключом <code class="language-plaintext highlighter-rouge">:datasource</code>. По аналогии с <code class="language-plaintext highlighter-rouge">:connection</code>, JDBC проверяет это поле, прежде чем открывать соединение. Если источник задан, библиотека берет соединение из него. В случае с <code class="language-plaintext highlighter-rouge">:datasource</code> мы получим заранее открытое соединение, и запрос пройдет так же быстро, как в случае с <code class="language-plaintext highlighter-rouge">:connection</code>. Новый компонент:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">pool-config</span><span class="w"> </span><span class="c1">;; truncated</span><span class="w">
  </span><span class="p">{</span><span class="no">:minimum-idle</span><span class="w">       </span><span class="mi">10</span><span class="w">
   </span><span class="no">:maximum-pool-size</span><span class="w">  </span><span class="mi">10</span><span class="w">
   </span><span class="no">:adapter</span><span class="w">            </span><span class="s">"postgresql"</span><span class="w">
   </span><span class="no">:username</span><span class="w">           </span><span class="s">"book"</span><span class="w">
   </span><span class="no">:server-name</span><span class="w">        </span><span class="s">"127.0.0.1"</span><span class="w">
   </span><span class="no">:port-number</span><span class="w">        </span><span class="mi">5432</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">defstate</span><span class="w"> </span><span class="n">DB</span><span class="w">
  </span><span class="no">:start</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pool</span><span class="w"> </span><span class="p">(</span><span class="nf">cp/make-datasource</span><span class="w"> </span><span class="n">pool-config</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:datasource</span><span class="w"> </span><span class="n">pool</span><span class="p">})</span><span class="w">
  </span><span class="no">:stop</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">DB</span><span class="w"> </span><span class="no">:datasource</span><span class="w"> </span><span class="n">cp/close-datasource</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Повторите эксперимент с отключением базы. Вы увидите тревожные сообщения, но затем HikariCP получит новое соединение, и система продолжит работу. Это крайне важно для веб-приложений, поэтому в боевом запуске всегда используют пул. Спеку без состояния применяют только для разработки или в тестах.</p>

<p>Состояние поддерживают не только с помощью Mount. Это может быть и другой фреймворк, например Component. Вот как задать JDBC-спеку, которая реагирует на методы <code class="language-plaintext highlighter-rouge">start</code> и <code class="language-plaintext highlighter-rouge">stop</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db</span><span class="w">
  </span><span class="p">(</span><span class="nb">with-meta</span><span class="w">
    </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgresql"</span><span class="w">
     </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"test"</span><span class="w">
     </span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
     </span><span class="no">:user</span><span class="w"> </span><span class="s">"book"</span><span class="w">
     </span><span class="no">:password</span><span class="w"> </span><span class="s">"book"</span><span class="p">}</span><span class="w">

    </span><span class="p">{</span><span class="ss">'com.stuartsierra.component/start</span><span class="w">
     </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:connection</span><span class="w">
              </span><span class="p">(</span><span class="nf">jdbc/get-connection</span><span class="w"> </span><span class="n">this</span><span class="p">)))</span><span class="w">

     </span><span class="ss">'com.stuartsierra.component/stop</span><span class="w">
     </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[{</span><span class="no">:as</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">connection</span><span class="p">]}]</span><span class="w">
       </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">connection</span><span class="w">
         </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="n">connection</span><span class="p">))</span><span class="w">
       </span><span class="p">(</span><span class="nb">dissoc</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:connection</span><span class="p">))}))</span><span class="w">
</span></code></pre></div></div>

<p>Компонент включают, работают с ним и отключают:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-started</span><span class="w"> </span><span class="p">(</span><span class="nf">component/start</span><span class="w"> </span><span class="n">db</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db-started</span><span class="w"> </span><span class="s">"select ..."</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db-started</span><span class="w"> </span><span class="s">"update ..."</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">component/stop</span><span class="w"> </span><span class="n">db-started</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Мы запустили компонент вручную, но на практике им управляет система. Если вы не уверены в том, что происходит, обратитесь к главе о системах из первой книги. По аналогии напишите компонент для Integrant – еще одной системы управления компонентами, которую мы изучили там же.</p>

<h2 id="sqlite">SQLite</h2>

<p>Особое место в обзоре занимает <a href="https://www.sqlite.org/index.html">SQLite</a>. Это не серверная, а клиентская база данных. Отличие от PostgreSQL или MySQL в том, что в SQLite нет центрального сервера, который обслуживает клиентов. SQLite работает на вашем компьютере и является частью проекта.</p>

<p>SQLite хранит данные в файлах по принципу один файл — одна база, что удобно для обмена. Например, внутренняя система раз в сутки выгружает базу SQLite с абонентами и их последними платежами. Эти данные показывает веб-приложение, и ему не нужно обращаться ко внутренней системе.</p>

<p>SQLite подходит для хранения настроек или историй действий пользователя. Браузеры и другие программы ведут несколько SQLite-баз. Ради интереса исследуйте папки профилей Google Chrome, Firefox или Telegram — в каждой их них вы найдете файлы с расширением *.db или *.sqlite.</p>

<p>SQLite ведет себя как обычная реляционная база данных. Ее основные сущности — таблицы, первичные ключи и индексы. База поддерживает транзакции, когда изменяются записи либо в нескольких таблицах, либо ни в одной. Для чтения нет ограничений на число клиентов, но для записи это не так: только один клиент может изменять данные. При попытке сделать это второй клиент получит ошибку, что база заблокирована на запись. Поэтому SQLite используют в основном в программах для одного пользователя. В этом случае данные меняются по очереди, а не параллельно.</p>

<p>Особенность SQLite в том, что она может хранить данные в памяти без обращения к диску. Это полезно, когда программа интенсивно читает данные. Если загрузить их в память целиком, доступ к данным будет быстрее. Иногда программа выполняет долгий расчет и использует базу в памяти как временное хранилище. Позже ее можно <a href="https://www.sqlite.org/backup.html">сохранить на диск</a>.</p>

<p>Как и в PostgreSQL, работа с SQLite сводится к функциям query, <code class="language-plaintext highlighter-rouge">insert!</code>, <code class="language-plaintext highlighter-rouge">update!</code> и другим. Разница в том, что, во-первых, нужно подключить драйвер базы, а во-вторых, изменить JDBC-спеку. Добавьте драйвер SQLite в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">org.xerial/sqlite-jdbc</span><span class="w"> </span><span class="s">"3.36.0"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Скорее всего, на вашем компьютере установлен браузер Chrome или Firefox. Чтобы не создавать базу вручную, позаимствуем готовую из профиля браузера. Google Chrome хранит историю в файле History (без расширения). Путь к профилю отличается в зависимости от системы:</p>

<ul>
  <li>Windows 10: <code class="language-plaintext highlighter-rouge">C:\Users\&lt;username&gt;\AppData\Local\Google\Chrome\User Data\Default</code></li>
  <li>MacOS: <code class="language-plaintext highlighter-rouge">/Users/&lt;username&gt;/Library/Application Support/Google/Chrome/Default</code></li>
  <li>Linux: <code class="language-plaintext highlighter-rouge">/home/&lt;username&gt;/.config/google-chrome/default</code></li>
</ul>

<p>В нашем случае спека JDBC выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db</span><span class="w">
  </span><span class="p">{</span><span class="no">:classname</span><span class="w"> </span><span class="s">"org.sqlite.JDBC"</span><span class="w">
   </span><span class="no">:subprotocol</span><span class="w"> </span><span class="s">"sqlite"</span><span class="w">
   </span><span class="no">:subname</span><span class="w"> </span><span class="s">"/Users/ivan/Library/Application Support/Google/Chrome/Default/History"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Для доступа к базе Chrome должен быть выключен, иначе вы получите ошибку.</p>

<p>Для начала узнаем, какие таблицы содержит база. Прочитаем их из главной таблицы <code class="language-plaintext highlighter-rouge">sqlite_master</code>, в которой записаны все сущности (таблицы, индексы, триггеры и прочее).</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"SELECT name FROM sqlite_master WHERE type = 'table'"</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="no">:name</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запрос вернет список строк:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="s">"meta"</span><span class="w">
 </span><span class="s">"urls"</span><span class="w">
 </span><span class="s">"sqlite_sequence"</span><span class="w">
 </span><span class="s">"visits"</span><span class="w">
 </span><span class="s">"visit_source"</span><span class="w">
 </span><span class="s">"keyword_search_terms"</span><span class="w">
 </span><span class="s">"downloads"</span><span class="w">
 </span><span class="s">"downloads_url_chains"</span><span class="w">
 </span><span class="s">"downloads_slices"</span><span class="w">
 </span><span class="s">"segments"</span><span class="w">
 </span><span class="s">"segment_usage"</span><span class="w">
 </span><span class="s">"typed_url_sync_metadata"</span><span class="w">
 </span><span class="s">"content_annotations"</span><span class="w">
 </span><span class="s">"context_annotations"</span><span class="w">
 </span><span class="s">"clusters"</span><span class="w">
 </span><span class="s">"clusters_and_visits"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы увидеть последние сайты, что вы посещали, выполните запрос:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"SELECT * FROM urls order by last_visit_time desc limit 10"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Приведем один из элементов списка. В нем указан адрес страницы, ее заголовок, число посещений и время последнего посещения в формате наносекунд.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">98</span><span class="n">,</span><span class="w">
 </span><span class="no">:url</span><span class="w"> </span><span class="s">"https://github.com/igrishaev"</span><span class="n">,</span><span class="w">
 </span><span class="no">:title</span><span class="w"> </span><span class="s">"igrishaev (Ivan Grishaev)"</span><span class="n">,</span><span class="w">
 </span><span class="no">:visit_count</span><span class="w"> </span><span class="mi">5</span><span class="n">,</span><span class="w">
 </span><span class="no">:typed_count</span><span class="w"> </span><span class="mi">0</span><span class="n">,</span><span class="w">
 </span><span class="no">:last_visit_time</span><span class="w"> </span><span class="mi">13261760285085441</span><span class="n">,</span><span class="w">
 </span><span class="no">:hidden</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Таблица <code class="language-plaintext highlighter-rouge">downloads</code> хранит данные о загруженных файлах:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"SELECT * FROM downloads limit 10"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Очистка этих таблиц приведет к удалению истории в браузере. Когда вы нажимаете на кнопку “Очистить историю”, браузер выполняет запросы <code class="language-plaintext highlighter-rouge">DELETE FROM</code> ко всем таблицам базы.</p>

<p>Пользуясь случаем, исследуйте другие таблицы истории Chrome. Обратите внимание, насколько легко чужой программе получить доступ к истории браузера. Этим пользуются некоторые приложения: взамен на бесплатную установку они читают историю и передают фирмам, которые показывают рекламу.</p>

<h3 id="база-в-памяти">База в памяти</h3>

<p>При работе с SQLite в режиме in-memory возникают особенности. Для начала измените путь к файлу на строку <code class="language-plaintext highlighter-rouge">:memory:</code> Это особое значение, которое велит драйверу переключиться на другой тип хранилища. Далее вас ждет странность: если создать таблицу и записать в нее значение, получим ошибку, что таблицы не существует.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db</span><span class="w">
  </span><span class="p">{</span><span class="no">:classname</span><span class="w">   </span><span class="s">"org.sqlite.JDBC"</span><span class="w">
   </span><span class="no">:subprotocol</span><span class="w"> </span><span class="s">"sqlite"</span><span class="w">
   </span><span class="no">:subname</span><span class="w">     </span><span class="s">":memory:"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"create table users (id integer)"</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from users"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [SQLITE_ERROR] SQL error or missing database (no such table: users)</span><span class="w">
</span></code></pre></div></div>

<p>Как мы помним, если в JDBC-спеке нет состояния, то каждый запрос протекает в новом соединении, которое тут же закрывается. Драйвер SQLite устроен так, что с закрытием соединения пропадает база, созданная в памяти. В примере выше мы создали и уничтожили две базы данных.</p>

<p>Чтобы все работало правильно, установим постоянное соединение. Для этого объявим переменную <code class="language-plaintext highlighter-rouge">db*</code> (со звездочкой), “заряженную” полем <code class="language-plaintext highlighter-rouge">:connection</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db</span><span class="w">
  </span><span class="p">{</span><span class="no">:classname</span><span class="w">   </span><span class="s">"org.sqlite.JDBC"</span><span class="w">
   </span><span class="no">:subprotocol</span><span class="w"> </span><span class="s">"sqlite"</span><span class="w">
   </span><span class="no">:subname</span><span class="w">     </span><span class="s">":memory:"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db*</span><span class="w">
  </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:connection</span><span class="w">
         </span><span class="p">(</span><span class="nf">jdbc/get-connection</span><span class="w"> </span><span class="n">db</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь запросы общаются с одной и той же базой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db*</span><span class="w"> </span><span class="s">"create table users (id integer)"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db*</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db*</span><span class="w"> </span><span class="s">"select * from users"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Эта оптимизация справедлива и для файловой версии. Если ее не сделать, на каждый запрос драйвер открывает и закрывает файл, что замедлит программу.</p>

<h2 id="сложные-типы">Сложные типы</h2>

<p>Когда драйвер читает данные, он приводит их типам языка, с которым вы работаете. Для простых типов, которые еще называют скалярными, эта связь очевидна: тип <code class="language-plaintext highlighter-rouge">int</code> становится условным <code class="language-plaintext highlighter-rouge">java.lang.Integer</code>, <code class="language-plaintext highlighter-rouge">varchar</code> и <code class="language-plaintext highlighter-rouge">text</code> становятся <code class="language-plaintext highlighter-rouge">java.lang.String</code> и так далее.</p>

<p>Гораздо интересней сложные типы, которые состоят из нескольких значений. К ним относятся точки на плоскости, географические объекты, хэш-таблицы, JSON. Нет четких правил о том, как сопоставить их представление в базе с типами Java, а если и есть, то они меняются от проекта к проекту.</p>

<p>Конечно, даже самый сложный объект можно хранить в виде строки. Для этого нужны две функции: привести объект к строке и восстановить его. Предположим, есть таблица платежей. У платежей может быть много полей: адреса отправителя и получателя, реквизиты банков и так далее. Чтобы не создавать колонку под каждое поле, обозначим только главные поля, а остальные данные запишем в виде JSON.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"CREATE TABLE payments (
  id SERIAL PRIMARY KEY,
  sum INTEGER,
  meta TEXT
)"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>В поле <code class="language-plaintext highlighter-rouge">meta</code> окажутся поля, для которых нет выделенных колонок. Подготовим функции для конвертации:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">cheshire.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">json</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">meta-&gt;str</span><span class="w"> </span><span class="p">[</span><span class="n">meta-info</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">json/generate-string</span><span class="w"> </span><span class="n">meta-info</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">str-&gt;meta</span><span class="w"> </span><span class="p">[</span><span class="n">db-string</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">json/parse-string</span><span class="w"> </span><span class="n">db-string</span><span class="w"> </span><span class="nb">keyword</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запишем в базу платеж с произвольными метаданными:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w">
 </span><span class="n">db</span><span class="w"> </span><span class="no">:payments</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="no">:sum</span><span class="w"> </span><span class="mi">99</span><span class="w">
  </span><span class="no">:meta</span><span class="w"> </span><span class="p">(</span><span class="nf">meta-&gt;str</span><span class="w"> </span><span class="p">{</span><span class="no">:date</span><span class="w"> </span><span class="s">"2021-03-10"</span><span class="w">
                    </span><span class="no">:from</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
                    </span><span class="no">:BIK</span><span class="w"> </span><span class="s">"332233"</span><span class="w">
                    </span><span class="no">:INN</span><span class="w"> </span><span class="s">"8626235235"</span><span class="p">})})</span><span class="w">
</span></code></pre></div></div>

<p>Вот как восстановить поле <code class="language-plaintext highlighter-rouge">:meta</code> после выборки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w">
      </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select * from payments"</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">row</span><span class="w"> </span><span class="n">result</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="no">:meta</span><span class="w"> </span><span class="n">str-&gt;meta</span><span class="p">)))</span><span class="w">

</span><span class="p">({</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="no">:sum</span><span class="w"> </span><span class="mi">99</span><span class="w">
  </span><span class="no">:meta</span><span class="w"> </span><span class="p">{</span><span class="no">:date</span><span class="w"> </span><span class="s">"2021-03-10"</span><span class="w">
         </span><span class="no">:from</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
         </span><span class="no">:BIK</span><span class="w"> </span><span class="s">"332233"</span><span class="w">
         </span><span class="no">:INN</span><span class="w"> </span><span class="s">"8626235235"</span><span class="p">}})</span><span class="w">
</span></code></pre></div></div>

<p>Недостаток в том, что функции <code class="language-plaintext highlighter-rouge">meta-&gt;str</code> и <code class="language-plaintext highlighter-rouge">str-&gt;meta</code> нужно вызывать каждый раз, когда мы пишем в базу объект или читаем его. Если забыть их, получим строку вместо объекта, что вызовет ошибку в дальнейшем коде. Кроме <code class="language-plaintext highlighter-rouge">meta</code>, в таблице могут быть другие поля с JSON, о которых нужно помнить.</p>

<p>Удачный подход в том, чтобы найти бутылочное горлышко, через которое проходят все данные от клиента в базу и обратно. Если изменить поведение там, функции <code class="language-plaintext highlighter-rouge">query</code>, <code class="language-plaintext highlighter-rouge">insert!</code> и другие сработают одинаково в любом месте проекта. JDBC предлагает такие горлышки для чтения и записи. Рассмотрим их на примере дат и JSON.</p>

<p>Проверим, что случится, если выбрать из базы дату. Для этого обратимся к переменной PostgreSQL с именем <code class="language-plaintext highlighter-rouge">current_timestamp</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"SELECT current_timestamp AS now"</span><span class="p">)</span><span class="w">
    </span><span class="nb">first</span><span class="w">
    </span><span class="no">:now</span><span class="w">
    </span><span class="n">type</span><span class="p">)</span><span class="w">

</span><span class="c1">;; java.sql.Timestamp</span><span class="w">
</span></code></pre></div></div>

<p>Тип значения будет <code class="language-plaintext highlighter-rouge">Timestamp</code>. Это класс-обертка над обычным <code class="language-plaintext highlighter-rouge">java.util.Date</code>, который учитывает особенности времени в SQL. Если мы хотим передать дату в параметрах, она тоже должна быть объектом <code class="language-plaintext highlighter-rouge">Timestamp</code>. Класс <code class="language-plaintext highlighter-rouge">Date</code> и другие вызовут ошибку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select ? as now"</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.util.Date</span><span class="p">)])</span><span class="w">

</span><span class="c1">;; Can't infer the SQL type to use for an instance of java.util.Date.</span><span class="w">
</span><span class="c1">;; Use setObject() with an explicit Types value to specify the type to use.</span><span class="w">
</span></code></pre></div></div>

<p>Класс <code class="language-plaintext highlighter-rouge">Timestamp</code> не совсем удобен в работе, особенно в бизнес-логике. Проекты на Java и Clojure используют более продвинутые типы времени, например библиотеку <a href="https://www.joda.org/joda-time/">Joda Time</a>. Рассмотрим, как подружить ее с JDBC.</p>

<p>Роль бутылочного горлышка играют протоколы <code class="language-plaintext highlighter-rouge">IResultSetReadColumn</code>, <code class="language-plaintext highlighter-rouge">ISQLParameter</code> и <code class="language-plaintext highlighter-rouge">ISQLValue</code>. Вместе они определяют, как обработать значение при чтении и записи. Протокол <code class="language-plaintext highlighter-rouge">IResultSetReadColumn</code> отвечает за чтение. Он реализует метод с тремя параметрами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">result-set-read-column</span><span class="w"> </span><span class="p">[</span><span class="nb">val</span><span class="w"> </span><span class="n">rsmeta</span><span class="w"> </span><span class="n">idx</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Аргументы:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">val</code>: исходное значение из базы;</li>
  <li><code class="language-plaintext highlighter-rouge">rsmeta</code>: метаданные результата, экземпляр класса <code class="language-plaintext highlighter-rouge">ResultSetMetaData</code>. Содержит сводную информацию о полях, именах и типах;</li>
  <li><code class="language-plaintext highlighter-rouge">idx</code>: индекс текущего поля (считается от нуля).</li>
</ul>

<p>При чтении результата JDBC прогоняет все значения через этот метод. По умолчанию протокол реализует <code class="language-plaintext highlighter-rouge">Object</code>, главный класс в дереве наследования. Для него функция <code class="language-plaintext highlighter-rouge">result-set-read-column</code> просто вернет <code class="language-plaintext highlighter-rouge">val</code>. Если не задано иное, значения останутся в том виде, в котором пришли из драйвера JDBC.</p>

<p>Изменим протокол так, чтобы для типа <code class="language-plaintext highlighter-rouge">Timestamp</code> получился экземпляр <code class="language-plaintext highlighter-rouge">DateTime</code> из библиотеки Joda Time. Для этого импортируем класс и расширим протокол:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="no">:import</span><span class="w"> </span><span class="n">org.joda.time.DateTime</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="n">jdbc/IResultSetReadColumn</span><span class="w">
  </span><span class="n">java.sql.Timestamp</span><span class="w">
  </span><span class="p">(</span><span class="nf">result-set-read-column</span><span class="w"> </span><span class="p">[</span><span class="nb">val</span><span class="w"> </span><span class="n">_rsmeta</span><span class="w"> </span><span class="n">_idx</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="p">(</span><span class="nf">.getTime</span><span class="w"> </span><span class="nb">val</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Поскольку параметры <code class="language-plaintext highlighter-rouge">rsmeta</code> и <code class="language-plaintext highlighter-rouge">idx</code> не нужны, предварим их подчеркиваниями. Из переменной <code class="language-plaintext highlighter-rouge">val</code> с типом <code class="language-plaintext highlighter-rouge">Timestamp</code> получим экземпляр <code class="language-plaintext highlighter-rouge">DateTime</code>. Проще всего это сделать передачей миллисекунд. Метод <code class="language-plaintext highlighter-rouge">getTime</code> класса <code class="language-plaintext highlighter-rouge">Timestamp</code> вернет их из <code class="language-plaintext highlighter-rouge">val</code>; далее передаем их в конструктор <code class="language-plaintext highlighter-rouge">DateTime</code>. Теперь любая дата, выбранная из базы, придет в новом виде. Проверим себя:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"SELECT current_timestamp AS now"</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:now</span><span class="w"> </span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">org.joda.time.DateTime</span><span class="w"> </span><span class="mi">0</span><span class="n">x49a269a4</span><span class="w"> </span><span class="s">"2021-07-22T10:23:51.136+03:00"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>С той же легкостью работает установка параметра. Для этой цели служит протокол <code class="language-plaintext highlighter-rouge">ISQLValue</code> и его метод <code class="language-plaintext highlighter-rouge">sql-value</code>. Он принимает значение и должен вернуть его JDBC-совместимый вариант. Если мы передали <code class="language-plaintext highlighter-rouge">DateTime</code>, на выходе должен быть <code class="language-plaintext highlighter-rouge">Timestamp</code>. Расширим протокол с обратным преобразованием:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="n">jdbc/ISQLValue</span><span class="w">
  </span><span class="n">DateTime</span><span class="w">
  </span><span class="p">(</span><span class="nf">sql-value</span><span class="w"> </span><span class="p">[</span><span class="nb">val</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.sql.Timestamp</span><span class="w"> </span><span class="p">(</span><span class="nf">.getMillis</span><span class="w"> </span><span class="nb">val</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Добавим в таблицу платежей поле с датой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"ALTER TABLE payments ADD COLUMN created_at TIMESTAMP WITH TIME ZONE"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Запишем дату, передав экземпляр <code class="language-plaintext highlighter-rouge">DateTime</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:payments</span><span class="w">
              </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:sum</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="no">:created_at</span><span class="w"> </span><span class="p">(</span><span class="nf">DateTime/now</span><span class="p">)})</span><span class="w">
</span></code></pre></div></div>

<p>Теперь любая работа с датами подразумевает Joda Time. Если понадобится другой тип даты, измените протокол. Предположим, вместо Joda Time вы предпочитаете встроенный класс <code class="language-plaintext highlighter-rouge">java.time.Instant</code>. Перепишите код так, чтобы база возвращала и принимала его экземпляры.</p>

<p>Третий протокол <code class="language-plaintext highlighter-rouge">ISQLParameter</code> полезен в случаях, когда установка параметра требует особых действий. По умолчанию JDBC вызывает метод <code class="language-plaintext highlighter-rouge">.setObject</code> подготовленного выражения, чего хватает в большинстве случаев. В будущем мы рассмотрим передачу массива в параметры, где вместо <code class="language-plaintext highlighter-rouge">.setObject</code> должен быть другой метод. Там мы и познакомимся с этим протоколом.</p>

<h3 id="организация-кода">Организация кода</h3>

<p>Расширение протокола не должно переплетаться с бизнес-логикой, поэтому держите его в отдельном модуле. Это глобальное действие, которое затрагивает всю среду исполнения. Сопоставление типов базы и языка меняется от проекта к проекту. В случае с датами будет правильно создать модули <code class="language-plaintext highlighter-rouge">project.time-joda</code> и <code class="language-plaintext highlighter-rouge">project.time-instant</code>. В зависимости от того, какой тип мы используем в проекте, подключим нужный модуль.</p>

<p>Импорт одного из этих модулей должен быть в коде, который загружается всегда, например в <code class="language-plaintext highlighter-rouge">.core</code>-модуле проекта. Добавьте комментарий о том, что импорт расширяет протокол:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">project.core</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="n">project.time-joda</span><span class="w"> </span><span class="c1">;; extends JDBC protocols</span><span class="w">
   </span><span class="p">[</span><span class="n">cheshire.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">json</span><span class="p">]</span><span class="w">
   </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Без комментария импорт станет неочевидным. Кажется, что модулем когда-то пользовались, но со временем забыли убрать из секции <code class="language-plaintext highlighter-rouge">:require</code>. Кто-то удалит импорт и столкнется со странным поведением базы. Если вы проверяете код линтером, добавьте пространство имен в список исключений. У линтера <a href="https://github.com/candid82/joker">Joker</a> опция называется <code class="language-plaintext highlighter-rouge">:ignored-unused-namespaces</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:ignored-unused-namespaces</span><span class="w"> </span><span class="p">[</span><span class="n">project.time-joda</span><span class="w">
                             </span><span class="n">...</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Теперь вы не получите предупреждения о том, что модуль <code class="language-plaintext highlighter-rouge">project.time-joda</code> подключен, но не используется в коде. Похожая настройка встречается в других линтерах.</p>

<p>В теле <code class="language-plaintext highlighter-rouge">:require</code> модули, которые изменяют состояние, обычно помещают без квадратных скобок и псевдонимов (имени после <code class="language-plaintext highlighter-rouge">:as</code>). Полезно отделить их пустой строкой от остальных, чтобы выделить на общем фоне.</p>

<h3 id="поддержка-json">Поддержка JSON</h3>

<p>Как видно из примеров с датами, управлять типами в JDBC нетрудно. Теперь мы добавим мощную функциональность: построим связь между типом JSON в PostgreSQL и Clojure. Для начала вспомним, в чем особенность JSON и где его применяют.</p>

<p><a href="https://www.json.org/json-en.html">JSON</a> — это запись данных на языке, близком к JavaScript. Кроме простых типов вроде чисел и строк, стандарт поддерживает коллекции — массивы и объекты — и их произвольную вложенность. С помощью JSON данные передают по сети и хранят в файлах. Формат используют для конфигурации приложений.</p>

<p>JSON полезен, когда у данных сложная структура, например глубокая вложенность. Раскладывать такие данные по таблицам и собирать обратно тяжело. Иногда проще записать JSON одну в колонку и позже восстановить данные в приложении.</p>

<p>Этот сценарий привел к тому, что базы научились работать с JSON своими силами. Для них JSON уже не строка, а сложный тип. Для примера запишем один и тот же объект с разным порядком ключей. Если сравнить две строки в лоб, получим ложь из-за отличия в символах:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="s1">'{"foo": 1, "bar": 2}'</span> <span class="o">=</span> <span class="s1">'{"bar": 2, "foo": 1}'</span><span class="p">;</span>
<span class="c1">-- false</span>
</code></pre></div></div>

<p>Если же указать строкам тип <code class="language-plaintext highlighter-rouge">jsonb</code>, получим истину, потому что порядок ключей в объектах не важен.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="s1">'{"foo": 1, "bar": 2}'</span><span class="p">::</span><span class="n">jsonb</span> <span class="o">=</span> <span class="s1">'{"bar": 2, "foo": 1}'</span><span class="p">::</span><span class="n">jsonb</span><span class="p">;</span>
<span class="c1">-- true</span>
</code></pre></div></div>

<p>Кроме сравнения, тип <code class="language-plaintext highlighter-rouge">json(b)</code> предлагает поиск по отдельному полю, объединение и пересечение объектов, массивов и многое другое. Почти любую операцию над JSON можно выполнить силами SQL, не прибегая к Clojure.</p>

<p>Предположим, поле <code class="language-plaintext highlighter-rouge">attributes</code> товара содержит JSON-объект с характеристиками, которые часто меняются:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">items</span> <span class="p">(</span><span class="n">id</span> <span class="nb">serial</span><span class="p">,</span> <span class="n">title</span> <span class="nb">text</span><span class="p">,</span> <span class="n">attrs</span> <span class="n">jsonb</span><span class="p">);</span>

<span class="k">insert</span> <span class="k">into</span> <span class="n">items</span> <span class="k">values</span>
  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Cap'</span><span class="p">,</span> <span class="s1">'{"size": "XL", "color": "red", "country": "China"}'</span><span class="p">);</span>

<span class="k">insert</span> <span class="k">into</span> <span class="n">items</span> <span class="k">values</span>
  <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Hoodie'</span><span class="p">,</span> <span class="s1">'{"size": "L", "color": "black", "country": "Germany"}'</span><span class="p">);</span>
</code></pre></div></div>

<p>Чтобы выбрать товары красного цвета, добавьте условие в запрос как в примере ниже. Оператор <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> означает извлечь поле <code class="language-plaintext highlighter-rouge">color</code> из объекта в виде текста.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="n">title</span> <span class="k">from</span> <span class="n">items</span> <span class="k">where</span> <span class="n">attrs</span><span class="o">-&gt;&gt;</span><span class="s1">'color'</span> <span class="o">=</span> <span class="s1">'red'</span><span class="p">;</span>

 <span class="n">id</span> <span class="o">|</span> <span class="n">title</span>
<span class="c1">----+-------</span>
  <span class="mi">1</span> <span class="o">|</span> <span class="n">Cap</span>
</code></pre></div></div>

<p>PostgreSQL поддерживает индексы для полей объектов. Если вы часто ищете товары цвету, добавьте следующий индекс, и скорость поиска возрастет:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CREATE</span><span class="w"> </span><span class="n">INDEX</span><span class="w"> </span><span class="n">idx_items_color</span><span class="w"> </span><span class="n">ON</span><span class="w"> </span><span class="n">items</span><span class="p">((</span><span class="nf">attrs-&gt;&gt;</span><span class="ss">'color</span><span class="o">'</span><span class="p">))</span><span class="c1">;</span><span class="w">
</span></code></pre></div></div>

<p>Тип <code class="language-plaintext highlighter-rouge">json(b)</code> полезен для хранения нечетких данных, чья структура меняется или от чего-то зависит. Один из примеров мы уже рассмотрели — это характеристики товаров. В зависимости от типа товара (техника, одежда, еда) у него могут быть самые разные характеристики. Если держать их в отдельной таблице, это породит лишние связи и таблицы-мосты, что усложнит запрос. Порой дешевле хранить их одним JSON-полем и проверять в приложении перед записью.</p>

<p>Другой случай, когда полезен JSON — в базе сложные и объемные документы. Это может быть бухгалтерский договор или история болезни. В виде JSON эти сущности занимают несколько экранов с глубокой вложенностью. Разложить их на отдельные таблицы стоит времени и сил; еще больше сил уйдет на запись и обновление. Проще хранить сущность как неделимый объект и изменять его целиком.</p>

<p>PostgreSQL поддерживает два типа JSON: одноименный (json) и с частичкой “b” на конце (jsonb). Последнее означает binary, двоичный JSON. Разница между типами в их устройстве. Тип json работает с данными наивно: он хранит исходную строку (с пробелами и переносами строк) и на каждую операцию разбирает ее. Наоборот, jsonb хранит данные в двоичном виде, что не требует разбора при обращении. Это снижает скорость записи, но ускоряет выборку. Скорее всего, вам подойдет jsonb: он поддерживает больше операций включая сравнение, что иногда необходимо.</p>

<p>Если выбрать из базы поле с типом JSON, получим загадочный <code class="language-plaintext highlighter-rouge">PGObject</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">attrs</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"SELECT * from items"</span><span class="p">)</span><span class="w">
      </span><span class="nb">first</span><span class="w">
      </span><span class="no">:attrs</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="n">attrs</span><span class="p">)</span><span class="w">
</span><span class="c1">;; org.postgresql.util.PGobject</span><span class="w">
</span></code></pre></div></div>

<p>Он служит для данных, свойственных PostgreSQL. У класса для поля: тип и значение в виде строки. Исследуем их:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">.getType</span><span class="w"> </span><span class="n">attrs</span><span class="p">)</span><span class="w">
</span><span class="c1">;; "jsonb"</span><span class="w">

</span><span class="p">(</span><span class="nf">.getValue</span><span class="w"> </span><span class="n">attrs</span><span class="p">)</span><span class="w">
</span><span class="c1">;; "{\"size\": \"XL\", \"color\": \"red\", \"country\": \"China\"}"</span><span class="w">
</span></code></pre></div></div>

<p>Кроме json(b), в <code class="language-plaintext highlighter-rouge">PGObject</code> могут быть данные другого типа, например сетевой адрес:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select '127.0.0.1'::inet as IP"</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:ip</span><span class="w"> </span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">org.postgresql.util.PGobject</span><span class="w"> </span><span class="mi">0</span><span class="n">x721ff1be</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Связь между <code class="language-plaintext highlighter-rouge">PGObject</code> и JDBC состоит из двух шагов. Во-первых, расширим протокол <code class="language-plaintext highlighter-rouge">IResultSetReadColumn</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="n">jdbc/IResultSetReadColumn</span><span class="w">
  </span><span class="n">org.postgresql.util.PGobject</span><span class="w">
  </span><span class="p">(</span><span class="nf">result-set-read-column</span><span class="w"> </span><span class="p">[</span><span class="n">pg-obj</span><span class="w"> </span><span class="n">_rsmeta</span><span class="w"> </span><span class="n">_idx</span><span class="p">]</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Пока что не ясно, что следует за многоточием. Как мы выяснили, <code class="language-plaintext highlighter-rouge">PGobject</code> служит для разных типов. Проверим тип поля и для каждого варианта вызовем свой обработчик. Проще всего это сделать оператором <code class="language-plaintext highlighter-rouge">case</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="n">jdbc/IResultSetReadColumn</span><span class="w">
  </span><span class="n">org.postgresql.util.PGobject</span><span class="w">
  </span><span class="p">(</span><span class="nf">result-set-read-column</span><span class="w"> </span><span class="p">[</span><span class="n">pg-obj</span><span class="w"> </span><span class="n">_rsmeta</span><span class="w"> </span><span class="n">_idx</span><span class="p">]</span><span class="w">

    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pg-val</span><span class="w"> </span><span class="p">(</span><span class="nf">.getValue</span><span class="w"> </span><span class="n">pg-obj</span><span class="p">)</span><span class="w">
          </span><span class="n">pg-type</span><span class="w"> </span><span class="p">(</span><span class="nf">.getType</span><span class="w"> </span><span class="n">pg-obj</span><span class="p">)]</span><span class="w">

      </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">pg-type</span><span class="w">
        </span><span class="p">(</span><span class="s">"json"</span><span class="w"> </span><span class="s">"jsonb"</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">json/parse-string</span><span class="w"> </span><span class="n">pg-val</span><span class="w"> </span><span class="nb">keyword</span><span class="p">)</span><span class="w">

        </span><span class="s">"inet"</span><span class="w">
        </span><span class="p">(</span><span class="nf">java.net.InetAddress/getByName</span><span class="w"> </span><span class="n">pg-val</span><span class="p">)</span><span class="w">

        </span><span class="c1">;; else</span><span class="w">
        </span><span class="n">pg-obj</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что реализации <code class="language-plaintext highlighter-rouge">json</code> и <code class="language-plaintext highlighter-rouge">jsonb</code> совпадают: в обоих случаях база вернет строку, которую парсим библиотекой <a href="https://github.com/dakrone/cheshire">Chesire</a>. Проверим теперь, что типы читаются верно:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"SELECT * from items"</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Cap"</span><span class="n">,</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:size</span><span class="w"> </span><span class="s">"XL"</span><span class="n">,</span><span class="w"> </span><span class="no">:color</span><span class="w"> </span><span class="s">"red"</span><span class="n">,</span><span class="w"> </span><span class="no">:country</span><span class="w"> </span><span class="s">"China"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Для сетевого адреса получим экземпляр <code class="language-plaintext highlighter-rouge">Inet4Address</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select '127.0.0.1'::inet as IP"</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:ip</span><span class="w"> </span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">java.net.Inet4Address</span><span class="w"> </span><span class="mi">0</span><span class="n">x38d6ba76</span><span class="w"> </span><span class="s">"/127.0.0.1"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Форма <code class="language-plaintext highlighter-rouge">case</code> выше не совсем удобна: если понадобится новый тип, придется дописывать что-то в хвост. Потребители вашего кода не смогут это сделать. Возможен более гибкий подход: мультиметод <code class="language-plaintext highlighter-rouge">pg-&gt;clojure</code>, чья функция-диспетчер возвращает тип поля:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmulti</span><span class="w"> </span><span class="n">pg-&gt;clojure</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">pg-obj</span><span class="p">]</span><span class="w">
                        </span><span class="p">(</span><span class="nf">.getValue</span><span class="w"> </span><span class="n">pg-obj</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь код <code class="language-plaintext highlighter-rouge">result-set-read-column</code> сводится к вызову мультиметода:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">result-set-read-column</span><span class="w"> </span><span class="p">[</span><span class="n">pg-obj</span><span class="w"> </span><span class="n">_rsmeta</span><span class="w"> </span><span class="n">_idx</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">pg-&gt;clojure</span><span class="w"> </span><span class="n">pg-obj</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Расширьте мультиметод типами <code class="language-plaintext highlighter-rouge">json</code> и сетевым адресом. Со временем мы добавим в него другие типы.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">pg-&gt;clojure</span><span class="w"> </span><span class="s">"json"</span><span class="w">
  </span><span class="p">[</span><span class="n">pg-obj</span><span class="p">]</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">pg-&gt;clojure</span><span class="w"> </span><span class="s">"inet"</span><span class="w">
  </span><span class="p">[</span><span class="n">pg-obj</span><span class="p">]</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h3 id="запись-json">Запись JSON</h3>

<p>Теперь когда мы читаем JSON из базы, позаботимся о записи. Для этого расширим протокол <code class="language-plaintext highlighter-rouge">jdbc/ISQLValue</code> так, чтобы любая коллекция Clojure становилась объектом <code class="language-plaintext highlighter-rouge">PGobject</code>. Но сперва уточним, что имеем в виду под термином “любая коллекция”.</p>

<p>Протоколы в Clojure устроены на базе интерфейсов и иерархии классов. Если мы хотим, чтобы вектор и словарь отзывались на какое-то действие, нужно найти общий интерфейс и расширить его протоколом. Чтобы увидеть интерфейсы, которые реализует коллекция, выполните выражение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">supers</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">{}))</span><span class="w">

</span><span class="o">#</span><span class="p">{</span><span class="n">clojure.lang.IMeta</span><span class="w">
  </span><span class="n">java.lang.Runnable</span><span class="w">
  </span><span class="n">java.io.Serializable</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="n">clojure.lang.IPersistentCollection</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Вы получите множество интерфейсов Java. Среди прочих нас интересует последний элемент, <code class="language-plaintext highlighter-rouge">IPersistentCollection</code>. Он же встречается в <code class="language-plaintext highlighter-rouge">supers</code> для типа вектора, списка и последовательности:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">supers</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">[]))</span><span class="w">
</span><span class="p">(</span><span class="nf">supers</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">()))</span><span class="w">
</span><span class="p">(</span><span class="nf">supers</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Расширим <code class="language-plaintext highlighter-rouge">ISQLValue</code> этим протоколом, чтобы Clojure-коллекция становилась объектом <code class="language-plaintext highlighter-rouge">PGobject</code> с типом <code class="language-plaintext highlighter-rouge">jsonb</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="n">jdbc/ISQLValue</span><span class="w">
  </span><span class="n">clojure.lang.IPersistentCollection</span><span class="w">
  </span><span class="p">(</span><span class="nf">sql-value</span><span class="w"> </span><span class="p">[</span><span class="nb">val</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">doto</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">org.postgresql.util.PGobject</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">.setType</span><span class="w"> </span><span class="s">"jsonb"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">.setValue</span><span class="w"> </span><span class="p">(</span><span class="nf">json/generate-string</span><span class="w"> </span><span class="nb">val</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь атрибуты товара можно задать словарем:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:items</span><span class="w">
              </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">5</span><span class="w">
               </span><span class="no">:title</span><span class="w"> </span><span class="s">"The Catcher in the Rye"</span><span class="w">
               </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:author</span><span class="w"> </span><span class="s">"J. D. Salinger"</span><span class="w">
                       </span><span class="no">:genre</span><span class="w"> </span><span class="s">"novel"</span><span class="w">
                       </span><span class="no">:year</span><span class="w"> </span><span class="mi">1951</span><span class="p">}})</span><span class="w">
</span></code></pre></div></div>

<p>То же самое методом <code class="language-plaintext highlighter-rouge">execute!</code>: поместим словарь в вектор SQL:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"INSERT INTO items VALUES (?, ?, ?)"</span><span class="w">
               </span><span class="mi">5</span><span class="w">
               </span><span class="s">"The Catcher in the Rye"</span><span class="w">
               </span><span class="p">{</span><span class="no">:year</span><span class="w"> </span><span class="mi">1951</span><span class="w"> </span><span class="no">:genre</span><span class="w"> </span><span class="s">"novel"</span><span class="w"> </span><span class="no">:author</span><span class="w"> </span><span class="s">"J. D. Salinger"</span><span class="p">}])</span><span class="w">
</span></code></pre></div></div>

<p>Предположим, мы храним теги товара — короткие строки с его описанием. Проще всего это сделать полем <code class="language-plaintext highlighter-rouge">tags</code> с типом <code class="language-plaintext highlighter-rouge">jsonb</code>, в который запишем вектор строк:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">alter</span> <span class="k">table</span> <span class="n">items</span> <span class="k">add</span> <span class="k">column</span> <span class="n">tags</span> <span class="n">jsonb</span><span class="p">;</span>
</code></pre></div></div>

<p>Обновим теги у только что созданной книги:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/update!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:items</span><span class="w">
              </span><span class="p">{</span><span class="no">:tags</span><span class="w"> </span><span class="p">[</span><span class="s">"book"</span><span class="w"> </span><span class="s">"novel"</span><span class="p">]}</span><span class="w">
              </span><span class="p">[</span><span class="s">"id = ?"</span><span class="w"> </span><span class="mi">5</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>и прочитаем ее:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/get-by-id</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:items</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">5</span><span class="w">
 </span><span class="no">:title</span><span class="w"> </span><span class="s">"The Catcher in the Rye"</span><span class="w">
 </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:year</span><span class="w"> </span><span class="mi">1951</span><span class="w"> </span><span class="no">:genre</span><span class="w"> </span><span class="s">"novel"</span><span class="w"> </span><span class="no">:author</span><span class="w"> </span><span class="s">"J. D. Salinger"</span><span class="p">}</span><span class="w">
 </span><span class="no">:tags</span><span class="w"> </span><span class="p">(</span><span class="s">"book"</span><span class="w"> </span><span class="s">"novel"</span><span class="p">)}</span><span class="w">
</span></code></pre></div></div>

<p>Технически возможно записать в теги словарь, а в атрибуты — список. С точки зрения базы у обоих значений тип json, поэтому ошибки нет. Чтобы этого избежать, проверяйте данные до записи в базу. Проще всего это сделать функцией <code class="language-plaintext highlighter-rouge">insert-item</code>, которая сверяет аргументы по спеке.</p>

<p>Для начала объявим спеку полей таблицы <code class="language-plaintext highlighter-rouge">items</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">​​</span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.spec.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::item-fields</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">::id</span><span class="w"> </span><span class="no">::title</span><span class="p">]</span><span class="w">
          </span><span class="no">:opt-un</span><span class="w"> </span><span class="p">[</span><span class="no">::attrs</span><span class="w"> </span><span class="no">::tags</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Расширим поля атрибутов и тегов:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::attrs</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/map-of</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="n">any?</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::tags</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/coll-of</span><span class="w"> </span><span class="nb">string?</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>В функции <code class="language-plaintext highlighter-rouge">insert-item</code> мы задали <code class="language-plaintext highlighter-rouge">pre</code>-выражение, в котором проверяем поля спекой макросом <code class="language-plaintext highlighter-rouge">s/assert</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">insert-item</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">fields</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:pre</span><span class="w"> </span><span class="p">[(</span><span class="nf">s/assert</span><span class="w"> </span><span class="no">::item-fields</span><span class="w"> </span><span class="n">fields</span><span class="p">)]}</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:items</span><span class="w"> </span><span class="n">fields</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>По умолчанию <code class="language-plaintext highlighter-rouge">s/assert</code> ничего не делает, потому что предназначен для отладки. Включите его выражением:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/check-asserts</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Вызовите функцию с неправильными полями:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">insert-item</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">5</span><span class="w">
                 </span><span class="no">:title</span><span class="w"> </span><span class="s">"The Catcher in the Rye"</span><span class="w">
                 </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:author</span><span class="w"> </span><span class="s">"J. D. Salinger"</span><span class="w">
                         </span><span class="no">:genre</span><span class="w"> </span><span class="s">"novel"</span><span class="w">
                         </span><span class="no">:year</span><span class="w"> </span><span class="mi">1951</span><span class="p">}</span><span class="w">
                 </span><span class="no">:tags</span><span class="w"> </span><span class="p">[</span><span class="s">"book"</span><span class="w"> </span><span class="s">"novel"</span><span class="w"> </span><span class="n">nil</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Вы получите ошибку спеки, и записи не произойдет. То же самое можно сделать макросом <code class="language-plaintext highlighter-rouge">fdef</code> и функцией <code class="language-plaintext highlighter-rouge">instrument</code> из модуля спеки. Мы подробно разобрали эти возможности во второй главе первой книги . Обратитесь к ней, если вам не понятны термины, о которых мы говорим.</p>

<h3 id="проблема-nil-в-json">Проблема nil в JSON</h3>

<p>При записи JSON проверяйте значение на <code class="language-plaintext highlighter-rouge">nil</code>. Если этого не делать, произойдет следующее: значение <code class="language-plaintext highlighter-rouge">nil</code> станет строкой <code class="language-plaintext highlighter-rouge">"null"</code> и займет место в базе. Это чревато странным поведением в запросах. Предположим, вы ищете записи с пустыми атрибутами. Если выполнить запрос:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">id</span> <span class="k">from</span> <span class="n">items</span> <span class="k">where</span> <span class="n">attrs</span> <span class="k">is</span> <span class="k">null</span>
</code></pre></div></div>

<p>, в результате не будет строк с полем <code class="language-plaintext highlighter-rouge">attrs</code>, равным <code class="language-plaintext highlighter-rouge">"null"</code>, потому что это значение <code class="language-plaintext highlighter-rouge">json(b)</code>, отличное от <code class="language-plaintext highlighter-rouge">NULL</code>. Другими словами, вы ввели новое пустое значение. С ним проверка выглядит сложнее:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">id</span> <span class="k">from</span> <span class="n">items</span> <span class="k">where</span> <span class="n">attrs</span> <span class="k">is</span> <span class="k">null</span> <span class="k">or</span> <span class="n">attrs</span> <span class="o">=</span> <span class="s1">'null'</span><span class="p">;</span>
</code></pre></div></div>

<p>Очевидно, первый запрос удобней, особенно если <code class="language-plaintext highlighter-rouge">json(b)</code> встречается в разных таблицах. Следите, чтобы пустое значение было выражено одним способом. Лучше всего для этого подходит стандартный <code class="language-plaintext highlighter-rouge">NULL</code>. С точки зрения Clojure это значит, что функция <code class="language-plaintext highlighter-rouge">-&gt;pg-object</code> возвращает <code class="language-plaintext highlighter-rouge">PGObject</code> только если исходное значение не <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>Для начала проверим текущее поведение в случае с <code class="language-plaintext highlighter-rouge">nil</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;pg-object</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">

</span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">org.postgresql.util.PGobject</span><span class="w"> </span><span class="mi">0</span><span class="n">x7c24e232</span><span class="w"> </span><span class="s">"null"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Получим <code class="language-plaintext highlighter-rouge">PGobject</code> с <code class="language-plaintext highlighter-rouge">"null"</code>, что нас не устраивает. С проверкой аргумента на <code class="language-plaintext highlighter-rouge">some?</code> получим <code class="language-plaintext highlighter-rouge">nil</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-&gt;pg-object</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nf">some?</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">doto</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">PGobject</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">.setType</span><span class="w"> </span><span class="s">"json"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">.setValue</span><span class="w"> </span><span class="p">(</span><span class="nf">json/generate-string</span><span class="w"> </span><span class="n">data</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="nf">-&gt;pg-object</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w"> </span><span class="c1">;; nil</span><span class="w">
</span></code></pre></div></div>

<p>Колонка в базе должна иметь атрибут <code class="language-plaintext highlighter-rouge">NULL</code>, установленный в истину.</p>

<h3 id="типизированные-записи">Типизированные записи</h3>

<p>Мы установили правило: при передаче параметров любая коллекция становится объектом JSON. Однако PostgreSQL предлагает другие сложные типы, например точки, линии и прямоугольники. Рассмотрим, что вернет база данных, если выбрать точку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select '(1, 2)'::point"</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:point</span><span class="w"> </span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">org.postgresql.geometric.PGpoint</span><span class="w"> </span><span class="mi">0</span><span class="n">x28ebf39e</span><span class="w"> </span><span class="s">"(1.0,2.0)"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Получим объект класса <code class="language-plaintext highlighter-rouge">PGpoint</code>. Логично привести его в словарю <code class="language-plaintext highlighter-rouge">{:x 1.0, :y 2.0}</code>, чтобы упростить дальнейшую работу. Однако при записи точки словарь будет преобразован в JSON, из-за чего получим ошибку типов.</p>

<p>Наиболее простое решение в том, чтобы задать типизированную запись, или рéкорд. Запись повторяет свойства словаря и вдобавок объявляет Java-класс. Если расширить протокол JDBC этим классом, мы сохраним функциональность JSON, потому что класс стоит ниже протокола <code class="language-plaintext highlighter-rouge">IPersistentCollection</code> в цепочке наследников.</p>

<p>Объявим запись с двумя слотами координат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Расширим протокол <code class="language-plaintext highlighter-rouge">IResultSetReadColumn</code> типом <code class="language-plaintext highlighter-rouge">PGpoint</code>. Импортируем его, чтобы не указывать весь путь. Метод <code class="language-plaintext highlighter-rouge">result-set-read-column</code> вернет экземпляр <code class="language-plaintext highlighter-rouge">Point</code> с заполненными слотами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="ss">'org.postgresql.geometric.PGpoint</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="n">jdbc/IResultSetReadColumn</span><span class="w">
  </span><span class="n">PGpoint</span><span class="w">
  </span><span class="p">(</span><span class="nf">result-set-read-column</span><span class="w"> </span><span class="p">[</span><span class="n">pg-point</span><span class="w"> </span><span class="n">_rsmeta</span><span class="w"> </span><span class="n">_idx</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">(</span><span class="nf">.-x</span><span class="w"> </span><span class="n">pg-point</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">.-y</span><span class="w"> </span><span class="n">pg-point</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь точка приходит из базы в удобном виде. При печати она выглядит как словарь, но на самом деле это экземпляр записи.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select '(1, 2)'::point"</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:point</span><span class="w"> </span><span class="p">{</span><span class="no">:x</span><span class="w"> </span><span class="mf">1.0</span><span class="n">,</span><span class="w"> </span><span class="no">:y</span><span class="w"> </span><span class="mf">2.0</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Расширим <code class="language-plaintext highlighter-rouge">ISQLValue</code> для перевода точки в тип JDBC. Обратите внимание: поскольку запись ведет себя как словарь, мы распаковали поля <code class="language-plaintext highlighter-rouge">x</code> и <code class="language-plaintext highlighter-rouge">y</code> на уровне сигнатуры.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="n">jdbc/ISQLValue</span><span class="w">
  </span><span class="n">Point</span><span class="w">
  </span><span class="p">(</span><span class="nf">sql-value</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]}]</span><span class="w">
    </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">PGpoint</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Передать точку в запрос можно несколькими способами. Первый — вызвать конструктор класса оператором <code class="language-plaintext highlighter-rouge">new</code>. Второй — получить запись из словаря функцией <code class="language-plaintext highlighter-rouge">map-&gt;&lt;RecordName&gt;</code>. Функция находится в том же пространстве имен, где объявлена запись. Третий способ — предварить словарь тегом с полным именем записи. Все три способа вернут экземпляр <code class="language-plaintext highlighter-rouge">Point</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select ? as point"</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)])</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select ? as point"</span><span class="w"> </span><span class="p">(</span><span class="nf">map-&gt;Point</span><span class="w"> </span><span class="p">{</span><span class="no">:x</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:y</span><span class="w"> </span><span class="mi">2</span><span class="p">})])</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select ? as point"</span><span class="w"> </span><span class="o">#</span><span class="n">book.db.Point</span><span class="p">{</span><span class="no">:x</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:y</span><span class="w"> </span><span class="mi">2</span><span class="p">}])</span><span class="w">
</span></code></pre></div></div>

<p>По аналогии сопоставьте другие типы с записями Clojure, например линии и прямоугольники (<code class="language-plaintext highlighter-rouge">line</code> и <code class="language-plaintext highlighter-rouge">box</code>).</p>

<h2 id="проблемы-sql">Проблемы SQL</h2>

<p>Каждый, кто работает с базой данных, сталкивается с проблемой: длинный SQL затрудняет чтение кода. Блоки SQL разрывают логику приложения и порождают визуальный шум.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">events</span><span class="w"> </span><span class="p">(</span><span class="nf">get-events</span><span class="w"> </span><span class="n">http-client</span><span class="p">)</span><span class="w">
      </span><span class="n">sql</span><span class="w"> </span><span class="s">"select * from users u
join profiles p on p.user_id = u.id
where u.is_active
and p.created_at &gt; ..."</span><span class="w">
      </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">sql</span><span class="p">)]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Большие запросы в коде смотрятся чужеродно. При чтении приходится переключать контекст, чтобы понять, что происходит в запросе. Ситуация ухудшается с копированием: часто необходим такой же запрос, но с небольшими правками. Это усложнит поддержку, ведь однажды критерии выборки могут измениться для всех запросов.</p>

<p>Предположим, в какой-то момент в таблице появился флаг отложенного удаления. Пользователь закрыл учетную запись, и нужно удалить ее из системы. Теперь при выборке пользователя нужно добавить условие “не удален”:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SELECT</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="n">AND</span><span class="w"> </span><span class="n">NOT</span><span class="w"> </span><span class="n">is_deleted</span><span class="w">
</span></code></pre></div></div>

<p>Если запрос многократно копирован по всему проекту, придется искать все случаи и дописывать каждому <code class="language-plaintext highlighter-rouge">AND NOT is_deleted</code>.</p>

<p>SQL-выражения со временем растут. На старте проекта в нем мало сущностей и таблиц, но с ростом бизнеса их число увеличивается. Например, выборка популярных товаров с их категориями, оценками и сортировкой может занять экран. Если вставить подобный SQL прямо в код, станет тяжелее поддерживать и код, и SQL.</p>

<p>Мы подводим читателя к вопросу о том, как управлять запросами в промышленных масштабах. В разных языках приняты разные подходы. Наиболее популярен способ с промежуточным слоем, который преобразует объекты в записи таблиц. Например, запрос к таблице <code class="language-plaintext highlighter-rouge">users</code> вернет список объектов <code class="language-plaintext highlighter-rouge">User</code>, который еще называют моделью. Если изменить поля модели и вызвать метод <code class="language-plaintext highlighter-rouge">.save()</code>, сработает либо запрос <code class="language-plaintext highlighter-rouge">UPDATE</code> (обновить текущую запись) или <code class="language-plaintext highlighter-rouge">INSERT</code> (добавить новую запись).</p>

<p>Сопоставление таблиц и объектов называется <a href="https://ru.wikipedia.org/wiki/ORM">ORM</a> (Object–relational mapping). Встречается его разновидность <a href="https://ru.wikipedia.org/wiki/ActiveRecord">ActiveRecord</a> (сокращенно AR). Как правило, любой современный язык предлагает библиотеки для ORM или AR.</p>

<p>Попытки создать ORM были и в Clojure, но они не получили широкого распространения. Практика показывает, что в Clojure легко работать с базой на низкому ровне. Причина в том, что коллекции Clojure <em>уже</em> обладают важными свойствами: они неизменяемы и на них действуют сотни функций стандартной библиотеки. В Clojure список словарей достаточен для дальнейшей работы, и нет смысла приводить их к другим сущностям.</p>

<p>Все-таки работу с SQL можно облегчить, подключив библиотеки. Мы рассмотрим построители запросов на шаблонах и данных: их особенности, преимущества и недостатки.</p>

<h3 id="шаблоны">Шаблоны</h3>

<p>Подход с шаблоном состоит из двух этапов. Сначала создают файл с расширением <code class="language-plaintext highlighter-rouge">.sql</code> и пишут в нем запросы. Каждый запрос предваряется шапкой из нескольких комментариев. В них указаны имя запроса, описание и характеристики. На месте параметров стоят именованные метки. Пример подобного файла:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :name list-users :?</span>
<span class="c1">-- :doc Get all the users</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span><span class="p">;</span>

<span class="c1">-- :name get-user-by-id :? :1</span>
<span class="c1">-- :doc Get a single user by ID</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span>
<span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Специальный код читает этот файл. Для каждого запроса он порождает одноименную функцию, которая принимает JDBC-спеку и словарь параметров. Результат запроса станет результатом функции при вызове. Так, для запроса <code class="language-plaintext highlighter-rouge">get-user-by-id</code> получим функцию, вызвав которую с подключением и параметром, увидим результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">

</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="n">...</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Способ с SQL, который порождает функции, несет несколько преимуществ. Прежде всего, в проекте единый источник SQL. Все запросы собраны в одном файле, и не нужно искать их по всей кодовой базе.</p>

<p>Некоторые фирмы проводят аудит запросов к базам данных, чтобы выявить узкие места. DBA-инженеру будет удобно посмотреть .sql файл и оптимизировать его. Если же вы обращаетесь к базе с помощью ORM, придется искать конечные запросы в логах базы. При этом запросы, составленные программой, читаются хуже, чем написанные человеком.</p>

<p>Если потребуется особый оператор, например слияние JSON-объектов или пересечение интервалов, вы напишете его явно. В случае с ORM придется расширить класс или писать какую-то обертку.</p>

<p>Запросы в исходном виде удобны для отладки. Если вы написали выборку с помощью ORM, то должны убедиться, что она порождает верный SQL. Нужно вызвать уловный объект <code class="language-plaintext highlighter-rouge">QuerySet</code> и проверить логи базы. С сырым SQL этот шаг отпадает: его можно выполнить в PGAdmin или схожей программе с минимальными усилиями.</p>

<p>Принцип “SQL на шаблонах” предлагает библиотека <a href="https://www.hugsql.org/">HugSQL</a>. Подключите ее в проект (понадобится свежая версия <code class="language-plaintext highlighter-rouge">tools.reader</code>):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">org.clojure/tools.reader</span><span class="w"> </span><span class="s">"1.3.6"</span><span class="p">]</span><span class="w">
</span><span class="p">[</span><span class="n">com.layerware/hugsql</span><span class="w"> </span><span class="s">"0.5.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Будем работать с пользователями. Создайте файл <code class="language-plaintext highlighter-rouge">resources/sql/queries.sql</code> с запросами:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :name list-users :?</span>
<span class="c1">-- :doc Get all the users</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span><span class="p">;</span>

<span class="c1">-- :name get-user-by-id :? :1</span>
<span class="c1">-- :doc Get a single user by ID</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span>
<span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Параметр <code class="language-plaintext highlighter-rouge">:name</code> означает имя будущей функции. По желанию добавьте <code class="language-plaintext highlighter-rouge">:doc</code> с описанием, и тогда редактор покажет справку в месте вызова. Особенно интересны параметры <code class="language-plaintext highlighter-rouge">:?</code> и <code class="language-plaintext highlighter-rouge">:1</code>, что указаны после <code class="language-plaintext highlighter-rouge">:name</code>. Это флаги, которые определяют, как обработать запрос и его результат.</p>

<p>Знак вопроса означает, что запрос следует выполнить функцией <code class="language-plaintext highlighter-rouge">jdbc/query</code>. Библиотека JDBC отличает чтение от исполнения. Чтение предполагает обработку результата, в то время как для исполнения его может либо не быть, либо он нам не интересен. Поэтому указываем <code class="language-plaintext highlighter-rouge">:?</code> в запросах на чтение.</p>

<p>Флаги <code class="language-plaintext highlighter-rouge">:*</code> и <code class="language-plaintext highlighter-rouge">:1</code> означают сколько записей прочитать из ответа: все или одну. Когда мы ищем заведомо одну запись, логично указать <code class="language-plaintext highlighter-rouge">:1</code>, чтобы получить либо ее, либо ничего. В противном случае вам придется оборачивать результат в <code class="language-plaintext highlighter-rouge">(first...)</code>, что неудобно. Если не задана единица, по умолчанию получим все записи.</p>

<p>Преобразуем запросы в функции. Вызов <code class="language-plaintext highlighter-rouge">def-db-fns</code> принимает путь к файлу и наполняет текущее пространство новыми функциями.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">hugsql.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">hugsql</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">hugsql/def-db-fns</span><span class="w"> </span><span class="s">"sql/queries.sql"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Выполним их:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">list-users</span><span class="w"> </span><span class="n">db</span><span class="p">)</span><span class="w">
</span><span class="c1">;; ({:id 1 :fname "Ivan", ...}, ...)</span><span class="w">

</span><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span><span class="c1">;; {:id 1 :fname "Ivan", ...}</span><span class="w">
</span></code></pre></div></div>

<p>Подготовим вставку пользователей:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :name create-user :i!</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">users</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">lname</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>
<span class="k">values</span> <span class="p">(:</span><span class="n">fname</span><span class="p">,</span> <span class="p">:</span><span class="n">lname</span><span class="p">,</span> <span class="p">:</span><span class="n">email</span><span class="p">,</span> <span class="p">:</span><span class="n">age</span><span class="p">);</span>
</code></pre></div></div>

<p>После изменений в файле сгенерируйте функции еще раз. Появится новая функция <code class="language-plaintext highlighter-rouge">create-user</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">create-user</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ioann"</span><span class="w">
                 </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Smith"</span><span class="w">
                 </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
                 </span><span class="no">:age</span><span class="w"> </span><span class="mi">30</span><span class="p">})</span><span class="w">
</span><span class="c1">;; {:id 76, :fname "Ioann", ...}</span><span class="w">
</span></code></pre></div></div>

<p>Флаг <code class="language-plaintext highlighter-rouge">:i!</code> служит для оператора <code class="language-plaintext highlighter-rouge">INSERT</code>. Он означает вернуть первичные ключи записей, которые произвела база данных. Схожий флаг <code class="language-plaintext highlighter-rouge">:&lt;!</code> работает с выражением вида <code class="language-plaintext highlighter-rouge">INSERT ... RETURNING ...</code>, что значит “вставить и вернуть”. Она полезна, когда полям таблицы заданы значения по умолчанию.</p>

<p>Эти и другие флаги служат синтаксическим сахаром для параметра <code class="language-plaintext highlighter-rouge">:command</code>. Если вам трудно запомнить флаги, укажите их явно:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">:command :query</code></li>
  <li><code class="language-plaintext highlighter-rouge">:command :insert</code></li>
  <li><code class="language-plaintext highlighter-rouge">:command :execute</code></li>
  <li><code class="language-plaintext highlighter-rouge">:command :returning-execute</code></li>
</ul>

<p>Чтобы создать несколько записей в транзакции, обернем функции в макрос <code class="language-plaintext highlighter-rouge">with-db-transaction</code> и укажем <code class="language-plaintext highlighter-rouge">tx</code> первым аргументом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/with-db-transaction</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">create-user</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"User1"</span><span class="w"> </span><span class="n">...</span><span class="p">})</span><span class="w">
  </span><span class="p">(</span><span class="nf">create-user</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="p">{</span><span class="no">:fname</span><span class="w"> </span><span class="s">"User2"</span><span class="w"> </span><span class="n">...</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>HugSQL упрощает работу с параметрами. JDBC принимает вектор параметров, и чем их больше, тем сложнее понять, что означает каждый. HugSQL полагается на кейворды и словари в качестве параметров. По ключу легко понять семантику значения, и на него можно сослаться в разных местах запроса.</p>

<p>HugSQL предлагает множество полезных функций. Среди прочих отметим сниппеты — повторяющиеся участки кода. Если один и тот же фрагмент SQL встречается много раз, его задают отдельно и позже ссылаются на него. Предположим, мы хотим контролировать, какие поля пользователя вернет запрос. Объявим их тегом <code class="language-plaintext highlighter-rouge">:snip</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :snip user-fields</span>
<span class="n">id</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">lname</span>
</code></pre></div></div>

<p>Запрос на выборку пользователя изменится. Вместо звездочки (все поля) укажем <code class="language-plaintext highlighter-rouge">:snip:user-fields</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :name get-user-by-id :? :1</span>
<span class="c1">-- :doc Get a single user by ID</span>
<span class="k">select</span> <span class="p">:</span><span class="n">snip</span><span class="p">:</span><span class="k">user</span><span class="o">-</span><span class="n">fields</span> <span class="k">from</span> <span class="n">users</span>
<span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Чтобы выполнить запрос, передайте в параметр <code class="language-plaintext highlighter-rouge">:user-fields</code> вызов сниппета. Так мы получим только те поля, что объявили.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:user-fields</span><span class="w"> </span><span class="p">(</span><span class="nf">user-fields</span><span class="p">)})</span><span class="w">

</span><span class="c1">;; {:id 1, :fname "Ivan", :lname "Petrov"}</span><span class="w">
</span></code></pre></div></div>

<p>В сниппете может быть что угодно: набор <code class="language-plaintext highlighter-rouge">WHERE</code>-условий, постраничная навигация с помощью <code class="language-plaintext highlighter-rouge">LIMIT</code> и <code class="language-plaintext highlighter-rouge">OFFSET</code> и так далее. Однако помните, что чем больше взапросе сниппетов, тем менее он декларативен. С ними вы теряете преимущества чистого SQL, о которых мы говорили.</p>

<h3 id="выражения">Выражения</h3>

<p>Еще одна важная функция HugSQL — это шаблонная система в запросах. С помощью особого синтаксиса в запрос можно добавить код на Clojure, который “склеивает” его части. Прием полезен, когда запрос меняется в зависимости от параметров.</p>

<p>Предположим, мы пишем поиск пользователей. В отборе участвуют несколько полей: имя, город, год рождения, при этом обязательно только имя. В этом случае мы не можем составить запрос как в примере ниже:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :name find-users :?</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span>
<span class="k">WHERE</span> <span class="n">fname</span> <span class="o">=</span> <span class="p">:</span><span class="n">name</span>
  <span class="k">AND</span> <span class="n">city</span> <span class="o">=</span> <span class="p">:</span><span class="n">city</span>
  <span class="k">AND</span> <span class="n">year_birth</span> <span class="o">=</span> <span class="p">:</span><span class="nb">year</span><span class="o">-</span><span class="n">birth</span>
<span class="k">LIMIT</span> <span class="mi">10</span>
</code></pre></div></div>

<p>Если не указать город или год рождения в параметрах, получим ошибку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">find-users</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">})</span><span class="w">

</span><span class="c1">;; Execution error (ExceptionInfo)</span><span class="w">
</span><span class="c1">;; at hugsql.core/validate-parameters! (core.clj:83).</span><span class="w">
</span><span class="c1">;; Parameter Mismatch: :city parameter data not found.</span><span class="w">
</span></code></pre></div></div>

<p>Отбор по необязательным полям должен быть только если значения не пустые. Правильный запрос выглядит так:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :name find-users :?</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span>
<span class="k">where</span> <span class="n">fname</span> <span class="o">=</span> <span class="p">:</span><span class="n">name</span>
<span class="c1">--~ (when (:city params) "and city = :city")</span>
<span class="c1">--~ (when (:year-birth params) "and year_birth = :year-birth")</span>
<span class="k">limit</span> <span class="mi">10</span>
</code></pre></div></div>

<p>Синтаксис <code class="language-plaintext highlighter-rouge">--~</code> предваряет строку с кодом на Clojure. Он должен вернуть строку SQL или <code class="language-plaintext highlighter-rouge">nil</code>. Внутри доступна переменная <code class="language-plaintext highlighter-rouge">params</code> — словарь параметров, которые передали в запрос. Выше мы проверяем: если заданы поля с городом или возрастом, добавить к <code class="language-plaintext highlighter-rouge">WHERE</code> отбор по ним.</p>

<p>Выражение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">find-users</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:city</span><span class="w"> </span><span class="s">"Chita"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>порождает следующий запрос:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span>
<span class="k">WHERE</span> <span class="n">fname</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span>
  <span class="k">AND</span> <span class="n">city</span> <span class="o">=</span> <span class="err">$</span><span class="mi">2</span>
<span class="k">LIMIT</span> <span class="mi">10</span>
<span class="k">parameters</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="s1">'Ivan'</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="s1">'Chita'</span>
</code></pre></div></div>

<p>Кроме однострочных выражений, HugSQL предлагает многострочные по следующим правилам:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*~ (if ... */</span>
<span class="k">SQL</span> <span class="n">if</span> <span class="k">true</span>
<span class="cm">/*~*/</span>
<span class="k">SQL</span> <span class="n">if</span> <span class="k">false</span>
<span class="cm">/*~ ) ~*/</span>
</code></pre></div></div>

<p>Форма <code class="language-plaintext highlighter-rouge">/*~*/</code> означает переход к следующей форме Clojure, в данном случае от положительной ветви <code class="language-plaintext highlighter-rouge">if</code> к негативной. Обратите внимание, что последняя строка несет закрывающую скобку для <code class="language-plaintext highlighter-rouge">if</code>. Без нее получится ошибка синтаксиса.</p>

<p>Опробуем условный оператор в действии. Доработаем функцию <code class="language-plaintext highlighter-rouge">get-user-by-id</code> так, что если не задан сниппет полей, вернем их все. Для этого проверим <code class="language-plaintext highlighter-rouge">:user-fields</code> на пустоту и подставим либо <code class="language-plaintext highlighter-rouge">:snip:user-fields</code>, либо <code class="language-plaintext highlighter-rouge">*</code>.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :name get-user-by-id :? :1</span>
<span class="c1">-- :doc Get a single user by ID</span>
<span class="k">select</span>
<span class="cm">/*~ (if (:user-fields params) */</span>
<span class="p">:</span><span class="n">snip</span><span class="p">:</span><span class="k">user</span><span class="o">-</span><span class="n">fields</span>
<span class="cm">/*~*/</span>
<span class="o">*</span>
<span class="cm">/*~ ) ~*/</span>
<span class="k">from</span> <span class="n">users</span>
<span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span><span class="c1">;; {:id 1 :fname "Ivan"</span><span class="w">
</span><span class="c1">;; :lname "Petrov"</span><span class="w">
</span><span class="c1">;; :email "...",</span><span class="w">
</span><span class="c1">;; :age ...}</span><span class="w">

</span><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:user-fields</span><span class="w"> </span><span class="p">(</span><span class="nf">user-fields</span><span class="p">)})</span><span class="w">
</span><span class="c1">;; {:id 1</span><span class="w">
</span><span class="c1">;;  :fname "Ivan"</span><span class="w">
</span><span class="c1">;;  :lname "Petrov"}</span><span class="w">
</span></code></pre></div></div>

<p>Настоящие сложности возникают, когда управляют не отдельными полями, а таблицами. Предположим, в поиске пользователей появилось галочка “только с фотографией”. Снимки хранятся в отдельной таблице <code class="language-plaintext highlighter-rouge">photos</code>, которая связана с пользователями внешним ключом. Чтобы выбрать пользователей по наличию фото, в запросе должно быть внутреннее соединение таблиц (<code class="language-plaintext highlighter-rouge">INNER JOIN</code>). При этом не всегда, а только если установлен параметр. Все вместе дает нам шаблон:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :name find-users2 :?</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="n">u</span>
<span class="cm">/*~ (when (:with-photo? params) */</span>
<span class="k">join</span> <span class="n">photos</span> <span class="n">p</span> <span class="k">on</span> <span class="n">p</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span>
<span class="cm">/*~ ) ~*/</span>
</code></pre></div></div>

<p>Если выполнить запрос с флагом, таблица <code class="language-plaintext highlighter-rouge">photos</code> окажется в запросе:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">find-users2</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:with-photo?</span><span class="w"> </span><span class="n">true</span><span class="p">})</span><span class="w">

</span><span class="c1">;; select * from users u</span><span class="w">
</span><span class="c1">;; join photos p on p.user_id = u.id</span><span class="w">
</span></code></pre></div></div>

<p>Сниппеты тоже принимают параметры. Добавим в <code class="language-plaintext highlighter-rouge">user-fields</code> следующее условие: если передан флаг <code class="language-plaintext highlighter-rouge">:root?</code>, вернуть все поля пользователя, а иначе только их часть.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- :snip user-fields</span>
<span class="cm">/*~ (if (:root? params) */</span>
<span class="o">*</span>
<span class="cm">/*~*/</span>
<span class="n">id</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">lname</span>
<span class="cm">/*~ ) ~*/</span>
</code></pre></div></div>

<p>Теперь запрос с флагом вернет все поля. Обратите внимание, что параметр <code class="language-plaintext highlighter-rouge">:root?</code> передан именно сниппету, а не основному запросу. Это гарантирует, что одноименные поля запроса и сниппета не вступят в конфликт.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w">
  </span><span class="n">db</span><span class="w">
  </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
   </span><span class="no">:user-fields</span><span class="w"> </span><span class="p">(</span><span class="nf">user-fields</span><span class="w"> </span><span class="p">{</span><span class="no">:root?</span><span class="w"> </span><span class="n">true</span><span class="p">})})</span><span class="w">
</span></code></pre></div></div>

<p>HugSQL предлагает многие другие возможности. Ознакомьтесь с ними на странице проекта.</p>

<p>Завершая раздел, отметим похожие библиотеки. <a href="https://github.com/krisajenkins/yesql">Yesql</a> предлагает аналогичный подход: по файлу запросов библиотека строит функции Clojure. Отличие в том, что при генерации вы указываете JDBC-спеку по умолчанию. В этом случае ее не нужно передавать в каждую функцию явно. Для транзакций и особых случаев спеку передают в словаре опций. Yesql портирована на Python, Ruby, Golang и другие популярные языки.</p>

<p>Еще одна библиотека называется <a href="https://github.com/luminus-framework/conman">Conman</a>. Это обертка над HugSQL с некоторыми упрощениями. Conman входит в состав фреймворка Luminus и является важной его частью. Можно использовать его отдельно от Luminus в проектах на другом стеке.</p>

<h3 id="построители">Построители</h3>

<p>Существует иной подход к написанию SQL, известный как Query Builder или построитель запросов. Это объект, который хранит структуру запроса: список полей, таблиц, условий и так далее. Вызывая методы <code class="language-plaintext highlighter-rouge">.addWhere</code>, <code class="language-plaintext highlighter-rouge">.addJoin</code> и другие, мы наполняем его состояние. Метод <code class="language-plaintext highlighter-rouge">.toString</code> или <code class="language-plaintext highlighter-rouge">.render</code> построит SQL из накопленных частей. Ниже — пример построителя запросов на Java:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="nc">QueryBuilder</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">"u.*"</span><span class="o">,</span> <span class="s">"p.*"</span><span class="o">)</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="s">"users"</span><span class="o">,</span> <span class="s">"u"</span><span class="o">)</span>
  <span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">"profiles"</span><span class="o">,</span> <span class="s">"p"</span><span class="o">).</span><span class="na">on</span><span class="o">(</span><span class="s">"p.user_id = u.id"</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="s">"not u.is_deleted"</span><span class="o">)</span>
  <span class="o">.</span><span class="na">toString</span><span class="o">();</span>

<span class="c1">// SELECT u*, p* FROM users AS u</span>
<span class="c1">// JOIN profiles AS p ON p.user_id = u.id</span>
<span class="c1">// WHERE NOT u.is_deleted</span>
</code></pre></div></div>

<p>Похоже устроены библиотеки SQLAlchemy и Knex.js в Python и JavaScript.</p>

<p>Принцип работает и в Clojure с той разницей, что вместо объекта используют привычный словарь. Специальная функция обходит его и строит SQL. Поскольку данные неизменяемы, каждая операция над словарем вернет новый словарь. Снижается риск ошибки, что мы случайно изменим запрос, на который используется в другом месте.</p>

<p>Библиотека <a href="https://github.com/seancorfield/honeysql">HoneySql</a> работает по принципу “SQL как данные”. Добавьте ее в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">com.github.seancorfield/honeysql</span><span class="w"> </span><span class="s">"2.0.0-rc5"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Создайте простой запрос в виде словаря:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">query</span><span class="w">
  </span><span class="p">{</span><span class="no">:select</span><span class="w"> </span><span class="p">[</span><span class="no">:*</span><span class="p">]</span><span class="w">
   </span><span class="no">:from</span><span class="w"> </span><span class="p">[</span><span class="no">:users</span><span class="p">]</span><span class="w">
   </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Очевидно, ключи <code class="language-plaintext highlighter-rouge">:select</code>, <code class="language-plaintext highlighter-rouge">:from</code> и <code class="language-plaintext highlighter-rouge">:where</code> означают одноименные части SQL. Важно, что переменная <code class="language-plaintext highlighter-rouge">query</code> имеет структуру. Ей легко добавить новое поле или условие функциями <code class="language-plaintext highlighter-rouge">assoc-in</code> и <code class="language-plaintext highlighter-rouge">update-in</code>.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">sql/format</code> принимает подобный словарь и возвращает SQL-вектор. Первый элемент этого вектора — строка запроса, остальные элементы — параметры. В нашем случае получим вектор:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">honey.sql</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">sql</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">sql/format</span><span class="w"> </span><span class="n">query</span><span class="p">)</span><span class="w">
</span><span class="c1">;; ["SELECT * FROM users WHERE id = ?" 1]</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что значение 1 стало параметром, а не частью запроса. Другими словами, запрос SQL не оказался таким:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Как мы обсуждали в начале главы, значения в запросе чреваты ошибками. Скорей всего, единица приходит извне и может содержать махинации для инъекций.</p>

<p>В HoneySql любое значение, отличное от символа и кейворда, означает параметр. Числа, булево и строки станут параметрами, а в запросе на их месте будут вопросительные знаки. Параметры установит драйвер JDBC с учетом кавычек, типов и правил безопасности. Пример со вставкой пользователя:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">query</span><span class="w">
  </span><span class="p">{</span><span class="no">:insert-into</span><span class="w"> </span><span class="no">:users</span><span class="w">
   </span><span class="no">:columns</span><span class="w"> </span><span class="p">[</span><span class="no">:id</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="no">:email</span><span class="p">]</span><span class="w">
   </span><span class="no">:values</span><span class="w"> </span><span class="p">[[</span><span class="mi">99</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">]]})</span><span class="w">

</span><span class="p">(</span><span class="nf">sql/format</span><span class="w"> </span><span class="n">query</span><span class="p">)</span><span class="w">

</span><span class="p">[</span><span class="s">"INSERT INTO users (id, fname, email) VALUES (?, ?, ?)"</span><span class="w">
 </span><span class="mi">99</span><span class="w">
 </span><span class="s">"Ivan"</span><span class="w">
 </span><span class="s">"test@test.com"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Передайте результат в <code class="language-plaintext highlighter-rouge">jdbc/execute!</code>, чтобы выполнить вставку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">(</span><span class="nf">sql/format</span><span class="w"> </span><span class="n">query</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы сослаться на другое поле в условии, поставьте на его место кейворд или символ. Предположим, мы храним бонусные баллы пользователя. Очередная покупка прибавляет сто баллов. Вот как начислить их пользователю с номером 99:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">query</span><span class="w">
  </span><span class="p">{</span><span class="no">:update</span><span class="w"> </span><span class="no">:users</span><span class="w">
   </span><span class="no">:set</span><span class="w"> </span><span class="p">{</span><span class="no">:bonus_points</span><span class="w"> </span><span class="p">[</span><span class="no">:+</span><span class="w"> </span><span class="no">:bonus_points</span><span class="w"> </span><span class="mi">100</span><span class="p">]}</span><span class="w">
   </span><span class="no">:where</span><span class="w"> </span><span class="p">[[</span><span class="no">:=</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="mi">99</span><span class="p">]]})</span><span class="w">

</span><span class="p">(</span><span class="nf">sql/format</span><span class="w"> </span><span class="n">query</span><span class="p">)</span><span class="w">

</span><span class="p">[</span><span class="s">"UPDATE users SET bonus_points = bonus_points + ? WHERE (id = ?)"</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="mi">99</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>По аналогии работают операторы удаления, группировки, <code class="language-plaintext highlighter-rouge">JOIN</code>, <code class="language-plaintext highlighter-rouge">UNION</code> и другие. Для каждого из них служит одноименный ключ, который принимает другой словарь или вектор. Справку по всем ключам вы найдете на странице проекта.</p>

<p>Кроме словаря, библиотека предлагает другой способ составить запрос. В модуле <code class="language-plaintext highlighter-rouge">honey.sql.helpers</code> находятся функции, совместимые со стрелочными оператором. Каждая функция принимает предыдущий запрос и возвращает дополненный новым полем. Перепишем пример с бонусными баллами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">honey.sql.helpers</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">h</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">query</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">h/update</span><span class="w"> </span><span class="no">:users</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">h/set</span><span class="w"> </span><span class="p">{</span><span class="no">:bonus_points</span><span class="w"> </span><span class="p">[</span><span class="no">:+</span><span class="w"> </span><span class="no">:bonus_points</span><span class="w"> </span><span class="mi">100</span><span class="p">]})</span><span class="w">
      </span><span class="p">(</span><span class="nf">h/where</span><span class="w"> </span><span class="p">[[</span><span class="no">:=</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="mi">99</span><span class="p">]])))</span><span class="w">
</span></code></pre></div></div>

<p>Некоторые предпочитают такой способ записи, хотя технически он сводится к наполнению словаря.</p>

<h3 id="служебные-функции">Служебные функции</h3>

<p>Выше мы проделываем одну и ту же работу: получаем SQL-вектор и передаем в JDBC. Совместим эти шаги в одной функции. Она принимает два словаря — запрос и параметры — и возвращает результат обращения к базе. Назовем ее <code class="language-plaintext highlighter-rouge">map-query</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">map-query</span><span class="w"> </span><span class="p">[</span><span class="n">db-spec</span><span class="w"> </span><span class="n">map-sql</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">map-params</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db-spec</span><span class="w"> </span><span class="p">(</span><span class="nf">sql/format</span><span class="w"> </span><span class="n">map-sql</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="n">map-params</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Пример с поиском ползователя по номеру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">query</span><span class="w">
  </span><span class="p">{</span><span class="no">:select</span><span class="w"> </span><span class="p">[</span><span class="no">:*</span><span class="p">]</span><span class="w">
   </span><span class="no">:from</span><span class="w"> </span><span class="p">[</span><span class="no">:users</span><span class="p">]</span><span class="w">
   </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="no">:?id</span><span class="p">]})</span><span class="w">

</span><span class="p">(</span><span class="nf">map-query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">13</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание на параметр <code class="language-plaintext highlighter-rouge">:?id</code> в секции <code class="language-plaintext highlighter-rouge">:where</code>: это кейворд со знаком вопроса впереди. HoneySQL считает его именным параметром. Значение параметра следует в словаре <code class="language-plaintext highlighter-rouge">:params</code> в аргументах <code class="language-plaintext highlighter-rouge">sql/format</code>.</p>

<p>С новой функцией код сократился. Для большего удобства выносите запросы в отдельный модуль, чтобы позже ссылаться на них. По аналогии напишите функцию <code class="language-plaintext highlighter-rouge">map-execute</code>, которая выполняет <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code> и другие операции, отличные от чтения.</p>

<h3 id="логирование-и-форматирование">Логирование и форматирование</h3>

<p>Теперь когда появилась общая точка, через которую проходят все запросы, ее можно улучшить. Например, добавить необязательные параметры, логирование и многое другое.</p>

<p>Предположим, в режиме разработки мы бы хотели видеть все запросы, что посылаем к базе. Добавим отладочный лог:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">map-query</span><span class="w"> </span><span class="p">[</span><span class="n">db-spec</span><span class="w"> </span><span class="n">map-sql</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">map-params</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">sql-vec</span><span class="w"> </span><span class="p">(</span><span class="nf">sql/format</span><span class="w"> </span><span class="n">map-sql</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="n">map-params</span><span class="p">})]</span><span class="w">
    </span><span class="p">(</span><span class="nf">log/infof</span><span class="w"> </span><span class="s">"Query: %s"</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">sql-vec</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db-spec</span><span class="w"> </span><span class="n">sql-vec</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>В консоли увидим запись:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">map-query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span><span class="c1">;; 2021-08-06 10:29:25,702 INFO  book.db - Query: SELECT * FROM users WHERE id = ?</span><span class="w">
</span></code></pre></div></div>

<p>К сожалению, HoneySql не поддерживает “красивые” запросы с отступами и переносами строк. Для больших запросов это становится проблемой, потому что длинную строку SQL трудно читать. На время разработки подключим Java-библиотеку <a href="https://github.com/vertical-blank/sql-formatter">SqlFormatter</a> для форматирования SQL. Добавьте зависимость в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">com.github.vertical-blank/sql-formatter</span><span class="w"> </span><span class="s">"2.0.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Импортируйте одноименный класс:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="ss">'com.github.vertical_blank.sqlformatter.SqlFormatter</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы получить форматированный запрос, передайте строку SQL в статический метод <code class="language-plaintext highlighter-rouge">SqlFormatter/format</code>. Доработаем логирование в функции <code class="language-plaintext highlighter-rouge">map-query</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">map-query</span><span class="w"> </span><span class="p">[</span><span class="n">db-spec</span><span class="w"> </span><span class="n">map-sql</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">map-params</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">sql-vec</span><span class="w"> </span><span class="p">(</span><span class="nf">sql/format</span><span class="w"> </span><span class="n">map-sql</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="n">map-params</span><span class="p">})]</span><span class="w">
    </span><span class="p">(</span><span class="nf">log/infof</span><span class="w"> </span><span class="s">"Query:\n%s"</span><span class="w"> </span><span class="p">(</span><span class="nf">SqlFormatter/format</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">sql-vec</span><span class="p">)))</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db-spec</span><span class="w"> </span><span class="n">sql-vec</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь в консоли появится красиво оформленный SQL:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">map-query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">

</span><span class="c1">;; 2021-08-06 10:40:24,062 INFO  book.db - Query:</span><span class="w">
</span><span class="c1">;; SELECT</span><span class="w">
</span><span class="c1">;;  *</span><span class="w">
</span><span class="c1">;; FROM</span><span class="w">
</span><span class="c1">;;   users</span><span class="w">
</span><span class="c1">;; WHERE</span><span class="w">
</span><span class="c1">;;  id = ?</span><span class="w">
</span></code></pre></div></div>

<p>По желанию его можно как-то выделить, например предварить каждую строку угловой скобкой или вертикальной чертой. Помните, что форматирование отнимает ресурсы и снижает скорость <code class="language-plaintext highlighter-rouge">map-query</code>. Сделайте так, чтобы логирование включалось по требованию или в зависимости от среды, например только при разработке.</p>

<p>Доработайте <code class="language-plaintext highlighter-rouge">map-query</code> так, чтобы в опциях можно было задать факт логирования, его уровень, признак форматирования и другие параметры.</p>

<h3 id="расширения">Расширения</h3>

<p>Honeysql легко расширить оператором, которого нет в поставке по умолчанию. Технически это значит вызвать функцию <code class="language-plaintext highlighter-rouge">sql/register-clause!</code>. Она меняет состояние библиотеки, где хранятся известные выражения. Функция принимает другую функцию, которая вернет вектор SQL по словарю.</p>

<p>Приведем пример с выражением <code class="language-plaintext highlighter-rouge">CREATE INDEX</code> для PostgreSQL. Это сложная команда со множеством полей и условий. Вот лишь малая часть ее синтаксиса:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="p">[</span> <span class="k">UNIQUE</span> <span class="p">]</span> <span class="k">INDEX</span> <span class="p">[</span> <span class="n">CONCURRENTLY</span> <span class="p">]</span>
    <span class="p">[</span> <span class="p">[</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="p">]</span> <span class="n">name</span> <span class="p">]</span>
    <span class="k">ON</span> <span class="p">[</span> <span class="k">ONLY</span> <span class="p">]</span> <span class="k">table</span>
    <span class="p">[</span> <span class="k">USING</span> <span class="k">method</span> <span class="p">]</span> <span class="p">...</span>
</code></pre></div></div>

<p>Наша задача — сделать так, чтобы индекс можно было задать словарем. Этим мы снизим риск ошибки при написании индексов вручную. Например:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">sql/format</span><span class="w">
  </span><span class="p">{</span><span class="no">:create-index</span><span class="w"> </span><span class="p">{</span><span class="no">:if-not-exists?</span><span class="w"> </span><span class="n">true</span><span class="w">
                  </span><span class="no">:name</span><span class="w"> </span><span class="s">"idx_user_lname"</span><span class="w">
                  </span><span class="no">:on-table</span><span class="w"> </span><span class="no">:users</span><span class="w">
                  </span><span class="no">:on-field</span><span class="w"> </span><span class="no">:lname</span><span class="p">}})</span><span class="w">

</span><span class="c1">;; CREATE INDEX IF NOT EXISTS idx_user_lname ON users (id);</span><span class="w">
</span></code></pre></div></div>

<p>Сперва обработаем главные поля индекса: его имя, уникальность, имя таблицы и некоторые другие. Ниже — черновая версия кода, которая строит индекс:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">sql/register-clause!</span><span class="w">
 </span><span class="no">:create-index</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="n">idx-name</span><span class="w"> </span><span class="no">:name</span><span class="w">
         </span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">unique?</span><span class="w">
                </span><span class="n">if-not-exists?</span><span class="w">
                </span><span class="n">on-table</span><span class="w">
                </span><span class="n">on-field</span><span class="w">
                </span><span class="n">using</span><span class="p">]}]</span><span class="w">

   </span><span class="p">[(</span><span class="nf">clojure.string/join</span><span class="w">
     </span><span class="s">" "</span><span class="w">
     </span><span class="p">[</span><span class="s">"CREATE"</span><span class="w">
      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">unique?</span><span class="w"> </span><span class="s">"UNIQUE"</span><span class="p">)</span><span class="w">
      </span><span class="s">"INDEX"</span><span class="w">
      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">if-not-exists?</span><span class="w"> </span><span class="s">"IF NOT EXISTS"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nb">name</span><span class="w"> </span><span class="n">idx-name</span><span class="p">)</span><span class="w">
      </span><span class="s">"ON"</span><span class="w">
      </span><span class="p">(</span><span class="nb">name</span><span class="w"> </span><span class="n">on-table</span><span class="p">)</span><span class="w">
      </span><span class="s">"("</span><span class="w"> </span><span class="p">(</span><span class="nb">name</span><span class="w"> </span><span class="n">on-field</span><span class="p">)</span><span class="w"> </span><span class="s">")"</span><span class="w">
      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="s">"USING"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">using</span><span class="p">)])])</span><span class="w">
 </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Проверим, что вернет форматирование:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">sql/format</span><span class="w"> </span><span class="p">{</span><span class="no">:create-index</span><span class="w"> </span><span class="p">{</span><span class="no">:if-not-exists?</span><span class="w"> </span><span class="n">true</span><span class="w">
                            </span><span class="no">:name</span><span class="w"> </span><span class="s">"idx_user_lname"</span><span class="w">
                            </span><span class="no">:on-table</span><span class="w"> </span><span class="no">:users</span><span class="w">
                            </span><span class="no">:on-field</span><span class="w"> </span><span class="no">:lname</span><span class="p">}})</span><span class="w">

</span><span class="p">[</span><span class="s">"CREATE INDEX IF NOT EXISTS idx_user_lname ON users ( lname )"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Если передать этот вектор в <code class="language-plaintext highlighter-rouge">jdbc/execute!</code>, мы действительно получим индекс. Доработайте ключ <code class="language-plaintext highlighter-rouge">:create-index</code> так, чтобы он поддерживал больше полей и условий, в том числе специфичных для некоторых баз данных.</p>

<p>Кроме выражений, HoneySQL можно расширить операторами. Например, сделать так, чтобы условие:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="p">[</span><span class="no">:json-&gt;&gt;</span><span class="w"> </span><span class="no">:attributes</span><span class="w"> </span><span class="no">:color</span><span class="p">]</span><span class="w"> </span><span class="s">"red"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>становилось:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="s">"... WHERE attributes -&gt;&gt; 'color' = ?"</span><span class="w"> </span><span class="s">"red"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>С таким подходом запросы становятся гибче. Если вы пользуетесь редкими операторами, зарегистрируйте их в HoneySQL, чтобы не копировать код и оперативно править их в одном месте. Изучите примеры с вызовом <code class="language-plaintext highlighter-rouge">sql/register-fn!</code> и <code class="language-plaintext highlighter-rouge">sql/register-op!</code> из документации библиотеки.</p>

<h3 id="сырой-sql">Сырой SQL</h3>

<p>HoneySql покрывает почти все операторы SQL, однако рано или поздно понадобится такой, которого нет в поставке. Для этого служит последнее средство — вкрапление сырого SQL. Ключ <code class="language-plaintext highlighter-rouge">:raw</code> принимает текст или вектор и внедряет его в запрос с минимальной обработкой. Приведем несколько примеров.</p>

<p>Выборка пользователей, созданных за последний день. В поле <code class="language-plaintext highlighter-rouge">:raw</code> следует строка SQL, а именно вычитание дня из текущей даты.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:select</span><span class="w"> </span><span class="p">[</span><span class="no">:*</span><span class="p">]</span><span class="w">
 </span><span class="no">:from</span><span class="w"> </span><span class="p">[</span><span class="no">:users</span><span class="p">]</span><span class="w">
 </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:&gt;=</span><span class="w"> </span><span class="no">:created_at</span><span class="w"> </span><span class="p">[</span><span class="no">:raw</span><span class="w"> </span><span class="s">"now() - interval '1 day'"</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<p>Более сложный запрос, где атрибуты товаров дополняют цветом и размером. Оператор <code class="language-plaintext highlighter-rouge">||</code> объединяет два объекта JSON.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">map-query</span><span class="w">
 </span><span class="n">db</span><span class="w">
 </span><span class="p">{</span><span class="no">:update</span><span class="w"> </span><span class="no">:items</span><span class="w">
  </span><span class="no">:set</span><span class="w"> </span><span class="p">{</span><span class="no">:attrs</span><span class="w"> </span><span class="p">[</span><span class="no">:raw</span><span class="w"> </span><span class="p">[</span><span class="s">"attrs || "</span><span class="w"> </span><span class="p">[</span><span class="no">:param</span><span class="w"> </span><span class="no">:new-attrs</span><span class="p">]]]}</span><span class="w">
  </span><span class="no">:returning</span><span class="w"> </span><span class="p">[</span><span class="no">:id</span><span class="p">]}</span><span class="w">
 </span><span class="p">{</span><span class="no">:new-attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:color</span><span class="w"> </span><span class="s">"red"</span><span class="w"> </span><span class="no">:size</span><span class="w"> </span><span class="s">"XL"</span><span class="p">}})</span><span class="w">
</span></code></pre></div></div>

<p>Во втором варианте в <code class="language-plaintext highlighter-rouge">:raw</code> указана не строка, а вектор элементов (тоже строк или векторов), которые позже объединяются в строку. С вектором проще поддерживать структуру запроса.</p>

<p>Будьте особенно осторожны с сырым SQL: не допускайте, чтобы в нем был ввод пользователя. Добавляйте его только ключом <code class="language-plaintext highlighter-rouge">:raw</code>, но ни в коем случае не конкатенацией строк. Сюда же относятся автозамена, разбиение и другие операции со строками. Все они будут ошибкой.</p>

<h3 id="повторное-использование-запросов">Повторное использование запросов</h3>

<p>В разделе про SQL-шаблоны мы выяснили, как повторно использовать части запросов. В HugSQL мы использовали сниппеты — именованные выражения. В HoneySQL это делается проще, потому что сводится к работе с неизменяемыми коллекциями.</p>

<p>Вернемся к таблице пользователей. Приложение часто обращается к ним: читает всех пользователей, ищет по имени или городу, находит конкретного человека по номеру. У этих запросов общая часть: имя таблицы и список полей, которые получит клиент. Вынесем ее в переменную, на которую позже будем ссылаться. По-другому ее называют “тушкой” запроса:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user-base</span><span class="w">
  </span><span class="p">{</span><span class="no">:select</span><span class="w"> </span><span class="p">[</span><span class="no">:*</span><span class="p">]</span><span class="w">
   </span><span class="no">:from</span><span class="w"> </span><span class="p">[</span><span class="no">:users</span><span class="p">]})</span><span class="w">
</span></code></pre></div></div>

<p>Если выполнить “тушку”, получим всех пользователей. Чтобы задать отбор по имени и ограничить длину выборки, добавим эти критерии с помощью <code class="language-plaintext highlighter-rouge">assoc</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">map-query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">user-base</span><span class="w">
                     </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">]</span><span class="w">
                     </span><span class="no">:limit</span><span class="w"> </span><span class="mi">9</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Переменная <code class="language-plaintext highlighter-rouge">user-base</code> не пострадает от новых ключей и не повлияет на дальнейшие запросы.</p>

<p>Усложним задачу поиском по многим полям. В зависимости от того, заполнено поле или нет, мы должны добавить его в <code class="language-plaintext highlighter-rouge">WHERE</code>. Обратимся к макросу <code class="language-plaintext highlighter-rouge">cond-&gt;</code>, который отлично справится с задачей. Он пропускает данные через серию предикатов и форм, при этом каждая форма получает результат предыдущей.</p>

<p>Предположим, при поиске пользователя имя обязательно для заполнения, а почта и возраст – нет. В этом случае составим запрос <code class="language-plaintext highlighter-rouge">query</code> на основе <code class="language-plaintext highlighter-rouge">user-base</code> с отбором по имени. Затем, если заданы почта и возраст, дополним секцию <code class="language-plaintext highlighter-rouge">WHERE</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">q-fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">          </span><span class="c1">;; (get params :name)</span><span class="w">
      </span><span class="n">q-email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="c1">;; (get params :email)</span><span class="w">
      </span><span class="n">q-age</span><span class="w"> </span><span class="n">nil</span><span class="w">               </span><span class="c1">;; (get params :age)</span><span class="w">

      </span><span class="n">query</span><span class="w">
      </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">user-base</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:and</span><span class="w"> </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="n">q-fname</span><span class="p">]])]</span><span class="w">

  </span><span class="p">(</span><span class="nf">cond-&gt;</span><span class="w"> </span><span class="n">query</span><span class="w">

    </span><span class="n">q-age</span><span class="w">
    </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="no">:age</span><span class="w"> </span><span class="n">q-age</span><span class="p">])</span><span class="w">

    </span><span class="n">q-email</span><span class="w">
    </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="n">q-email</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>Результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:select</span><span class="w"> </span><span class="p">[</span><span class="no">:*</span><span class="p">]</span><span class="w">
 </span><span class="no">:from</span><span class="w"> </span><span class="p">[</span><span class="no">:users</span><span class="p">]</span><span class="w">
 </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:and</span><span class="w">
         </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">]</span><span class="w">
         </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<p>Похоже работает условное соединение таблиц. Если задан флаг “с фотографией”, добавим в запрос ключ <code class="language-plaintext highlighter-rouge">:join</code> с таблицей <code class="language-plaintext highlighter-rouge">photos</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">q-fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">   </span><span class="c1">;; (get params :name)</span><span class="w">
      </span><span class="n">with-photo?</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="c1">;; (get params :with_photo)</span><span class="w">

      </span><span class="n">query</span><span class="w">
      </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">user-base</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:and</span><span class="w"> </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="n">q-fname</span><span class="p">]])]</span><span class="w">

  </span><span class="p">(</span><span class="nf">cond-&gt;</span><span class="w"> </span><span class="n">query</span><span class="w">

    </span><span class="n">with-photo?</span><span class="w">
    </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="no">:join</span><span class="w"> </span><span class="p">[</span><span class="no">:photos</span><span class="w"> </span><span class="p">[</span><span class="no">:=</span><span class="w"> </span><span class="no">:users.id</span><span class="w"> </span><span class="no">:photos.user_id</span><span class="p">]])))</span><span class="w">
</span></code></pre></div></div>

<p>Форма выше вернет запрос:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">photos</span> <span class="k">ON</span> <span class="n">users</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">photos</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span> <span class="p">(</span><span class="n">fname</span> <span class="o">=</span> <span class="s1">'Ivan'</span><span class="p">)</span>
</code></pre></div></div>

<p>Усложним поиск еще больше. До сих пор мы использовали равенство по полю, но на практике применяют диапазоны и частичные совпадения. Например, цена от и до при поиске товара или вхождение слова в полное название. Доработайте код так, чтобы для возраста можно было задать границы. Теперь мы ожидаем не одно, а два поля: <code class="language-plaintext highlighter-rouge">age__min</code> и <code class="language-plaintext highlighter-rouge">age__max</code>. Обратите внимание на двойное подчеркивание: оно отделяет имя поля (<code class="language-plaintext highlighter-rouge">age</code>) от оператора сравнения (<code class="language-plaintext highlighter-rouge">min</code>, больше или <code class="language-plaintext highlighter-rouge">max</code>, меньше). Для почты, города и других строковых полей напишите оператор вхождения <code class="language-plaintext highlighter-rouge">contains</code>: <code class="language-plaintext highlighter-rouge">name__contains</code>, <code class="language-plaintext highlighter-rouge">city__contains</code> и другие.</p>

<h3 id="аналоги">Аналоги</h3>

<p>Коротко перечислим аналоги HoneySQL. Это <a href="https://github.com/r0man/sqlingvo">SQLingvo</a>, <a href="https://github.com/metabase/toucan">Toucan</a>, Korma и другие. Все они так или иначе выражают SQL с помощью данных, которые позже становятся строкой. Познакомившись HoneySQL, вы без труда освоите эти библиотеки, потому что в них принят тот же подход.</p>

<p>Отдельно отметим фреймворк <a href="https://github.com/korma/Korma">Korma</a>: он делает шаг в сторону ORM. Вы объявляете сущности базы данных, по которым позже строятся запросы. Korma понравится тем, кто работал с фреймворками Django или Rails и теперь ищет что-то похожее.</p>

<h3 id="промежуточный-итог">Промежуточный итог</h3>

<p>Мы рассмотрели два способа работы с SQL: шаблоны и данные. В первом случае в файле пишут сырой SQL, который позже становится функциями. Во втором случае запросы получают из словарей и списков. Что выбрать?</p>

<p>Вариант с шаблонами хорош тем, что мысленно вы остаетесь на уровне базы. Запрос легко скопировать в PGAdmin, выполнить и оценить результат; там же отладить его и перенести обратно с минимальными усилиями. Если в фирме есть специалист по базам данных, он сделает аудит запросов: найдет медленные выражения, не оптимальные операторы <code class="language-plaintext highlighter-rouge">WHERE</code> и <code class="language-plaintext highlighter-rouge">JOIN</code>.</p>

<p>Наоборот, когда запросы описаны словарями, за ними плохо видна логика SQL. Для больших и сложных запросов это становится проблемой. Иногда запросы пишут в исходном виде, долго тестируют и только затем приводят к “кложурному” виду. Получается двойная работа.</p>

<p>С другой стороны, запросы в виде данных легче использовать повторно. Если в нескольких запросах повторяется одно выражение, легко вынести его в переменную. Словари и списки удобней наращивать формами <code class="language-plaintext highlighter-rouge">assoc-in</code> и <code class="language-plaintext highlighter-rouge">cond-&gt;</code>, нежели добавлять код на Clojure в шаблоны SQL.</p>

<p>Оба способа равнозначны, и нельзя с уверенностью сказать, что лучше. Чтобы определиться, испытайте то и другое на практике.</p>

<h2 id="структура-и-группировка">Структура и группировка</h2>

<p>Библиотеки, что мы рассмотрели выше, только составляют запрос, но не влияют на его обработку. Независимо от того, что вы предпочитаете – шаблоны или данные – вы столкнетесь с тем, что выполнить запрос еще не достаточно. Часто ответ базы нуждается в обработке из-за вложенных данных. Рассмотрим, что это за проблема и как ее решить.</p>

<p>В сердце реляционных баз данных лежат отношения между таблицами. Почти все операции над таблицами возвращают таблицы. Прибегая к аналогии, можно сказать, что из прямоугольных блоков можно выложить только прямоугольные формы, но не треугольные или круглые. В общем случае база хранит плоские данные и не может построить из них дерево.</p>

<p>На практике мы имеем дело с подчиненными сущностями. Например, у организации несколько филиалов и в каждом из них департаменты. У автора несколько статей, а к статьям пишут комментарии. Товары делятся на категории и подкатегории, заказ состоит из этапов и так далее. Это значит, не достаточно просто выбрать сущности по типу, например отдельно авторов и статьи:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; authors</span><span class="w">
</span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Petrov"</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Rublev"</span><span class="p">}]</span><span class="w">

</span><span class="c1">;; posts</span><span class="w">
</span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Introduction to Python"</span><span class="w"> </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Thoughts on LISP"</span><span class="w"> </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">2</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>Мы должны выразить их структуру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Petrov"</span><span class="w">
  </span><span class="no">:posts</span><span class="w"> </span><span class="p">[{</span><span class="no">:id</span><span class="w">
           </span><span class="no">:title</span><span class="w"> </span><span class="s">"Introduction to Python"</span><span class="w">
           </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">1</span><span class="p">}]}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Rublev"</span><span class="w">
  </span><span class="no">:posts</span><span class="w"> </span><span class="p">[{</span><span class="no">:id</span><span class="w">
           </span><span class="no">:title</span><span class="w"> </span><span class="s">"Thoughts on LISP"</span><span class="w">
           </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">2</span><span class="p">}]}]</span><span class="w">
</span></code></pre></div></div>

<p>На этом месте реляционные базы вступают в конфликт с требованиями. Без особых ухищрений нельзя получить ответ как в примере выше. Проверим это на практике: создадим таблицы и выберем из них данные.</p>

<p>Первый шаг, таблицы авторов и статей:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">authors</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
  <span class="n">name</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span>
<span class="p">);</span>

<span class="k">create</span> <span class="k">table</span> <span class="n">posts</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
  <span class="n">title</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
  <span class="n">author_id</span> <span class="nb">integer</span> <span class="k">references</span> <span class="n">authors</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Добавим минимальный набор данных. У каждого автора по две статьи:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">authors</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">VALUES</span>
  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Ivan Petrov'</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Ivan Rublev'</span><span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">posts</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">author_id</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span> <span class="k">VALUES</span>
  <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'Introduction to Python'</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'Thoughts on LISP'</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'Learning Clojure'</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'Working on my pet project'</span><span class="p">);</span>
</code></pre></div></div>

<p>Третий шаг: запрос на выборку авторов и их статей:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">authors</span> <span class="n">a</span>
<span class="k">JOIN</span> <span class="n">posts</span> <span class="n">p</span> <span class="k">ON</span> <span class="n">p</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Результат:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> id |    name     | id |            title            | author_id
----+-------------+----+-----------------------------+-----------
  1 | Ivan Petrov | 10 | Introduction to Python      |         1
  1 | Ivan Petrov | 20 | Thoughts on LISP            |         1
  2 | Ivan Rublev | 30 | Learning Clojure            |         2
  2 | Ivan Rublev | 40 | Working on my pet project   |         2
</code></pre></div></div>

<p>Видим, что родительская сущность (автор) повторяется столько раз, столько у нее дочерних записей (статей). Результат нельзя выводить в плоском виде, потому что пользователь ожидает другую структуру. Наверняка он хочет увидеть вложенный список:</p>

<ul>
  <li>Ivan Petrov
    <ul>
      <li>Introduction to Python</li>
      <li>Thoughts on LISP</li>
    </ul>
  </li>
  <li>Ivan Rublev
    <ul>
      <li>Learning Clojure</li>
      <li>Working on my pet project</li>
    </ul>
  </li>
</ul>

<p>Ситуация ухудшается, если у дочерних записей есть другие дочерние, например оценки или комментарии. Это приведет к еще большему дублированию родителей.</p>

<p>Проблема структуры не так проста, какой кажется на первый взгляд. Она может серьезно задержать разработку. Как правило, клиенты ожидают вложенные данные, чтобы не перестраивать их перед выводом. Требуется общий подход к решению задачи. Мы рассмотрим несколько способов: на уровне кода и базы данных.</p>

<h3 id="выборка-по-слоям">Выборка по слоям</h3>

<p>Наиболее простой способ в том, чтобы выбрать главную и подчиненные сущности по отдельности. Предположим, мы знаем номер автора, которого нужно найти. Тогда первый запрос вернет его по первичному ключу:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">author-id</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/get-by-id</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:authors</span><span class="w"> </span><span class="n">author-id</span><span class="p">)</span><span class="w">
</span><span class="c1">;; {:id 1 :name "Ivan Petrov"}</span><span class="w">
</span></code></pre></div></div>

<p>Дочерние записи получим запросом, где ссылка на автора равна его номеру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/find-by-keys</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:posts</span><span class="w"> </span><span class="p">{</span><span class="no">:author_id</span><span class="w"> </span><span class="n">author-id</span><span class="p">})</span><span class="w">

</span><span class="p">({</span><span class="no">:id</span><span class="w"> </span><span class="mi">10</span><span class="n">,</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Introduction to Python"</span><span class="n">,</span><span class="w"> </span><span class="no">:author_id</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">20</span><span class="n">,</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Thoughts on LISP"</span><span class="n">,</span><span class="w"> </span><span class="no">:author_id</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Соедининим результаты, и ответ готов:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">author-id</span><span class="w"> </span><span class="mi">1</span><span class="w">
      </span><span class="n">author</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/get-by-id</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
      </span><span class="n">posts</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/find-by-keys</span><span class="w"> </span><span class="n">...</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">author</span><span class="w"> </span><span class="no">:posts</span><span class="w"> </span><span class="n">posts</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Хоть это и наивное решение, оно имеет право на жизнь. Мы производим строго два запроса, что не нагрузит базу данных. При желании их можно запустить параллельно.</p>

<p>Номер сущности известен не всегда. Порой записи ищут не по первичным ключам, а более общим признакам: имени, городу. В этом случае сперва выберем родительские записи (их будет несколько), а затем дочерние, что на них ссылаются.</p>

<p>Поиск авторов по имени:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"SELECT * FROM authors WHERE name = ?"</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">])</span><span class="w">

</span><span class="c1">;; ({:id 1 ...} {:id 2 ...})</span><span class="w">
</span></code></pre></div></div>

<p>Получили несколько записей. Возникает вопрос, как найти дочерние. Если делать это в цикле для каждого родителя, как в примере ниже:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">author</span><span class="w"> </span><span class="n">authors</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="p">]}</span><span class="w"> </span><span class="n">author</span><span class="w">
        </span><span class="n">posts</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/find-by-keys</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:posts</span><span class="w"> </span><span class="p">{</span><span class="no">:author_id</span><span class="w"> </span><span class="n">id</span><span class="p">})]</span><span class="w">
    </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">author</span><span class="w"> </span><span class="no">:posts</span><span class="w"> </span><span class="n">posts</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>, мы произведем столько запросов, сколько авторов. Это неэффективно: с ростом выборки число запросов будет расти линейно. Если запрос по имени вернул тысячу авторов, мы тысячу раз обратимся к базе.</p>

<p>Другой способ в том, чтобы получить номера авторов и составить запрос вида:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span> <span class="k">FROM</span> <span class="n">posts</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="k">IN</span> <span class="p">(</span><span class="o">?</span><span class="p">,</span> <span class="o">?</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div></div>

<p>, где знаков вопроса столько же, сколько авторов. Получится один запрос к базе. Если добавить индекс на поле <code class="language-plaintext highlighter-rouge">posts.author_id</code>, это ускорит выборку.</p>

<p>Заметим, что выражение <code class="language-plaintext highlighter-rouge">IN (...)</code> требует усилий в построении запроса. Это не один, а несколько параметров, разделенных запятой. Их позиция должна совпадать с позицией значения в векторе SQL. Если поиск по имени нашел десять авторов, вот как будет выглядеть вектор SQL с поиском статей:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"SELECT * FROM posts WHERE author_id IN (?,?,?,?,?,?,?,?,?,?)"</span><span class="w">
                </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="mi">3</span><span class="n">,</span><span class="w"> </span><span class="mi">4</span><span class="n">,</span><span class="w"> </span><span class="mi">5</span><span class="n">,</span><span class="w"> </span><span class="mi">6</span><span class="n">,</span><span class="w"> </span><span class="mi">7</span><span class="n">,</span><span class="w"> </span><span class="mi">8</span><span class="n">,</span><span class="w"> </span><span class="mi">9</span><span class="n">,</span><span class="w"> </span><span class="mi">10</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Библиотеки пытаются облегчить подобную запись. В HugSQL для этого служит оператор <code class="language-plaintext highlighter-rouge">where id in (:v*:ids)</code> — частичка <code class="language-plaintext highlighter-rouge">:v*</code> означает вектор параметров с именем <code class="language-plaintext highlighter-rouge">ids</code>. HoneySQL предлагает форму <code class="language-plaintext highlighter-rouge">:in</code> с похожей семантикой.</p>

<p>В современных ORM такая выборка называется fetch related, извлечь связанные записи. Например, в Django ORM у объекта QuerySet есть одноименный метод <code class="language-plaintext highlighter-rouge">prefetch_related</code>. С его помощью данные извлекают послойно: сперва сущности первого порядка, затем те, что ссылаются на них, затем потомки потомков и так далее. Вы можете управлять глубиной вложенности и другими параметрами.</p>

<p>Напишем функцию на Clojure, которая выбирает данные схожим образом. Она ожидает подключение к базе, таблицу, имя внешнего ключа и список их значений.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fetch-related</span><span class="w">
  </span><span class="p">[</span><span class="n">db-spec</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">fk-name</span><span class="w"> </span><span class="n">fk-vals</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w">
   </span><span class="n">db-spec</span><span class="w">
   </span><span class="p">(</span><span class="nf">sql/format</span><span class="w">
   </span><span class="p">{</span><span class="no">:select</span><span class="w"> </span><span class="p">[</span><span class="no">:*</span><span class="p">]</span><span class="w">
    </span><span class="no">:from</span><span class="w"> </span><span class="p">[</span><span class="n">table</span><span class="p">]</span><span class="w">
    </span><span class="no">:where</span><span class="w"> </span><span class="p">[[</span><span class="no">:in</span><span class="w"> </span><span class="n">fk-name</span><span class="w"> </span><span class="n">fk-vals</span><span class="p">]]})))</span><span class="w">
</span></code></pre></div></div>

<p>Пример ее вызова:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">fetch-related</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:posts</span><span class="w"> </span><span class="no">:author_id</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="n">..10</span><span class="p">])</span><span class="w">
</span><span class="c1">;; ["SELECT * FROM posts WHERE</span><span class="w">
</span><span class="c1">;;   (author_id IN (?, ?, ...))" 1 2 ...]</span><span class="w">
</span></code></pre></div></div>

<p>Номера авторов получим формой <code class="language-plaintext highlighter-rouge">(mapv :id authors)</code> из предыдущего результата.</p>

<p>Будьте осторожны с оператором <code class="language-plaintext highlighter-rouge">IN</code>. Когда параметров много, это плохо сказывается на производительности. Поиск авторов может вернуть сто тысяч записей, что породит запрос с таким же числом параметров. Трудно обозначить конкретный порог для <code class="language-plaintext highlighter-rouge">IN</code>, потому что он зависит от окружения. В одном из проектов, над которым работал автор, таким порогом было число 100. Другими словами, в оператор <code class="language-plaintext highlighter-rouge">WHERE ... IN (...)</code> разрешалось передать не более ста параметров.</p>

<p>Это условие меняет код. Мы не знаем заранее, сколько ключей получим из базы, поэтому приходиться делать запросы в цикле. Для этого разбиваем список ключей по сотням и наполняем единый результат. Очевидно, должна быть универсальная функция, которая проходит цикл. Если каждый раз копировать код, вы не избежите ошибок.</p>

<p>Проще всего сделать выборку через <code class="language-plaintext highlighter-rouge">loop</code> или <code class="language-plaintext highlighter-rouge">reduce</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">by-chunks</span><span class="w"> </span><span class="p">[</span><span class="n">coll</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">partition</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">coll</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">reduce</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">ids-chunk</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">rows</span><span class="w"> </span><span class="p">(</span><span class="nf">fetch-related</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="n">ids-chunk</span><span class="p">)]</span><span class="w">
     </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">rows</span><span class="p">)))</span><span class="w">
 </span><span class="p">[]</span><span class="w">
 </span><span class="p">(</span><span class="nf">by-chunks</span><span class="w"> </span><span class="n">ids-all</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Опробуйте выборку в полупараллельном режиме через <code class="language-plaintext highlighter-rouge">pmap</code>. Функция строит ленивую коллекцию футур, которые выполняются по мере ее чтения. Окно коллекции (chunk size) равно числу ядер компьютера, умноженному на два.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">ids-chunks</span><span class="w">
      </span><span class="p">(</span><span class="nf">by-chunks</span><span class="w"> </span><span class="n">ids-all</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w">

      </span><span class="n">futs</span><span class="w">
      </span><span class="p">(</span><span class="nf">pmap</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">ids-chunk</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="nf">fetch-related</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="n">ids-chunk</span><span class="p">))</span><span class="w">
            </span><span class="n">ids-chunks</span><span class="p">)]</span><span class="w">

  </span><span class="p">(</span><span class="nb">reduce</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">fut</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">@</span><span class="n">fut</span><span class="p">))</span><span class="w">
   </span><span class="p">[]</span><span class="w">
   </span><span class="n">futs</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Оператор <code class="language-plaintext highlighter-rouge">IN</code> можно записать в виде условия <code class="language-plaintext highlighter-rouge">ANY</code> с массивом. Синтаксис читается как “поле <code class="language-plaintext highlighter-rouge">id</code> равно хотя бы одному элементу”:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SELECT</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">authors</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">ANY</span><span class="p">(</span><span class="o">'</span><span class="p">{</span><span class="mi">1</span><span class="n">,2,3,4,5</span><span class="p">}</span><span class="o">'</span><span class="p">)</span><span class="c1">;</span><span class="w">
</span></code></pre></div></div>

<p>Следующий код показывает, как передать массив в параметры запроса. Для начала получим соединение с базой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="n">java.sql.Connection</span><span class="w"> </span><span class="n">conn</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/get-connection</span><span class="w"> </span><span class="n">db</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Соединение нужно для того, чтобы построить объект массива. Метод <code class="language-plaintext highlighter-rouge">.createArrayOf</code> принимает тип элемента и массив объектов <code class="language-plaintext highlighter-rouge">Object</code> с номерами сущностей.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">array</span><span class="w">
  </span><span class="p">(</span><span class="nf">.createArrayOf</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"INTEGER"</span><span class="w"> </span><span class="p">(</span><span class="nf">object-array</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">])))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы установить массив в параметр, расширим протокол <code class="language-plaintext highlighter-rouge">ISQLParameter</code> для типа <code class="language-plaintext highlighter-rouge">java.sql.Array</code>. По умолчанию JDBC вызывает метод <code class="language-plaintext highlighter-rouge">.setObject</code>, что не подходит для массива. Реализуем метод <code class="language-plaintext highlighter-rouge">set-parameter</code> так, что у подготовленного выражения вызывается метод <code class="language-plaintext highlighter-rouge">.setArray</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="n">jdbc/ISQLParameter</span><span class="w">
  </span><span class="n">java.sql.Array</span><span class="w">
  </span><span class="p">(</span><span class="nf">set-parameter</span><span class="w"> </span><span class="p">[</span><span class="nb">val</span><span class="w"> </span><span class="o">^</span><span class="n">java.sql.PreparedStatement</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="n">ix</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">.setArray</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="n">ix</span><span class="w"> </span><span class="nb">val</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>После всех подготовок выполните запрос с массивом. Он будет правильно передан в запрос:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">array</span><span class="w">
  </span><span class="p">(</span><span class="nf">.createArrayOf</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="s">"INTEGER"</span><span class="w"> </span><span class="p">(</span><span class="nf">object-array</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">])))</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from authors where id = ANY(?)"</span><span class="w"> </span><span class="n">array</span><span class="p">])</span><span class="w">

</span><span class="c1">;; ({:id 1 :name "Ivan Petrov"} {:id 2 :name "Ivan Rublev"})</span><span class="w">
</span></code></pre></div></div>

<p>Сократим код при помощи служебной функции <code class="language-plaintext highlighter-rouge">make-db-array</code>. По спеке, типу и вектору значений она вернет экземпляр <code class="language-plaintext highlighter-rouge">java.sql.Array</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-db-array</span><span class="w"> </span><span class="p">[</span><span class="n">db-spec</span><span class="w"> </span><span class="n">db-type</span><span class="w"> </span><span class="n">values</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/get-connection</span><span class="w"> </span><span class="n">db</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">.createArrayOf</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="n">db-type</span><span class="w"> </span><span class="p">(</span><span class="nf">object-array</span><span class="w"> </span><span class="n">values</span><span class="p">))))</span><span class="w">


</span><span class="p">(</span><span class="nf">make-db-array</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"integer"</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">

</span><span class="c1">;; #object[org.postgresql.jdbc.PgArray 0x7d1d3233 "{\"1\",\"2\",\"3\"}"]</span><span class="w">
</span></code></pre></div></div>

<h3 id="ручная-группировка">Ручная группировка</h3>

<p>Выбрать смежные записи можно оператором <code class="language-plaintext highlighter-rouge">JOIN</code>. С ним мы получим данные одним запросом. Порой это выгодней обхода по слоям, который совершает серию запросов. Даже если выборка не обладает нужной структурой, ее обрабатывают в коде, в то время как база обслуживает других клиентов. С другой стороны, на больших таблицах оператор <code class="language-plaintext highlighter-rouge">JOIN</code> замедляется, особенно если условие связи не попадает в индекс. Производительность таких запросов зависит от окружения, оборудования и прочих факторов.</p>

<p>Пример запроса с <code class="language-plaintext highlighter-rouge">JOIN</code>, который вернет плоские данные. Обратите внимание на повторы в первых трех колонках (авторах):</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">authors</span> <span class="n">a</span>
<span class="k">JOIN</span> <span class="n">posts</span> <span class="n">p</span> <span class="k">ON</span> <span class="n">p</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> id |    name     | id |            title            | author_id
----+-------------+----+-----------------------------+-----------
  1 | Ivan Petrov | 10 | Introduction to Python      |         1
  1 | Ivan Petrov | 20 | Thoughts on LISP            |         1
  2 | Ivan Rublev | 30 | Learning Clojure            |         2
  2 | Ivan Rublev | 40 | Working on my pet project   |         2
</code></pre></div></div>

<p>Первый шаг к группировке — задать полям уникальные имена. В выборке два поля <code class="language-plaintext highlighter-rouge">id</code>, и может возникнуть путаница где чей номер. Чтобы этого избежать, укажем псевдонимы с пространством имен. Из-за символа <code class="language-plaintext highlighter-rouge">/</code> их нужно заключить в двойные кавычки.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">a</span><span class="p">.</span><span class="n">id</span>        <span class="k">as</span> <span class="nv">"author/id"</span><span class="p">,</span>
  <span class="n">a</span><span class="p">.</span><span class="n">name</span>      <span class="k">as</span> <span class="nv">"author/name"</span><span class="p">,</span>
  <span class="n">p</span><span class="p">.</span><span class="n">id</span>        <span class="k">as</span> <span class="nv">"post/id"</span><span class="p">,</span>
  <span class="n">p</span><span class="p">.</span><span class="n">title</span>     <span class="k">as</span> <span class="nv">"post/title"</span><span class="p">,</span>
  <span class="n">p</span><span class="p">.</span><span class="n">author_id</span> <span class="k">as</span> <span class="nv">"post/author-id"</span>
<span class="k">FROM</span> <span class="n">authors</span> <span class="n">a</span>
<span class="k">JOIN</span> <span class="n">posts</span> <span class="n">p</span> <span class="k">ON</span> <span class="n">p</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Польза подобных имен в том, что мы получим словари с ключами <code class="language-plaintext highlighter-rouge">:author/id</code>, <code class="language-plaintext highlighter-rouge">:post/id</code> и другими, что удобно для работы в Clojure.</p>

<p>Каждая запись содержит “слипшиеся” сущности – автора и публикацию – и наша задача разделить их. Простой способ это сделать — написать функции <code class="language-plaintext highlighter-rouge">get-author</code> и <code class="language-plaintext highlighter-rouge">get-post</code> с явной выборкой ключей:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-author</span><span class="w"> </span><span class="p">[</span><span class="n">db-row</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">select-keys</span><span class="w"> </span><span class="n">db-row</span><span class="w"> </span><span class="p">[</span><span class="no">:author/id</span><span class="w"> </span><span class="no">:author/name</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-post</span><span class="w"> </span><span class="p">[</span><span class="n">db-row</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">select-keys</span><span class="w"> </span><span class="n">db-row</span><span class="w"> </span><span class="p">[</span><span class="no">:post/id</span><span class="w"> </span><span class="no">:post/title</span><span class="w"> </span><span class="no">:post/author-id</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Проверка функций:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">row</span><span class="w">
  </span><span class="p">{</span><span class="no">:author/id</span><span class="w"> </span><span class="mi">1</span><span class="w">
   </span><span class="no">:author/name</span><span class="w"> </span><span class="s">"Ivan Petrov"</span><span class="w">
   </span><span class="no">:post/id</span><span class="w"> </span><span class="mi">10</span><span class="w">
   </span><span class="no">:post/title</span><span class="w"> </span><span class="s">"Introduction to Python"</span><span class="w">
   </span><span class="no">:post/author-id</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">get-author</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w">
</span><span class="c1">;; #:author{:id 1, :name "Ivan Petrov"}</span><span class="w">

</span><span class="p">(</span><span class="nf">get-post</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w">
</span><span class="c1">;; #:post{:id 10, :title "Introduction to Python", :author-id 1}</span><span class="w">
</span></code></pre></div></div>

<p>Выполним обход всех записей. На каждом шаге разделяем запись на сущности и наполняем пустой словарь.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">reduce</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">row</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">author</span><span class="w">    </span><span class="p">(</span><span class="nf">get-author</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w">
         </span><span class="n">post</span><span class="w">      </span><span class="p">(</span><span class="nf">get-post</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w">
         </span><span class="n">author-id</span><span class="w"> </span><span class="p">(</span><span class="no">:author/id</span><span class="w"> </span><span class="n">author</span><span class="p">)</span><span class="w">
         </span><span class="n">post-id</span><span class="w">   </span><span class="p">(</span><span class="no">:post/id</span><span class="w"> </span><span class="n">post</span><span class="p">)]</span><span class="w">
     </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">result</span><span class="w">
         </span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="p">[</span><span class="no">:authors</span><span class="w"> </span><span class="n">author-id</span><span class="p">]</span><span class="w"> </span><span class="nb">merge</span><span class="w"> </span><span class="n">author</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="p">[</span><span class="no">:authors</span><span class="w"> </span><span class="n">author-id</span><span class="w"> </span><span class="no">:author/posts</span><span class="w"> </span><span class="n">post-id</span><span class="p">]</span><span class="w"> </span><span class="nb">merge</span><span class="w"> </span><span class="n">post</span><span class="p">))))</span><span class="w">
 </span><span class="p">{}</span><span class="w">
 </span><span class="n">db-result</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Распечатаем результат. Видим, что статьи сгруппированы по авторам:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:authors</span><span class="w">
 </span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="o">#</span><span class="no">:author</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
             </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Petrov"</span><span class="w">
             </span><span class="no">:posts</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="w"> </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Introduction to Python"</span><span class="w"> </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
                     </span><span class="mi">20</span><span class="w"> </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Thoughts on LISP"</span><span class="w"> </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">1</span><span class="p">}}}</span><span class="w">
  </span><span class="mi">2</span><span class="w"> </span><span class="o">#</span><span class="no">:author</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w">
             </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Rublev"</span><span class="w">
             </span><span class="no">:posts</span><span class="w"> </span><span class="p">{</span><span class="mi">30</span><span class="w"> </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Learning Clojure"</span><span class="w"> </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
                     </span><span class="mi">40</span><span class="w"> </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Working on my pet project"</span><span class="w"> </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">2</span><span class="p">}}}}}</span><span class="w">
</span></code></pre></div></div>

<p>Можно отдать эти данные клиенту в виде JSON. Заметим, мы выполнили только один обход функцией <code class="language-plaintext highlighter-rouge">reduce</code>, что немаловажно. Если алгоритм требует два и более обходов выборки, с ее ростом код замедлится.</p>

<p>Расширим алгоритм под тройную вложенность. Предположим, к статьям оставляют комментарии и мы бы хотели видеть несколько последних. Для начала добавим комментарии в базу:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">comments</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
  <span class="nb">text</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
  <span class="n">post_id</span> <span class="nb">integer</span> <span class="k">not</span> <span class="k">null</span> <span class="k">references</span> <span class="n">posts</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">comments</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">post_id</span><span class="p">,</span> <span class="nb">text</span><span class="p">)</span> <span class="k">VALUES</span>
  <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">'Thanks for sharing this!'</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">'Nice reading, it was useful.'</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">'TL;DR: you must learn lisp'</span><span class="p">);</span>
</code></pre></div></div>

<p>Новый запрос включает авторов, статьи и комментарии к ним. Обратите внимание на разницу в операторах <code class="language-plaintext highlighter-rouge">JOIN</code>. Для таблицы <code class="language-plaintext highlighter-rouge">posts</code> это <code class="language-plaintext highlighter-rouge">(INNER) JOIN</code>. С ним мы пропустим авторов, у которых нет статей. Но для <code class="language-plaintext highlighter-rouge">comments</code> используем <code class="language-plaintext highlighter-rouge">LEFT JOIN</code>, чтобы оставить статьи без комментариев.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">a</span><span class="p">.</span><span class="n">id</span>        <span class="k">as</span> <span class="nv">"author/id"</span><span class="p">,</span>
  <span class="n">a</span><span class="p">.</span><span class="n">name</span>      <span class="k">as</span> <span class="nv">"author/name"</span><span class="p">,</span>
  <span class="n">p</span><span class="p">.</span><span class="n">id</span>        <span class="k">as</span> <span class="nv">"post/id"</span><span class="p">,</span>
  <span class="n">p</span><span class="p">.</span><span class="n">title</span>     <span class="k">as</span> <span class="nv">"post/title"</span><span class="p">,</span>
  <span class="n">p</span><span class="p">.</span><span class="n">author_id</span> <span class="k">as</span> <span class="nv">"post/author-id"</span><span class="p">,</span>
  <span class="k">c</span><span class="p">.</span><span class="n">id</span>        <span class="k">as</span> <span class="nv">"comment/id"</span><span class="p">,</span>
  <span class="k">c</span><span class="p">.</span><span class="nb">text</span>      <span class="k">as</span> <span class="nv">"comment/text"</span>
<span class="k">FROM</span> <span class="n">authors</span> <span class="n">a</span>
<span class="k">JOIN</span> <span class="n">posts</span> <span class="n">p</span> <span class="k">ON</span> <span class="n">p</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">comments</span> <span class="k">c</span> <span class="k">ON</span> <span class="k">c</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Повторов станет еще больше:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> author/id | author/name | post/id |         post/title          | post/author-id | comment/id |         comment/text
-----------+-------------+---------+-----------------------------+----------------+------------+------------------------------
         1 | Ivan Petrov |      10 | Introduction to Python      |              1 |        100 | Thanks for sharing this!
         1 | Ivan Petrov |      10 | Introduction to Python      |              1 |        200 | Nice reading, it was useful.
         2 | Ivan Rublev |      30 | Learning Clojure            |              2 |        300 | TL;DR: you must learn lisp
         1 | Ivan Petrov |      20 | Thoughts on LISP            |              1 |            |
         2 | Ivan Rublev |      40 | Working on my pet project   |              2 |            |
</code></pre></div></div>

<p>Доработаем прошлый код. Прежде всего, в функциях <code class="language-plaintext highlighter-rouge">get-author</code>, <code class="language-plaintext highlighter-rouge">get-post</code> и других нет смысла. Поля сущности определяют по пространству, например, все ключи с пространством <code class="language-plaintext highlighter-rouge">:author/</code> относятся к авторам. Напишем общую функцию <code class="language-plaintext highlighter-rouge">get-entity</code>, которая принимает пространство и запись базы данных.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-entity</span><span class="w"> </span><span class="p">[</span><span class="n">entity</span><span class="w"> </span><span class="n">db-row</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">reduce-kv</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">namespace</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="n">entity</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w">
       </span><span class="n">result</span><span class="p">))</span><span class="w">
   </span><span class="p">{}</span><span class="w">
   </span><span class="n">db-row</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>С ней мы получим любую сущность:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">get-entity</span><span class="w"> </span><span class="s">"author"</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="no">:author</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Petrov"</span><span class="p">}</span><span class="w">

</span><span class="p">(</span><span class="nf">get-entity</span><span class="w"> </span><span class="s">"post"</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Introduction to Python"</span><span class="w"> </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Более универсальное решение: напишем функцию, которая принимает запись и вернет словарь сущностей:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">row-&gt;entities</span><span class="w"> </span><span class="p">[</span><span class="n">db-row</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">reduce-kv</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">[(</span><span class="nb">namespace</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="n">v</span><span class="p">))</span><span class="w">
   </span><span class="p">{}</span><span class="w">
   </span><span class="n">db-row</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Пример ее работы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">row-&gt;entities</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w">

</span><span class="p">{</span><span class="s">"author"</span><span class="w"> </span><span class="o">#</span><span class="no">:author</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Petrov"</span><span class="p">}</span><span class="w">
 </span><span class="s">"post"</span><span class="w"> </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Introduction to Python"</span><span class="w"> </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">1</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы извлечь сущности в переменные, применим синтаксис <code class="language-plaintext highlighter-rouge">:strs</code> для разбиения словаря с ключами-строками. Это значительно сэкономит код.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:strs</span><span class="w"> </span><span class="p">[</span><span class="n">author</span><span class="w">
              </span><span class="n">post</span><span class="w">
              </span><span class="nb">comment</span><span class="p">]}</span><span class="w"> </span><span class="p">(</span><span class="nf">row-&gt;entities</span><span class="w"> </span><span class="n">row</span><span class="p">)]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Новый обход с учетом комментариев:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">reduce</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">row</span><span class="p">]</span><span class="w">

   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:strs</span><span class="w"> </span><span class="p">[</span><span class="n">author</span><span class="w"> </span><span class="n">post</span><span class="w"> </span><span class="nb">comment</span><span class="p">]}</span><span class="w">
         </span><span class="p">(</span><span class="nf">row-&gt;entities</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w">

         </span><span class="p">{</span><span class="n">author-id</span><span class="w"> </span><span class="no">:author/id</span><span class="p">}</span><span class="w">   </span><span class="n">author</span><span class="w">
         </span><span class="p">{</span><span class="n">post-id</span><span class="w"> </span><span class="no">:post/id</span><span class="p">}</span><span class="w">       </span><span class="n">post</span><span class="w">
         </span><span class="p">{</span><span class="n">comment-id</span><span class="w"> </span><span class="no">:comment/id</span><span class="p">}</span><span class="w"> </span><span class="nb">comment</span><span class="p">]</span><span class="w">

     </span><span class="p">(</span><span class="nf">cond-&gt;</span><span class="w"> </span><span class="n">result</span><span class="w">
       </span><span class="no">:then</span><span class="w">
       </span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="p">[</span><span class="no">:authors</span><span class="w">
                   </span><span class="n">author-id</span><span class="p">]</span><span class="w"> </span><span class="nb">merge</span><span class="w"> </span><span class="n">author</span><span class="p">)</span><span class="w">

       </span><span class="no">:then</span><span class="w">
       </span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="p">[</span><span class="no">:authors</span><span class="w">
                   </span><span class="n">author-id</span><span class="w">
                   </span><span class="no">:author/posts</span><span class="w">
                   </span><span class="n">post-id</span><span class="p">]</span><span class="w"> </span><span class="nb">merge</span><span class="w"> </span><span class="n">post</span><span class="p">)</span><span class="w">

       </span><span class="n">comment-id</span><span class="w">
       </span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="p">[</span><span class="no">:authors</span><span class="w">
                   </span><span class="n">author-id</span><span class="w">
                   </span><span class="no">:author/posts</span><span class="w">
                   </span><span class="n">post-id</span><span class="w">
                   </span><span class="no">:post/comments</span><span class="w">
                   </span><span class="n">comment-id</span><span class="p">]</span><span class="w"> </span><span class="nb">merge</span><span class="w"> </span><span class="nb">comment</span><span class="p">))))</span><span class="w">
 </span><span class="p">{}</span><span class="w">
 </span><span class="n">db-result</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание: вместо линейного оператора <code class="language-plaintext highlighter-rouge">-&gt;</code> мы используем условный <code class="language-plaintext highlighter-rouge">cond-&gt;</code>. С ним комментарий присоединяется к результату только если поле <code class="language-plaintext highlighter-rouge">comment-id</code> не пустое. Проверка необходима, потому что комментарий может быть пустым. Результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:authors</span><span class="w">
 </span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="o">#</span><span class="no">:author</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
             </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Petrov"</span><span class="w">
             </span><span class="no">:posts</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="w"> </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">10</span><span class="w">
                               </span><span class="no">:title</span><span class="w"> </span><span class="s">"Introduction to Python"</span><span class="w">
                               </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">1</span><span class="w">
                               </span><span class="no">:comments</span><span class="w"> </span><span class="p">{</span><span class="mi">100</span><span class="w"> </span><span class="o">#</span><span class="no">:comment</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">100</span><span class="w">
                                                        </span><span class="no">:text</span><span class="w"> </span><span class="s">"Thanks for sharing this!"</span><span class="w">
                                                        </span><span class="no">:post-id</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w">
                                          </span><span class="mi">200</span><span class="w"> </span><span class="o">#</span><span class="no">:comment</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">200</span><span class="w">
                                                        </span><span class="no">:text</span><span class="w"> </span><span class="s">"Nice reading, it was useful."</span><span class="w">
                                                        </span><span class="no">:post-id</span><span class="w"> </span><span class="mi">10</span><span class="p">}}}</span><span class="w">
                     </span><span class="mi">20</span><span class="w"> </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Thoughts on LISP"</span><span class="w"> </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">1</span><span class="p">}}}</span><span class="w">
  </span><span class="mi">2</span><span class="w"> </span><span class="o">#</span><span class="no">:author</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w">
             </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Rublev"</span><span class="w">
             </span><span class="no">:posts</span><span class="w"> </span><span class="p">{</span><span class="mi">30</span><span class="w"> </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">30</span><span class="w">
                               </span><span class="no">:title</span><span class="w"> </span><span class="s">"Learning Clojure"</span><span class="w">
                               </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">2</span><span class="w">
                               </span><span class="no">:comments</span><span class="w"> </span><span class="p">{</span><span class="mi">300</span><span class="w"> </span><span class="o">#</span><span class="no">:comment</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">300</span><span class="w">
                                                        </span><span class="no">:text</span><span class="w"> </span><span class="s">"TL;DR: you must learn lisp"</span><span class="w">
                                                        </span><span class="no">:post-id</span><span class="w"> </span><span class="mi">30</span><span class="p">}}}</span><span class="w">
                     </span><span class="mi">40</span><span class="w"> </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Working on my pet project"</span><span class="w"> </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">2</span><span class="p">}}}}}</span><span class="w">
</span></code></pre></div></div>

<p>Из примеров напрашивается общая функция группировки. Они принимает результат базы и описание сущностей: их поля и связи между родителем и потомком. Функция обходит выборку согласно структуре и наполняет словарь результата. С учетом всех тонкостей код будет велик, поэтому оставим эту задачу в качестве упражнения.</p>

<h3 id="порядок-записей">Порядок записей</h3>

<p>У нашего обхода один недостаток. Предположим, мы выбрали данные из базы в особом порядке: авторы по алфавиту, статьи — по дате публикации, комментарии — по оценке пользователями. Поскольку мы группируем сущности в словарях, порядок записей теряется. Если отправить данные из примера выше клиенту, он будет вынужден сортировать их заново, что неудобно.</p>

<p>Чтобы клиент был доволен, после группировки мы должны восстановить порядок записей. В техническом плане поля <code class="language-plaintext highlighter-rouge">:authors</code>, <code class="language-plaintext highlighter-rouge">:author/posts</code> и <code class="language-plaintext highlighter-rouge">:post/comments</code> должны стать списками, элементы которых идут в той же последовательности, что и в запросе. Для этого назначим сущностям поле <code class="language-plaintext highlighter-rouge">:db/index</code> с числом – позицию в выборке. Чтобы знать индекс на каждом шаге, напишем служебную функцию <code class="language-plaintext highlighter-rouge">enumerate</code>. Она превращает коллекцию в список пар, где первый элемент — индекс от нуля:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">enumerate</span><span class="w">
  </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">map-indexed</span><span class="w"> </span><span class="nb">vector</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">enumerate</span><span class="w"> </span><span class="p">[</span><span class="s">"a"</span><span class="w"> </span><span class="s">"b"</span><span class="w"> </span><span class="s">"c"</span><span class="p">])</span><span class="w">
</span><span class="c1">;; ([0 "a"] [1 "b"] [2 "c"])</span><span class="w">
</span></code></pre></div></div>

<p>Группировка сущностей тоже изменится: теперь она принимает индекс и добавляет его к каждой сущности.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">row-&gt;entities</span><span class="w"> </span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="n">db-row</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">reduce-kv</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="n">result</span><span class="w">
             </span><span class="p">(</span><span class="nb">namespace</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">
             </span><span class="nb">assoc</span><span class="w">
             </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w">
             </span><span class="no">:db/index</span><span class="w"> </span><span class="n">idx</span><span class="p">))</span><span class="w">
   </span><span class="p">{}</span><span class="w">
   </span><span class="n">db-row</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Пример:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">row-&gt;entities</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="no">:post/id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:author/id</span><span class="w"> </span><span class="mi">2</span><span class="p">})</span><span class="w">

</span><span class="p">{</span><span class="s">"post"</span><span class="w"> </span><span class="p">{</span><span class="no">:post/id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
 </span><span class="s">"author"</span><span class="w"> </span><span class="p">{</span><span class="no">:author/id</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">3</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Новый обход выборки отличается тем, что <code class="language-plaintext highlighter-rouge">reduce</code> принимает результат <code class="language-plaintext highlighter-rouge">enumerate</code>. Индекс каждой записи передается в <code class="language-plaintext highlighter-rouge">row-&gt;entities</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">reduce</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="n">row</span><span class="p">]]</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:strs</span><span class="w"> </span><span class="p">[</span><span class="n">author</span><span class="w"> </span><span class="n">post</span><span class="w"> </span><span class="nb">comment</span><span class="p">]}</span><span class="w">
         </span><span class="p">(</span><span class="nf">row-&gt;entities</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="n">row</span><span class="p">)]</span><span class="w">
     </span><span class="n">...</span><span class="p">))</span><span class="w">
 </span><span class="p">{}</span><span class="w">
 </span><span class="p">(</span><span class="nf">enumerate</span><span class="w"> </span><span class="n">db-result</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Приведем малую часть результата:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:authors</span><span class="w">
 </span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="no">:author/id</span><span class="w"> </span><span class="mi">1</span><span class="w">
     </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">3</span><span class="w">
     </span><span class="no">:author/posts</span><span class="w">
     </span><span class="p">{</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="no">:post/id</span><span class="w"> </span><span class="mi">10</span><span class="w">
          </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">1</span><span class="w">
          </span><span class="no">:post/comments</span><span class="w">
          </span><span class="p">{</span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="no">:comment/id</span><span class="w"> </span><span class="mi">100</span><span class="w">
                </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">0</span><span class="w">
                </span><span class="no">:comment/post-id</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w">
           </span><span class="mi">200</span><span class="w"> </span><span class="p">{</span><span class="no">:comment/id</span><span class="w"> </span><span class="mi">200</span><span class="w">
                </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">1</span><span class="w">
                </span><span class="no">:comment/post-id</span><span class="w"> </span><span class="mi">10</span><span class="p">}}}}}}}</span><span class="w">
</span></code></pre></div></div>

<p>Видим, что в каждой сущности появилось поле <code class="language-plaintext highlighter-rouge">:db/index</code>. Изменим дерево так, чтобы некоторые словари стали вектором, упорядоченным по этому полю. Проще всего это сделать модулем <code class="language-plaintext highlighter-rouge">clojure.walk</code>. Подготовим проверку на элемент словаря:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">entry?</span><span class="w">
  </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">instance?</span><span class="w"> </span><span class="n">clojure.lang.MapEntry</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Укажем теги, которые нуждаются в сортировке:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">nested-tags</span><span class="w">
  </span><span class="o">#</span><span class="p">{</span><span class="no">:authors</span><span class="w"> </span><span class="no">:author/posts</span><span class="w"> </span><span class="no">:post/comments</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Вот как выглядит “ремаппинг” сущностей. Если текущая форма – элемент словаря, а ключ – один из тех, что нуждается в сортировке, то значение (вложенный словарь) приводится к вектору, элементы которого – значения вложенного словаря, упорядоченные по <code class="language-plaintext highlighter-rouge">:db/index</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-entities</span><span class="w">
  </span><span class="p">[</span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">entry?</span><span class="w"> </span><span class="n">form</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">nested-tags</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">
        </span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="nb">vals</span><span class="w"> </span><span class="p">(</span><span class="nb">sort-by</span><span class="w"> </span><span class="no">:db/index</span><span class="p">)</span><span class="w"> </span><span class="n">vec</span><span class="p">)]</span><span class="w">
        </span><span class="n">form</span><span class="p">))</span><span class="w">
    </span><span class="n">form</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Мы используем префикс <code class="language-plaintext highlighter-rouge">remap-</code> вместо <code class="language-plaintext highlighter-rouge">sort-</code> потому, что функция не только сортирует сущности, но и меняет структуру данных. Подключим модуль <code class="language-plaintext highlighter-rouge">clojure.walk</code> и вызовем <code class="language-plaintext highlighter-rouge">prewalk</code> с новой функцией и результатом группировки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.walk</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">walk</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="no">:authors</span><span class="w">
 </span><span class="p">(</span><span class="nf">walk/prewalk</span><span class="w"> </span><span class="n">remap-entities</span><span class="w"> </span><span class="n">result-grouped</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="no">:author/id</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">3</span><span class="w">
  </span><span class="no">:author/name</span><span class="w"> </span><span class="s">"Ivan Petrov"</span><span class="w">
  </span><span class="no">:author/posts</span><span class="w">
  </span><span class="p">[{</span><span class="no">:post/id</span><span class="w"> </span><span class="mi">10</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="no">:post/title</span><span class="w"> </span><span class="s">"Introduction to Python"</span><span class="w">
    </span><span class="no">:post/author-id</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="no">:post/comments</span><span class="w">
    </span><span class="p">[{</span><span class="no">:comment/id</span><span class="w"> </span><span class="mi">100</span><span class="w">
      </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">0</span><span class="w">
      </span><span class="no">:comment/text</span><span class="w"> </span><span class="s">"Thanks for sharing this!"</span><span class="w">
      </span><span class="no">:comment/post-id</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w">
     </span><span class="p">{</span><span class="no">:comment/id</span><span class="w"> </span><span class="mi">200</span><span class="w">
      </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">1</span><span class="w">
      </span><span class="no">:comment/text</span><span class="w"> </span><span class="s">"Nice reading, it was useful."</span><span class="w">
      </span><span class="no">:comment/post-id</span><span class="w"> </span><span class="mi">10</span><span class="p">}]}</span><span class="w">
   </span><span class="p">{</span><span class="no">:post/id</span><span class="w"> </span><span class="mi">20</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">3</span><span class="w">
    </span><span class="no">:post/title</span><span class="w"> </span><span class="s">"Thoughts on LISP"</span><span class="w">
    </span><span class="no">:post/author-id</span><span class="w"> </span><span class="mi">1</span><span class="p">}]}</span><span class="w">
 </span><span class="p">{</span><span class="no">:author/id</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">4</span><span class="w">
  </span><span class="no">:author/name</span><span class="w"> </span><span class="s">"Ivan Rublev"</span><span class="w">
  </span><span class="no">:author/posts</span><span class="w">
  </span><span class="p">[{</span><span class="no">:post/id</span><span class="w"> </span><span class="mi">30</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">2</span><span class="w">
    </span><span class="no">:post/title</span><span class="w"> </span><span class="s">"Learning Clojure"</span><span class="w">
    </span><span class="no">:post/author-id</span><span class="w"> </span><span class="mi">2</span><span class="w">
    </span><span class="no">:post/comments</span><span class="w">
    </span><span class="p">[{</span><span class="no">:comment/id</span><span class="w"> </span><span class="mi">300</span><span class="w">
      </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">2</span><span class="w">
      </span><span class="no">:comment/text</span><span class="w"> </span><span class="s">"TL;DR: you must learn lisp"</span><span class="w">
      </span><span class="no">:comment/post-id</span><span class="w"> </span><span class="mi">30</span><span class="p">}]}</span><span class="w">
   </span><span class="p">{</span><span class="no">:post/id</span><span class="w"> </span><span class="mi">40</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="mi">4</span><span class="w">
    </span><span class="no">:post/title</span><span class="w"> </span><span class="s">"Working on my pet project"</span><span class="w">
    </span><span class="no">:post/author-id</span><span class="w"> </span><span class="mi">2</span><span class="p">}]}]</span><span class="w">
</span></code></pre></div></div>

<p>Эти данные устроят клиента, поскольку не нуждаются в обработке на стороне браузера. Разве что поле <code class="language-plaintext highlighter-rouge">:db/index</code> можно удалить: это технический артефакт, в котором больше нет смысла. Доработайте <code class="language-plaintext highlighter-rouge">remap-entities</code> так, чтобы после <code class="language-plaintext highlighter-rouge">(sort-by :db/index)</code> шла форма с удалением <code class="language-plaintext highlighter-rouge">:db/index</code>. Искушенные читатели могут объединить сортировку и удаление в трансдьюсер.</p>

<h3 id="итог">Итог</h3>

<p>Подход fetch related означает, что записи извлекают по слоям. Сперва находят основные сущности, затем те, что ссылаются на них и так далее. Подобные запросы содержат оператор <code class="language-plaintext highlighter-rouge">IN</code> с набором первичных ключей. Чтобы не передать их огромное количество, дочерние записи накапливают в цикле с шагом в сто элементов. Для вашего проекта это число может быть другим.</p>

<p>Способ, когда из базы выбирают все за раз, называется select related. Одноименный метод в ORM добавляет в запрос оператор <code class="language-plaintext highlighter-rouge">(LEFT) JOIN</code> с дочерними таблицами, которые ссылаются на основную. Позже, когда вы обращаетесь к полям-ссылкам, система находит их из выборки без обращения к базе.</p>

<p>Каждый подход несет преимущества и недостатки. Select related снижает число обращений к базе, но требует код, который приведет плоскую выборку к дереву. Как правило, содержание базы стоит дороже, поэтому если можно снизить на нее нагрузку, создав больше приложений, так и поступают.</p>

<p>С другой стороны, желание выбрать все за раз может обернуться медленным запросом, особенно если участвуют много таблиц с оператором <code class="language-plaintext highlighter-rouge">JOIN</code>. В нагруженных проектах это даже невозможно из-за того, что таблицы разносят по разным базам. В этом случае подход fetch related остается одним вариантом.</p>

<p>Очевидно, нельзя сказать, какой способ предпочтительней. Важно понимать достоинства и недостатки каждого и верно применять их в текущих условиях.</p>

<h2 id="группировка-в-базе">Группировка в базе</h2>

<p>Рассмотрим третий способ группировать данные — делать это запросом на уровне базы. С помощью функций <code class="language-plaintext highlighter-rouge">json(b)_agg</code> и <code class="language-plaintext highlighter-rouge">json(b)_object_agg</code> можно превратить часть полей во вложенный массив с типом <code class="language-plaintext highlighter-rouge">json(b)</code>. Если расширить протоколы JDBC типом JSON, как описано выше, вызов <code class="language-plaintext highlighter-rouge">jdbc/query</code> вернет привычные коллекции Clojure.</p>

<p>Агрегация JSON не входит в стандарт SQL и поэтому доступна не во всех базах. Однако спрос на эту возможность привел к тому, что в том или ином виде она работает не только в PostgreSQL, но и в MySQL или Sqlite. Уточним, что далее по тексту речь идет именно о PostgreSQL; для других баз синтаксис будет иным.</p>

<p>Агрегация в базе несет преимущества и недостатки. Запрос можно составить так, что данным не нужна обработка — они сразу готовы к отправке. За счет этого уходит код, что мы писали для обхода и группировки. С другой стороны, агрегация занимает ресурсы базы, что может не подойти для нагруженных проектов. Усложняется синтаксис SQL: когда уровней вложенности больше двух, его трудно читать и поддерживать.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">jsonb_agg</code> принимает колонку и возвращает массив jsonb со значениями этих колонок. Еще одна функция <code class="language-plaintext highlighter-rouge">row_to_json</code> принимает произвольную запись и возвращает JSON, где ключи — имена полей записи. Вместе эти функции группируют целые таблицы и подзапросы, а не только колонки.</p>

<p>Вернемся к примеру с авторами, статьями и комментариями. Для начала выберем статьи с комментариями:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">p</span><span class="p">.</span><span class="n">id</span>        <span class="k">as</span> <span class="nv">"post/id"</span><span class="p">,</span>
  <span class="n">p</span><span class="p">.</span><span class="n">title</span>     <span class="k">as</span> <span class="nv">"post/title"</span><span class="p">,</span>
  <span class="n">p</span><span class="p">.</span><span class="n">author_id</span> <span class="k">as</span> <span class="nv">"post/author-id"</span><span class="p">,</span>
  <span class="n">json_agg</span><span class="p">(</span><span class="n">row_to_json</span><span class="p">(</span><span class="k">c</span><span class="p">))</span> <span class="n">FILTER</span> <span class="p">(</span><span class="k">WHERE</span> <span class="k">c</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">)</span> <span class="k">as</span> <span class="nv">"post/comments"</span>
<span class="k">FROM</span> <span class="n">posts</span> <span class="n">p</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">comments</span> <span class="k">c</span> <span class="k">ON</span> <span class="k">c</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Результат:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> post/id |         post/title          | post/author-id |                                                       post/comments
---------+-----------------------------+----------------+----------------------------------------------------------------------------------------------------------------------------
      10 | Introduction to Python      |              1 | [{"id":100,"text":"Thanks for sharing this!","post_id":10}, {"id":200,"text":"Nice reading, it was useful.","post_id":10}]
      20 | Thoughts on LISP            |              1 |
      30 | Learning Clojure            |              2 | [{"id":300,"text":"TL;DR: you must learn lisp","post_id":30}]
      40 | Working on my pet project   |              2 |
</code></pre></div></div>

<p>Статья, у которой нет комментариев, осталась в выборке. Поле <code class="language-plaintext highlighter-rouge">post/comments</code> носит тип json; внутри него массив объектов, где каждый объект представляет запись таблицы <code class="language-plaintext highlighter-rouge">comments</code>.</p>

<p>Выражение <code class="language-plaintext highlighter-rouge">FILTER</code> после <code class="language-plaintext highlighter-rouge">json_agg</code> отсекает пустые элементы. Если этого не сделать, получим массив с одним элементом <code class="language-plaintext highlighter-rouge">NULL</code>, что семантически неверно.</p>

<p>Теперь выберем авторов и присоединим к ним запрос выше со статьями и комментариями. Поместим его в подзапрос и сгруппируем еще раз по авторам. При наборе подобного SQL важны отступы, чтобы не запутаться с логическим уровнем.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">a</span><span class="p">.</span><span class="n">id</span>                         <span class="k">as</span> <span class="nv">"author/id"</span><span class="p">,</span>
  <span class="n">a</span><span class="p">.</span><span class="n">name</span>                       <span class="k">as</span> <span class="nv">"author/name"</span><span class="p">,</span>
  <span class="n">json_agg</span><span class="p">(</span><span class="n">row_to_json</span><span class="p">(</span><span class="n">posts</span><span class="p">))</span> <span class="k">as</span> <span class="nv">"author/posts"</span>
<span class="k">FROM</span>
  <span class="n">authors</span> <span class="n">a</span><span class="p">,</span>
  <span class="p">(</span><span class="k">SELECT</span>
    <span class="n">p</span><span class="p">.</span><span class="n">id</span>        <span class="k">as</span> <span class="nv">"post/id"</span><span class="p">,</span>
    <span class="n">p</span><span class="p">.</span><span class="n">title</span>     <span class="k">as</span> <span class="nv">"post/title"</span><span class="p">,</span>
    <span class="n">p</span><span class="p">.</span><span class="n">author_id</span> <span class="k">as</span> <span class="nv">"post/author-id"</span><span class="p">,</span>
    <span class="n">json_agg</span><span class="p">(</span><span class="n">row_to_json</span><span class="p">(</span><span class="k">c</span><span class="p">))</span> <span class="n">FILTER</span> <span class="p">(</span><span class="k">WHERE</span> <span class="k">c</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">)</span> <span class="k">as</span> <span class="nv">"post/comments"</span>
  <span class="k">FROM</span> <span class="n">posts</span> <span class="n">p</span>
  <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">comments</span> <span class="k">c</span> <span class="k">ON</span> <span class="k">c</span><span class="p">.</span><span class="n">post_id</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span>
<span class="p">)</span> <span class="k">AS</span> <span class="n">posts</span>
<span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">posts</span><span class="p">.</span><span class="nv">"post/author-id"</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Если выполнить запрос, получим данные как в примере ниже. Они готовы к отправке клиенту; не требуется сортировка или дополнительный обход.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">#</span><span class="no">:author</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
          </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Petrov"</span><span class="w">
          </span><span class="no">:posts</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">10</span><span class="w">
                         </span><span class="no">:title</span><span class="w"> </span><span class="s">"Introduction to Python"</span><span class="w">
                         </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">1</span><span class="w">
                         </span><span class="no">:comments</span><span class="w"> </span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="no">:text</span><span class="w"> </span><span class="s">"Thanks for sharing this!"</span><span class="w"> </span><span class="no">:post_id</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w">
                                    </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">200</span><span class="w">
                                     </span><span class="no">:text</span><span class="w"> </span><span class="s">"Nice reading, it was useful."</span><span class="w">
                                     </span><span class="no">:post_id</span><span class="w"> </span><span class="mi">10</span><span class="p">}]}</span><span class="w">
                  </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">20</span><span class="w">
                         </span><span class="no">:title</span><span class="w"> </span><span class="s">"Thoughts on LISP"</span><span class="w">
                         </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">1</span><span class="w">
                         </span><span class="no">:comments</span><span class="w"> </span><span class="n">nil</span><span class="p">}]}</span><span class="w">
 </span><span class="o">#</span><span class="no">:author</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w">
          </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan Rublev"</span><span class="w">
          </span><span class="no">:posts</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">30</span><span class="w">
                         </span><span class="no">:title</span><span class="w"> </span><span class="s">"Learning Clojure"</span><span class="w">
                         </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">2</span><span class="w">
                         </span><span class="no">:comments</span><span class="w"> </span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">300</span><span class="w"> </span><span class="no">:text</span><span class="w"> </span><span class="s">"TL;DR: you must learn lisp"</span><span class="w"> </span><span class="no">:post_id</span><span class="w"> </span><span class="mi">30</span><span class="p">}]}</span><span class="w">
                  </span><span class="o">#</span><span class="no">:post</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">40</span><span class="w">
                         </span><span class="no">:title</span><span class="w"> </span><span class="s">"Working on my pet project"</span><span class="w">
                         </span><span class="no">:author-id</span><span class="w"> </span><span class="mi">2</span><span class="w">
                         </span><span class="no">:comments</span><span class="w"> </span><span class="n">nil</span><span class="p">}]}]</span><span class="w">
</span></code></pre></div></div>

<p>Библиотеки HugSQL и HoneySQL помогают строить подобные запросы по частям. В обоих случаях можно вынести внутреннюю часть (статьи и комментарии) в отдельную сущность и сослаться на нее. В HugSQL мы бы вынесли подзапрос в сниппет, а в HoneySQL поместили бы его в переменную. С таким подходом главный запрос выглядит чище и удобней для чтения.</p>

<p>Рассмотрим другой пример группировки. Предположим, таблица хранит данные о товарах: артикул, название и так далее. У каждого товара могут быть десятки характеристик: жанр книги, размер талии или разъем питания. Чтобы бесконечно не добавлять столбцы к товарам, вынесем характеристики в отдельную таблицу с именем характеристики, значением и ссылкой на товар.</p>

<p>Подготовим таблицы:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">goods</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
  <span class="n">title</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">good_attrs</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
  <span class="n">good_id</span> <span class="nb">integer</span> <span class="k">not</span> <span class="k">null</span> <span class="k">references</span> <span class="n">goods</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
  <span class="n">attr</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
  <span class="n">val</span> <span class="n">jsonb</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Добавим несколько товаров с характеристиками:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">goods</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'iPhone 99x'</span><span class="p">),</span>
       <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Galaxy 33.plus'</span><span class="p">),</span>
       <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'G. Orwell 1984'</span><span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">good_attrs</span> <span class="p">(</span><span class="n">good_id</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'phone.display.diag'</span><span class="p">,</span> <span class="s1">'145'</span><span class="p">),</span>
       <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'phone.wifi.support'</span><span class="p">,</span> <span class="s1">'true'</span><span class="p">),</span>
       <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'book.pages'</span><span class="p">,</span> <span class="s1">'215'</span><span class="p">),</span>
       <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'book.genre'</span><span class="p">,</span> <span class="s1">'"dystopia"'</span><span class="p">);</span>
</code></pre></div></div>

<p>Обратите внимание, что значение характеристики носит тип <code class="language-plaintext highlighter-rouge">jsonb</code>. Это значит, нам доступно все богатство его типов. Например, можно указать размер одежды буквой (L, M); число портов натуральным числом (2, 3); поддержку протокола (истина или ложь); список ссылок на сторонние ресурсы (массив строк).</p>

<p>Хотелось бы извлечь товары одним запросом, чтобы получить структуру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="no">:title</span><span class="w"> </span><span class="s">"iPhone 99x"</span><span class="w">
  </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:phone.display.diag</span><span class="w"> </span><span class="mi">145</span><span class="w">
          </span><span class="no">:phone.wifi.support</span><span class="w"> </span><span class="n">true</span><span class="p">}}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="no">:title</span><span class="w"> </span><span class="s">"Galaxy 33.plus"</span><span class="w">
  </span><span class="no">:attrs</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">3</span><span class="w">
  </span><span class="no">:title</span><span class="w"> </span><span class="s">"G. Orwell 1984"</span><span class="w">
  </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:book.genre</span><span class="w"> </span><span class="s">"dystopia"</span><span class="w">
          </span><span class="no">:book.pages</span><span class="w"> </span><span class="mi">215</span><span class="p">}}]</span><span class="w">
</span></code></pre></div></div>

<p>Однако при выборке в лоб через JOIN получим задвоение товаров, что требует обработки результата.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">json_object_agg</code> принимает списки ключей и значений и строит словарь (в терминах JSON — объект). Напишем вложенный запрос, который группирует колонки <code class="language-plaintext highlighter-rouge">attr</code> и <code class="language-plaintext highlighter-rouge">val</code> таблицы <code class="language-plaintext highlighter-rouge">good_attrs</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SELECT</span><span class="w">
  </span><span class="n">ga.good_id,</span><span class="w">
  </span><span class="n">jsonb_object_agg</span><span class="p">(</span><span class="nf">ga.attr,</span><span class="w"> </span><span class="n">ga.val</span><span class="p">)</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">attrs</span><span class="w">
</span><span class="n">FROM</span><span class="w"> </span><span class="n">good_attrs</span><span class="w"> </span><span class="n">ga</span><span class="w">
  </span><span class="n">GROUP</span><span class="w"> </span><span class="n">BY</span><span class="w"> </span><span class="n">ga.good_id</span><span class="c1">;</span><span class="w">
</span></code></pre></div></div>

<p>Результат:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> good_id |                          attrs
---------+---------------------------------------------------------
       3 | {"book.genre": "dystopia", "book.pages": 215}
       1 | {"phone.display.diag": 145, "phone.wifi.support": true}
</code></pre></div></div>

<p>Поместим его в подзапрос и присоединим к товарам при помощи <code class="language-plaintext highlighter-rouge">LEFT JOIN</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="k">g</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
  <span class="k">g</span><span class="p">.</span><span class="n">title</span><span class="p">,</span>
  <span class="n">a</span><span class="p">.</span><span class="n">attrs</span>
<span class="k">FROM</span>
  <span class="n">goods</span> <span class="k">g</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="p">(</span>
  <span class="k">SELECT</span>
    <span class="n">ga</span><span class="p">.</span><span class="n">good_id</span><span class="p">,</span>
    <span class="n">jsonb_object_agg</span><span class="p">(</span><span class="n">ga</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span> <span class="n">ga</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="k">as</span> <span class="n">attrs</span>
  <span class="k">FROM</span> <span class="n">good_attrs</span> <span class="n">ga</span>
    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">ga</span><span class="p">.</span><span class="n">good_id</span>
<span class="p">)</span> <span class="n">a</span> <span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">good_id</span> <span class="o">=</span> <span class="k">g</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> id |     title      |                          attrs
----+----------------+---------------------------------------------------------
  1 | iPhone 99x     | {"phone.display.diag": 145, "phone.wifi.support": true}
  2 | Galaxy 33.plus |
  3 | G. Orwell 1984 | {"book.genre": "dystopia", "book.pages": 215}
</code></pre></div></div>

<p>Товар, у которого нет характеристик, остался в выборке. Если передать итоговый запрос в <code class="language-plaintext highlighter-rouge">jdbc/query</code>, получим именно ту структуру данных Clojure, на которую рассчитывали.</p>

<p>В этом преимущество <code class="language-plaintext highlighter-rouge">json(b)</code>: PostgreSQL предлагает множество функций для этого типа, в том числе группировку. Любое поле <code class="language-plaintext highlighter-rouge">json(b)</code> будет прочитано в Clojure за счет протокола. Это может быть массив, словарь и любая их комбинация.</p>

<p>Еще один прием, связанный с группировкий — использовать <code class="language-plaintext highlighter-rouge">row_to_json</code> в сочетании с оператором <code class="language-plaintext highlighter-rouge">UNION</code>. Он объединяет несколько запросов по вертикали, при этом обязательно, чтобы состав полей (их число и типы) был одинаков во всех запросах. Пример с числом и строкой:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="mi">1</span> <span class="k">as</span> <span class="n">id</span><span class="p">,</span> <span class="s1">'foo'</span> <span class="k">as</span> <span class="n">name</span>
<span class="k">UNION</span>
<span class="k">select</span> <span class="mi">2</span> <span class="k">as</span> <span class="n">id</span><span class="p">,</span> <span class="s1">'bar'</span> <span class="k">as</span> <span class="n">name</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> id | name
----+------
  1 | foo
  2 | bar
</code></pre></div></div>

<p>Иногда в проекте бывает несколько похожих сущностей в разных таблицах. Например, договоры с юрлицами и населением; администраторы и пользователи; крупные и малые поставщики. Из-за разной структуры их нельзя объединить в один запрос. Но поскольку функция <code class="language-plaintext highlighter-rouge">row_to_json</code> приводит запись к json, можно объединить результаты любых записей.</p>

<p>Покажем это на примере. Предположим, администраторы системы хранятся отдельно от пользователей, но в какой-то момент нужно увидеть и тех, и других. Создадим таблицу администраторов:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">admins</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">serial</span><span class="p">,</span>
  <span class="n">full_name</span> <span class="nb">text</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">email</span> <span class="nb">text</span>
<span class="p">);</span>
</code></pre></div></div>

<p>и несколько записей:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">admins</span> <span class="p">(</span><span class="n">full_name</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Petr Smirnov'</span><span class="p">,</span> <span class="s1">'petr@test.com'</span><span class="p">),</span>
       <span class="p">(</span><span class="s1">'Oleg Ivanov'</span><span class="p">,</span> <span class="s1">'oleg@test.com'</span><span class="p">);</span>
</code></pre></div></div>

<p>Ниже — запрос, который выберет обе сущности. Обратите внимание на поля <code class="language-plaintext highlighter-rouge">id</code> и <code class="language-plaintext highlighter-rouge">type</code> в обеих частях. Первичный ключ (<code class="language-plaintext highlighter-rouge">id</code>) нужен настолько часто, что логично вынести его на верхний уровень запроса. Поле <code class="language-plaintext highlighter-rouge">type</code> содержит строку с типом сущности: “user” для пользователя и “admin” для администратора. По этому полю легко понять, что находится в <code class="language-plaintext highlighter-rouge">entity</code>.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">id</span><span class="p">,</span>
  <span class="s1">'user'</span> <span class="k">AS</span> <span class="k">type</span><span class="p">,</span>
  <span class="n">row_to_json</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">AS</span> <span class="n">entity</span>
<span class="k">FROM</span>
  <span class="n">users</span> <span class="n">u</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span>
  <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">id</span><span class="p">,</span>
  <span class="s1">'admin'</span> <span class="k">AS</span> <span class="k">type</span><span class="p">,</span>
  <span class="n">row_to_json</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">AS</span> <span class="n">entity</span>
<span class="k">FROM</span>
  <span class="n">admins</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div></div>

<p>Результат в консоли <code class="language-plaintext highlighter-rouge">psql</code>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> id | type  |                                                                           entity
----+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------
  1 | user  | {"id":1,"fname":"Ivan","lname":"Petrov","email":"test@test.com","age":30,"city":null,"year_birth":null,"created_at":"2021-08-10T07:36:03.934029+00:00"}
  3 | user  | {"id":3,"fname":"Huan","lname":null,"email":null,"age":null,"city":null,"year_birth":null,"created_at":"2021-08-10T07:36:03.934029+00:00"}
  1 | admin | {"id":1,"full_name":"Petr Smirnov","email":"petr@test.com"}
  2 | admin | {"id":2,"full_name":"Oleg Ivanov","email":"oleg@test.com"}
</code></pre></div></div>

<p>и в Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="no">:type</span><span class="w"> </span><span class="s">"user"</span><span class="w">
  </span><span class="no">:entity</span><span class="w">
  </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
   </span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
   </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w">
   </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
   </span><span class="no">:age</span><span class="w"> </span><span class="mi">30</span><span class="w">
   </span><span class="no">:city</span><span class="w"> </span><span class="n">nil</span><span class="w">
   </span><span class="no">:year_birth</span><span class="w"> </span><span class="n">nil</span><span class="w">
   </span><span class="no">:created_at</span><span class="w"> </span><span class="s">"2021-08-10T10:36:03.934029+03:00"</span><span class="p">}}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">3</span><span class="w">
  </span><span class="no">:type</span><span class="w"> </span><span class="s">"user"</span><span class="w">
  </span><span class="no">:entity</span><span class="w">
  </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">3</span><span class="w">
   </span><span class="no">:fname</span><span class="w"> </span><span class="s">"Huan"</span><span class="w">
   </span><span class="no">:lname</span><span class="w"> </span><span class="n">nil</span><span class="w">
   </span><span class="no">:email</span><span class="w"> </span><span class="n">nil</span><span class="w">
   </span><span class="no">:age</span><span class="w"> </span><span class="n">nil</span><span class="w">
   </span><span class="no">:city</span><span class="w"> </span><span class="n">nil</span><span class="w">
   </span><span class="no">:year_birth</span><span class="w"> </span><span class="n">nil</span><span class="w">
   </span><span class="no">:created_at</span><span class="w"> </span><span class="s">"2021-08-10T10:36:03.934029+03:00"</span><span class="p">}}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="no">:type</span><span class="w"> </span><span class="s">"admin"</span><span class="w">
  </span><span class="no">:entity</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
           </span><span class="no">:full_name</span><span class="w"> </span><span class="s">"Petr Smirnov"</span><span class="w">
           </span><span class="no">:email</span><span class="w"> </span><span class="s">"petr@test.com"</span><span class="p">}}</span><span class="w">
 </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="no">:type</span><span class="w"> </span><span class="s">"admin"</span><span class="w">
  </span><span class="no">:entity</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w">
           </span><span class="no">:full_name</span><span class="w"> </span><span class="s">"Oleg Ivanov"</span><span class="w">
           </span><span class="no">:email</span><span class="w"> </span><span class="s">"oleg@test.com"</span><span class="p">}}]</span><span class="w">
</span></code></pre></div></div>

<p>При обходе выборки проверим поле <code class="language-plaintext highlighter-rouge">type</code> оператором <code class="language-plaintext highlighter-rouge">case</code> и вызовем нужный обработчик:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">entity</span><span class="p">]}</span><span class="w"> </span><span class="n">result</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">type</span><span class="w">
    </span><span class="s">"user"</span><span class="w"> </span><span class="p">(</span><span class="nf">process-user</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
    </span><span class="s">"admin"</span><span class="w"> </span><span class="p">(</span><span class="nf">process-admin</span><span class="w"> </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Еще одно замечание касается оператора <code class="language-plaintext highlighter-rouge">UNION</code>. Обратите внимание, что мы использовали его <code class="language-plaintext highlighter-rouge">-ALL</code> версию. Если опустить частицу <code class="language-plaintext highlighter-rouge">ALL</code> после <code class="language-plaintext highlighter-rouge">UNION</code>, база попытается убрать дубликаты записей. Чтобы проверить запись на повтор, ее сравнивают с уже накопленными записями. А поскольку тип json не поддерживает сравнение, получим ошибку:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">u</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">id</span><span class="p">,</span>
  <span class="s1">'user'</span> <span class="k">AS</span> <span class="k">type</span><span class="p">,</span>
  <span class="n">row_to_json</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">AS</span> <span class="n">entity</span>
<span class="k">FROM</span>
  <span class="n">users</span> <span class="n">u</span>
<span class="k">UNION</span>
<span class="k">SELECT</span>
  <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">id</span><span class="p">,</span>
  <span class="s1">'admin'</span> <span class="k">AS</span> <span class="k">type</span><span class="p">,</span>
  <span class="n">row_to_json</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">AS</span> <span class="n">entity</span>
<span class="k">FROM</span>
  <span class="n">admins</span> <span class="n">a</span><span class="p">;</span>

<span class="c1">-- ERROR:  could not identify an equality operator for type json</span>
<span class="c1">-- LINE 4:   row_to_json(u) AS entity</span>
</code></pre></div></div>

<p>Чтобы отсечь дубликаты, используйте <code class="language-plaintext highlighter-rouge">to_jsonb</code> вместо <code class="language-plaintext highlighter-rouge">row_to_json</code>. Эта функция вернет результат с типом <code class="language-plaintext highlighter-rouge">jsonb</code>, который поддерживает сравнение. Как следствие, оператор <code class="language-plaintext highlighter-rouge">UNION ALL</code> не вызовет ошибку для поля этого типа.</p>

<p>Группировка в базе может быть удачным решением, которое сэкономит время и код. Однако она зависит от объема данных и их структуры. Опробуйте выборку на больших данных (сотни тысяч записей) и оцените время и план исполнения. Если данных нет, сгенерируйте их спекой. В первой книге о Clojure мы рассмотрели, как это сделать модулем <code class="language-plaintext highlighter-rouge">gen</code>.</p>

<h2 id="миграции">Миграции</h2>

<p>С развитием проекта в базе появляются новые таблицы, индексы, триггеры. Чтобы контролировать изменения в базе, придумана концепция миграций. В этом разделе мы рассмотрим ее общие принципы и как они работают в Clojure.</p>

<p>Технически миграция выглядят как .sql-файл. В нем находится код, который создает таблицы и другие сущности базы. Различают up- и down-миграции, они же прямые и обратные. Как правило, прямые описывают новые сущности, например создают таблицу и индексы для нее. Down-миграция совершает обратное: удаляет индекс и таблицу. В редких случаях отмена не требуется, и тогда миграция состоит только из up-части.</p>

<p>Каждая миграция имеет уникальный идентификатор. Чаще всего это дата в формате ISO или время Unix. Идентификатор должен поддаваться сортировке, чтобы однозначно определить порядок миграций.</p>

<p>Миграции похожи на дерево коммитов: с ними базу можно “накатить” или “откатить” до определенной версии. Подобно тому, как с помощью git мы переключаемся на нужную версию кода, базу данных переключают на нужное состояние. Для этого нужно знать, какая миграция текущая и в какую сторону двигаться.</p>

<p>Сведения о миграциях хранится в базе. Как правило, движок миграций создает таблицу <code class="language-plaintext highlighter-rouge">migrations</code> примерно такой структуры:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">migrations</span> <span class="p">(</span>
  <span class="n">migration_id</span> <span class="nb">text</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
  <span class="n">created_at</span> <span class="nb">timestamp</span><span class="p">,</span>
  <span class="n">description</span> <span class="nb">text</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Таблица запоминает, какие миграции и когда мы применили. При запуске миграций программа читает таблицу и сканирует файлы на диске. Файлы называют по принципу <code class="language-plaintext highlighter-rouge">&lt;time/id&gt;-&lt;description&gt;.&lt;up/down&gt;.sql</code>. Объясним значения в угловых скобках:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;time/id&gt;</code> — время или идентификатор, по которому сортируются миграции;</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;description&gt;</code> — короткое описание миграции;</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;up/down&gt;</code> — признак прямой или обратной миграции.</li>
</ul>

<p>Примеры файлов:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>20210830075251-create-users-table.up.sql
20210830075251-create-users-table.down.sql

20210831064602-create-profiles-table.up.sql
20210831064602-create-profiles-table.down.sql
</code></pre></div></div>

<p>Движок группирует файлы примерно в такую структуру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">migrations</span><span class="w">
  </span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">20210830075251</span><span class="w">
    </span><span class="no">:description</span><span class="w"> </span><span class="s">"Create users table"</span><span class="w">
    </span><span class="no">:up</span><span class="w"> </span><span class="s">"20210830075251-create-users-table.up.sql"</span><span class="w">
    </span><span class="no">:down</span><span class="w"> </span><span class="s">"20210830075251-create-users-table.down.sql"</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">20210831064602</span><span class="w">
    </span><span class="no">:description</span><span class="w"> </span><span class="s">"Create profiles table"</span><span class="w">
    </span><span class="no">:up</span><span class="w"> </span><span class="s">"20210831064602-create-profiles-table.up.sql"</span><span class="w">
    </span><span class="no">:down</span><span class="w"> </span><span class="s">"20210831064602-create-profiles-table.down.sql"</span><span class="p">}])</span><span class="w">
</span></code></pre></div></div>

<p>В зависимости от того, какая версия базы сейчас и что мы хотим сделать, сработают разные алгоритмы. Наиболее частый сценарий — migrate forward, то есть применить миграции, что еще не были обработаны. Технически это значит отфильтровать список миграций по id и выбрать файлы с частичкой <code class="language-plaintext highlighter-rouge">up</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">migrations</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="p">]}]</span><span class="w">
               </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">current-id</span><span class="p">)))</span><span class="w">
     </span><span class="p">(</span><span class="nb">sort-by</span><span class="w"> </span><span class="no">:id</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="no">:up</span><span class="p">))</span><span class="w">

</span><span class="c1">;; ("20210831064602-create-profiles-table.up.sql"...)</span><span class="w">
</span></code></pre></div></div>

<p>Каждуя миграция выполняется в транзакции. Если изменения прошли без ошибок, в таблицу <code class="language-plaintext highlighter-rouge">migrations</code> попадает номер миграции, которую только что выполнили. Даже если миграция “упала” где-то на полпути, не останется ее промежуточных следов.</p>

<p>При движении в обратную сторону стратегия меняется. Если нужно вернуться к прошлой версии базы, указывают нужный идентификатор, и программа применяет down-файлы, чей идентификатор находится между указанным и текущим. При этом порядок миграций обратный: от новых к старым.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">migrations</span><span class="w">
     </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="p">]}]</span><span class="w">
               </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">target_id</span><span class="p">)</span><span class="w">
                    </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">current-id</span><span class="p">))))</span><span class="w">
     </span><span class="p">(</span><span class="nb">sort-by</span><span class="w"> </span><span class="no">:id</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">reverse</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="no">:down</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>У миграций несколько преимуществ. Прежде всего, это автоматизация. Не нужно подключаться к базе и добавлять колонку вручную. Достаточно вызвать прогон миграций на удаленной машине.</p>

<p>При разработке приходится работать с разными версиями кода и, соответственно, базы. Переключать базу должно быть так же удобно, как и ветку в git.</p>

<p>Случается, что изменения в таблицах были неудачны, и это выяснилось после запуска в бою. В этом случае изменения открывают обратной миграцией. Конечно, лучше всего избежать этой ситуации, но иметь средство тоже не помешает.</p>

<p>Наконец, когда схема базы описана в файле, это означает контроль за ней. Проект легче запустить локально, а новичкам проще понять систему таблиц.</p>

<p>Clojure предлагает несколько библиотек для миграций. Мы рассмотрим две из них: Migratus и Ragtime.</p>

<h3 id="migratus">Migratus</h3>

<p>Проект <a href="https://github.com/yogthos/migratus">Migratus</a> состоит из двух частей: библиотеки и плагина к lein. Проще всего начать работу при помощи плагина. Добавьте его в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:plugins</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="w"> </span><span class="p">[</span><span class="n">migratus-lein</span><span class="w"> </span><span class="s">"0.7.3"</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>Напишем несколько миграций. В папке <code class="language-plaintext highlighter-rouge">resources/migrations</code> создайте пока что пустые файлы:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">mkdir</span> <span class="nt">-p</span> resources/migrations
<span class="o">&gt;</span> <span class="nb">cd </span>resources/migrations

<span class="nb">touch </span>20210830075251-create-users-table.up.sql
<span class="nb">touch </span>20210830075251-create-users-table.down.sql
</code></pre></div></div>

<p>Теперь наполним их. Содержимое up-миграции:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TYPE</span> <span class="n">user_status</span> <span class="k">AS</span> <span class="nb">ENUM</span> <span class="p">(</span><span class="s1">'active'</span><span class="p">,</span> <span class="s1">'pending'</span><span class="p">,</span> <span class="s1">'blocked'</span><span class="p">);</span>

<span class="c1">--;;</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">users</span><span class="p">(</span>
  <span class="n">id</span> <span class="nb">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
  <span class="n">name</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
  <span class="n">status</span> <span class="n">user_status</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
  <span class="n">email</span> <span class="nb">text</span>
<span class="p">);</span>

<span class="c1">--;;</span>

<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_users_name</span> <span class="k">ON</span> <span class="n">users</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</code></pre></div></div>

<p>Это прямая (up) половина первой миграции. Она создает тип-перечисление, таблицу <code class="language-plaintext highlighter-rouge">users</code> и индекс на имя пользователя. Чтобы откатить эти шаги, поместите в down-файл следующий код:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">INDEX</span> <span class="n">idx_users_name</span><span class="p">;</span>

<span class="c1">--;;</span>

<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">users</span><span class="p">;</span>

<span class="c1">--;;</span>

<span class="k">DROP</span> <span class="k">TYPE</span> <span class="n">user_status</span><span class="p">;</span>
</code></pre></div></div>

<p>Обратите внимание, что порядок удаления сущностей обратный. Нельзя удалить индекс и тип-перечисление, пока существует таблица.</p>

<p>Когда миграции готовы, применим их к базе. Для этого укажем параметры подключения. В файле <code class="language-plaintext highlighter-rouge">project.clj</code> добавьте ключ <code class="language-plaintext highlighter-rouge">:migratus</code> со словарем:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:store</span><span class="w"> </span><span class="no">:database</span><span class="w">
 </span><span class="no">:migration-dir</span><span class="w"> </span><span class="s">"migrations"</span><span class="w">
 </span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgresql"</span><span class="w">
      </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"migration_test"</span><span class="w">
      </span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
      </span><span class="no">:user</span><span class="w"> </span><span class="s">"book"</span><span class="w">
      </span><span class="no">:password</span><span class="w"> </span><span class="s">"book"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Ключ <code class="language-plaintext highlighter-rouge">:migration-dir</code> указывает папку относительно ресурсов, в которой хранятся миграции. В нашем случае это <code class="language-plaintext highlighter-rouge">resources/migrations</code>. В поле <code class="language-plaintext highlighter-rouge">:db</code> находится знакомая вам JDBC-спека. Выполните в терминале:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lein migratus migrate
</code></pre></div></div>

<p>Вы увидите список миграций, которые плагин применил к базе данных. Подключитесь к ней с помощью <code class="language-plaintext highlighter-rouge">psql</code> или другой утилиты — появится таблица <code class="language-plaintext highlighter-rouge">users</code>. Кроме того, исследуйте таблицу миграций под названием <code class="language-plaintext highlighter-rouge">schema_migrations</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SELECT</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">schema_migrations</span><span class="c1">;</span><span class="w">
</span></code></pre></div></div>

<p>В ней окажется запись с датой и именем миграции:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         id     |         applied         |      description
----------------+-------------------------+-----------------------
 20210830075251 | 2021-08-28 09:28:26.911 | create-users-table
</code></pre></div></div>

<p>Повторный запуск миграций ничего не даст, потому что миграция <code class="language-plaintext highlighter-rouge">20210830075251</code> уже обработана, а новых не появилось. Чтобы откатить изменения, выполните команду <code class="language-plaintext highlighter-rouge">rollback</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">&gt;</span><span class="w"> </span><span class="n">lein</span><span class="w"> </span><span class="n">migratus</span><span class="w"> </span><span class="n">rollback</span><span class="w">
</span></code></pre></div></div>

<p>Это действие означает откатить последнюю транзакцию. После нее не останется таблицы <code class="language-plaintext highlighter-rouge">users</code> и связанных с ней сущностей. Из таблицы <code class="language-plaintext highlighter-rouge">schema_migrations</code> исчезнут сведения о миграции <code class="language-plaintext highlighter-rouge">20210830075251</code>, и ее можно будет применить снова. Применение и откат миграций можно повторять сколько угодно раз при условии, что откат удаляет все изменения прямой части.</p>

<h3 id="несколько-запросов-в-миграции">Несколько запросов в миграции</h3>

<p>Обратите внимание на строку <code class="language-plaintext highlighter-rouge">--;;</code> между запросами в файлах. С точки зрения SQL это обычный комментарий, однако здесь у него особая роль.</p>

<p>По умолчанию Migratus рассматривает файл как единый запрос и выполняет его с помощью <code class="language-plaintext highlighter-rouge">jdbc/execute!</code>. Но не всегда миграцию можно описать одним запросом. В примере выше понадобилось три выражения, чтобы создать перечисление, таблицу и индекс.</p>

<p>Для таких случаев строка <code class="language-plaintext highlighter-rouge">--;;</code> служит разделителем запросов. Migratus разбивает файл и выполняет запросы по одному в транзакции. За счет этого не нужно создавать несколько файлов на каждый запрос.</p>

<p>О разделителе часто забывают новички. Это тот случай, который придется запомнить.</p>

<h3 id="миграции-с-профилями">Миграции с профилями</h3>

<p>При запуске миграций в <code class="language-plaintext highlighter-rouge">lein</code> доступны все опции этого инструмента, в том числе профили. С их помощью легко нацелить Migratus на другую базу или папку с файлами. Например, по умолчанию команда</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lein migratus migrate
</code></pre></div></div>

<p>работает с локальной базой, но с профилем <code class="language-plaintext highlighter-rouge">staging</code> подключается к удаленной тестовой машине:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lein with-profile staging migratus migrate
</code></pre></div></div>

<p>Для этого задайте иные настройки <code class="language-plaintext highlighter-rouge">:migratus</code> в профиле <code class="language-plaintext highlighter-rouge">:staging</code>. Обратите внимание, что необязательно копировать их все. Профили <code class="language-plaintext highlighter-rouge">lein</code> подлежат глубокому слиянию, поэтому достаточно только отличия от корневых настроек <code class="language-plaintext highlighter-rouge">:migratus</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:profiles</span><span class="w">
 </span><span class="p">{</span><span class="no">:staging</span><span class="w">
  </span><span class="p">{</span><span class="no">:migratus</span><span class="w">
   </span><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbname</span><span class="w"> </span><span class="s">"prod_db"</span><span class="w">
         </span><span class="no">:host</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"DB_HOST"</span><span class="p">)</span><span class="w">
         </span><span class="no">:user</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"DB_USER"</span><span class="p">)</span><span class="w">
         </span><span class="no">:password</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"DB_PASSWORD"</span><span class="p">)}}}}}</span><span class="w">
</span></code></pre></div></div>

<p>Когда приложение “выкатывают” на тестовой машине, в базе должны быть минимальные данные для проверки. Обычно это пользователь с известным паролем, несколько товаров, покупок и так далее. Поместим их в миграцию, которая выполняется только на удаленной машине. Создайте каталог <code class="language-plaintext highlighter-rouge">env/staging/resources/migrations</code> и файл в нем:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 20210830075415-add-test-data.up.sql</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="p">...)</span>
<span class="k">VALUES</span>
 <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Test1'</span><span class="p">,</span> <span class="s1">'active'</span><span class="p">,</span>  <span class="s1">'test1@test.com'</span><span class="p">,</span> <span class="p">...),</span>
 <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Test2'</span><span class="p">,</span> <span class="s1">'pending'</span><span class="p">,</span> <span class="s1">'test2@test.com'</span><span class="p">,</span> <span class="p">...),</span>
 <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'Test3'</span><span class="p">,</span> <span class="s1">'blocked'</span><span class="p">,</span> <span class="s1">'test3@test.com'</span><span class="p">,</span> <span class="p">...);</span>
</code></pre></div></div>

<p>Укажите профилю <code class="language-plaintext highlighter-rouge">:staging</code> дополнительный путь ресурсов. Он заменит текущий <code class="language-plaintext highlighter-rouge">resources</code>, и папка <code class="language-plaintext highlighter-rouge">migrations</code> будет взята из нового пути.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:resource-paths</span><span class="w"> </span><span class="p">[</span><span class="s">"env/staging/resources"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Важно понимать, что Migratus ищет файлы только в одной папке: невозможно сделать так, чтобы использовались одновременно <code class="language-plaintext highlighter-rouge">resources/migrations</code> и <code class="language-plaintext highlighter-rouge">env/staging/resources/migrations</code>. Поэтому миграции накатывают в два этапа: в первый раз основные, во второй – специфичные для текущего окружения, если это необходимо.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lein migratus migrate
<span class="o">&gt;</span> lein with-profile staging migratus migrate
</code></pre></div></div>

<h3 id="параметры-подключения">Параметры подключения</h3>

<p>До сих пор мы указывали подключение к базе явно. Это подойдет для локальной разработки, но не промышленного запуска. Чтобы запустить миграции на удаленной базе, передайте ее параметры в переменных среды. Для этого изменим значения словаря <code class="language-plaintext highlighter-rouge">:db</code> на формы <code class="language-plaintext highlighter-rouge">~(System/getenv ...)</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:store</span><span class="w"> </span><span class="no">:database</span><span class="w">
 </span><span class="no">:migration-dir</span><span class="w"> </span><span class="s">"migrations"</span><span class="w">
 </span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgresql"</span><span class="w">
      </span><span class="no">:dbname</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"DB_NAME"</span><span class="p">)</span><span class="w">
      </span><span class="no">:host</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"DB_HOST"</span><span class="p">)</span><span class="w">
      </span><span class="no">:user</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"DB_USER"</span><span class="p">)</span><span class="w">
      </span><span class="no">:password</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"DB_PASSWORD"</span><span class="p">)}}</span><span class="w">
</span></code></pre></div></div>

<p>Синтаксис <code class="language-plaintext highlighter-rouge">~&lt;form&gt;</code> внутри макроса <code class="language-plaintext highlighter-rouge">defproject</code> означет вычислить форму. При запуске <code class="language-plaintext highlighter-rouge">lein</code> на месте <code class="language-plaintext highlighter-rouge">~(System/getenv "ENV_NAME")</code> окажется значение одноименной переменной. Чтобы запустить миграции, укажите переменные процессу <code class="language-plaintext highlighter-rouge">lein</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nv">DB_USER</span><span class="o">=</span>book <span class="nv">DB_PASSWORD</span><span class="o">=</span>secret lein migratus migrate
</code></pre></div></div>

<p>Мы подробно разобрали конфигурацию и переменные среды в пятой главе первой книги.</p>

<h3 id="миграции-в-коде">Миграции в коде</h3>

<p>Иногда миграциями управляют не командой <code class="language-plaintext highlighter-rouge">lein</code>, напрямую из Clojure. Для этого Migratus должен быть подключен не виде плагина к <code class="language-plaintext highlighter-rouge">lein</code>, а библиотекой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">migratus</span><span class="w"> </span><span class="s">"1.3.5"</span><span class="p">]]}</span><span class="w">
</span></code></pre></div></div>

<p>Приведем минимальный код, чтобы запустить миграции в коде:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">migratus.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">migratus</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">config</span><span class="w">
  </span><span class="p">{</span><span class="no">:store</span><span class="w"> </span><span class="no">:database</span><span class="w">
   </span><span class="no">:migration-dir</span><span class="w"> </span><span class="s">"migrations"</span><span class="w">
   </span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">}})</span><span class="w">

</span><span class="p">(</span><span class="nf">migratus/init</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">migratus/migrate</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">migratus/rollback</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Процесс сводится к простым шагам: объявить конфигурацию, инициировать библиотеку и вызывать функции <code class="language-plaintext highlighter-rouge">migrate</code> или <code class="language-plaintext highlighter-rouge">rollback</code> с конфигурацией.</p>

<p>Запуск миграций помещают в начало работы программы. Если приложение запущено на нескольких машинах, выполнять миграции должен только один экземпляр. Проще всего задать этот признак переменной среды: всем ложь и только одной машине — истину.</p>

<p>Если проект основан на системе (библиотеки Component и Integrant), создайте компонент <code class="language-plaintext highlighter-rouge">Migration</code>, который зависит от базы данных. При запуске (метод <code class="language-plaintext highlighter-rouge">start</code> или <code class="language-plaintext highlighter-rouge">init-key</code>) он вызывает <code class="language-plaintext highlighter-rouge">migratus/migrate</code> с конфигурацией. В поле <code class="language-plaintext highlighter-rouge">:db</code> конфигурации указывают компонент базы.</p>

<h3 id="программные-миграции">Программные миграции</h3>

<p>Как правило, изменения в базе данных описывают на языке SQL. Однако не все действия можно выполнить с его помощью. Предположим, нужно заполнить колонку данными из стороннего источника. В этом случае помогут программные миграции.</p>

<p>Технические подобные миграции — это файлы .edn со словарем. Ключи <code class="language-plaintext highlighter-rouge">:up</code> и <code class="language-plaintext highlighter-rouge">:down</code> указывают на функции Clojure. Функции принимают один параметр — конфигурацию — и выполняют действия с базой. Код функции остается на ваше усмотрение. С помощью библиотек вы можете читать данные из сети или файлов и записывать в базу. Обратная программная миграция удаляет то, что внесла ее прямая часть.</p>

<p>Пусть таблица <code class="language-plaintext highlighter-rouge">requests</code> собирает сведения о просмотрах страниц. У нас есть только IP-адрес пользователя, но хотелось бы знать страну, город и другие данные. Исходные поля таблицы:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">requests</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> id |       ip       | country_code
----+----------------+--------------
  1 | 24.198.249.0   |
  2 | 187.33.237.120 |
</code></pre></div></div>

<p>Создайте файл <code class="language-plaintext highlighter-rouge">20210831070224-update-country-by-ip.edn</code> со словарем внутри:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:ns</span><span class="w"> </span><span class="n">book.migrations.update-country</span><span class="w">
 </span><span class="no">:up-fn</span><span class="w"> </span><span class="n">migrate-up</span><span class="w">
 </span><span class="no">:down-fn</span><span class="w"> </span><span class="n">migrate-down</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Поле <code class="language-plaintext highlighter-rouge">:ns</code> указывает на пространство, а <code class="language-plaintext highlighter-rouge">:up-fn</code> и <code class="language-plaintext highlighter-rouge">:down-fn</code> — на функции прямой и обратной миграций. Технически возможно держать несколько миграций в одном Clojure-модуле, но лучше резделить их.</p>

<p>В файл <code class="language-plaintext highlighter-rouge">book/migrations/update_country.clj</code> поместим модуль миграции. Начнем с шапки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.migrations.update-country</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">clojure.java.jdbc</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">clj-http.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">client</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Код страны получим с помощью сервиса <a href="https://iplocation.com">IPLocation</a> по HTTP API. Сервис принимает POST-запрос с адресом и выдает JSON с информацией о нем. Напишем функцию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-ip-info</span><span class="w"> </span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="no">:body</span><span class="w">
   </span><span class="p">(</span><span class="nf">client/post</span><span class="w"> </span><span class="s">"https://iplocation.com"</span><span class="w">
                </span><span class="p">{</span><span class="no">:form-params</span><span class="w"> </span><span class="p">{</span><span class="no">:ip</span><span class="w"> </span><span class="n">ip</span><span class="p">}</span><span class="w">
                 </span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Прямая миграция выбирает записи с пустым кодом страны и обходит в цикле. Для каждого IP-адреса она выполняет HTTP-запрос и обновляет запись с найденным кодом.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">migrate-up</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">rows</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"select id, ip from requests where country_code is null"</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="n">ip</span><span class="p">]}</span><span class="w"> </span><span class="n">rows</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">country_code</span><span class="p">]}</span><span class="w"> </span><span class="p">(</span><span class="nf">get-ip-info</span><span class="w"> </span><span class="n">ip</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">jdbc/update!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:requests</span><span class="w">
                      </span><span class="p">{</span><span class="no">:country_code</span><span class="w"> </span><span class="n">country_code</span><span class="p">}</span><span class="w">
                      </span><span class="p">[</span><span class="s">"id = ?"</span><span class="w"> </span><span class="n">id</span><span class="p">])))))</span><span class="w">
</span></code></pre></div></div>

<p>Обратная миграция сбрасывает коды стран в <code class="language-plaintext highlighter-rouge">NULL</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">migrate-down</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/update!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:requests</span><span class="w">
                </span><span class="p">{</span><span class="no">:country_code</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w">
                </span><span class="p">[</span><span class="s">"true"</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Запустите миграции в терминале. По окончании в таблице <code class="language-plaintext highlighter-rouge">requests</code> появятся коды стран:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SELECT</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">requests</span><span class="c1">;</span><span class="w">
</span></code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> id |       ip       | country_code
----+----------------+--------------
  1 | 24.198.249.0   | US
  2 | 187.33.237.120 | BR
</code></pre></div></div>

<p>При откате коды пропадут из таблицы.</p>

<p>Код миграции можно улучшить: добавить логирование и перехват ошибок, вести запросы параллельно при помощи <code class="language-plaintext highlighter-rouge">pmap</code>. В запрос <code class="language-plaintext highlighter-rouge">SELECT</code> дописать оператор <code class="language-plaintext highlighter-rouge">FOR UPDATE</code>, чтобы заблокировать запись на время транзакции. Предлагаем читателю поработать над кодом в свободное время.</p>

<h3 id="ragtime">Ragtime</h3>

<p>Коротко рассмотрим вторую библиотеку под названием <a href="https://github.com/weavejester/ragtime">Ragtime</a>. Ее принцип такой же, что мы рассмотрели выше. Это .sql-файлы в папке, их чтение и обход, таблица с именами обработанных миграций. В отличие от Migratus, Ragtime более гибок: если первый привязан к драйверу JDBC, то Ragtime основан на протоколах, которые легко адаптировать под любую базу, не обязательно реляционную.</p>

<p>Протоколы <code class="language-plaintext highlighter-rouge">DataStore</code> и <code class="language-plaintext highlighter-rouge">Migration</code> описывают хранилище данных и миграцию. Встроенный пакет <code class="language-plaintext highlighter-rouge">ragtime.jdbc</code> расширяет их для JDBC-совместимых баз, как это делает Migratus. За счет этого Ragtime можно применить к разным базам, например Cassandra, MongoDB или Datomic. Работая в Exoscale, автор написал библиотеку миграций для Cassandra на базе Ragtime. Присмотритесь к этой библиотеке, если в проекте участвуют не только JDBC-совместимые базы.</p>

<p>Мы не будем рассматривать Ragtime столь же подробно, как Migratus. К этому моменту читатель достаточно опытен, чтобы разобраться с библиотекой самостоятельно.</p>

<h2 id="nextjdbc">Next.JDBC</h2>

<p>Библиотека <a href="https://github.com/seancorfield/next-jdbc">Next.JDBC</a> — это следующий этап в адаптации JDBC для Clojure. Проект ставит следующие цели:</p>

<ul>
  <li>ускорить обработку выборки. Автор считает неоптимальным текущее проеобразование <code class="language-plaintext highlighter-rouge">ResultSet</code> в коллекцию Clojure. На больших результатах алгоритм действительно замедляется.</li>
</ul>

<ul>
  <li>
    <p>Обеспечить более тесную связь с Clojure за счет <a href="https://clojure.github.io/clojure/branch-master/clojure.datafy-api.html">протокола Datafy</a>. Протокол появился в Clojure 1.11 и служит посредником между сущностями Java и Clojure.</p>
  </li>
  <li>
    <p>Предложить более простой и понятный API. Прежняя библиотека различает функции <code class="language-plaintext highlighter-rouge">query</code>, <code class="language-plaintext highlighter-rouge">execute!</code>, <code class="language-plaintext highlighter-rouge">db-do-commands</code> и другие; вдобавок она обязывает помнить об их особенностях. Next.JDBC планирует сократить разнообразие API.</p>
  </li>
</ul>

<p>Коротко опробуем библиотеку. Подключим ее к проекту:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; project.clj</span><span class="w">
</span><span class="p">[</span><span class="n">com.github.seancorfield/next.jdbc</span><span class="w"> </span><span class="s">"1.2.709"</span><span class="p">]</span><span class="w">

</span><span class="c1">;; module.clj</span><span class="w">
</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w">
   </span><span class="p">[</span><span class="n">next.jdbc</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">next.jdbc.sql</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc.sql</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">next.jdbc.prepare</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc.prepare</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="n">next.jdbc.result-set</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc.rs</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>В отличии от предшественника, Next.JDBC не следует правилу “все в одном файле”. Смысловые части разнесены по отдельным модулям.</p>

<p>Роль источника данных играет объект <code class="language-plaintext highlighter-rouge">datasource</code>, который получают из JDBC-спеки. Однажды получив, его передают в функции первым аргументом.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-spec</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgresql"</span><span class="w"> </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"test"</span><span class="w"> </span><span class="n">...</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">ds</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/get-datasource</span><span class="w"> </span><span class="n">db-spec</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Объект <code class="language-plaintext highlighter-rouge">datasource</code> хранит открытое соединение и не порождает новое на каждый запрос. Подобную ошибку легко совершить в <code class="language-plaintext highlighter-rouge">clojure.java.jdbc</code>, когда JDBC-спека не содержит поля <code class="language-plaintext highlighter-rouge">:datasource</code> или <code class="language-plaintext highlighter-rouge">:connection</code>, и обращение к базе замедляется на порядок. Содержимое <code class="language-plaintext highlighter-rouge">datasource</code> легко проверить функцией <code class="language-plaintext highlighter-rouge">bean</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">bean</span><span class="w"> </span><span class="n">ds</span><span class="p">)</span><span class="w">

</span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="n">next.jdbc.connection$url_PLUS_etc$...</span><span class="w">
 </span><span class="no">:connection</span><span class="w"> </span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">...PgConnection</span><span class="w"> </span><span class="mi">0</span><span class="n">x352c5229...</span><span class="p">]</span><span class="w">
 </span><span class="no">:loginTimeout</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Прочитаем таблицу пользователей:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">ds</span><span class="w"> </span><span class="p">[</span><span class="s">"SELECT * FROM users"</span><span class="p">]))</span><span class="w">

</span><span class="o">#</span><span class="no">:users</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
        </span><span class="no">:fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
        </span><span class="no">:lname</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w">
        </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
        </span><span class="no">:age</span><span class="w"> </span><span class="mi">30</span><span class="w">
        </span><span class="no">:created_at</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2021-08-10T07:36:03.934029000-00:00"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что ключи словарей квалифицированы, то есть содержат пространство с именем таблицы. За счет пространств легко понять, какой таблице принадлежит поле. Пространства работают в том числе для связанных таблиц. Убедимся в этом на примере соединения с профилями:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">ds</span><span class="w"> </span><span class="p">[</span><span class="s">"SELECT * FROM users u, profiles p WHERE p.user_id = u.id"</span><span class="p">]))</span><span class="w">

</span><span class="p">{</span><span class="no">:users/id</span><span class="w"> </span><span class="mi">1</span><span class="w">
 </span><span class="no">:users/lname</span><span class="w"> </span><span class="s">"Petrov"</span><span class="w">
 </span><span class="no">:users/fname</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w">
 </span><span class="no">:users/age</span><span class="w"> </span><span class="mi">30</span><span class="w">
 </span><span class="no">:users/email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
 </span><span class="no">:users/created_at</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2021-08-10T07:36:03.934029000-00:00"</span><span class="w">
 </span><span class="no">:profiles/id</span><span class="w"> </span><span class="mi">1</span><span class="w">
 </span><span class="no">:profiles/user_id</span><span class="w"> </span><span class="mi">1</span><span class="w">
 </span><span class="no">:profiles/avatar</span><span class="w"> </span><span class="s">"kitten.jpg"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Видим, что поля из разных таблиц обрели разные пространства. Это освобождает нас от расстановки псевдонимов вручную:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">u</span><span class="p">.</span><span class="n">id</span>     <span class="k">AS</span> <span class="nv">"user/id"</span><span class="p">,</span>
  <span class="n">u</span><span class="p">.</span><span class="n">fname</span>  <span class="k">AS</span> <span class="nv">"user/fname"</span><span class="p">,</span>
  <span class="p">...</span>
  <span class="n">p</span><span class="p">.</span><span class="n">id</span>     <span class="k">AS</span> <span class="nv">"profile/id"</span><span class="p">,</span>
  <span class="p">...</span>
</code></pre></div></div>

<p>Важно понимать, что поиск таблицы для поля не бесплатен, а требует отдельного запроса в базу. Пример выше с пользователем и профилем порождает следующий запрос:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">c</span><span class="p">.</span><span class="n">oid</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">attnum</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">attname</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">relname</span><span class="p">,</span> <span class="n">n</span><span class="p">.</span><span class="n">nspname</span><span class="p">,</span>
<span class="n">a</span><span class="p">.</span><span class="n">attnotnull</span> <span class="k">OR</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">typtype</span> <span class="o">=</span> <span class="s1">'d'</span> <span class="k">AND</span> <span class="n">t</span><span class="p">.</span><span class="n">typnotnull</span><span class="p">),</span>
<span class="n">pg_catalog</span><span class="p">.</span><span class="n">pg_get_expr</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">adbin</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">adrelid</span><span class="p">)</span> <span class="k">LIKE</span> <span class="s1">'%nextval(%'</span> <span class="k">FROM</span>
<span class="n">pg_catalog</span><span class="p">.</span><span class="n">pg_class</span> <span class="k">c</span> <span class="k">JOIN</span> <span class="n">pg_catalog</span><span class="p">.</span><span class="n">pg_namespace</span> <span class="n">n</span>
<span class="k">ON</span> <span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">relnamespace</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="n">oid</span><span class="p">)</span> <span class="k">JOIN</span> <span class="n">pg_catalog</span><span class="p">.</span><span class="n">pg_attribute</span> <span class="n">a</span>
<span class="k">ON</span> <span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">attrelid</span><span class="p">)</span> <span class="k">JOIN</span> <span class="n">pg_catalog</span><span class="p">.</span><span class="n">pg_type</span> <span class="n">t</span> <span class="k">ON</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">atttypid</span>
<span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">oid</span><span class="p">)</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">pg_catalog</span><span class="p">.</span><span class="n">pg_attrdef</span> <span class="n">d</span> <span class="k">ON</span> <span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">adrelid</span> <span class="o">=</span>
<span class="n">a</span><span class="p">.</span><span class="n">attrelid</span> <span class="k">AND</span> <span class="n">d</span><span class="p">.</span><span class="n">adnum</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">attnum</span><span class="p">)</span> <span class="k">JOIN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="mi">32824</span> <span class="k">AS</span> <span class="n">oid</span> <span class="p">,</span> <span class="mi">1</span>
<span class="k">AS</span> <span class="n">attnum</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">32824</span><span class="p">,</span> <span class="mi">2</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">32824</span><span class="p">,</span> <span class="mi">3</span>
<span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">32824</span><span class="p">,</span> <span class="mi">4</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">32824</span><span class="p">,</span> <span class="mi">5</span> <span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="mi">32824</span><span class="p">,</span> <span class="mi">6</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">32824</span><span class="p">,</span> <span class="mi">8</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">32824</span><span class="p">,</span>
<span class="mi">9</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">32835</span><span class="p">,</span> <span class="mi">1</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">32835</span><span class="p">,</span> <span class="mi">2</span> <span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="mi">32835</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="n">vals</span> <span class="k">ON</span> <span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">vals</span><span class="p">.</span><span class="n">oid</span> <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">attnum</span> <span class="o">=</span>
<span class="n">vals</span><span class="p">.</span><span class="n">attnum</span><span class="p">)</span>
</code></pre></div></div>

<p>Который, в свою очередь, дает сведения о колонках и таблицах:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  oid  | attnum |  attname   | relname  | nspname | ?column? | ?column?
-------+--------+------------+----------+---------+----------+----------
 32835 |      3 | avatar     | profiles | public  | f        |
 32835 |      2 | user_id    | profiles | public  | t        |
 32835 |      1 | id         | profiles | public  | t        | t
 32824 |      9 | created_at | users    | public  | f        |
 32824 |      8 | year_birth | users    | public  | f        |
 32824 |      6 | city       | users    | public  | f        |
 32824 |      5 | age        | users    | public  | f        |
 32824 |      4 | email      | users    | public  | f        |
 32824 |      3 | lname      | users    | public  | f        |
 32824 |      2 | fname      | users    | public  | f        |
 32824 |      1 | id         | users    | public  | t        | t
</code></pre></div></div>

<p>Если подход кажется вам расточительным, отключите квалификацию полей параметром <code class="language-plaintext highlighter-rouge">builder-fn</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w">
 </span><span class="n">ds</span><span class="w">
 </span><span class="p">[</span><span class="s">"SELECT * FROM users ..."</span><span class="p">]</span><span class="w">
 </span><span class="p">{</span><span class="no">:builder-fn</span><span class="w"> </span><span class="n">jdbc.rs/as-unqualified-maps</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Кроме функции <code class="language-plaintext highlighter-rouge">as-unqualified-maps</code>, вам доступны <code class="language-plaintext highlighter-rouge">as-arrays</code> для векторов и другие обработчики.</p>

<p>Вспомогательные функции <code class="language-plaintext highlighter-rouge">get-by-id</code>, <code class="language-plaintext highlighter-rouge">find-by-keys</code>, <code class="language-plaintext highlighter-rouge">update!</code>, <code class="language-plaintext highlighter-rouge">insert!</code> и аналоги перешли в модуль <code class="language-plaintext highlighter-rouge">next.jdbc.sql</code>. Они отличаются только тем, что принимают первым параметром <code class="language-plaintext highlighter-rouge">datasource</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc.sql/get-by-id</span><span class="w"> </span><span class="n">ds</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc.sql/insert!</span><span class="w"> </span><span class="n">ds</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">199</span><span class="w"> </span><span class="no">:fname</span><span class="w"> </span><span class="s">"Test"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">jdbc.sql/query</span><span class="w"> </span><span class="n">ds</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from users"</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Макрос <code class="language-plaintext highlighter-rouge">with-transaction</code> тоже почти не изменился. Он принимает вектор, где первый элемент — символ, а второй — текущий <code class="language-plaintext highlighter-rouge">datasource</code>. С первым символом будет связан новый <code class="language-plaintext highlighter-rouge">datasource</code> с транзакционным соединением. В примере ниже мы открываем транзакцию с двумя запросами. Первый добавляет товар, второй записывает для него скидку 33%.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/with-transaction</span><span class="w"> </span><span class="p">[</span><span class="n">tx</span><span class="w"> </span><span class="n">ds</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:items/keys</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="p">]}</span><span class="w">
        </span><span class="p">(</span><span class="nf">jdbc.sql/insert!</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="no">:items</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">})]</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc.sql/insert!</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="no">:sales</span><span class="w"> </span><span class="p">{</span><span class="no">:item_id</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="no">:ratio</span><span class="w"> </span><span class="mf">0.66</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Как мы выяснили, поддержка JSON открывает новые горизонты в работе с базой. Next.JDBC предлагает протоколы для чтения и установки нестандартных типов. Подготовим функцию для перевода <code class="language-plaintext highlighter-rouge">PGobject</code> в Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">pg-&gt;clj</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">PGobject</span><span class="w"> </span><span class="n">pg-obj</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pg-val</span><span class="w"> </span><span class="p">(</span><span class="nf">.getValue</span><span class="w"> </span><span class="n">pg-obj</span><span class="p">)</span><span class="w">
        </span><span class="n">pg-type</span><span class="w"> </span><span class="p">(</span><span class="nf">.getType</span><span class="w"> </span><span class="n">pg-obj</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">pg-type</span><span class="w">
      </span><span class="p">(</span><span class="s">"json"</span><span class="w"> </span><span class="s">"jsonb"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">json/parse-string</span><span class="w"> </span><span class="n">pg-val</span><span class="w"> </span><span class="nb">keyword</span><span class="p">)</span><span class="w">
      </span><span class="c1">;; else</span><span class="w">
      </span><span class="n">pg-obj</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>и расширим с ее помощью протокол:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="n">jdbc.rs/ReadableColumn</span><span class="w">
  </span><span class="n">PGobject</span><span class="w">
  </span><span class="p">(</span><span class="nf">read-column-by-label</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="n">_</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">pg-&gt;clj</span><span class="w"> </span><span class="n">v</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">read-column-by-index</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">pg-&gt;clj</span><span class="w"> </span><span class="n">v</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что у протокола два метода: получить поле по индексу и имени. В нашем случае реализации совпадают. При чтении колонки с типом <code class="language-plaintext highlighter-rouge">json(b)</code> получим коллекцию Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc.sql/query</span><span class="w"> </span><span class="n">ds</span><span class="w"> </span><span class="p">[</span><span class="s">"select * from items"</span><span class="p">]))</span><span class="w">

</span><span class="o">#</span><span class="no">:items</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
        </span><span class="no">:title</span><span class="w"> </span><span class="s">"Cap"</span><span class="w">
        </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:size</span><span class="w"> </span><span class="s">"XL"</span><span class="w"> </span><span class="no">:color</span><span class="w"> </span><span class="s">"red"</span><span class="w"> </span><span class="no">:country</span><span class="w"> </span><span class="s">"China"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Расширим установку параметров. Любая коллекция Clojure станет объектом <code class="language-plaintext highlighter-rouge">PGobject</code> с типом json. Вспомогательная функция:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-&gt;pg-object</span><span class="w"> </span><span class="p">[</span><span class="n">data</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doto</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">PGobject</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">.setType</span><span class="w"> </span><span class="s">"json"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">.setValue</span><span class="w"> </span><span class="p">(</span><span class="nf">json/generate-string</span><span class="w"> </span><span class="n">data</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>и протокол:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="n">jdbc.prepare/SettableParameter</span><span class="w">
  </span><span class="n">clojure.lang.IPersistentCollection</span><span class="w">
  </span><span class="p">(</span><span class="nf">set-parameter</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="o">^</span><span class="n">java.sql.PreparedStatement</span><span class="w"> </span><span class="n">pr-st</span><span class="w"> </span><span class="n">idx</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">.setObject</span><span class="w"> </span><span class="n">pr-st</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;pg-object</span><span class="w"> </span><span class="n">v</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Вставка товара с JSON-атирибутами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc.sql/insert!</span><span class="w"> </span><span class="n">ds</span><span class="w"> </span><span class="no">:items</span><span class="w"> </span><span class="p">{</span><span class="no">:title</span><span class="w"> </span><span class="s">"t-shirt"</span><span class="w"> </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:size</span><span class="w"> </span><span class="s">"XXL"</span><span class="w"> </span><span class="no">:brand</span><span class="w"> </span><span class="s">"Abibas"</span><span class="p">}})</span><span class="w">

</span><span class="o">#</span><span class="no">:items</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
        </span><span class="no">:title</span><span class="w"> </span><span class="s">"t-shirt"</span><span class="w">
        </span><span class="no">:attrs</span><span class="w"> </span><span class="p">{</span><span class="no">:size</span><span class="w"> </span><span class="s">"XXL"</span><span class="w"> </span><span class="no">:brand</span><span class="w"> </span><span class="s">"Abibas"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Как видно, интерфейс Next.JDBC в целом похож на предшественника. Функции ведут себя так же, но дают больше контроля за происходящим. Если у вас долгий опыт работы с <code class="language-plaintext highlighter-rouge">clojure.java.jdbc</code>, перейти на Next.JDBC будет несложно. Тонкости перехода описаны в <a href="https://github.com/seancorfield/next-jdbc/blob/develop/doc/migration-from-clojure-java-jdbc.md">Wiki-документации</a> проекта. Там же вы узнаете о других возможностях JDBC.next.</p>

<h2 id="заключение">Заключение</h2>

<p>Реляционные базы данных основаны на модели реляционной алгебры. Модель описывает отношения между сущностями и операции над ними: проекция, пересечение, объединение и другие. В базах данных модель представлена таблицами и операторами SQL. Как правило, оператор принимает несколько таблиц и возвращает табличный результат.</p>

<p>SQL — строго декларативный язык: в нем нет циклов, переменных и прочих возможностей, доступных в языках программирования. Говорят, что SQL не полон по Тьюрингу. Существуют несколько стандартов SQL, датированных годами: 92, 99, 2008 и другие. Кроме обычных возможностей, современные базы предлагают расширенные операторы и типы данных.</p>

<p>В мире Java доступ к базам обеспечивает библиотека JDBC. Это универсальный интерфейс, который учитывает особенности каждой базы и приводит их к общему виду. JDBC нуждается в драйвере — библиотеке для конкретной базы данных, которая связывает высокоуровневый API с вводом-выводом. JDBC-драйверы доступны не только для классических баз PostgreSQL или MySQL, но и экзотических решений вроде файлов CSV и Excel.</p>

<p>Clojure предлагает легковесную обертку над JDBC — пакет <code class="language-plaintext highlighter-rouge">clojure.java.jdbc</code>. В ней доступны емкие и удобные функции для выборки, вставки и других операций с базой. Макрос <code class="language-plaintext highlighter-rouge">with-transaction</code> радикально упрощает работу с транзакциями. Библиотека содержит функции для типовых случаев: найти запись по <code class="language-plaintext highlighter-rouge">id</code>, по ключам, вставить из словаря и другие.</p>

<p>Чтобы связать типы Clojure с типами базы, расширьте протоколы. С их помощью сделают так, чтобы значение <code class="language-plaintext highlighter-rouge">Timestamp</code> из базы становилось <code class="language-plaintext highlighter-rouge">DateTime</code> из пакета JodaTime. Полезно обеспечить бесшовную связь с JSON, потому что этот тип несет колоссальные преимущества. Связь типов работает в обе стороны. Для установки параметров служит отдельный протокол, которые приводит типы Clojure в <code class="language-plaintext highlighter-rouge">PGObject</code> и другие объекты, известные JDBC.</p>

<p>Наибольшая опасность в SQL исходит от инъекций. Так называют прием, когда в запрос попадает вредоносный текст, например чтение системных таблиц или всегда истинное условие. Вероятность инъекции высока, если вы строите запросы конкатенацией (“склейкой”) строк, а также внедряете параметры в тело запроса. Тем же опасен и текст с кавычками: их умелая расстановка может нарушить логику запроса. Чтобы обезопасить запрос от кавычек, библиотеки экранируют их на этапе установки параметров.</p>

<p>В боевых проектах вы столкнетесь с тем, что запросы занимают много места и затрудняют чтение кода. Кроме того, SQL неудобно строить по условию, когда заранее неизвестно, нужно ли делать отбор по некоторому полю или нет. Здесь вам помогут библиотеки. Некоторые из них выносят запросы в файл и порождают функции, которые выполняют эти запросы. Другие строят SQL из коллекций — комбинаций списков и словарей.</p>

<p>Как правило, реляционные базы возвращают данные в виде плоских таблиц. На практике нас интересуют вложенные данные, например магазин и его товары, публикации и комментарии к ним. Существует два способа сгруппировать данные. Первый — получить плоский ответ и обработать на стороне Clojure. Второй — выполнить группировку в базе функциями <code class="language-plaintext highlighter-rouge">array_agg</code> или аналогами. Выбор способа зависит от окружения, объема данных и ваших навыков: в какой среде вы чувствуете себя уверенней.</p>

<p>Миграциями называют историю изменений базы. Как правило, это sql-файлы, которые добавляют таблицы, поля или индексы. Специальный код обходит эти файлы и применяет к базе. Отдельная таблица хранит имена обработанных миграций, чтобы не выполнить их повторно. Миграции автоматизируют рутину, позволяют оперативно откатить неудачные изменения. В локальной разработке ими переключают схему в соответствии с версией кода.</p>

<p>Библиотека <code class="language-plaintext highlighter-rouge">clojure.java.jdbc</code> — не единственная для работы с базой данных в Clojure. Обратите внимание на ее преемника JDBC.next. Новая библиотека работает с данными эффективней, что заметно на больших выборках. JDBC.next тесно связана с Clojure за счет встроенного протокола Datafy. Ее функции дают больше контроля за тем, что происходит с базой.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-db/">
    <input required name="captcha" type="hidden" value="1 &#215; 5">

    <div class="block">
        <span class="comment-form-label"><small>1 &#215; 5 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
