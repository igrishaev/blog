<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ivan Grishaev's blog</title>
    <description>Writing on programming, education, books and negotiations.
</description>
    <link>https://grishaev.me/</link>
    <atom:link href="https://grishaev.me/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 13 Aug 2025 05:30:56 +0000</pubDate>
    <lastBuildDate>Wed, 13 Aug 2025 05:30:56 +0000</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Системный дизайн</title>
        <description>&lt;p&gt;В айти есть забавная вещь – собеседование а-ля “систем-дизайн”. Компании выносят
ее в отдельный собес наравне со скринингом, алгоритмами и так далее. Теперь
наряду с красно-черными деревьями надо помнить, как задизайнить убийцу Твиттера
или Ютуба. За ночь перед собесом покупается книга Алекса Сюя, штудируется, и
наутро кандидат рисует ноды в Кубернетисе с Кафкой в кластере.&lt;/p&gt;

&lt;p&gt;Когда-то систем-дизайн был не везде, и это можно было стерпеть. Но сегодня он в
повсеместно – от Гугла до КолымВодоканала. С приходом в массы систем-дизайн
превратился в ритуал или проще говоря – в клоунаду.&lt;/p&gt;

&lt;p&gt;Так, ритуал предполагает, что нужно сделать аналог Твиттера. При этом нельзя
сразу писать код или рисовать диаграммы. Нужно задать интервьюеру вопросы:
сколько пользователей в день, сколько они пишут твитов, сколько селебрити
(людей, чья популярность резко выше остальных), сколько датацентров и так
далее. Потом цифры перемножаются, чтобы получить размер данных на
диске. Например, умножим миллион юзеров на пять твитов, на 100 байтов, &lt;del&gt;на
число цилиндров, на длину сектора…&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;Как вы поняли, эти цифры взяты с потолка и отношения к реальности не
имеют. Нельзя построить сервис, который посещают миллион пользователей в день
сразу после открытия. Так не бывает, если у вас нет другого такого же
сервиса. Но вас не пустят к рисованию схем, пока вы не посчитаете цифры.&lt;/p&gt;

&lt;p&gt;Представляю: сели и посчитали, что на хранение данных понадобится петабайт
данных. Идем такие к инвестору и говорим: мистер Джонс, дайте ундециллион
долларов на пять датацентров с петабайтами дискового хранилища, бекапы на
магнитной ленте в Арктике, ну и столько же для тренировки AI. Да, убийца
Твиттера, успех 100%, мы все посчитали.&lt;/p&gt;

&lt;p&gt;Слушайте, хорошо дизайнить петабайты данных и датацентры на Луне! Дорого-богато,
ни в чем себе не отказываем. А попробуй задизайнить, когда горизонт бюджета —
шесть зарплат. Весь дизайн разбивается о реальность: база с кафкой на одной
ноде, бекапы не делаем, потому что некогда и дорого, логи грепаем в терминале.&lt;/p&gt;

&lt;p&gt;Если серьезно, то на такие ресурсы денег никто не даст – если вы не
господрядчик, конечно. Скажут – выкати минималку, приведи хотя бы сто тысяч
пользователей, потом и поговорим. И это правильный подход.&lt;/p&gt;

&lt;p&gt;А во-вторых, когда нас просят задизайнить Твиттер, Инстаграм или Ютуб, забывают
одну мелочь – &lt;strong&gt;ни один из этих сервисов не дизайнили по этому принципу&lt;/strong&gt;.
Каждый айти-гигант начинался со стартапа с сотней детских болезней. Твитер в
молодости был поделкой на Руби и падал чаще, чем работал. Гугл вышел из
гаража. Первый Яндекс работал на личном компе одного из разрабов и
перезагружался, когда тот толкал его ногой. Каждый сервис прошел особый путь
роста, и рассчитать его на бумажке – все равно что запланировать жизнь ребенка:
во столько-то лет он поступит сюда, выйдет на работу туда, вступит в брак с
тем-то. Это глупость, потому что в жизни все оказывается не так.&lt;/p&gt;

&lt;p&gt;Сегодня стартапы начинают с гексагонных архитектур, сине-зеленого деплоя и так
далее. Увы, часто этого хватает на год-два, не больше. Счета за Амазон съедают
выручку, и даже когда компания спохватится, бывает поздно. Я работал в стартапах
и знаю это не по рассказам друзей, а видел воочию. Систем-дизайн буквально
съедает бизнес. Лично слышал от основателя фирмы: “мы не будем возражать, если
вы найдете другую работу”.&lt;/p&gt;

&lt;p&gt;Кроме того, даже Гугл со своими мощностями порой не может раскрутить
сервисы. Может, помните Google Wave, прообраз современной Слаки? Общество было
не готово к формату, и проект закрылся. То же самое произошло с Google Buzz,
аналогом Твиттера. Он продержался два года. Не сомневаюсь, что в Гугле очень
точно перемножили число людей на длину сообщения, но что-то пошло не так. Еще
пример – Google Video, там Гугл просто капитулировал и понял, что проще купить
Ютуб, чем делать платформу самому.&lt;/p&gt;

&lt;p&gt;Так что систем-дизайн стал очередным ритуалом, который нужно выучить и
пройти. Еще одна боль для тех, кто хочет поменять работу или войти в
айти. Разумеется, читая Сюя, можно узнать много полезного – это справедливо для
любой книги в принципе. Но делать из ритуала культ – это глупо.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Aug 2025 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/sys-disign/</link>
        <guid isPermaLink="true">https://grishaev.me/sys-disign/</guid>
        
        <category>programming</category>
        
        <category>system</category>
        
        <category>design</category>
        
        <category>interview</category>
        
        
      </item>
    
      <item>
        <title>SQL как REPL</title>
        <description>&lt;p&gt;Самый надежный способ проверить, работает ли код – запустить его. Компиляторы и
линтеры отсеивают ошибки, но не все. Легко написать код, который пройдет
компиляцию, но при запуске упадет.&lt;/p&gt;

&lt;p&gt;Поэтому языки с REPL-ом такие продуктивные. Любой клочок кода можно выполнить в
редакторе и посмотреть, что будет. Это не отменяет тесты и другие практики, но
здорово помогает.&lt;/p&gt;

&lt;p&gt;Я исповедую тот же принцип в отношении SQL. SQL – это репл к данным. Другая
плоскость, но принцип такой же. Что-то ввели – тут же получили результат. Чтобы
работать продуктивно, нужно иметь возможность в любой момент выполнить запрос к
данным, похожим на прод.&lt;/p&gt;

&lt;p&gt;Чтобы выбрать данные, я открываю PGAdmin и пишу SQL ручками. Сперва убеждаюсь,
что он вернул то, что я ожидал. Потом смотрю план, проверяю, попал ли в
индексы. Если все в порядке, переношу запрос в код с минимальными правками.&lt;/p&gt;

&lt;p&gt;Иногда я даже забиваю на тесты, потому что все равно проверяю запросы на
тестовой базе. Ожидаю, что если кто-то исправит запрос, то проверит его
тоже. Однако я всегда пишу тест, который выполнит запрос на пустой базе – чтобы
убедиться, что нет ошибок синтаксиса.&lt;/p&gt;

&lt;p&gt;Если в проекте используется ORM, то непонятно, как быть. Скажем, написал я
запрос с группировкой и джоинами. От отлично работает. Как перенести его в ORM?
Даже если я напишу цепочку методов, нужно проверить, что итоговый SQL выглядит
как я хотел. Можно включить логирование запросов и посмотреть, что получилось,
но способ сомнительный. Получается двойная работа: пишешь SQL, переносишь в
объектную модель, подсматриваешь логи, правишь объекты и так по кругу.&lt;/p&gt;

&lt;p&gt;Со временем я понял, что лучше сидеть на одном стуле, а не на двух. Поэтому –
оставьте SQL в виде SQL. Любой человек скопирует его в PGAdmin и получит
результат. Когда вместо SQL – каскад квери-билдеров, теряется та самая быстрая
связь, о которой речь в начале. Все, она прервана, репл не работает, очередной
радостью меньше.&lt;/p&gt;

&lt;p&gt;Зачем так жить?&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Aug 2025 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/sql-repl/</link>
        <guid isPermaLink="true">https://grishaev.me/sql-repl/</guid>
        
        <category>programming</category>
        
        <category>sql</category>
        
        <category>repl</category>
        
        
      </item>
    
      <item>
        <title>Нарезка интерфейса</title>
        <description>&lt;p&gt;На текущем месте я работаю над веб-приложением для сотрудников. Недавно выкатили
раздел с большой таблицей. Я делал бекенд, там сотни строк скуля, чтобы собрать
данные по всей базе джоинами. Кое-что материализуется по крону, и еще много
хранимых функций.&lt;/p&gt;

&lt;p&gt;Фронт у нас тоже продвинутый: SPA, re-frame (кложурная обертка над Реактом),
сотни модулей на кложур-скрипте, десятки аякс-запросов на страницу. Используется
какой-то Material UI или вроде этого. Все элементы пухлые как подушки и затянуты
в скругленные прямоугольники.&lt;/p&gt;

&lt;p&gt;И слои. Много слоев, будто смотришь на разрез почвы в атласе. Сначала шапка с
логотипом и аватаркой в правом углу. Потом главное меню. Потом второстепенное
меню. Потом тулбар. Потом дата-грид, но у него свой тулбар. Потом шапка
таблицы. Потом фильтры. Когда высота перевалила за середину, начинаются
строки. В подвале – еще один тулбар с пагинацией.&lt;/p&gt;

&lt;p&gt;Как в современном кинотеатре: реклама, логотип, трейлер, логотип, трейлер,
логотип, короткометражка, логотип, логотип, фильм. “Черт, моя кола выдохлась”
(с) не помню кто.&lt;/p&gt;

&lt;p&gt;Так вот, что я сделал. Беру скриншот интерфейса, закидываю в Фигму. Клонирую,
ставлю рядом. Нарезаю второй скриншот на слои по границам тулбаров, шапок и
прочего. Потом у каждого слоя срезаю чуть-чуть сверху и снизу – будто уменьшаю
margin-top и bottom, только в растре.&lt;/p&gt;

&lt;p&gt;Схлопываю пустоту – нарезка занимает на четверть меньше, чем оригинал.&lt;/p&gt;

&lt;p&gt;Беру два тулбара и объединяю в один – напомню, в каждом из них по одной
кнопке. Получаю -2 сантиметра по высоте. Подрезаю шапку таблицы, она тоже
непомерно вытянута.&lt;/p&gt;

&lt;p&gt;Выигрыш уже не в четверть, а на треть.&lt;/p&gt;

&lt;p&gt;Срезаю капсулу со скругленными краями вокруг таблицы. Переставляю
пагинатор. Подрезаю каждую строку на пять пикселей сверху и снизу. Клонирую их
до конца экрана.&lt;/p&gt;

&lt;p&gt;Считаю: на первом скриншоте девять строк, на втором, где нарезка – двадцать
семь. Ровно в три раза больше.&lt;/p&gt;

&lt;p&gt;При этом я не менял шрифт и ничего не масштабировал. Все действия свелись к
кропу и перемещению. Буквально из ничего нашлось место, чтобы вместить в три
раза больше данных.&lt;/p&gt;

&lt;p&gt;В итоге улучшения дизайна свелись к тому, что кнопка из одного слоя переехала в
другой. Теперь влезает не 9, а целых 11 строк. Интерфейс должен быть воздушным,
иначе пользователи теряются.&lt;/p&gt;

&lt;p&gt;Подтвердилось все то, что я обычно пишу про дизайн, и пересказывать это нет
смысла.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Aug 2025 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/slice-and-dice/</link>
        <guid isPermaLink="true">https://grishaev.me/slice-and-dice/</guid>
        
        <category>ui</category>
        
        
      </item>
    
      <item>
        <title>Don't use println with two and more arguments</title>
        <description>&lt;p&gt;When printing, please avoid &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;println&lt;/code&gt; invocations with more than one argument,
for example:&lt;/p&gt;

&lt;div class=&quot;language-clojure highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;defn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;processing item&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Above, we have two items passed into the function, not one. This style can let
you down when processing data in parallel.&lt;/p&gt;

&lt;p&gt;Let’s run this function with a regular &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; as follows:&lt;/p&gt;

&lt;div class=&quot;language-clojure highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;doall&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The output looks fair:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;processing item 1
processing item 2
processing item 3
processing item 4
processing item 5
processing item 6
processing item 7
processing item 8
processing item 9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Replace &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pmap&lt;/code&gt; which is a semi-parallel method of processing. Now the
output goes nuts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-clojure(doall&quot;&gt;(pmap process (range 10)))

processing itemprocessing item  10

processing item processing item8 7
processing item 6
processing itemprocessing item 4
processing item 3
processing item 2
 5
processing item
 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why?&lt;/p&gt;

&lt;p&gt;When you pass more than one argument to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;println&lt;/code&gt; function, it doesn’t print
them at once. Instead, it sends them to the underlying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.io.Writer&lt;/code&gt; instance
in a cycle. Under the hood, each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.write&lt;/code&gt; Java invocation is synchronized so no
one can interfere when a certain chunk of characters is being printed.&lt;/p&gt;

&lt;p&gt;But when multiple threads print something in a cycle, &lt;strong&gt;they do interfere&lt;/strong&gt;. For
example, one thread prints “processing item” and before it prints “1”, another
thread prints “processing item”. At this moment, you have “processing
itemprocessing item” on your screen.&lt;/p&gt;

&lt;p&gt;Then, the first thread prints “1” and since it’s the last argument to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;println&lt;/code&gt;,
it adds &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\n&lt;/code&gt; at the end. Now the second thread prints “2” with a line break at
the end, so you see this:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;processing itemprocessing item
1
2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The more cores and threads you computer has, the more entangled the output
becomes.&lt;/p&gt;

&lt;p&gt;This kind of a mistake happens often. People do such complex things in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;
function like querying DB, fetching data from API and so on. They forget that
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pmap&lt;/code&gt; can bootstrap such cases up to ten times. But unfortunately, all prints,
should invoked with two or more arguments, get entangled.&lt;/p&gt;

&lt;p&gt;There are two things to remember. The first one is to not use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;println&lt;/code&gt; with
more than one argument. For two and more, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt; as follows:&lt;/p&gt;

&lt;div class=&quot;language-clojure highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;defn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;processing item %d%n&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Above, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; sequence stands for a platform-specific line-ending character
(or a sequence of characters, if Windows). Let’ check it out:&lt;/p&gt;

&lt;div class=&quot;language-clojure highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pmap&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Although the order of numbers is random due to the parallel nature of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pmap&lt;/code&gt;,
each line has been consistent.&lt;/p&gt;

&lt;p&gt;One may say “just use logging” but too often, setting up logging is another
pain: add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clojure.tools.logging&lt;/code&gt;, add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log4this&lt;/code&gt;, add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log4that&lt;/code&gt;, put
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logging.xml&lt;/code&gt; into the class path and so on.&lt;/p&gt;

&lt;p&gt;The second thing: for IO-heavy computations, consider &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pmap&lt;/code&gt; over &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;. It
takes an extra “p” character but completes the task ten times faster. Amazing!&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Aug 2025 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/clojure-println/</link>
        <guid isPermaLink="true">https://grishaev.me/clojure-println/</guid>
        
        <category>clojure</category>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>Пустая истина (3)</title>
        <description>
&lt;p&gt;После второго раунда обсуждений стало ясно, почему every от пустого множества
дает истину. Читатель &lt;a href=&quot;https://t.me/themishkun&quot;&gt;Миша Левченко&lt;/a&gt; дал внятное объяснение, которое
понятно мне как программисту. Оно не опирается на кванторы и логику. И хотя
вывод все равно не нравится, приведу объяснение здесь.&lt;/p&gt;

&lt;p&gt;Дело в том, что операции над списками нужно рассматривать как свертку. Есть
такая функция &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt; (она же &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fold&lt;/code&gt;), которая принимает функцию двух
аргументов и коллекцию. Результат функции такой:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fn(fn(fn(fn(item0, item1), item2), item3), item4)...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Например, для сложения чисел 1, 2, 3, 4 получим форму:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(((1 + 2) + 3) + 4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduce&lt;/code&gt; может накапливать в том числе другую коллекцию: словарь или список. Это
вообще очень мощная функция. Про себя я называю ее царицей функций, потому что
через reduce можно выразить что угодно.&lt;/p&gt;

&lt;p&gt;Reduce выше прекрасно работает, если элементов два и более. Когда их один или
ноль, начинаются граничные случаи. Одно из решений в том, что &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt; может
принимать т.к. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt; — первичный элемент, который подставляется в начало
цепочки. Чаще всего он выступает коллекцией-аккумулятором, но может быть и
простым скаляром.&lt;/p&gt;

&lt;p&gt;Если передать &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt;, форма будет такой:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fn(fn(fn(init, item0), item1), item2)...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Другими словами, он гарантирует, что элементов больше нуля. Если основной список
пустой, просто вернем init.&lt;/p&gt;

&lt;p&gt;Так вот, в терминах свертки функция &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL&lt;/code&gt; (которую я раньше называл &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;every?&lt;/code&gt;)
выглядит так:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(func ALL [fn-pred items]
  (reduce (fn [x y]
         (and x (fn-pred y)))
       true
       items))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Демо:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(ALL int? [1 2 3])
true

(ALL int? [1 nil 3])
false

(ALL int? [])
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;А вот функция &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ANY&lt;/code&gt; (что хотя бы один элемент вернул истину для предиката):&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(func ANY [fn-pred items]
  (reduce (fn [x y]
         (or x (fn-pred y)))
       false
       items))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Демо:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(ANY int? [1 nil 3])
true

(ANY int? [nil nil nil])
false

(ANY int? [])
false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Аналогично работают функции суммирования: это &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt;, где начальные элементы
равны 0 и 1. Поэтому &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(+)&lt;/code&gt; дает 0, а &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(*)&lt;/code&gt; — 1.&lt;/p&gt;

&lt;p&gt;Как видим, все это можно объяснить без греческих букв и терминов. А пустая
истина, о которой я писал ранее, считается истиной только потому, что таков
начальный элемент свертки.&lt;/p&gt;

&lt;p&gt;Другое дело, что такой подход все равно мне не нравится. В каждом из них скрыт
начальный элемент: для &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL&lt;/code&gt; — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;, для &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ANY&lt;/code&gt; — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;, единица для
умножения и так далее. Считается очевидным, что он должен быть именно таким. А
мне это не очевидно. Я спотыкаюсь, когда вижу, что произведение элементов
пустого списка равно единице. Я бы предпочел неопределённость — то есть null.&lt;/p&gt;

&lt;p&gt;Я в курсе про нейтральный элемент: ноль для сложения, единица для умножения. Но
на пустых списках это как-то не очень. Душа не принимает, если совсем честно.&lt;/p&gt;

&lt;p&gt;В самом деле, в математике оператор умножения — бинарный, ему нужно два
операнда. Нельзя записать что-то вроде &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5 * = 5&lt;/code&gt; — тут не хватает операнда
справа. С какой стати мы обходим математические правила — не ясно.&lt;/p&gt;

&lt;p&gt;Я часто использую &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt; и вывел правило: всегда указываю начальный
элемент. Например, чтобы сложить список чисел, я пишу так:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(reduce + 0 numbers)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;вместо&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(apply + numbers)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Потому что во втором случае не очевидно, во что накапливается результат.&lt;/p&gt;

&lt;p&gt;Словом, пока что меня отпустило на тему пустой истины. Все оказалось просто: это
свертка, где начальный элемент — истина. Крайне неочевидно, на мой взгляд. Чтобы
не отстрелить ногу, либо проверяйте коллекцию на пустоту, либо пишите явный
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt;, где начальный элемент — ложь, если того требует контекст.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Jul 2025 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/vacuous-truth-3/</link>
        <guid isPermaLink="true">https://grishaev.me/vacuous-truth-3/</guid>
        
        <category>programming</category>
        
        <category>logic</category>
        
        
      </item>
    
      <item>
        <title>Пустая истина (2)</title>
        <description>&lt;p&gt;После прошлой заметки мне стали приходить, что называется, письма читателей. Их
можно разделить на два вида.&lt;/p&gt;

&lt;p&gt;Первый — ты не шаришь в логике, сейчас я все объясню. Гляди… (далее километр
греческих букв, термины “антецедент”, “консеквент” и другие). Вывалив все это,
человек считает, что открыл мне глаза. Я ничего из этого не понимаю, поэтому
прошу — не утруждайтесь подобными доказательствами.&lt;/p&gt;

&lt;p&gt;Второй тип писем — в языке X предикат every работает так же: для пустого
множества вернет истину независимо от предиката. Да, согласен. Еще пять лет
назад выполнил в Постгресе такой запрос:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;, получил истину и опечалился. Если же поменять &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL&lt;/code&gt; на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ANY&lt;/code&gt;, получим
противоположный результат:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ANY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Здесь мы уподобляемся Джаваскриптерам: подаем нелепый ввод, получаем нелепый
вывод. При этом силимся подвести его под какую-то базу: антецеденты-консеквенты,
кванторы и прочее.&lt;/p&gt;

&lt;p&gt;А дело в другом: аппарат логики не учитывает неопределенность. Это утопичная
модель, где есть только истина и ложь — третьего не дано. В тех местах, где
модель не ложится на реальность, начинаются подтасовки: истину раз — и обозвали
“пустой”. То есть как бы истина, но не совсем.&lt;/p&gt;

&lt;p&gt;Меня это страшно бесит, прям так, что не передать словами. Если результат
отличен от истины и лжи, заведи под него тип. Переработай модель логики, в конце
концов. Признай, что старая модель ограничена и не подходит под прикладные
задачи. И уж чего точно я не пойму, так это того, почему в языках
программирования мы опираемся на логику бог знает какой давности. Нужно делать
так, чтобы удобно здесь и сейчас, а не как принято в учебнике логики.&lt;/p&gt;

&lt;p&gt;Правильный ответ в том, что в функции every пустое множество — это
неопределенность, краевой случай. То же самое, что получить первый элемент
массива, когда он пуст. В зависимости от языка мы получим null или исключение,
но точно не число 42 с пометкой “пустое” — это нонсенс.&lt;/p&gt;

&lt;p&gt;Обратимся к более достойной науке, чем логика — математике. Рассмотрим функцию
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y = 1/x&lt;/code&gt; (см. график ниже). Прелесть этой функции в том, что в точке 0 ее
значение не определено. Если точнее, при &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x=0&lt;/code&gt; результат будет бесконечностью,
причем даже нельзя сказать, какой именно — положительной или отрицательной. В
зависимости от того, с какой стороны приближаться к нулю — правой или левой —
функция будет уходить в плюс- и минус-бесконечность.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/static/aws/vacuous-truth-2/1.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Область определения этой функции записывается так: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(-inf, 0);(0, +inf)&lt;/code&gt;. В нуле
функция не определена — и при этом никто не умер. Бывают функции и с большим
количеством точек и даже целых областей, где они не определены. И ничего — нас
это устраивает, с функцией можно работать.&lt;/p&gt;

&lt;p&gt;(В скобках отмечу, стандарт чисел с плавающей запятой предусматривает комбинации
битов, которые трактуются как обычная бесконечность, а также плюс- и
минус-версии. То же самое касается нуля: может быть ноль, минус ноль и плюс
ноль. Это помогает при сходимости рядов, когда мы пришли к нулю и хотим знать
откуда — справа или слева. По крайней мере в Фортране этими штуками
пользовались).&lt;/p&gt;

&lt;p&gt;Другой пример из математики — решение квадратного уравнения вида &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ax^2 + bx + c
= 0&lt;/code&gt;. У него может быть либо два корня, либо один, либо никаких. Во втором
случае еще можно слукавить: сказать, что один корень — это два
одинаковых. Ладно, но с третьим вариантом это не прокатит. Нельзя вернуть
какое-то левое число и сказать, что это пустой корень. Они не определены.&lt;/p&gt;

&lt;p&gt;Пример из географии: чтобы попасть на северный полюс, нужно идти на север. Каким
же будет северное направление на Северном полюсе? Ответ — никаким, оно не
определено.&lt;/p&gt;

&lt;p&gt;То же самое с предикатами: когда нас просят сказать, что все камни белые, но
камней нет, это неопределенность. Потому что если сказать да, оказывается, что
камни в том числе черные, прозрачные, резиновые — и все это одновременно. Этого
не было, если бы every возвращал NULL — я имею в виду не в коде, а на уровне
логики.&lt;/p&gt;

&lt;p&gt;Уж не говорю, что пустая истина совершенно неприемлема на бытовом уровне. Это
либо троллинг, либо саботаж, либо неразбериха.&lt;/p&gt;

&lt;p&gt;Когда я читаю в документации: &lt;em&gt;if the stream is empty then true is returned and
the predicate is not evaluated&lt;/em&gt; — мне немного плохеет. Выходит так, что функция
возвращает один и тот же результат при РАЗНЫХ случаях. А значит, ответственность
перекладывается на тебя — будь добр сам проверяй, пустое множество или не
пустое.&lt;/p&gt;

&lt;p&gt;Это просто плохой API — что, в общем-то, не редкость. Надо это признать и больше
так не делать. А вот оправдываться логикой и чепухой а-ля “антецедент-квантор” —
это отстой.&lt;/p&gt;

&lt;p&gt;Под конец напомню вам о Булгакове. Если свежесть отлична от первой, это уже не
свежесть. Если перед истиной стоит какой-то тег — пустая, неполная, вторичная —
то это не истина. Вот и все, что нужно запомнить. И это — истина.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Jul 2025 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/vacuous-truth-2/</link>
        <guid isPermaLink="true">https://grishaev.me/vacuous-truth-2/</guid>
        
        <category>programming</category>
        
        <category>logic</category>
        
        
      </item>
    
      <item>
        <title>Пустая истина (1)</title>
        <description>&lt;p&gt;Расскажу, как однажды погорел на забавной вещи под названием “пустая
истина”. Это было лет пять назад, когда я ничего про это не знал.&lt;/p&gt;

&lt;p&gt;Значит, смотрите: когда мускулистые греки работали над логикой, они ввели в том
числе предикаты. Например, белый? – это предикат. Если применить его к любому
предмету, получим истину или ложь.&lt;/p&gt;

&lt;p&gt;Также греки придумали пакетную версию предикатов, батч, так сказать. Это
супер-предикаты “каждый из”, “любой из”, “ни один из”. Все они принимают другой
предикат и множество объектов. Далее они редьюсят множество логических
результатов в один (простите за функциональные термины).&lt;/p&gt;

&lt;p&gt;Если на столе три белых камня, то выражение “все камни – белые” вернет
истину. Если один – тоже истину. Если сто белых и один черный – ложь. А что
случится, если камней нет? Греки почесали бороды и сказали – будет тоже истина,
только назовем ее пустой.&lt;/p&gt;

&lt;p&gt;В результате: если на столе нет камней, выражение “все камни – белые” будет
истинно. Таким же истинным будет выражение “все камни – черные”, в крапинку и
полоску. Все камни обладают какими угодно свойствами одновременно. Одна беда –
их нет.&lt;/p&gt;

&lt;p&gt;На мой взгляд, греки подложили нам свинью. Истина, как известно, одна – не
бывает двух разных истин. Когда вводят истину с какой-то характеристикой,
получается черт знает что. Вроде бы это истина, но какая-то другая, что требует
особого обращения с ней.&lt;/p&gt;

&lt;p&gt;Напоминает диалог Булгакова об осетрине второй свежести: голубчик, это вздор!
Свежесть бывает только одна – первая, она же последняя. Если осетрина второй
свежести, значит, она тухлая.&lt;/p&gt;

&lt;p&gt;Знал же человек!&lt;/p&gt;

&lt;p&gt;Интересно, что греческая вторая свежесть, тьфу, пустая истина идеально ложится
на быдлокод! Это при том, что программировать греки не умели.&lt;/p&gt;

&lt;p&gt;Предположим, нужно написать функцию, которая принимает предикат и список
объектов. Функция возвращает истину, если предикат справедлив для каждого
элемента. Вот как выглядит самая тупая реализация:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func is_every(fn_pred, items):
  for item in items:
    if not fn_pred(item):
      return false;
  return true;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Все просто: бежим по списку, как только предикат вернул ложь, мы тоже возвращаем
ложь. Если прошли по всем элементам, значит, лжи ни разу не было, и мы
возвращаем истину. Если список пуст, мы благополучно пропустим цикл и перейдем к
выражению с истиной.&lt;/p&gt;

&lt;p&gt;Как это связано с моей работой? Несколько лет назад в Exoscale я делал систему
прав доступа, аналог IAM в Амазоне. Из базы читались разрешения, и нужно было
проверить, что каждое из них совпадает с политикой ресурса. Для этого я вызывал
кложурную функцию &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;every?&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(every? policy-match? permissions)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Оказалось, Рич Хикки знал эти штучки, и для пустого множества &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;every?&lt;/code&gt;
возвращает истину. Это легко проверить:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(every? int? [1 2 3])
true

(every? int? [1 &quot;a&quot; 3])
false

(every? int? [])
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вышло так, что если у пользователя вообще не было прав, то список был пуст и
every? возвращала истину. В результате пользователь, который не имел доступа ни
к чему, имел доступ ко всему – из-за моих бедных знаний в этой области.&lt;/p&gt;

&lt;p&gt;С тех пор у меня отпечаталось в подкорке, что перед &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;every?&lt;/code&gt; должна быть
проверка на пустоту. Пустая истина может трактоваться как угодно, но мне нужна
точность.&lt;/p&gt;

&lt;p&gt;Второе – я не согласен с греками. Видимо, они еще не знали про NULL и
неопределенность, плохо понимали троичную логику. Увы, наш мир сложнее, чем
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;, есть нуллы и другие досадные вещи. Но нужно жить с ними, а не
сводить к каким-то сомнительным истинам.&lt;/p&gt;

&lt;p&gt;Кстати, пустая истина позволяет сказать жене: все мои любовницы – брюнетки. Если
у вас нет любовниц, это тоже будет истиной. Разве что придется потратить время
на объяснение, но ничего. Истина дороже.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Jul 2025 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/vacuous-truth-1/</link>
        <guid isPermaLink="true">https://grishaev.me/vacuous-truth-1/</guid>
        
        <category>programming</category>
        
        <category>logic</category>
        
        
      </item>
    
      <item>
        <title>Подорожание Google Workspace</title>
        <description>&lt;p&gt;Гугл пишет, что поднимет цену на подписку Google Workspace. Это для тех, кто
привязял домен к Гуглу и тем самым создал мини-организацию из одного
человека. Правда, со временем я открыл учетки для других членов семьи, включая
маму, потому что никто не помнит пароль, да и пройдет авторизацию Гугла сегодня
не каждый. Так что сейчас в моей организации пять человек.&lt;/p&gt;

&lt;p&gt;Интересна причина роста цен — это внедрение AI и некие фичи:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The updated subscription pricing reflects the significant added AI value, as
well as the many new features we have introduced and are launching to Google
Workspace editions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;В тот момент я подумал: Гугл напоминает российский Газпром. Потому что все
развлечения Газпрома оплачивает потребитель — покупку футбольных клубов,
километры списанных труб, бонусы менеждеров. За все это платит простолюдин,
неважно какие успехи рапортует Газпром по телевизору.&lt;/p&gt;

&lt;p&gt;То же самое с Гуглом — казалось бы, он и так гребет деньги лопатой за рекламу;
собирает и продает личные данные; везде где можно предлагает платный Gemini. И
все равно этого мало, поэтому пусть заплатит потребитель.&lt;/p&gt;

&lt;p&gt;Тем чудикам, которые топят за ИИ, советую подумать: на ровном месте мы получили
прибавку к цене только потому, что компания внедряет ИИ. Такая вот новая
нормальность.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Jul 2025 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/google-prices/</link>
        <guid isPermaLink="true">https://grishaev.me/google-prices/</guid>
        
        <category>google</category>
        
        <category>ai</category>
        
        
      </item>
    
      <item>
        <title>Кнопки в Гитхабе</title>
        <description>&lt;p&gt;У Гитхаба странный интерфейс — посмотрите на картинки ниже.&lt;/p&gt;

&lt;p&gt;Первая картинка: я хочу смержить пул-реквест. Нажимаю кнопку Squash and merge,
ожидаю, что произойдет то, что написано на кнопке — логично же?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/static/aws/github-buttons/1.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Но мерджа не происходит. Вместо этого появляется форма с двумя полями, а кнопка
Confirm squash and merge проваливается ниже. Как у Чуковского: “и подушка как
лягушка ускакала от меня”. Нужно мотать вниз и жать ее еще раз.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/static/aws/github-buttons/2.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Вот эти убегающие кнопки — бич Гитхаба. Вроде нажал, а всплыло что-то
другое. Кстати, после мерджа обычно я удаляю ветку, и кнопка Delete branch
оказывается на 10 сантиметров ВЫШЕ. То есть сначала нажал кнопку на высоте X,
потом X+10 см, потом снова X-10 см.  Дизайнеру Гитхаба это норм — не жмет, не
чешется.&lt;/p&gt;

&lt;p&gt;Вы, конечно, скажете: надо запросить описание коммита. Ну вот ниже на картинке
есть форма комментариев — она статична и не появляется по клику. Можно сделать
такой же статичный инбокс для мерджа. Еще лучше — сделать так, чтобы кнопка не
уплывала вниз, а оставалась на месте, при этом поле повляется ПОД ней. Чаще
всего я ничего не пишу, поэтому просто нажал бы кнопку еще раз.&lt;/p&gt;

&lt;p&gt;Решений может быть много, но то, что сейчас — крайне неудачно.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Jul 2025 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/github-buttons/</link>
        <guid isPermaLink="true">https://grishaev.me/github-buttons/</guid>
        
        <category>ui</category>
        
        <category>github</category>
        
        
      </item>
    
      <item>
        <title>Игрушечный парсер</title>
        <description>
&lt;p&gt;Месяц назад я помогал одной студентке с домашней работой по Кложе. Да, я тоже
удивился: есть вуз, где на первом курсе пишут парсеры на этом языке. Сомневаюсь,
что у студентов что-то останется в голове: после интенсива Кложи их перебросили
на Пролог, и в чем замысел такого обучения — загадка.&lt;/p&gt;

&lt;p&gt;Тем не менее была домашка, которую нужно было сделать. Я помогал с двумя
заданиями: написать комбинаторные парсеры для разбора постфиксной и инфиксной
нотаций. Я всегда любил парсеры, и хоть не силен в них, не прочь что-нибудь
распарсить своими силами.&lt;/p&gt;

&lt;p&gt;Так что если вы студент(ка) и пишете парсеры, &lt;a href=&quot;https://github.com/igrishaev/toy-parser&quot;&gt;загляните в репозиторий&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Там простой модуль с комментариями и базовыми парсерами. Также есть два модуля
demo1 и demo2. В одном пример с префиксной нотацией, во втором — с
инфиксной. Второй пример интересен тем, что там используется рекурсивный парсер,
и поэтому нужны конструкции declare и var.&lt;/p&gt;

&lt;p&gt;Эти парсеры в высшей степени просты, и по-хорошему им нужна доработка. Скажем, в
случае ошибки возвращать не nil, а сообщение о том, что пошло не так. Это
сделано нарочно, чтобы акцент остался на главном: парсинге и комбинации
парсеров.&lt;/p&gt;

&lt;p&gt;Если будут вопросы, пишите.&lt;/p&gt;
</description>
        <pubDate>Sat, 05 Jul 2025 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/toy-parser/</link>
        <guid isPermaLink="true">https://grishaev.me/toy-parser/</guid>
        
        <category>programming</category>
        
        <category>clojure</category>
        
        
      </item>
    
  </channel>
</rss>
