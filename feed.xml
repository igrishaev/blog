<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ivan Grishaev's blog</title>
    <description>Writing on programming, education, books and negotiations.
</description>
    <link>https://grishaev.me/</link>
    <atom:link href="https://grishaev.me/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 12 Dec 2024 12:48:14 +0000</pubDate>
    <lastBuildDate>Thu, 12 Dec 2024 12:48:14 +0000</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Зачем спринты?</title>
        <description>&lt;p&gt;За все время работы в айти я не понял, зачем нужны спринты.&lt;/p&gt;

&lt;p&gt;Как правило, спринт — это период от двух недель до месяца. В него набирают задач
и пытаются их сделать к концу спринта. Потом спринты оценивают: этот был лучше,
чем в прошлый раз, а этот хуже. Тут собрали двадцать стори-поинтов, а тут
восемнадцать. Проводят ретро, которые убивают время.&lt;/p&gt;

&lt;p&gt;Все это кажется мне бредом. Зачем делить время на равные участки? Зачем считать
стори-поинты? Какое знание дает цифра 18 стори-поинтов? Чем это хуже, чем 20
поинтов?&lt;/p&gt;

&lt;p&gt;В чем проблема, если задача из одного спринта переносится в другой? Кто от этого
пострадал? Если задача не умещается в спринт, то может просто не впихивать
невпихуемое?&lt;/p&gt;

&lt;p&gt;Нужно обсудить процесс? Так проведи серию звонков 1 на 1 с разработчиками. Не
обязательно ждать ретро.&lt;/p&gt;

&lt;p&gt;В моем понимании процесс управляется релизами. Скажем, поставили мы задачу
выкатить новый релиз через два месяца. Договорились, что в релиз войдет то, се,
пятое-десятое. Не успеваем? Что-то упрощаем, что-то откладываем в следующий
релиз.&lt;/p&gt;

&lt;p&gt;Зачем нам спринты? Почему все следуют карго-культу гуглов-амазонов? Нужно думать
своей головой, а не как менеджер Гугла.&lt;/p&gt;

&lt;p&gt;UPD: сюда же относятся эстимейты. Воистину, самое тупое и бесмыссленое, что есть
в айти. Эстимейтить все и вся, ошибаться на порядок и потом рвать задницу, чтобы
успеть.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/why-sprints/</link>
        <guid isPermaLink="true">https://grishaev.me/why-sprints/</guid>
        
        <category>work</category>
        
        <category>sprint</category>
        
        
      </item>
    
      <item>
        <title>Шкала ООП</title>
        <description>&lt;p&gt;Когда говорят про ООП, упоминают всякие солиды, наследование и прочее. И не
говорят вот про что (а надо бы).&lt;/p&gt;

&lt;p&gt;Если в языке присутствует ООП, то типизация объектов размывается. Только
структуры и функции дают четкие типы; объекты, наоборот, разрушают их путем
абстракций. Они замыливают глаз.&lt;/p&gt;

&lt;p&gt;Скажем, у нас есть классы &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dog&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cat&lt;/code&gt;, унаследованные от &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animal&lt;/code&gt;. Пока мы
передаем собак и котов явно, все хорошо. Но когда мы передаем их как животных
(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animal&lt;/code&gt;), там может быть что угодно. В итоге на одни и те же данные смотришь
по-разному.&lt;/p&gt;

&lt;p&gt;Если предположить, что &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animal&lt;/code&gt; наследуется еще от чего-то, то получится шкала
от &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt; к &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dog&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cat&lt;/code&gt;, и как смотреть на объект — зависит от контекста. В
некоторых случаях делают даун-каст и ап-каст: передают кота в виде объекта, а
потом проверяют: если это кот, то одно, если собака, то другое, иначе эксепшен.&lt;/p&gt;

&lt;p&gt;Эту шкалу (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt; — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animal&lt;/code&gt; — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mammal&lt;/code&gt; — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dog&lt;/code&gt;) важно держать в голове и
знать, где находишься сейчас. Лично мне она доставляет много хлопот, когда я
пишу на ООП-языках, например Джаве. Шкала — это не вкл/выкл, а некая доля,
позиция в в дереве, следить за которой сложнее.&lt;/p&gt;

&lt;p&gt;Может быть, кто-то лучше выразил эту мысль, но либо я не слышал, либо забыл.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/oop-gauge/</link>
        <guid isPermaLink="true">https://grishaev.me/oop-gauge/</guid>
        
        <category>programming</category>
        
        <category>oop</category>
        
        
      </item>
    
      <item>
        <title>Не люблю регулярки</title>
        <description>&lt;p&gt;Признаться, я не особо люблю регулярные выражения. Я знаю их где-то на троечку,
время от времени применяю, но стараюсь, чтобы их было меньше.&lt;/p&gt;

&lt;p&gt;Дело в том, что регулярные выражения — это сверхплотный, сверхкраткий язык
описания шаблонов в тексте. Из его главного преимущества — краткости — следует
главный недостаток. Когда регулярка больше какого-то порога, ее понимание и
поддержка резко идут вниз. В этом случае следует отказаться от регулярки, однако
в проекте запросто может оказаться маньяк, который накрутит еще пару этажей
регулярок.&lt;/p&gt;

&lt;p&gt;Другой момент — с регуляркой часто оказывается, что ты не все учел. Предположим,
нужно искать в тексте числа с плавающей запятой. Вы написали регулярку, которая
ищет числа вроде &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-12.0042&lt;/code&gt;. А потом оказалось, что у чисел может не быть целой
части, например &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-.0042&lt;/code&gt;. А еще оказались числа в научной нотации: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1.2E9&lt;/code&gt;. И
регулярку нужно допиливать, допиливать и накидывать тесты.&lt;/p&gt;

&lt;p&gt;У регулярок есть хорошее применение: ими удобно разбивать текст. Как правило, я
разбиваю текст на части и проверяю, что их количество и содержимое чему-то
соответствует. Это проще отлаживать, это лучше в плане сообщения об ошибке. Если
текст не натягивается на монструозную регулярку, ты не можешь объяснить, что
пошло не так. А если обрабатывать текст по частям, легко сказать, в чем
проблема.&lt;/p&gt;

&lt;p&gt;В одном из проектов у нас была библиотека для генерации регулярок. Это когда
декларативно указываешь: либо это слово, либо это, либо то, но не это и не то, и
библиотека строит одну регулярку. В ней учитываются общие начала слов, например
для &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fuck&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fuckoff&lt;/code&gt; получим &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fuck(?=off)&lt;/code&gt;. Выбрал такой пример, потому что
фильтровали сообщения в чате. Было много других слов, значения которых я не знал
и смотрел в словаре.&lt;/p&gt;

&lt;p&gt;Этот подход интересен тем, что регуляркам отводится служебная
часть. Конфигурация делается словарями и списками, все ясно и прозрачно.&lt;/p&gt;

&lt;p&gt;Вместо регулярок мне больше нравится парсинг грамматикой. Пару лет назад я
прочитал пару статей про комбинаторные парсеры и решил сделать свой. В
результате я написал огрызок, который назвал Ostap (потому что великий
комбинатор). В библиотеке были простые парсеры и те, что составляются из других
(and, or). Можно задать грамматику словарем и получить из нее парсер.&lt;/p&gt;

&lt;p&gt;В результате у меня получилось составить &lt;a href=&quot;https://github.com/igrishaev/ostap/blob/master/src/ostap/json.clj&quot;&gt;грамматику JSON&lt;/a&gt;, и парсер
разбирал произвольный JSON-документ. Правда, это было медленней джавного Jackson
раз в десять, но за скоростью я не гнался. Почему-то зачесались руки сесть и
переписать его на Джаве и собрать парсеры для JSON, INI, Tolm и других форматов.&lt;/p&gt;

&lt;p&gt;Словом, регулярки хороши, но я предпочитаю держать их на расстоянии вытянутой
руки. Чем они ближе, тем строже я слежу за ними.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/no-regex/</link>
        <guid isPermaLink="true">https://grishaev.me/no-regex/</guid>
        
        <category>programming</category>
        
        <category>regex</category>
        
        
      </item>
    
      <item>
        <title>Jira</title>
        <description>&lt;p&gt;Я считаю, работать в компании, которая пилит Джиру, это примерно то же самое,
что работать в военкомате или Роскомнадзоре. Нормальному человеку, даже если он
туда попал, будет стыдно, и он уйдет в другое место.&lt;/p&gt;

&lt;p&gt;Современная Джира — это просто заповедник багов и косяков. Каждый ее квадратный
сантиметр несет бред. Без шуток, по мотивам Джиры можно написать небольшую книгу
о том, как делать не надо.&lt;/p&gt;

&lt;p&gt;Из сегодняшнего: заполняю тикет, прикладываю кусочек кода. Пишу:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{code:clоjure}
(dеfn do-some-shit [a b]
  (do-this {:a b}))
{code}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Сохраняюсь и вижу:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Unable to find source-code formatter for language: clоjure.
Available languages are: actionscript, ada, applescript, bash,
c, c#, c++, cpp, css, relange, go, groovy, haskell, html,
java, javascript, js, json, lua, none, nyan, objc, perl,
php, python, r, rainbow, ruby, scala, sh, swift, visualbasic,
xml, yaml(dеfn do-some-shit [a b]
  (do-this {:a b}))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Иными словами: сообщение о том, что подсветка Clоjure не поддерживается,
внедрилось прямо в код! Причем даже без переноса строки: код следует сразу за
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...yaml&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Сначала я проклял всеми словами фронтендеров, но посмотрел в Network и убедился:
это серверный рендер. Клиент посылает фрагмент, а сервер возвращает
HTML. Поскольку это не JSON, некуда положить нотис о том, что язык не
поддерживается, и ребята такие — давайте просто засунем его в код.&lt;/p&gt;

&lt;p&gt;Каким же мудаком надо быть, чтобы протащить это в прод — я просто не знаю. И
куда глядела армия QA, разные бета-тестеры и вообще сами сотрудники фирмы?
Фееризм космического дна.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/lol-jira/</link>
        <guid isPermaLink="true">https://grishaev.me/lol-jira/</guid>
        
        <category>jira</category>
        
        <category>syntax</category>
        
        <category>code</category>
        
        
      </item>
    
      <item>
        <title>Сишные строки</title>
        <description>&lt;p&gt;Одна из самых худших вещей в айти — это сишные нуль-терминированные
строки. Другими словами, цепочка байтов, которая завершается нулем. Керниган и
Ричи были гениями, никто не спорит, но решение с нулем на конце трудно назвать
удобным.&lt;/p&gt;

&lt;p&gt;Беда в том, что, читая эту строку, никогда не знаешь, где конец. Сколько байтов
резервировать — 32 или килобайт? Немало ошибок в сишных программах связано с
тем, что неверно определяется конец строки.&lt;/p&gt;

&lt;p&gt;Интересно наблюдать сишные строки в бинарном протоколе Postgres. В оригинальной
его части строки передаются как в Си — то есть неизвестной длины с нулем на
конце. Скажем, сообщение StartupMessage строится по принципу&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;u s e r n a m e 0 d a t a b a s e 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;А в расширениях, которые появились позже, строки передаются нормально: сначала
длина в int32, потом байты без нуля:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 0 0 5 h e l l o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Пример — расширение &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hstore&lt;/code&gt;, в нем строки передаются с фиксированной
длиной. Видимо, разработчики поняли, что жить с нулем на конце нельзя и сделали
нормально.&lt;/p&gt;

&lt;p&gt;Чтение строки известной длины — это две строчки кода. Чтение неизвестной строки
— это цикл, выделения буферов, конкатенация и прочий бред.&lt;/p&gt;

&lt;p&gt;Общий тезис таков: главное должно быть первым. В строке чаще всего нас
интересует длина, поэтому она должна быть в начале. Бывает, содержимое вообще
неважно, нужно только переложить строку в другое место и не ошибиться на байт
туда-сюда. Сишные строки делают все, что такая ошибка случилась.&lt;/p&gt;

&lt;p&gt;С любовью вспоминаю Паскаль, где строки были правильными: сначала байт с длиной,
потом содержимое. Правда, из-за этого строки не могли быть больше 256
байтов. Разные компиляторы предлагали строки, где под длину выделялось два байта
или четыре.&lt;/p&gt;

&lt;p&gt;Можно долго рассуждать, что было и по каким причинам, но к делу это отношения не
имеет. Важно запомнить, что главное должно быть первым — как на экране, так и в
байтиках.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/c-strings/</link>
        <guid isPermaLink="true">https://grishaev.me/c-strings/</guid>
        
        <category>programming</category>
        
        <category>c</category>
        
        <category>string</category>
        
        
      </item>
    
      <item>
        <title>Бусти и почта</title>
        <description>&lt;p&gt;Подписался на одного человека в Бусти — первый раз пользовался этой
платформой. Заодно наблюдал котовасию с подтверждением почты.&lt;/p&gt;

&lt;p&gt;Дело было так: захожу через Гугло-учетку, все нормально, пришло письмо
“здравствуй, дорогой Ivan”. А как начал читать, появилась плашка: чел,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ivan@grishaev.me&lt;/code&gt; — это твой емейл?&lt;/p&gt;

&lt;p&gt;Вы серьезно? Гугл уже подтвердил, что это моя почта, что вам еще нужно? Как вы
это представляете: зашел через Гугл, а почта не моя? Тыкаю Yes, чтобы
отвязался. Перехожу в соседнюю вкладку, а там вылезла та же плашка. На этот раз
я промахнулся и нажал No. В результате моя почта пропала из профиля, и Бусти
пишет — пока не подтвердишь почту, покоя не дам.&lt;/p&gt;

&lt;p&gt;Хоть я и не видел кода Бусти, легко понять, почему так происходит. Когда
создается учетка, у нее стоит флаг “почта не подтверждена” — нормальное
поведение для регистрации по email. Но разработчики не учли, что в случае с
Гуглом почта подтверждается автоматом и выносят мозг подтверждением.&lt;/p&gt;

&lt;p&gt;На ровном месте устроили бурю в стакане: подтверди, хотя никакого подтверждения
не нужно. Большой и денежный сервис, а такие косяки.&lt;/p&gt;

&lt;p&gt;Интересный факт об авторизации, который я не знаю, куда приткнуть, поэтому пусть
будет здесь. Когда пользователь входит через Фейсбук, он может отказать в
передаче емейла. В результате вам прилетит джейсончик, где всякие
токены-шмокены, а почты нет. Если почта критична (а это чаще всего так),
приходится заворачивать пользователя со словами “не быкуй, галочку не
снимай”. Требует много кода и тестов.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/boosty/</link>
        <guid isPermaLink="true">https://grishaev.me/boosty/</guid>
        
        <category>boosty</category>
        
        <category>email</category>
        
        <category>google</category>
        
        
      </item>
    
      <item>
        <title>Приглашаю на митап</title>
        <description>
&lt;p&gt;В следующий четверг (28 ноября) Health Samurai проводят очередной кложурный
митап. Я буду рассказывать про свою библиотеку PG2 — это которая клиент к
Постгресу. Начало в 19:00, нужна регистрация. Ссылка на &lt;a href=&quot;https://health-samurai.ru/postgresql-level-up/&quot;&gt;страницу
организаторов&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Из анонса может показаться, что доклад будет про библиотеку, но на самом деле я
бы хотел поговорить о другом. Пока я работал над ней, то столкнулся со
спецификой, о которой раньше не думал, и теперь хочу ей поделиться. Кроме самой
библиотеки, расскажу о следующих вещах:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;как устроен Postgres Wire Protocol&lt;/li&gt;
  &lt;li&gt;зачем браться за свое решение, когда есть другие, проверенные годами&lt;/li&gt;
  &lt;li&gt;сопоставление типов Postgresql и Java/Clоjure&lt;/li&gt;
  &lt;li&gt;заморочки с парсингом&lt;/li&gt;
  &lt;li&gt;мысли об API и дизайне&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Подойдет всем, кто как-то связан базами данных. Запись на Ютубе будет через
несколько дней после митапа.&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Nov 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/pg-meetup/</link>
        <guid isPermaLink="true">https://grishaev.me/pg-meetup/</guid>
        
        <category>programming</category>
        
        <category>postgres</category>
        
        
      </item>
    
      <item>
        <title>Можешь поправить</title>
        <description>&lt;p&gt;Есть одна обидная вещь, я называю ее “можешь поправить”. Это когда находишь
ошибку, которой много лет и которую воспринимают как данность. И когда обращаешь
внимание, тебе отвечают — можешь поправить.&lt;/p&gt;

&lt;p&gt;Текст ошибки совершенно нечитаем? Можешь поправить. Сервис делает тысячу
запросов вместо одного? Можешь поправить. Хрупкие билды? Можешь поправить. Не
собирается под твоей операционкой? Можешь поправить. Не работает в Фаерфоксе?
Можешь поправить.&lt;/p&gt;

&lt;p&gt;Ну вы поняли: “можешь поправить” — это вежливая форма “е…сь сам”. Ощущение,
что на полу лежит какашка, и все старательно ее обходят, дожидаясь, кто вступит
первым. Как правило, первым вступаю я.&lt;/p&gt;

&lt;p&gt;Повторюсь, это очень обидная вещь, и вдобавок тревожный маркер о состоянии
команды. В данном случае нужно править не только технические косяки, но и
отношение к ним в команде.&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Nov 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/you-may-fix-it/</link>
        <guid isPermaLink="true">https://grishaev.me/you-may-fix-it/</guid>
        
        <category>programming</category>
        
        <category>work</category>
        
        <category>life</category>
        
        
      </item>
    
      <item>
        <title>Пробел в урлах</title>
        <description>&lt;p&gt;Хотя интернету 55 лет, мы до сих пор не починили пробел в урлах.&lt;/p&gt;

&lt;p&gt;На выходных была ситуация: упали крон-джобы, и вообще произошла какая-то
фигня. Файлы в S3 есть, а клиенты жалуются, что нету.&lt;/p&gt;

&lt;p&gt;Смотрю — кто-то поменял название папки в S3. Раньше было &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Daily_Reports&lt;/code&gt;, а
теперь &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Daily Reports&lt;/code&gt; (с пробелом). Половина клиентов пишет файлы нормально. Но
есть другие клиенты на питоне и баше, которые кодируют урлы дважды. В результате
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Daily Reports&lt;/code&gt; становится новой папкой &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Daily%20Reports&lt;/code&gt; в S3. Один клиент
пишет в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Daily Reports&lt;/code&gt; и ему ок. Второй клиент ищет файлы в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Daily%20Reports&lt;/code&gt;,
не находит и падает.&lt;/p&gt;

&lt;p&gt;Увы, мой быдлокод тоже упал. У меня такая задача: прилетает S3-урл вида&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s3://some.bucket.com/path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;и мне нужно вытащить из него бакет, в данном случае хост. Делаю так:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(-&amp;gt; s3-url java.net.URI. .getHost)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Но когда в урле оказался пробел, класс &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;URI&lt;/code&gt; валится — вай, не по стандарту, не
знаю-не могу. Поменял на класс &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;URL&lt;/code&gt; — он парсит урлы с пробелами нормально, но
теперь ему не нравится схема &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s3://&lt;/code&gt; — опять не по стандарту. Сделал так: беру
урл, меняю схему автозаменой на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://&lt;/code&gt;, оборачиваю в URL и достаю
хост. Обмазал тестами.&lt;/p&gt;

&lt;p&gt;“Какая шаткая система, если её может разрушить пригоршня ягод!” (с)&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Nov 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/url-space/</link>
        <guid isPermaLink="true">https://grishaev.me/url-space/</guid>
        
        <category>programming</category>
        
        <category>url</category>
        
        <category>space</category>
        
        
      </item>
    
      <item>
        <title>О переменных среды</title>
        <description>&lt;p&gt;Про переменные среды нужно знать две вещи. Первая — если не было значения по
умолчанию, функция должна бросить исключение, где написано, какой именно
переменной не нашлось. Вторая — нельзя читать переменные посреди
программы. Нужно сделать это один раз на старте. Эти два правила улучшают код на
порядок.&lt;/p&gt;

&lt;p&gt;Теперь подробнее. Как правило, если переменная среды не установлена, то попытка
ее прочесть вернет пустую строку или &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;. Это неправильно. Должно выскочить
исключение с примерно таким текстом:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.getenv(&quot;DB_PASSWORD&quot;) =&amp;gt;
RuntimeException &quot;env variable DB_PASSWORD is not set&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если вместо исключения будет &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;, то он провалится в дальнейшие вычисления,
например, в формирование урла или бакета. Постоянно вижу такое в коде:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;host = &quot;api.&quot; + getenv(&quot;ENV_PREFIX&quot;) + &quot;.acme.com&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENV_PREFIX&lt;/code&gt; не задан, то получится &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;api.null.acme.com&lt;/code&gt;. Из-за этого
HTTP-клиент пойдет на левый хост и кинет непонятное исключение. То же самое с
бакетом в S3: Амазон скажет, мол, нет такого бакета, а вы будете рвать волосы.&lt;/p&gt;

&lt;p&gt;Простой фикс — написать свою функцию, которая бросит исключение. Потом заменить
все коробочные getenv на ваш. Пример:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(dеfn env!
  ([varname]
   (or (System/getenv varname)
       (throw (new RuntimeError ...))))
  ([varname dеfault]
   (or (System/getenv varname)
       dеfault)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Исключение не кидается, если передан дефолт.&lt;/p&gt;

&lt;p&gt;Второе. Чтение переменной среды — это грязная операция. Формально никакого IO не
происходит, потому что переменные уже в памяти программы. Но это сторонняя
зависимость, которую ваш код не контролирует. По факту чтение переменной не
отличается от чтения файла. Нет файла — программа сломается; нет переменной —
тоже.&lt;/p&gt;

&lt;p&gt;Поэтому, если уж вы связались с переменными среды, читайте их на старте в
какую-то мапку. Передавайте эту мапку в функции, чтобы они были чистыми. Это
легко тестировать: подал на вход то, это, пятое-десятое. А когда код завязан на
getenv, с ним невозможно работать.&lt;/p&gt;

&lt;p&gt;Приходилось работать в проекте, который писали одни чудики. Они прочитали The
Twelve-Factor App и особенно прониклись пунктом насчет переменных
среды. Результат можно описать одним словом: пи…ц. Представьте проект на 600
файлов, где на каждый чих читается переменная среды, да к тому же приводится к
нужному типу. На старте ничего не проверяется: запустил код без переменной —
узнал об этом в продакшене. Какой-то чел добавил глобальный кэш переменных и
целый ворох связанных с ним проблем.&lt;/p&gt;

&lt;p&gt;Чудики вынесли настройки в переменные среды, чтобы быть свободными от
конфигурации. Так им сказали в The Twelve-Factor App. А потом написали ENV-файлы
на три экрана. Было несколько ENV-файлов, которые загружались в особом порядке,
переопределяя значения друг друга. Например, сначала базовый энв, потом энв
текущего окружения (тест, прод, стейджинг), потому энв текущей машины. Удачной
отладки.&lt;/p&gt;

&lt;p&gt;Из этого вывод: много чего можно прочитать в интернете, но если нет своей
головы, оно не поможет. Нужно делать так, чтобы было удобно, а не как написано в
The Twelve-Factor App или на Хакер-Ньюз.&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Nov 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/env-trap/</link>
        <guid isPermaLink="true">https://grishaev.me/env-trap/</guid>
        
        <category>programming</category>
        
        <category>environment</category>
        
        
      </item>
    
  </channel>
</rss>
