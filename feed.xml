<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ivan Grishaev's blog</title>
    <description>Writing on programming, education, books and negotiations.
</description>
    <link>https://grishaev.me/</link>
    <atom:link href="https://grishaev.me/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 23 Dec 2024 08:48:56 +0000</pubDate>
    <lastBuildDate>Mon, 23 Dec 2024 08:48:56 +0000</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Приши, улучшай</title>
        <description>&lt;p&gt;Кто читал Ильяхова, знает формулу “пиши, сокращай”. Суть в том, что хороший
текст не пишут сразу. Пишется болванка, полная косяков, а потом по ней
многократно проходят: здесь снимают стружку, тут, наоборот, доливают
свинца. Только тогда текст становится сильным.&lt;/p&gt;

&lt;p&gt;То же самое с кодом: недостаточно его написать и проверить. Когда тесты написаны
и код рабочий, нужно пройтись по нему и причесать. Дать нормальные имена,
вынести анонимные функции на верхний уровень. Одни участки кода разнести на
промежуточные шаги, чтобы не было слишком плотно. Другие, наоборот, сократить.&lt;/p&gt;

&lt;p&gt;Здесь нет точных правил, важно чутье — как воспримет этот код другой
человек. Будет ему ли понятна логика, насколько легко внести изменения.&lt;/p&gt;

&lt;p&gt;И если есть программисты, которые комитят рабочий код, то со второй фазой все
очень плохо. Кажется, что когда код заработал, у программиста щелкает какое-то
реле — работа сделана, закрывай таску. Потратить двадцать минут на причесывание
кода — не знаем, не слышали.&lt;/p&gt;

&lt;p&gt;И да, этим страдают в том числе кложуристы. Кто-то напел им, что на Кложе
получается божественный код, который хорош сам по себе. Иммутабельность, лисп,
дэ-эс-эль, бла-бла.&lt;/p&gt;

&lt;p&gt;Читаю чужой код: коллекцию пропускают через пачку &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;partition-by&lt;/code&gt;. В
каждой из них — анонимная функция со вложенными reduce и другими анонимными
функциями. Партицирование замкнуто на другой коллекции, которая что-то достает
из первой. Неделимый блок кода размером с экран. Функция в функции внутри
функции.&lt;/p&gt;

&lt;p&gt;Нечитаемый ад. Писал его не молодой программист, надо полагать, с опытом. И то
же самое: как только он дошел до стадии “работает”, то оформил PR — и получил
апрув коллег.&lt;/p&gt;

&lt;p&gt;Давайте не будем так делать. Если код работает, это не значит, что задачу пора
закрывать. От двадцати минут, потраченных сверху, вреда не будет — прод не
сгорит, менеджер подождет. Зато спасет день коллеги, который вкатывается в
проект.&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/write-and-check/</link>
        <guid isPermaLink="true">https://grishaev.me/write-and-check/</guid>
        
        <category>programming</category>
        
        <category>code</category>
        
        
      </item>
    
      <item>
        <title>Две системы клавиш</title>
        <description>&lt;p&gt;Это короткая заметка, которую хотелось бы развить в будущем.&lt;/p&gt;

&lt;p&gt;Есть только два редактора, в которых хоткеи сделаны правильно — это Вим и
Емакс. Не то чтобы я маньяк, но других вариантов не вижу.&lt;/p&gt;

&lt;p&gt;Возьмем современный редактор и посмотрим на хоткеи. Нажатие на кнопку приводит к
печати символа, и это логично. Чтобы вместо печати было действие, кнопку
нажимают со служебной клавишей, скажем Ctrl, Alt, Command. Все это тоже логично.&lt;/p&gt;

&lt;p&gt;Но вот беда — многие комбинации заняты дефолтами! Ctrl-Q, T, N, O, P — все это
системные действия. Еще десяток клавиш уходит на навигацию каретки, еще десяток
— на удаление строк, слов и символов, и привет — Ctrl уже исчерпан. Попутно
нужно учесть, что на Маке роль Ctrl играет Command, поэтому удвоения емкости это
не дает.&lt;/p&gt;

&lt;p&gt;Остается Alt, но на него могут быть повешены хоткеи терминала и операционки, и в
итоге какой-нибудь Alt-N просто не дойдет до редактора. Ну и часто на Альт тоже
много чего навешено.&lt;/p&gt;

&lt;p&gt;Только в двух редакторах подумали о том, как решить проблему комплексно: это Vim
и Emacs. В первом разграничили режимы ввода и команд. Я пытался в Вим, но не
зашло. Уважаю тех, кто сидит в нем, потому что нравится сама концепция.&lt;/p&gt;

&lt;p&gt;В Емаксе хоткеи сделали последовательностями, или цепочками. Например, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-x f&lt;/code&gt;
открывает файл, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-x o&lt;/code&gt; открывает новое окно, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-x C-c&lt;/code&gt; —закрывает Емакс. Подход
с цепочками позволяет делать домены хоткеев, когда на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-x&lt;/code&gt; вешаются базовые
функции, на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-h&lt;/code&gt; — все, что имеет отношение к справке, на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C-x r&lt;/code&gt; — операции с
прямоугольниками и так далее. Все это легко наращивается вглубь, не мешая
остальным.&lt;/p&gt;

&lt;p&gt;Недавно загуглил, как вызвать в Идее выпадашку с методами. Знаете как? Command +
F12! Если учесть, что F-клавиши на маке работают с зажатым Ctrl, получается три
кнопки одновременно! Пользователь Идеи должен быть осьминогом, чтобы с этим
совладать. А в Xcode на полном серьезе одна из функций навешена на
Shift+Alt+Command+V. Я уже не помню какая, но точно помню подсказку в меню.&lt;/p&gt;

&lt;p&gt;Не то чтобы это большая проблема; можно продуктивно работать в любом
редакторе. Но повторюсь, системно к проблеме хоткеев подошли только в двух
редакторах: Виме и Емаксе. Все остальное — ситуативно и нерасширяемо.&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/two-hotkey-systems/</link>
        <guid isPermaLink="true">https://grishaev.me/two-hotkey-systems/</guid>
        
        <category>text</category>
        
        <category>emacs</category>
        
        <category>vim</category>
        
        
      </item>
    
      <item>
        <title>Выпрямить данные</title>
        <description>&lt;p&gt;В кложурном чатике скинули очередную задачу: дана такая-то мапа, нужно перегнать
ее в другую мапу. Примерный исходник:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(var DATA
  {:kek {:foo {:type :LOL}
         :bar {:type :KEK}}
   :owo {:pip {:type :AGA}}})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ожидание:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{:LOL {:foo :kek}
 :KEK {:bar :kek}
 :AGA {:pip :owo}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Это очень упрощенный пример. Грубо говоря, нужно вывернуть вложенную мапу
наизнанку: поместить наверх то, что сейчас внизу.&lt;/p&gt;

&lt;p&gt;Большинство кложуристов подходят к этой задаче как есть. Они берут мапу и
прогоняют ее через комбо &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mapcat&lt;/code&gt; и анонимных функций. Кто-то накручивает
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt; внутри &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt;. В целом работает, но как это читать и отлаживать — я
не знаю.&lt;/p&gt;

&lt;p&gt;Я тоже скинул решение, точнее его часть, и оно зашло: понаставили пальчиков и
огней. Раз так, стоит рассказать подробней, тем более что я замечаю, что никто
так не делает.&lt;/p&gt;

&lt;p&gt;Итак, если посмотреть на исходную мапу, станет ясно, что когда-то она была
плоской таблицей:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kek foo LOL
kek bar KEK
owo pip AGA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Из-за того, что в левой части были повторы, кто-то решил избавиться от них
группировкой. Но данные никуда не пропали: мы по-прежнему знаем, у кого какой
атрибут. Посмотрев на самый вложенный элемент, легко проследить его
путь. Например, обнаружить, что AGA начинается с owo.&lt;/p&gt;

&lt;p&gt;Так вот, чтобы переколбасить эту мапу во что-то другое, нужно сперва выправить
данные — привести их к таблице. Поможет макрос for. Он принимает несколько
коллекций и строит декартово произведение их элементов. Примечательно, что
каждая следующая коллекция может быть получена из предыдущих элементов. Код ниже
строит ленивую таблицу:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(for [[k1 submap1]
      DATA

      [k2 submap2]
      submap1

      [_ item]
      submap2]

  [k1 k2 item])

([:kek :foo :LOL]
 [:kek :bar :KEK]
 [:owo :pip :AGA])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь когда мапа развернута, можно сгруппировать ее по-другому. Как именно —
это уже тривиальное дело, потому что, имея плоские данные, это делается на
раз-два. Кроме того, нужно спросить себя — действительно ли нужна новая
группировка? Может быть, лучше оставить как есть? Возможно, на той стороне тоже
хотели бы плоские данные.&lt;/p&gt;

&lt;p&gt;Я как-то рассказывал о нелепой ситуации со вложенностью. На одной стороне
человек потеет, чтобы построить из списка вложенную мапу вида:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{:node shit
 :children
 [{:node crap
   :children
   [{:node fuck
     :children
     [...]}]}]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;А на второй стороне другой человек потеет, чтобы обойти ее как список. Оба пишут
быдлокод и матерятся, а ради чего — не ясно. Такую структуру даже не каждый
кложурист обойдет, потому что не все знают про tree-seq и зипперы.&lt;/p&gt;

&lt;p&gt;Возвращаясь к теме переколбаса данных: хорошо бы запомнить аналогию. Плоские
данные — это как лист бумаги, из которого можно сложить самолет, кораблик или
лягушку-квакушку. Но переход от одной фигуры к другой происходит через развертку
— то есть откату к нулевому состоянию. Только потом можно переходить к новому.&lt;/p&gt;

&lt;p&gt;Наверняка найдется японец, который может сложить самолет в лягушку, минуя
лист. Точно так же можно написать быдлокод, который переколбасит одну мапу в
другую. Но это сложно, не очевидно, хрупко. Лучше избегать.&lt;/p&gt;

&lt;p&gt;Видеть простейшую форму и возвращаться к ней, когда что-то идет не так — важный
навык.&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/straight-data/</link>
        <guid isPermaLink="true">https://grishaev.me/straight-data/</guid>
        
        <category>programming</category>
        
        <category>data</category>
        
        
      </item>
    
      <item>
        <title>Файловые пути</title>
        <description>&lt;p&gt;У меня пожелание: давайте не будем строить файловые пути конкатенацией строк. Не
будем сами и не позволим другим. Как увидите в ревью что-то вроде&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file_path = some_dir + &quot;/&quot; + file_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;, сразу пишите комментарий: не клей строки, используй функции, для этого
предназначенные.&lt;/p&gt;

&lt;p&gt;Достоверно известен случай, когда человек потерял бизнес из-за ошибки в
файлах. Это был небольшой хостинг, и чел выполнил на всех машинах &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo rm -rf
$FOO/$BAR&lt;/code&gt;. Беда в том, что переменные не подхватились, и получилось &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo rm
-rf /&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Вы скажете, что есть флаг &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e&lt;/code&gt;, чтобы вылететь с ошибкой, если переменная среды
не задана. Ну, допустим. Однако ничто не мешает сделать такую же ошибку в
коде. Например, кложуристы (которые, как известно, боги программирования),
строят пути конкатенацией строк:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(str some-dir &quot;/&quot; subdir &quot;/&quot; file-name)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;И не знают, что функция &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; молча пропускает нуллы. Это значит, если
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file-name&lt;/code&gt; равен nil, то путь получится &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/some/dir/subdir/&lt;/code&gt;. Если передать его
в функцию удаления, можно удалить всю папку.&lt;/p&gt;

&lt;p&gt;По закону подлости, если что-то “можно”, то оно случается. Сегодня отлаживал
этот баг. Человек строит путь примерно так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(str &quot;/tmp/&quot; (get-dir-name ...))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Этот путь передается в функцию, которая рекурсивно удаляет папку. Но во-первых,
функция удаления была с багом и ничего не удаляла. А как только я починил,
выяснилось: при особых условиях &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(get-dir-name...)&lt;/code&gt; выдает nil, и путь
получается /tmp/. Функция исправно удаляет весь /tmp, в котором масса нужных
файлов.&lt;/p&gt;

&lt;p&gt;Мораль: работая с путями как строками, легко отстрелить ногу. Вдвойне печально,
что это делают снова и снова. Я с этим борюсь, и вы помогайте.&lt;/p&gt;

&lt;p&gt;Если речь про Кложу без библиотек, испольуйте &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io/file&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(io/file &quot;/tmp&quot; subdir filename)

java.io.File&amp;lt;&quot;/tmp/subsir/filename.txt&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если один из аргументов nil, оно свалится с ошибкой. А так есть либы вроде
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;babashka/fs&lt;/code&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/file-paths-concat/</link>
        <guid isPermaLink="true">https://grishaev.me/file-paths-concat/</guid>
        
        <category>programming</category>
        
        <category>files</category>
        
        
      </item>
    
      <item>
        <title>Зачем OpenAPI?</title>
        <description>&lt;p&gt;Чего не могу понять, так это одержимость OpenAPI. Казалось бы, нужна апишка на
сайте — ну, сделай как тебе удобно. Но люди берут OpenAPI, крафтят спеку,
генерят по ней контроллеры, схемы, тесты. Превозмогают, потеют и потом
рассказывают: смотрите, наша апишка по стандарту OpenAPI.&lt;/p&gt;

&lt;p&gt;А кого волнует этот ваш OpenAPI? Расстрою: никому не интересно, какая у вас
апишка. Пользователю все равно, что гоняетя под капотом. Для программистов на
Питоне, как правило, пишут клиентские библиотеки. Вызывая метод
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client.get_user(id=42)&lt;/code&gt;, программист в гробу видал, что там у вас — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt;, джейсон или XML. Никто на это не смотрит.&lt;/p&gt;

&lt;p&gt;Если точнее, на это смотрят только кложуристы, потому что для них клиентских
библиотек никто не пишет. Но кого интересуют проблемы кложуристов? Они сами
напишут клиент поверх чего нужно.&lt;/p&gt;

&lt;p&gt;За много лет я не припомню, чтобы от OpenAPI была какая-то польза. А вот проблем
— целый мешок. Это стандарт, которому нужно следовать; это определенные
инструменты, которые навязывают игру. Инструмент X написан на Руби, ставь его и
миллион пакетов. Инструмент Y написан на Ноде, ставь ее тоже и качай половину
npm. Я неделю настраивал swagger в докере, чтобы он показывал веб-страничку со
спекой. Команда привязала гирю к ноге и удивляется: почему разработка идет так
медленно?&lt;/p&gt;

&lt;p&gt;Когда мне нужна апишка, я делаю простой RPC: команда-параметры,
команда-параметры. Все в теле запроса, а не как в REST, где один параметр в
заголовке, второй в адресной строке, третий черт знает где. В теле гоняю либо
JSON, либо message pack в зависимости от content type.&lt;/p&gt;

&lt;p&gt;Это просто, это быстро, это прозрачно. В коде большая мапа вида&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{action {doc ...
         schema-in
         schema-out
         handler ...}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;По текущей команде я вынимаю схему, проверяю вход, вызываю функцию &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler&lt;/code&gt; с
параметрами. Если дебаг, то проверяю выходные данные. Один раз настроил этот
словарь и потом только наращиваешь.&lt;/p&gt;

&lt;p&gt;Если нужна документация, пишется код, который пробегает по словарю и рендерит
markdown-файл. В нем список команд, описание из поля &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;doc&lt;/code&gt; и схемы
ввода-вывода. Если нужно, md-файлик рендерится в HTML или PDF.&lt;/p&gt;

&lt;p&gt;Но серьезным людям этого не понять. Им нужна OpenAPI-спека, чтобы что-то
генерить и чему-то соответсвовать. Пишутся запредельные объемы тулинга под
OpenAPI. Бывает, в Кложу приходит бывший рубист и заводит песню: мол, в моих
Рельсах есть библиотека, которая по спеке сгенерит контроллер и модели, напишет
тесты, а у вас в Кложе ничего нет… блин, потому я и довольный, что нет.&lt;/p&gt;

&lt;p&gt;На самом деле я был разок в проекте на Кложе, где по OpenAPI-спеке генерили
код. Два слова: это ужасно. Ни при каких обстоятельствах не сяду за это
снова. Генерация — это стремно, это хрупко, это километровые диффы. Духота,
трение и тошнота.&lt;/p&gt;

&lt;p&gt;И никому не прихоит в голову спросить — зачем? Какую проблему ты решаешь своим
OpenAPI? Зачем соответствовать чужому стандарту, который не контролируешь? Чтобы
что?&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/why-openapi/</link>
        <guid isPermaLink="true">https://grishaev.me/why-openapi/</guid>
        
        <category>programming</category>
        
        <category>openapi</category>
        
        <category>web</category>
        
        <category>rpc</category>
        
        
      </item>
    
      <item>
        <title>Видео с митапа о Postgres</title>
        <description>&lt;p&gt;Появилась запись митапа:&lt;/p&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;500&quot; src=&quot;https://www.youtube.com/embed/PDaLQLSCuJ8&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; referrerpolicy=&quot;strict-origin-when-cross-origin&quot; allowfullscreen=&quot;&quot;&gt;
&lt;/iframe&gt;

&lt;p&gt;Примерно час я рассказываю про всякие технические кишки, потом дискуссия с
Николаем (CTO Самураев) и Владимиром (разработчиком JDBC-драйвера для Postgres).&lt;/p&gt;

&lt;p&gt;Не обещаю, что будет интересно, скорее сильно на любителя.&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/pg-meetup-video/</link>
        <guid isPermaLink="true">https://grishaev.me/pg-meetup-video/</guid>
        
        <category>programming</category>
        
        <category>postgres</category>
        
        <category>meetup</category>
        
        
      </item>
    
      <item>
        <title>Copilot и документация</title>
        <description>&lt;p&gt;Вчера провел с коллегой эксперимент.&lt;/p&gt;

&lt;p&gt;Коллега подключил в редакторе Copilot и говорит — смотри, как круто он генерит
комментарии к функции! Скажем, для функции &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generate-time-buckets(account,
time-frames)&lt;/code&gt; пишет что-то вроде “generate time buckets for given account and
time frames”.&lt;/p&gt;

&lt;p&gt;Мда, содержательно: для &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generate-time-buckets&lt;/code&gt; получить “generate time
buckets”… Мне такой подход кажется малоинформативным: очевидно, Copilot берет
сигнатуру и аргументы, конкатит их, разбивает на лексемы и причесывает, чтобы
смотрелось по-человечески.&lt;/p&gt;

&lt;p&gt;Предложил эксперимент: пишем фукнцию, которая тупо складывает два числа: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return
a + b&lt;/code&gt;. Называем функцию &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete-file&lt;/code&gt; и просим Copilot написать докстринг. Что
он пишет? Правильно, “Delete а file”. Есть и второй вариант — “Delete a file
from S3”, видимо, для корпоративных клиентов в облаке.&lt;/p&gt;

&lt;p&gt;Словом, теперь у нас ИИ-комментарии, а чего мы добились и какую проблему решили
— не понятно.&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/copilot-test/</link>
        <guid isPermaLink="true">https://grishaev.me/copilot-test/</guid>
        
        <category>programming</category>
        
        <category>copilot</category>
        
        <category>ai</category>
        
        
      </item>
    
      <item>
        <title>Зачем спринты?</title>
        <description>&lt;p&gt;За все время работы в айти я не понял, зачем нужны спринты.&lt;/p&gt;

&lt;p&gt;Как правило, спринт — это период от двух недель до месяца. В него набирают задач
и пытаются их сделать к концу спринта. Потом спринты оценивают: этот был лучше,
чем в прошлый раз, а этот хуже. Тут собрали двадцать стори-поинтов, а тут
восемнадцать. Проводят ретро, которые убивают время.&lt;/p&gt;

&lt;p&gt;Все это кажется мне бредом. Зачем делить время на равные участки? Зачем считать
стори-поинты? Какое знание дает цифра 18 стори-поинтов? Чем это хуже, чем 20
поинтов?&lt;/p&gt;

&lt;p&gt;В чем проблема, если задача из одного спринта переносится в другой? Кто от этого
пострадал? Если задача не умещается в спринт, то может просто не впихивать
невпихуемое?&lt;/p&gt;

&lt;p&gt;Нужно обсудить процесс? Так проведи серию звонков 1 на 1 с разработчиками. Не
обязательно ждать ретро.&lt;/p&gt;

&lt;p&gt;В моем понимании процесс управляется релизами. Скажем, поставили мы задачу
выкатить новый релиз через два месяца. Договорились, что в релиз войдет то, се,
пятое-десятое. Не успеваем? Что-то упрощаем, что-то откладываем в следующий
релиз.&lt;/p&gt;

&lt;p&gt;Зачем нам спринты? Почему все следуют карго-культу гуглов-амазонов? Нужно думать
своей головой, а не как менеджер Гугла.&lt;/p&gt;

&lt;p&gt;UPD: сюда же относятся эстимейты. Воистину, самое тупое и бесмыссленое, что есть
в айти. Эстимейтить все и вся, ошибаться на порядок и потом рвать задницу, чтобы
успеть.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/why-sprints/</link>
        <guid isPermaLink="true">https://grishaev.me/why-sprints/</guid>
        
        <category>work</category>
        
        <category>sprint</category>
        
        
      </item>
    
      <item>
        <title>Шкала ООП</title>
        <description>&lt;p&gt;Когда говорят про ООП, упоминают всякие солиды, наследование и прочее. И не
говорят вот про что (а надо бы).&lt;/p&gt;

&lt;p&gt;Если в языке присутствует ООП, то типизация объектов размывается. Только
структуры и функции дают четкие типы; объекты, наоборот, разрушают их путем
абстракций. Они замыливают глаз.&lt;/p&gt;

&lt;p&gt;Скажем, у нас есть классы &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dog&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cat&lt;/code&gt;, унаследованные от &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animal&lt;/code&gt;. Пока мы
передаем собак и котов явно, все хорошо. Но когда мы передаем их как животных
(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animal&lt;/code&gt;), там может быть что угодно. В итоге на одни и те же данные смотришь
по-разному.&lt;/p&gt;

&lt;p&gt;Если предположить, что &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animal&lt;/code&gt; наследуется еще от чего-то, то получится шкала
от &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt; к &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dog&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cat&lt;/code&gt;, и как смотреть на объект — зависит от контекста. В
некоторых случаях делают даун-каст и ап-каст: передают кота в виде объекта, а
потом проверяют: если это кот, то одно, если собака, то другое, иначе эксепшен.&lt;/p&gt;

&lt;p&gt;Эту шкалу (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt; — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animal&lt;/code&gt; — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mammal&lt;/code&gt; — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dog&lt;/code&gt;) важно держать в голове и
знать, где находишься сейчас. Лично мне она доставляет много хлопот, когда я
пишу на ООП-языках, например Джаве. Шкала — это не вкл/выкл, а некая доля,
позиция в в дереве, следить за которой сложнее.&lt;/p&gt;

&lt;p&gt;Может быть, кто-то лучше выразил эту мысль, но либо я не слышал, либо забыл.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/oop-gauge/</link>
        <guid isPermaLink="true">https://grishaev.me/oop-gauge/</guid>
        
        <category>programming</category>
        
        <category>oop</category>
        
        
      </item>
    
      <item>
        <title>Не люблю регулярки</title>
        <description>&lt;p&gt;Признаться, я не особо люблю регулярные выражения. Я знаю их где-то на троечку,
время от времени применяю, но стараюсь, чтобы их было меньше.&lt;/p&gt;

&lt;p&gt;Дело в том, что регулярные выражения — это сверхплотный, сверхкраткий язык
описания шаблонов в тексте. Из его главного преимущества — краткости — следует
главный недостаток. Когда регулярка больше какого-то порога, ее понимание и
поддержка резко идут вниз. В этом случае следует отказаться от регулярки, однако
в проекте запросто может оказаться маньяк, который накрутит еще пару этажей
регулярок.&lt;/p&gt;

&lt;p&gt;Другой момент — с регуляркой часто оказывается, что ты не все учел. Предположим,
нужно искать в тексте числа с плавающей запятой. Вы написали регулярку, которая
ищет числа вроде &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-12.0042&lt;/code&gt;. А потом оказалось, что у чисел может не быть целой
части, например &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-.0042&lt;/code&gt;. А еще оказались числа в научной нотации: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1.2E9&lt;/code&gt;. И
регулярку нужно допиливать, допиливать и накидывать тесты.&lt;/p&gt;

&lt;p&gt;У регулярок есть хорошее применение: ими удобно разбивать текст. Как правило, я
разбиваю текст на части и проверяю, что их количество и содержимое чему-то
соответствует. Это проще отлаживать, это лучше в плане сообщения об ошибке. Если
текст не натягивается на монструозную регулярку, ты не можешь объяснить, что
пошло не так. А если обрабатывать текст по частям, легко сказать, в чем
проблема.&lt;/p&gt;

&lt;p&gt;В одном из проектов у нас была библиотека для генерации регулярок. Это когда
декларативно указываешь: либо это слово, либо это, либо то, но не это и не то, и
библиотека строит одну регулярку. В ней учитываются общие начала слов, например
для &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fuck&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fuckoff&lt;/code&gt; получим &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fuck(?=off)&lt;/code&gt;. Выбрал такой пример, потому что
фильтровали сообщения в чате. Было много других слов, значения которых я не знал
и смотрел в словаре.&lt;/p&gt;

&lt;p&gt;Этот подход интересен тем, что регуляркам отводится служебная
часть. Конфигурация делается словарями и списками, все ясно и прозрачно.&lt;/p&gt;

&lt;p&gt;Вместо регулярок мне больше нравится парсинг грамматикой. Пару лет назад я
прочитал пару статей про комбинаторные парсеры и решил сделать свой. В
результате я написал огрызок, который назвал Ostap (потому что великий
комбинатор). В библиотеке были простые парсеры и те, что составляются из других
(and, or). Можно задать грамматику словарем и получить из нее парсер.&lt;/p&gt;

&lt;p&gt;В результате у меня получилось составить &lt;a href=&quot;https://github.com/igrishaev/ostap/blob/master/src/ostap/json.clj&quot;&gt;грамматику JSON&lt;/a&gt;, и парсер
разбирал произвольный JSON-документ. Правда, это было медленней джавного Jackson
раз в десять, но за скоростью я не гнался. Почему-то зачесались руки сесть и
переписать его на Джаве и собрать парсеры для JSON, INI, Tolm и других форматов.&lt;/p&gt;

&lt;p&gt;Словом, регулярки хороши, но я предпочитаю держать их на расстоянии вытянутой
руки. Чем они ближе, тем строже я слежу за ними.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
        <link>https://grishaev.me/no-regex/</link>
        <guid isPermaLink="true">https://grishaev.me/no-regex/</guid>
        
        <category>programming</category>
        
        <category>regex</category>
        
        
      </item>
    
  </channel>
</rss>
