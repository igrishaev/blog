<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Тесты в Clojure (фрагмент главы)</title>
  <meta name="description" content="В последней главе мы поговорим о тестировании приложений. Читатель узнает, чтотакое тесты и каких типов они бывают. Мы рассмотрим методы тестирования ихороши...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-book-tests-1/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Тесты в Clojure (фрагмент главы)</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2019-11-07T00:00:00+00:00">
        Nov 7, 2019
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/tests/" rel="tag">tests</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>В последней главе мы поговорим о тестировании приложений. Читатель узнает, что
такое тесты и каких типов они бывают. Мы рассмотрим методы тестирования и
хорошие практики. Постараемся избежать лишней сложности: не будем злоупотреблять
терминами вроде TDD и BDT. Покажем, что в мире Clojure легко писать и
поддерживать тесты.</em></p>

<h2>

    Содержание

</h2>

<ul id="toc-item-clj-book-tests-1">
  <li><a href="#основные-понятия" id="toc-item-clj-book-tests-1-основные-понятия">Основные понятия</a>    <ul>
      <li><a href="#кейсы-и-покрытие" id="toc-item-clj-book-tests-1-кейсы-и-покрытие">Кейсы и покрытие</a></li>
      <li><a href="#не-только-числа" id="toc-item-clj-book-tests-1-не-только-числа">Не только числа</a></li>
      <li><a href="#когда-писать-тесты" id="toc-item-clj-book-tests-1-когда-писать-тесты">Когда писать тесты</a></li>
      <li><a href="#о-чистоте-функций" id="toc-item-clj-book-tests-1-о-чистоте-функций">О чистоте функций</a></li>
      <li><a href="#производство" id="toc-item-clj-book-tests-1-производство">Производство</a></li>
      <li><a href="#устройство-тестов" id="toc-item-clj-book-tests-1-устройство-тестов">Устройство тестов</a></li>
      <li><a href="#типы-тестов" id="toc-item-clj-book-tests-1-типы-тестов">Типы тестов</a></li>
    </ul>
  </li>
  <li><a href="#тесты-в-clojure" id="toc-item-clj-book-tests-1-тесты-в-clojure">Тесты в Clojure</a>    <ul>
      <li><a href="#командная-строка" id="toc-item-clj-book-tests-1-командная-строка">Командная строка</a></li>
      <li><a href="#repl" id="toc-item-clj-book-tests-1-repl">REPL</a></li>
    </ul>
  </li>
  <li><a href="#полезные-практики" id="toc-item-clj-book-tests-1-полезные-практики">Полезные практики</a>    <ul>
      <li><a href="#testing" id="toc-item-clj-book-tests-1-testing">Testing</a></li>
      <li><a href="#исключения" id="toc-item-clj-book-tests-1-исключения">Исключения</a></li>
      <li><a href="#пакетная-проверка" id="toc-item-clj-book-tests-1-пакетная-проверка">Пакетная проверка</a></li>
      <li><a href="#именование" id="toc-item-clj-book-tests-1-именование">Именование</a></li>
    </ul>
  </li>
  <li><a href="#фикстуры" id="toc-item-clj-book-tests-1-фикстуры">Фикстуры</a>    <ul>
      <li><a href="#регистрация" id="toc-item-clj-book-tests-1-регистрация">Регистрация</a></li>
      <li><a href="#пример" id="toc-item-clj-book-tests-1-пример">Пример</a></li>
      <li><a href="#на-нижнем-уровне" id="toc-item-clj-book-tests-1-на-нижнем-уровне">На нижнем уровне</a></li>
      <li><a href="#связанные-переменные" id="toc-item-clj-book-tests-1-связанные-переменные">Связанные переменные</a></li>
    </ul>
  </li>
  <li><a href="#мульти-фикстуры" id="toc-item-clj-book-tests-1-мульти-фикстуры">Мульти-фикстуры</a>    <ul>
      <li><a href="#минутка-неадекватности" id="toc-item-clj-book-tests-1-минутка-неадекватности">Минутка неадекватности</a></li>
      <li><a href="#фикстуры-с-условиями" id="toc-item-clj-book-tests-1-фикстуры-с-условиями">Фикстуры с условиями</a></li>
    </ul>
  </li>
  <li><a href="#метки-и-селекторы" id="toc-item-clj-book-tests-1-метки-и-селекторы">Метки и селекторы</a>    <ul>
      <li><a href="#тесты-в-depsedn" id="toc-item-clj-book-tests-1-тесты-в-depsedn">Тесты в deps.edn</a></li>
    </ul>
  </li>
  <li><a href="#проблема-окружения" id="toc-item-clj-book-tests-1-проблема-окружения">Проблема окружения</a>    <ul>
      <li><a href="#моки" id="toc-item-clj-book-tests-1-моки">Моки</a></li>
      <li><a href="#вынести-данные-в-файл" id="toc-item-clj-book-tests-1-вынести-данные-в-файл">Вынести данные в файл</a></li>
      <li><a href="#перенести-мок-в-фикстуру" id="toc-item-clj-book-tests-1-перенести-мок-в-фикстуру">Перенести мок в фикстуру</a></li>
      <li><a href="#негативные-сценарии" id="toc-item-clj-book-tests-1-негативные-сценарии">Негативные сценарии</a></li>
      <li><a href="#сбор-данных" id="toc-item-clj-book-tests-1-сбор-данных">Сбор данных</a></li>
      <li><a href="#недостатки" id="toc-item-clj-book-tests-1-недостатки">Недостатки</a></li>
      <li><a href="#стабы" id="toc-item-clj-book-tests-1-стабы">Стабы</a></li>
      <li><a href="#ресурсы-и-пути" id="toc-item-clj-book-tests-1-ресурсы-и-пути">Ресурсы и пути</a></li>
      <li><a href="#база-данных" id="toc-item-clj-book-tests-1-база-данных">База данных</a></li>
    </ul>
  </li>
</ul>

<!-- more -->

<h2 id="основные-понятия">Основные понятия</h2>

<p>На тему тестов написано много книг и статей, придуманы разные методологии. Их
сторонники отстаивают позиции в бесконечных спорах. Начинающих сбивает с толку
обилие терминов и фрагментация мнений. Вводный раздел к этой главе поможет
читателю погрузиться в тему. Расскажем основные моменты тестирования простыми
словами.</p>

<p class="draft-warn">Внимание! Вы читаете черновик к книге <a href="/clojure-in-prod/">“Clojure на производстве”</a>. Для
книги я переписывал его много раз, но в блоге осталась старая версия. Здесь она
для истории, а вам я рекомендую купить книжку.</p>

<p>Тест — это код, который проверяет другой код. Например, мы написали функцию для
перевода температуры из Цельсия в Фаренгейты:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-&gt;fahr</span><span class="w"> </span><span class="p">[</span><span class="n">cel</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">cel</span><span class="w"> </span><span class="mf">1.8</span><span class="p">)</span><span class="w"> </span><span class="mi">32</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Мы вызвали ее вручную несколько раз убедились, что результаты такие же, как в
школьном справочнике. Зафиксируем расчеты в специальной функции
проверки. Функция сравнивает вызов <code class="language-plaintext highlighter-rouge">-&gt;fahr</code> с каноничными значениями 68 и 212. Их
посчитали заранее и расценивают как верные.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">test-fahr</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">20</span><span class="p">))</span><span class="w"> </span><span class="mi">68</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w"> </span><span class="mi">212</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Макрос assert бросает исключение, если его тело вычисляется в ложь. На данный
момент вызов <code class="language-plaintext highlighter-rouge">(test-fahr)</code> вернет nil без ошибок. Если внести в алгоритм
изменения, функция бросит исключение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-&gt;fahr</span><span class="w"> </span><span class="p">[</span><span class="n">cel</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">cel</span><span class="w"> </span><span class="mf">1.9</span><span class="p">)</span><span class="w"> </span><span class="mi">32</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">test-fahr</span><span class="p">)</span><span class="w">
</span><span class="n">Assert</span><span class="w"> </span><span class="n">failed</span><span class="err">:</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">20</span><span class="p">))</span><span class="w"> </span><span class="mi">68</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">test-fahr</code> и есть тест. Она проверяет, что никто не изменил код
<code class="language-plaintext highlighter-rouge">-&gt;fahr</code> так, что мы получим другие результаты. В наших интересах вызвать
<code class="language-plaintext highlighter-rouge">(test-fahr)</code> перед сборкой программы. Так мы не допустим, чтобы алгоритм с
ошибкой попал в производство.</p>

<p>Техническая деталь: в тесте выше мы сравниваем результат -&gt;fahr с целым
числом. Без обертки в (int …) функция вернет число с плавающей запятой,
которое трудно сравнить с другим таким же числом. Поэтому мы приводим значение к
целому.</p>

<p>Тест не знает о внутреннем устройстве функции, которую проверяет. Мы вправе
менять алгоритм до тех пор, пока тест выполняется без ошибок. Предположим, мы
тестируем функцию факториала. Первая версия работает как линейное перемножение
чисел, что не эффективно. Но уже для первой версии мы написали тест, который
проверяют, что (= (fact 5) 120). Если заменить линейный алгоритм на дерево или
таблицу значений, тест должен пройти без ошибок. В противном случае это значит,
что в новом алгоритме ошибка.</p>

<h3 id="кейсы-и-покрытие">Кейсы и покрытие</h3>

<p>Близкие по семантике тесты объединяются в тест-кейсы. Вспомним школьную задачу с
квадратным уравнением. Требуется найти корни по заданным коэффициентам a, b,
c. Особенность этой задачи в том, что ее логика ветвится. В зависимости от
параметров может быть два корня, один или ни одного.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">square-roots</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">D</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="k">cond</span><span class="w">
      </span><span class="p">(</span><span class="nb">pos?</span><span class="w"> </span><span class="n">D</span><span class="p">)</span><span class="w"> </span><span class="p">[(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Math/sqrt</span><span class="w"> </span><span class="n">D</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w">
                </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Math/sqrt</span><span class="w"> </span><span class="n">D</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">a</span><span class="p">))]</span><span class="w">
      </span><span class="p">(</span><span class="nb">zero?</span><span class="w"> </span><span class="n">D</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">neg?</span><span class="w"> </span><span class="n">D</span><span class="p">)</span><span class="w"> </span><span class="n">nil</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы проверить алгоритм, тест вызывает функцию (square-roots a b c) минимум три
раза. Параметры должны быть подобраны таким образом, чтобы отработала каждая
ветка. Еще лучше, если на каждую ветку приходится отдельный тест с разными
значениями. Каждый тест можно расширить в будущем. Три теста ниже образуют кейс,
который проверяет алгоритм целиком.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">test-square-roots-two-roots</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">x1</span><span class="w"> </span><span class="n">x2</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">square-roots</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="mi">6</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[(</span><span class="nb">int</span><span class="w"> </span><span class="n">x1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">x2</span><span class="p">)]</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">]))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">test-square-roots-one-root</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">square-roots</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="mi">-3</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">test-square-roots-no-roots</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">square-roots</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="n">nil</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Как правило, в объектно-ориентированных языках кейсы это классы, а тесты — их
методы. Но в мире Clojure тест это просто функция.</p>

<p>В разговорах о тестах часто упоминают их покрытие. Под этим словом имеют в виду
долю кода, которая сработала в момент запуска теста. Предположим, мы написали
тесты только для двух корней. В этом случае ветки (zero? D) и (neg? D) не
выполнятся. Специальный модуль в тестовом фреймворке читает общее число строк в
исходной функции, количество исполненных строк и коэффициент
покрытия. Продвинутые фреймворки строят отчет, где выполненные строки помечены
зеленым (плюсом), а пропущенные красным (минусом).</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+(defn square-roots [a b c]
+  (let [D (- (* b b) (* 4 a c))]
+    (cond
+      (pos? D) [(/ (+ (- b) (Math/sqrt D)) (* 2 a))
+                (/ (- (- b) (Math/sqrt D)) (* 2 a))]
</span><span class="gd">-      (zero? D) (/ (- b) (* 2 a))
-      (neg? D) nil)))
</span></code></pre></div></div>

<p>В функции square-roots всего 7 строк. При запуске test-square-roots-two-roots
сработали 5 из них. Покрытие составит 5/7, что приблизительно 71%.</p>

<p>Принято считать, что покрытия 80% достаточно для того, чтобы код работал
надежно. Значения ниже говорят о недостаточном покрытии. Это значит, в проекте
встречается код, который не защищен от спонтанных изменений. При попытке
приблизиться к 100% возрастают затраты на разработку и поддержку тестов. Поэтому
в каждой команде придерживаются той величины, которая удобна для производства.</p>

<p>Процентная величина не должна затмевать здравый смысл. В примере выше цифра 71%
кажется большой только на первый взгляд. Из покрытия видно, что мы проверяем
одну ветку алгоритма из трех. Если в двух других затаились ошибки, мы не узнаем
о них. При оценке покрытия программист смотрит не на процентную величину, а на
ветвления алгоритма. Надежные тесты гарантируют, что сработала каждая ветка.</p>

<h3 id="не-только-числа">Не только числа</h3>

<p>У начинающих складывается мнение, что тесты пишут в основном для математических
расчетов. Это не так. Тесты подходят для всех функций, поведение которых хотят
зафиксировать. Это может быть обработка коллекций, криптография, операции с
текстом, словом — что угодно.</p>

<p>Рассмотрим пример с подписью командной строки. Функция sign-params принимает
словарь параметров и секретный ключ. Алгоритм подписи следующий:</p>

<ul>
  <li>отсортировать параметры по именам ключей;</li>
  <li>составить строку вида <code class="language-plaintext highlighter-rouge">param1=value1&amp;param2=value2...</code>;</li>
  <li>экранировать некоторые символы, например, пробел, знак плюса и другие;</li>
  <li>получить сигнатуру строки по алгоритму HMAC SHA256 и секретному ключу;</li>
  <li>вернуть словарь параметров с полем <code class="language-plaintext highlighter-rouge">:signature</code></li>
</ul>

<p>По такому принципу работает авторизация в API популярных сервисов и социальных
сетей. Напишем простой тест для функции подписи. Проверим, что входные параметры
дополнены сигнатурой, которую мы посчитали заранее.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">test-sign-params</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">api-key</span><span class="w"> </span><span class="s">"2Ag48&amp;@%776^634Tsdf23"</span><span class="w">
        </span><span class="n">params</span><span class="w"> </span><span class="p">{</span><span class="no">:action</span><span class="w"> </span><span class="no">:postComment</span><span class="w">
                </span><span class="no">:user_id</span><span class="w"> </span><span class="mi">42</span><span class="w">
                </span><span class="no">:post_id</span><span class="w"> </span><span class="mi">1999</span><span class="w">
                </span><span class="no">:comment</span><span class="w"> </span><span class="s">"This is a great article!"</span><span class="p">}</span><span class="w">
        </span><span class="n">signature</span><span class="w"> </span><span class="s">"e36b331823b..."</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">sign-params</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="n">api-key</span><span class="p">)</span><span class="w">
               </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="no">:signature</span><span class="w"> </span><span class="n">signature</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что sign-params работает не с числами, а коллекциями, строками и
криптографией. Это не помешало написать для нее тест. Чтобы улучшить нашу
работу, добавьте проверку на пустой ключ, экранирование символов, кириллические
языки, эмодзи и так далее.</p>

<h3 id="когда-писать-тесты">Когда писать тесты</h3>

<p>Начинающие разработчики иногда не понимают, какие функции покрывать
тестами. Случается и другая крайность: тесты пишут строго для каждой функции из
модуля. Это приводит к их избыточности и замедляет разработку. Верное решение,
как всегда, находится посередине.</p>

<p>Покрывать тестами следует те функции, которые атомарны с точки зрения
бизнес-логики. Например, подпись запроса состоит из множества других функций
рангом ниже: сортировки, экранирования и других. Но это технические шаги, детали
реализации. На высоком уровне подпись — один из промежуточных шагов
бизнес-логики, и технические тонкости отходят на задний план.</p>

<p>Разделять бизнес-логику и код это особый навык программиста. Пишите тесты так,
чтобы они проверяли именно логику, а не код. Это абстрактный навык, и его трудно
передать на словах. Здесь и помогут тесты: они подтолкнут вас писать код с
упором на потребности бизнеса.</p>

<h3 id="о-чистоте-функций">О чистоте функций</h3>

<p>Из примеров выше следует важное правило. Функцию удобно тестировать, если она не
несет побочных эффектов. Это значит, что функция не обращается к диску или сети,
не меняет глобальные переменные. Ее результат зависит только от входных
параметров.</p>

<p>Представим, что функция читает данные из файла. Это значит, что перед запуском
теста мы обязаны записать файл в нужное место, а после запуска удалить
его. Технически это возможно, но тесты становятся сложнее: теперь они зависят от
окружающей среды.</p>

<p>Чтобы облегчить тестирование, функцию разделяют на две. Первая читает содержимое
файла и передает на обработку второй. Тогда мы сможем тестировать вторую
функцию, вызывая ее со строкой.</p>

<p>Было:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-csv</span><span class="w"> </span><span class="p">[</span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">content</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="nb">path</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">line</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/split</span><span class="w"> </span><span class="n">content</span><span class="w"> </span><span class="o">#</span><span class="s">"\n"</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">remap-line</span><span class="w"> </span><span class="n">line</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Стало:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-csv-content</span><span class="w"> </span><span class="p">[</span><span class="n">content</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">line</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/split</span><span class="w"> </span><span class="n">content</span><span class="w"> </span><span class="o">#</span><span class="s">"\n"</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">remap-line</span><span class="w"> </span><span class="n">line</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-csv</span><span class="w"> </span><span class="p">[</span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">process-csv-content</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="nb">path</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Напишем тест для process-csv-content:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">CONTENT</span><span class="w">
  </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Ivan;ivan@test.ru;http://example.ru"</span><span class="w">
       </span><span class="sc">\n</span><span class="n">ewline</span><span class="w">
       </span><span class="s">"John;john@test.com;http://example.com"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">process-csv-content</span><span class="w"> </span><span class="n">CONTENT</span><span class="p">)</span><span class="w">
           </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="n">...</span><span class="p">}</span><span class="w">
            </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="n">...</span><span class="p">}]))</span><span class="w">
</span></code></pre></div></div>

<p>Другой способ в том, чтобы заменить функцию на мультиметод. Его реализация
зависит от типа первого аргумента. Если это java.io.File, мы читаем файл и
вызываем метод с содержимым. Для String срабатывает разбор данных.</p>

<p>Чистая функция — это идеальный случай тестирования. На практике мы столкнемся с
тем, что промышленный код трудно изолировать от побочных эффектов. В некоторых
случаях это даже невозможно. Чтобы тестировать код с эффектами, прибегают к
расширенным практикам: используют объекты-заглушки (стабы), подменяют объекты в
памяти (моки). Эти и другие приемы мы рассмотрим ниже.</p>

<p>Запомните, что подмена среды это вынужденная мера, и к ней прибегают в последнюю
очередь. Перед тестированием проверьте, можно ли выделить из кода его чистую
часть. Если да, создайте отдельную функцию и тестируйте ее.</p>

<h3 id="производство">Производство</h3>

<p>Тесты не только проверяют логику приложения. Они помогают проекту на разных
стадиях производства. Например, ветку с изменениями нельзя слить в мастер до тех
пор, пока не пройдут все тесты. Этим вы обезопасите код от случайных изменений.</p>

<p>Если разработчик добавил код, не не покрыл его тестами, это снизит долю
покрытия. Можно задать правило, что при значении ниже заданного слияние такой
ветки запрещено. Сервисы GitHub, CircleCI и другие гибко реагируют на ошибки в
тестах. Они шлют письма с отчетом, пишут сообщения в Slack, всячески
сигнализируют о проблеме.</p>

<p>В некоторых случаях тесты заменяют документацию. Это утверждение нельзя
воспринимать буквально — настоящую документацию не заменит ничто. Но в open
source-проектах ее недостаток иногда компенсируют тестами. Это нормально, потому
что на качественную документацию уходит столько же времени, сколько на
техническую часть. Если вы не уверены, как работает та или иная функция,
возможно, ее поведение прояснится из тестов.</p>

<h3 id="устройство-тестов">Устройство тестов</h3>

<p>Функции с макросом assert это сильно упрощенные тесты. Они пригодятся на раннем
этапе разработки, когда автор только обозначил контуры программы. Assert-ы это
временные меры чтобы сдержать код от изменений. Для полноценной работы с тестами
понадобится фремворк. Это библиотека, которая определяет, где и как описаны
тесты.</p>

<p>Когда выполнить команду lein test в папке проекта, тем самым мы запустим
тестовый фреймворк. Это сложный цикл из нескольких шагов. Мы рассмотрим основные
из них, чтобы читатель понимал так называемый стек тестов.</p>

<p>На первом этапе фреймворк ищет тесты в кодовой базе проекта. По-другому фаза
называется test discovery. Это не простая задача: фреймворк загружает все модули
и ищет среди них тесты. Каждый найденный тест попадает в глобальный регистр.</p>

<p>Тест должен носить какой-то признак, по которому его можно отличить от обычной
функции. В примере выше test-sign-params это именно функция, а не тест (префикс
test- не делает функцию тестом). Далее мы рассмотрим, как превратить ее в тест.</p>

<p>Когда тесты найдены, система определяет, какие из них будут запущены. Если
фильтры не заданы, сработают все тесты. Иногда нужно выполнить тесты только из
определенного модуля или по признаку. Ести такие параметры заданы, сработает
фильтрация тестов.</p>

<p>На этапе прогона фреймворк выполняет тесты один за другим как функции. Система
фиксирует их количество и имена. Вызов теста обернут в try/catch, чтобы
исключение не прервало процесс. Каждая проверка попадает в глобальную
переменную. Эти сведения необходимы, чтобы построить отчет.</p>

<p>На этапе отчета система выводит накопленные данные в консоль. Качественный
фреймворк отличает удобство вывода — насколько он понятен человеку. Проблемные
тесты должны быть обозначены красным цветом. Для неудачных сравнений мы ожидаем
полные формы, а не финальные значения. Например, <code class="language-plaintext highlighter-rouge">(= (int (-&gt;fahr 20)) 68)</code>
вместо <code class="language-plaintext highlighter-rouge">(= 69 68)</code>.</p>

<p>Промышленные фреймворки показывают отчет в разных форматах. Кроме текста в
консоли это может быть HTML-файл. Систему сборки настраивают так, что отчет о
тестах публикуется на внутреннем веб-сервере по адресу
<code class="language-plaintext highlighter-rouge">/&lt;project&gt;-&lt;artifact&gt;-test.html</code>. Часть <code class="language-plaintext highlighter-rouge">&lt;artifact&gt;</code> это имя ветки или хэш
коммита.</p>

<p>Стандарт XUnit определяет, как записать отчет в виде XML-файла. Промышленные
системы вроде TeamCity и Atlassian понимают, как вывести этот файл в удобном
виде. XUnit удобен тем, что это стандарт. У вас могут быть тесты на Python,
JavaScript или Clojure, но если прогон запущен с флагом –xunit (или подобным),
отчеты будут выглядеть одинаково.</p>

<p>Это был поверхностный обзор того, как устроен обычный тестовый фреймворк. В
последующих разделах мы рассмотрим, как управлять им на каждом этапе.</p>

<h3 id="типы-тестов">Типы тестов</h3>

<p>Прежде чем писать тесты, разберемся каких видов они бывают. Возможно, читатель
слышал термины “юнит”, “интеграционные” и другие. На первый взгляд кажется, что
это излишняя классификация. На практике тесты из разных категорий отличаются
стилем, окружением и порядком запуска.</p>

<p>Понятие “юнит-тест” происходит от английского unit, модуль. Термин пришел из
мира Java и фреймворка JUnit. Согласно его идеологии, тесты группируют по
модулям. На каждый модуль из кодовой базы приходится одноименный тестовый,
который проверяет функциональность первого.</p>

<p>Юнит-тесты это простой способ зафиксировать логику приложения. Чаще всего проект
включает только эту категорию тестов. Юнит-тестирование поощряет чистые
функции. Чем меньше требований к окружению тестов, тем они удобней в
поддержке. Рассматривайте юнит-тесты как проверку отдельных частей приложения
(но не всего разом). Примеры выше подходят под категорию юнит-тестов.</p>

<p>Интеграционные тесты решают проблему, с которой не справляются юнит-тесты. Даже
когда отдельные части приложения проверены, в их совместной работе может что-то
пойти не так. Это известный феномен; про него говорят, что целое больше суммы
его частей.</p>

<p>В качестве примера вспомним регистрацию на сайте. Это сложный процесс из
нескольких шагов:</p>

<ul>
  <li>проверить, что такого пользователя нет в базе;</li>
  <li>создать временную учетную запись;</li>
  <li>сгенерировать ссылку для подтверждения записи;</li>
  <li>отправить письмо с этой ссылкой;</li>
  <li>проверить, что ссылка не подделана и не вышел срок ее действия;</li>
  <li>активировать учетную запись.</li>
</ul>

<p>Даже если каждый шаг обильно покрыт тестами, это не гарантирует работу всей
цепи. Например, письмо не уйдет адресату или попадет в спам. В одном из
браузеров не сработает AJAX-запрос или поедет верстка. Причины такого уровня
слишком абстрактны, чтобы решать их на уровне юнит-тестов.</p>

<p>Интеграционные тесты проверяют, что отдельные части системы согласованы друг с
другом. Такой тест выполняется в среде, максимально приближенный к
реальности. Это главное отличие юнит-тестов от интеграционных: в первом случае
окружение сужают, во втором расширяют.</p>

<p>Чтобы проиграть сценарий регистрации, понадобится запущенная система и смежные
ресурсы: веб-сервер, почтовый сервер, база данных. Интеграционный тест
подключается к браузеру по протоколу WebDriver и командует им. Открывает
страницу регистрации, вводит данные и нажимает кнопку. Проверяет, что появилось
сообщение с просьбой проверить почту. По протоколу SMTP скачивает последнее
письмо. Ищет ссылку активации регулярным выражением. Открывает ссылку в новой
вкладке. Переходит на страницу авторизации и вводит почту и пароль. Убеждается,
что попал в личный кабинет.</p>

<p>Интеграционные тесты сложнее юнит-аналогов. Их труднее организовать, потому что
требуется настроить компоненты друг на друга и привести к нужному
состоянию. Например, если выполнить тест повторно, пользователь уже будет в базе
данных, и сценарий оборвется.</p>

<p>Интеграционные тесты выполняются дольше. Открыть страницу, дождаться ее загрузки
и заполнить поля занимает больше времени, чем отправить запрос машинным
способом. Иногда управление браузером намеренно замедляют, чтобы согласовать
команды с содержимым. Например, не кликнуть на кнопку, которую браузер еще не
успел отрисовать.</p>

<p>Ошибки в интеграционных тестах требуют расследования. Юнит-тесты выводят отчет
об ошибках, где четко указано, какое выражение не равно чему. В интеграционных
тестах причина ошибки чаще всего не ясна. Например, после отправки формы мы
ожидаем сообщение с просьбой проверить почту. Но оно не появилось. Была ли это
ошибка на сервере? И пользователь уже существует? Или в форме новое обязательное
поле, которое мы не заполнили? Или сообщение изменилось так, что не ищется
селектором? Ответ требует вмешательства человека.</p>

<p>Чтобы проверить, как проект ведет себя под нагрузкой, прибегают к нагрузочному
тестированию. Приложению посылают запросы и фиксируют множество показателей:
время ответа, общее число запросов, сколько из них параллельны, потребление
процессора и памяти. По этим данным строят отчеты и графики.</p>

<p>Нагрузочное тестирование находит медленные части в проекте. С помощью него можно
узнать, насколько готова новая функциональность к промышленному
запуску. Например, если боевой сервер обслуживает в среднем сто запросов в
секунду, а новая страница выдает только двадцать, ее отправят на доработку.</p>

<p>К другим категориям тестов относятся Smoke-, Sanity-, регрессионные и
другие. Полный их список состоит из десяти и более пунктов. Мы не ставим цель
рассмотреть их все. В этой главе мы глубоко изучим юнит- и интеграционные
тесты. На этих двух категориях основаны остальные. Читателю хватит знаний, чтобы
разобраться с ними самостоятельно.</p>

<h2 id="тесты-в-clojure">Тесты в Clojure</h2>

<p>Переходим к практике. В этом разделе мы познакомимся со стандартным тестовым
фреймворком Clojure. Мы напишем настоящие тесты — такие, которые отвечают
требованиям фреймворка. Будем тестировать функции Фаренгейта и квадратного
уравнения из примеров выше.</p>

<p>Предположим, что функция -&gt;fahr находится в модуле src/book/util.clj. Создайте
файл test/book/util_test.clj с содержимым:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.util-test</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">book.util</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">-&gt;fahr</span><span class="p">]]</span><span class="w">
            </span><span class="p">[</span><span class="n">clojure.test</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">deftest</span><span class="w"> </span><span class="n">testing</span><span class="w"> </span><span class="n">is</span><span class="p">]]))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-fahr</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">20</span><span class="p">))</span><span class="w"> </span><span class="mi">68</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w"> </span><span class="mi">212</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Получился тестовый модуль. Он импортирует -&gt;fahr и объявляет для нее один тест
test-fahr. Макросы is и deftest заимствованы из пакета clojure.test. Это
тестовый фреймворк из поставки Clojure.</p>

<p>Шесть строк выше несут много новой информации. У читателя появятся резонные
вопросы. Почему тесты лежат в папке test, а не src? Разве не логично хранить
тесты рядом с тем, что они проверяют? Как система найдет их? Почему тест
объявляют особым макросом deftest? Автор утверждал, что тест это функция, или
это не так? Зачем было менять assert на is? Ответим на эти вопросы по порядку.</p>

<p>В Clojure разделяют код приложения и тестов. Код приложения находится в папке
src/, а тесты в test/. Такой подход несет преимущества. Во-первых, делит код на
смысловые части. Чтобы найти неисправный тест, мы сужаем область поиска до папки
test/, а не ищем по всему проекту. Во-вторых, когда тесты отделены, это снижает
риск того, что они станут частью скомпилированного результата. В этом нет
смысла, потому что тесты запускают только на этапе разработки. Мы только
увеличим время сборки и объем конечного файла.</p>

<p>Во время тестов проект запускается с особым параметром. Он определяет, где еще
кроме src/ искать исходные файлы. Технически это список, в котором по умолчанию
один путь src/. В режиме тестов система добавляет к нему путь test/. Когда
компилятор ищет файл, он по очереди просматривает пути из списка. С точки зрения
программиста пути как будто сливаются друг с другом. Далее в главе мы
рассмотрим, как настроить пути под нужды проекта.</p>

<p>Мы упоминали, что фреймворку необходим какой-то признак, чтобы отличить тест от
обычной функции. Макрос deftest объявляет функцию и сообщает ее метаданными
особое поле :test. Чтобы выбрать все тесты, фреймворк сканирует пространства
имен и читает метаданные каждой переменной. Если среди полей есть :test,
переменная считается тестом.</p>

<p>Заметим, что deftest не оставляет возможности задать аргументы теста. Это
сделано нарочно: в Clojure тест не зависит от внешних данных. Если тесту нужны
особые условия, их задают фикстурами. Мы рассмотрим фикстуры в отдельном
разделе.</p>

<p>Макрос is отличается от assert побочными эффектами. Assert это чистое сравнение:
мы получим либо nil, либо исключение. Макрос is изменяет глобальные
переменные. Он записывает данные о том, сколько раз и с какими параметрами его
вызвали. Из этих данных фреймворк строит отчет. Например, покажет все выражения
как они записаны в коде, которые не прошли проверку.</p>

<p>Пока что мы только написали тест, но не запустили его. Clojure предлагает
несколько способов сделать это.</p>

<h3 id="командная-строка">Командная строка</h3>

<p>Самый простой способ — поручить прогон утилите для сопровождения проекта. Если
проект основан на Leiningen, достаточно вызвать в терминале lein
test. Потребуется некоторое время, чтобы загрузить код из папок src/ и test/,
найти тесты и выполнить их. Вы увидите следующий отчет:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein test book.util-test

Ran 1 tests containing 2 assertions.
0 failures, 0 errors.
</code></pre></div></div>

<p>Clojure группирует тесты по пространствам имен. Под каждым пространством сводная
информация о том, сколько выполнено тестов (объявлений deftest) и проверок
(вызовов is). В нашем случае это один тест test-fahr с двумя проверками is.</p>

<p>Выражение <code class="language-plaintext highlighter-rouge">lein test book.util-test</code> напечатано для того, чтобы его можно было
скопировать и запустить в терминале. Тогда сработают тесты только из
пространства <code class="language-plaintext highlighter-rouge">book.util-test</code>.</p>

<p>Фреймворк различает т.н. failures и errors. Failure (анг. неудача) — это ошибка
в проверке. Например, мы утверждаем, что <code class="language-plaintext highlighter-rouge">(= (int (-&gt;fahr 20)) 68)</code>. Если формула
изменится и значения станут не верны, счетчик failures увеличится на
единицу. Каждое неудачное утверждение помнит о том, с какими параметрами его
запустили. Если была хотя бы одна неудача, мы увидим отчет об ошибке.</p>

<p>Откройте определение <code class="language-plaintext highlighter-rouge">-&gt;fahr</code> и измените коэффициент 1.8 на 1.9. Сохраните файл и
запустите в терминале lein test:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ lein test

lein test :only book.util-test/test-fahr

FAIL in (test-fahr) (util_test.clj:6)
expected: (= (int (-&gt;fahr 20)) 68)
  actual: (not (= 70 68))

lein test :only book.util-test/test-fahr

FAIL in (test-fahr) (util_test.clj:7)
expected: (= (int (-&gt;fahr 100)) 212)
  actual: (not (= 222 212))

Ran 1 tests containing 2 assertions.
2 failures, 0 errors.
Tests failed.
</code></pre></div></div>

<p>Отчет показывает 2 failures, что верно: в теле test-fahr макрос is встречается
два раза. Обе проверки неверны, потому что опираются на -&gt;fahr. Для каждой из
них отчет показывает исходное выражение (= (int (-&gt;fahr 100)) 212) и конечные
значения (= 222 212).</p>

<p>Выражение</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein test :only book.util-test/test-fahr
</code></pre></div></div>

<p>, которое отчет выводит над каждой проверкой, запустит только указанный
тест. Это полезно, когда вы работаете над определенным участком кода запускаете
один и тот же тест много раз.</p>

<p>Errors или ошибки это непойманные исключения, которые случились во время работы
теста. Чаще всего ошибки возникают, когда в функции передают некорректные
данные. Например, мы решили проверить поведение -&gt;fahr с nil. Добавим второй
тест:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-fahr-nil</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Отчет будет таким:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">$</span><span class="w"> </span><span class="n">lein</span><span class="w"> </span><span class="nb">test</span><span class="w">

</span><span class="n">lein</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span><span class="no">:only</span><span class="w"> </span><span class="n">book.util-test/test-fahr-nil</span><span class="w">

</span><span class="n">ERROR</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">(</span><span class="nf">test-fahr-nil</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Numbers.java</span><span class="no">:3849</span><span class="p">)</span><span class="w">
</span><span class="n">expected</span><span class="err">:</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">
  </span><span class="n">actual</span><span class="err">:</span><span class="w"> </span><span class="n">java.lang.NullPointerException</span><span class="err">:</span><span class="w"> </span><span class="n">null</span><span class="w">
 </span><span class="n">at</span><span class="w"> </span><span class="n">clojure.lang.Numbers.multiply</span><span class="w"> </span><span class="p">(</span><span class="nf">Numbers.java</span><span class="no">:3849</span><span class="p">)</span><span class="w">
    </span><span class="n">book.util$__GT_fahr.invokeStatic</span><span class="w"> </span><span class="p">(</span><span class="nf">util.clj</span><span class="no">:5</span><span class="p">)</span><span class="w">
    </span><span class="n">book.util$__GT_fahr.invoke</span><span class="w"> </span><span class="p">(</span><span class="nf">util.clj</span><span class="no">:4</span><span class="p">)</span><span class="w">
    </span><span class="n">book.util_test$fn__370.invokeStatic</span><span class="w"> </span><span class="p">(</span><span class="nf">util_test.clj</span><span class="no">:10</span><span class="p">)</span><span class="w">
    </span><span class="n">book.util_test/fn</span><span class="w"> </span><span class="p">(</span><span class="nf">util_test.clj</span><span class="no">:9</span><span class="p">)</span><span class="w">
    </span><span class="n">...</span><span class="w"> </span><span class="n">&lt;truncated&gt;</span><span class="w">

</span><span class="n">Ran</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">tests</span><span class="w"> </span><span class="n">containing</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">assertions.</span><span class="w">
</span><span class="mi">0</span><span class="w"> </span><span class="n">failures,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">errors.</span><span class="w">
</span><span class="n">Tests</span><span class="w"> </span><span class="n">failed.</span><span class="w">
</span></code></pre></div></div>

<p>Вызов (-&gt;fahr nil) приводит к выбросу NullPointerException. Фреймворк
оборачивает тест в try/catch и запоминает исключение. Для ошибок отчет выводит
их стек-трейс. В примере выше мы сократили его для экономии места.</p>

<p>Непойманные исключения говорят о том, что тесты спроектированы неудачно. Скорее
всего, тест вышел из-под контроля и делает что-то не то. Например, вы не
проверили, что результат функции положительный перед тем, как передать его в
другую функцию.</p>

<p>Иногда мы ожидаем, что функция действительно бросит исключение при определенных
параметрах. Фреймворк готов к такому сценарию. Макрос is, записанный в особой
форме, выражает это как обычное утверждение. Мы рассмотрим пример с исключениями
в следующем разделе.</p>

<h3 id="repl">REPL</h3>

<p>У тестов в консоли один недостаток: это долго. Код на Clojure, когда загружен в
память, выполняется быстро, но его загрузка занимает от трех до десяти
секунд. Время зависит от подключенных библиотек, размера кодовой базы и мощности
компьютера. Даже если вы запускаете один тест, lein стартует новую копию
проекта, что неэффективно.</p>

<p>Когда вы работаете с проектом, скорее всего, вы подключены к его сеансу
REPL. Будет удобно выполнить тест прямо в REPL по команде, не запуская новый
проект. Тогда издержки на загрузку кода станут равны нулю.</p>

<p>Наивный способ выполнить тест — запустить его как функцию. Выражение (test-fahr)
вернет nil, что означает, что все утверждения сработали верно. Теперь исправим
тест: пусть одно из утверждений заведомо ошибочно:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">20</span><span class="p">))</span><span class="w"> </span><span class="mi">999</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Даже если сохранить файл и вызвать (test-fahr), по-прежнему получим результат
без ошибок. Это происходит потому, что мы только сохранили файл, но не загрузили
новый теста в память JVM. То, как изменения в файле перетекают в память
Lisp-машины, зависит от вашего окружения.</p>

<p>Если это Emacs/CIDER, выполните одно из действий. Переместите курсор за
последнюю закрывающую скобку формы (deftest test-fahr …) и нажмите C-c
C-e. Сработает команда cider-eval-last-sexp, которая выполняет последнее
S-выражение. Другой способ в том, чтобы выполнить весь буфер. Независимо от
того, где сейчас курсор, нажмите C-c C-k (или M-x cider-eval-buffer <RET>). Эта
команда равносильна тому, чтобы скопировать буфер и вставить в сеанс REPL.</RET></p>

<p>Повторный вызов (test-fahr) вернет nil, но в консоли появятся строки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FAIL</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">(</span><span class="nf">test-fahr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">util_test.clj</span><span class="no">:14</span><span class="p">)</span><span class="w">
</span><span class="n">expected</span><span class="err">:</span><span class="w"> </span><span class="mi">68</span><span class="w">
  </span><span class="n">actual</span><span class="err">:</span><span class="w"> </span><span class="p">(</span><span class="nf">999</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Если вызвать тест (test-fahr-nil), который мы все еще не исправили, увидим
данные об исключении:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ERROR</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">(</span><span class="nf">test-fahr-nil</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Numbers.java</span><span class="no">:3849</span><span class="p">)</span><span class="w">
</span><span class="n">expected</span><span class="err">:</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">
  </span><span class="n">actual</span><span class="err">:</span><span class="w"> </span><span class="n">java.lang.NullPointerException</span><span class="err">:</span><span class="w"> </span><span class="n">null</span><span class="w">
 </span><span class="n">at</span><span class="w"> </span><span class="n">clojure.lang.Numbers.multiply</span><span class="w"> </span><span class="p">(</span><span class="nf">Numbers.java</span><span class="no">:3849</span><span class="p">)</span><span class="w">
    </span><span class="n">book.util$__GT_fahr.invokeStatic</span><span class="w"> </span><span class="p">(</span><span class="nf">form-init3606582116051051694.clj</span><span class="no">:5</span><span class="p">)</span><span class="w">
    </span><span class="n">book.util$__GT_fahr.invoke</span><span class="w"> </span><span class="p">(</span><span class="nf">form-init3606582116051051694.clj</span><span class="no">:4</span><span class="p">)</span><span class="w">
    </span><span class="n">...</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, это только вывод в консоль, а не брошенное исключение. Тест устроен
так, что его тело обернуто в try/catch. Поэтому дополнительно оборачивать вызов
теста не нужно.</p>

<p>Когда тест запускают вручную как функцию, к нему не применяются фикстуры. Это
пре- и пост-обработчики, которые подготавливают среду для теста. О фикстурах мы
поговорим в дальнейших разделах главы. Пока что отметим, что функция test-vars
выполняет тесты с учетом фикстур. Она принимает вектор объектов Var:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.test</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">test-vars</span><span class="p">]])</span><span class="w">
</span><span class="p">(</span><span class="nf">test-vars</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="ss">'test-fahr</span><span class="w"> </span><span class="o">#</span><span class="ss">'test-fahr-nil</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Функция run-test запускает все тесты пространства (текущего или
указанного). Технически она сводится к вызову test-vars со всеми переменными из
этого пространства:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.test</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">run-tests</span><span class="p">]])</span><span class="w">
</span><span class="p">(</span><span class="nf">run-tests</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Еще одна функция run-all-tests из выполняет тесты для всех загруженных
пространств:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.test</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">run-all-tests</span><span class="p">]])</span><span class="w">
</span><span class="p">(</span><span class="nf">run-all-tests</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Запустив это выражение, вы увидете, как тестовый фреймворк перебирает все
загруженные модули:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Testing nrepl.middleware.interruptible-eval
Testing cider.nrepl.middleware.util.nrepl
Testing clojure.test
Testing clojure.core.server
Testing clojure.core.specs.alpha
Testing book.util
...
</code></pre></div></div>

<p>Чтобы отбросить лишние пространства, в run-all-tests передают регулярное
выражение. С этим выражением сверяют имена пространств. Например, чтобы
выполнить только наши тесты, укажем, что имя модуля начинается с book:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">run-all-tests</span><span class="w"> </span><span class="o">#</span><span class="s">"$book"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Emacs/CIDER</p>

<p>Модуль CIDER для редактора Emacs упрощает работу с тестами. CIDER предлагает
команды и комбинации клавиш, чтобы выполнить один или несколько тестов. Он же
показывает отчет об ошибках в отдельном буфере. Вызвать тест клавишей гораздо
быстрее, чем печатать команду в REPL.</p>

<p>Чтобы запустить один тест, переместите на него курсор и нажмите C-c C-t t (или
M-x cider-test-run-test). Курсор может быть в любом месте (deftest …). Если
тест прошел без ошибок, вы увидите в области сообщений зеленый текст. Если
случились ошибки, откроется специальный буфер <em>cider-test-report</em>.</p>

<p>Этот буфер выводит отчет в более удобной форме. Ошибки в утверждениях подсвечены
красным цветом, а непойманные исключения желтым. Буфер интерактивен: если
подвести курсор к блоку с ошибкой и нажать Enter, соседний буфер покажет
исходный код теста. То же самое работает для исключений: чтобы не засорять
отчет, CIDER показывает только класс и сообщение. По Enter открывается отдельный
буфер с полным стек-трейсом.</p>

<p>Перечислим другие полезные команды:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cider-test-rerun-failed-tests (C-c C-t r)</code> повторно выполняет неудачный тест
из прошлого запуска. Это удобно, если в первый раз вы запустили блок тестов, и
ошибка случилась где-то на середине.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cider-test-run-ns-tests (C-c C-t n)</code> выполняет тесты для определенного
пространства. С помощью этой команды можно запустить тесты без перехода в их
модуль. Чтобы сопоставить пространство и тесты, CIDER добавляет к имени
“-test”. Например, для book.util целевой модуль получится <code class="language-plaintext highlighter-rouge">book.util-test</code>.</p>
  </li>
</ul>

<p>Запуск тестов это рутинная операция; избегайте ее ручного вызова. Чтобы не
терять время, изучите, как это сделать напрямую из редактора или IDE.</p>

<h2 id="полезные-практики">Полезные практики</h2>

<p>В этом разделе мы рассмотрим несколько практик по написанию тестов. Поскольку
тесты это тоже код, логично, что они нуждается в поддержке. Небрежные тесты
причиняют столько же проблем, сколько и основное приложение. Следующие приемы
сделают тесты удобней в чтении, навигации и поддержке.</p>

<h3 id="testing">Testing</h3>

<p>Макрос <code class="language-plaintext highlighter-rouge">testing</code> оборачивает произвольное тело строкой. Это сообщение, которое
говорит о том, что мы собираемся делать:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-square-roots</span><span class="w">
  </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"Two roots"</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">square-roots</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="mi">6</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">]))))</span><span class="w">
  </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"One root"</span><span class="w">
    </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">square-roots</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="mi">-3</span><span class="p">)))</span><span class="w">
  </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"No roots"</span><span class="w">
    </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nf">square-roots</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">7</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Сообщение важно по двум причинам: визуальной и технической. Оно разбивает тест
на логические блоки, заменяет комментарии, делает тест понятнее. Если
утверждение не сработало, в отчете будет указано сообщение, в которое оно
обернуто.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(is (= (square-roots 1 6 10) -3))

Fail in test-square-roots
One root
expected: nil
  actual: -3
</code></pre></div></div>

<p>Макросы testing могут быть вложенными. Тогда каждое следующее сообщение
добавляется к предыдущему через пробел. Тест ниже проверяет, что API createUser
действительно заносит пользователя в базу данных. Дополнительно мы
убеждаемся, что пароль в базе зашифрован. Если отбросить основной код, получим
скелет теста из форм testing:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-some-api</span><span class="w">
  </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"API call"</span><span class="w">
    </span><span class="n">...</span><span class="w">
    </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"HTTP response"</span><span class="w">
      </span><span class="n">...</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"DB checks"</span><span class="w">
    </span><span class="n">...</span><span class="w">
    </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"common user fields"</span><span class="w">
      </span><span class="n">...</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"password is hashed"</span><span class="w">
      </span><span class="n">...</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h3 id="исключения">Исключения</h3>

<p>Мы все еще не решили вопрос о том, как проверять код с исключениями. Хотелось бы
убедиться, что вызов (-&gt;fahr nil) порождает ошибку, а не возвращает nil. Если
теста на исключение нет, код не защищен от таких изменений:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-&gt;fahr</span><span class="w"> </span><span class="p">[</span><span class="n">cel</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">cel</span><span class="w">
    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">cel</span><span class="w"> </span><span class="mf">1.8</span><span class="p">)</span><span class="w"> </span><span class="mi">32</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>В этом случае nil провалится ниже по стеку вызовов, что усложнит поиск причины.</p>

<p>Пример ниже с try/catch решает проблему лишь отчасти. В таком виде (is true)
действительно сработает. Если же заменить (-&gt;fahr nil) на (-&gt;fahr 1), то
исключения не произойдет, и ветка (catch…) будет отброшена вместе с
содержимым. Это значит, что исключение, которое не выбросили там, где его
ожидают, — тоже ошибка.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-fahr-nil</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">NullPointerException</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="n">true</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Макрос <code class="language-plaintext highlighter-rouge">(is (thrown?...))</code> решает эту проблему. Форма thrown? принимает класс
исключения и произвольное тело. Если в момент исполнения было брошено исключение
этого класса (с учетом наследования), внешний (is…) сработает
положительно. Если исключения не было, получим ошибку в утверждении:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-fahr-nil</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nf">thrown?</span><span class="w"> </span><span class="n">NullPointerException</span><span class="w">
               </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Исправьте nil на любое число и убедитесь, что тест не проходит.</p>

<p>Иногда одной проверки на класс недостаточно. Когда тестируют большой участок
кода, NullPointerException возникает на разных уровнях программы. Например, если
кто-то изменит -&gt;fahr так, что она возвращает nil, ошибка придет из другой
функции, которая принимает результат -&gt;fahr. Это приводит к ложному
тестированию: тест проходит, но на самом деле не фиксирует поведение программы.</p>

<p>Проблему решают двумя шагами. Первый — исправить функцию так, чтобы она бросала
что-то более осмысленное, чем NPE. Например, специальное исключение
IllegalArgumentException. Его дополняют сообщением о том, что пошло не так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-&gt;fahr</span><span class="w"> </span><span class="p">[</span><span class="n">cel</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">cel</span><span class="w">
    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">cel</span><span class="w"> </span><span class="mf">1.8</span><span class="p">)</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="w">
            </span><span class="s">"Fahrenheit temperature should be a real number"</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Второй шаг — убедиться, что исключение пришло именно из -&gt;fahr. Форма (is
(thrown-with-msg?…)) проверяет, что текст исключения совпадает с регулярным
выражением. Тест ниже покрывает все перечисленные требования:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-fahr-nil</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nf">thrown-with-msg?</span><span class="w">
       </span><span class="n">IllegalArgumentException</span><span class="w"> </span><span class="o">#</span><span class="s">"Fahrenheit temperature"</span><span class="w">
       </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">nil</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<h3 id="пакетная-проверка">Пакетная проверка</h3>

<p>Вспомним, как выглядит test-fahr:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-fahr</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">20</span><span class="p">))</span><span class="w"> </span><span class="mi">68</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w"> </span><span class="mi">212</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Второе утверждение это копия первого и отличается только числами. Чтобы добавить
новую проверку, придется снова копировать одну из форм (is…). Подход с
копированием зашумляет код и в целом выходит боком. Очевидно, что из похожих
(is…) можно выделить постоянную и переменную части и переписать тест в
короткой форме.</p>

<p>Макрос are (анг. множественная форма глагола is) выполняет несколько is по
шаблону. Он принимает форму связывания, шаблон выражения и произвольные
аргументы. Число аргументов должно быть кратно переменным из формы
связывания. На каждом шаге макрос связывает часть аргументов с переменными и
выполняет шаблон в рамках is:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-fahr</span><span class="w">
  </span><span class="p">(</span><span class="nf">are</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;fahr</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w">
    </span><span class="mi">20</span><span class="w"> </span><span class="mi">68</span><span class="w">
    </span><span class="mi">100</span><span class="w"> </span><span class="mi">212</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Аргументы записывают столбиком по принципу одна строка — один is. В примере выше
f и c означают цифры по Фаренгейту и Цельсию, то есть исходное и ожидаемое
значения. Выражение (int (-&gt;fahr f)) переехало в шаблон, поэтому нет смысла
повторять его каждый раз.</p>

<p>Макрос are удобен для небольших выражений. С ростом логики он становится трудным
в поддержке. В этом случае тест переписывают на doseq, который пробегает по
данным.</p>

<p>Предположим, мы тестируем HTTP API для создания пользователя. Один из тестов
проверяет входные параметры. Мы ожидаем негативный ответ для случаев, когда нет
обязательного поля или оно в неверном формате. В переменную params-ok запишем
удачные параметры:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">params-ok</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"John Smith"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"john@test.com"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы проверить негативные случаи, объявим вектор params-variations. Каждый его
элемент это пара: словарь и текст. Словарь это измененные параметры, которые мы
добавим к params-ok функцией merge. Текст это сообщение с описанием проблемы,
например, неверный адрес почты, слишком длинное имя и тд.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">params-variations</span><span class="w">
  </span><span class="p">[[{</span><span class="no">:name</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w"> </span><span class="s">"Empty name"</span><span class="p">]</span><span class="w">
   </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="mi">999</span><span class="w"> </span><span class="s">"A"</span><span class="p">))}</span><span class="w"> </span><span class="s">"Name is too long"</span><span class="p">]</span><span class="w">
   </span><span class="p">[{</span><span class="no">:email</span><span class="w"> </span><span class="s">"dunno"</span><span class="p">}</span><span class="w"> </span><span class="s">"Wrong email"</span><span class="p">]</span><span class="w">
   </span><span class="p">[{</span><span class="no">:email</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w"> </span><span class="s">"No email"</span><span class="p">]</span><span class="w">
   </span><span class="p">[{</span><span class="no">:extra</span><span class="w"> </span><span class="mi">42</span><span class="p">}</span><span class="w"> </span><span class="s">"Extra field"</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>

<p>Тест ниже пробегает по params-variations. На каждом шаге он вызывает
api-create-user с испорченными параметрами. Обратите внимание, что вызов обернут
в форму testing с сообщением. Если на одном из шагов утверждение не сработает,
мы узнаем причину по сообщению из отчета.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-api-create-user-bad-params</span><span class="w">
  </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="s">"Sending bad parameters"</span><span class="w">
    </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[[</span><span class="n">params*</span><span class="w"> </span><span class="n">description</span><span class="p">]</span><span class="w"> </span><span class="n">params-variations</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="n">description</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">params</span><span class="w"> </span><span class="p">(</span><span class="nb">merge</span><span class="w"> </span><span class="n">params-ok</span><span class="w"> </span><span class="n">params*</span><span class="p">)</span><span class="w">
              </span><span class="n">response</span><span class="w"> </span><span class="p">(</span><span class="nf">api-create-user</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w">
              </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">status</span><span class="p">]}</span><span class="w"> </span><span class="n">response</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">400</span><span class="w"> </span><span class="n">status</span><span class="p">)))))))</span><span class="w">
</span></code></pre></div></div>

<p>Когда тест разделяет данные и проверку, его легко поддерживать. Если в API
появятся новые поля, достаточно расширить params-variations, не изменяя тест.</p>

<h3 id="именование">Именование</h3>

<p>Приучите себя к правилу: имя теста всегда начинается с префикса test-. Мы
упоминали, что с точки зрения Clojure это необязательно. Тестовый фремворк
находит тесты по метаданным, а не имени. Поэтому выражения (defn
test-if-suspended [user]) и (deftest if-suspended) останутся функцией и тестом.</p>

<p>Префикс необходим для навигации по коду. В модуле может быть гораздо больше
тестов, чем влезает на экран. Вперемешку с тестами идут вспомогательные
переменные и функции. С ростом модуля станет трудно понять, где функция, а где
тест. С префиксом такой ошибки быть не может.</p>

<p>Emacs предлагает навигацию по коду командой imenu и ее улучшенной версией
helm-imenu. При вызове команды открывается буфер со списком определений. С
вводом текста в буфере останутся только те элементы, имена которых содержат
текст. Называйте определения так, чтобы по команде M-x helm-imenu <RET> test в
списке остались только тесты.</RET></p>

<p>В общем случае имя теста устроено по правилу <code class="language-plaintext highlighter-rouge">test-&lt;what&gt;-&lt;case&gt;</code>, где <code class="language-plaintext highlighter-rouge">&lt;what&gt;</code>
означает что мы тестируем, а <code class="language-plaintext highlighter-rouge">&lt;case&gt;</code> — сценарий. Например,
<code class="language-plaintext highlighter-rouge">test-create-user-ok</code> означает, что это положительный сценарий для создания
пользователя. Имя <code class="language-plaintext highlighter-rouge">test-create-user-bad-params</code> говорит о попытке создать
пользователя с неправильными параметрами. От теста
<code class="language-plaintext highlighter-rouge">test-user-login-signature-expired</code> мы ожидаем, что пользователь не смог
авторизоваться, потому что подпись устарела.</p>

<h2 id="фикстуры">Фикстуры</h2>

<p>До сих пор мы рассматривали простые тесты. Они запускаются в любой момент,
потому что не зависят от сторонних ресурсов. Выдержать это условие удается не
всегда. Чем сложнее код, тем больше у него требований к базе данных, файлам и
сети. Все вместе это называется окружением теста.</p>

<p>В этом разделе мы рассмотрим, как сообщить тесту его окружение. Для этого служат
фикстуры. Термин пришел из промышленности и означает стенд, на котором собирают
и испытывают изделие. В программировании фикстура это объект или функция,
которая работает до или после теста. Фикстура готовит окружение и очищает его.</p>

<p>Перечислим несколько случаев, когда фикстуры полезны.</p>

<p><strong>Файлы на диске.</strong> Код, который мы тестируем, ожидает, что по заданному пути
находится файл с данными. Фикстура копирует файл в нужную папку и по завершению
теста удаляет его. Такой подход гарантирует, что не оставит следов на диске
после работы.</p>

<p><strong>Данные в базе</strong> — частный случай фикстуры по подготовке данных. Например,
чтобы проверить авторизацию, необходимо заранее записать в базу пользователя с
известным паролем. Возможно, понадобятся и другие данные о пользователе: его
профиль или история заказов. Фикстура, которая готовит данные в базе, очищает
таблицы перед записью, чтобы следующий тест не зависел от действий предыдущего.</p>

<p><strong>Запуск и остановка системы.</strong> Иногда фикстуры управляют глобальным состоянием
программы. Например, для интеграционного теста необходимы все компоненты системы
(веб-сервер, база, почта и тд). Логику запуска и остановки системы логично
вынести в фикстуру.</p>

<p>По ходу главы мы рассмотрим эти и другие сценарии, когда прибегают к
фикстурам. Прямо сейчас разберемся, как они устроены технически.</p>

<p>С точки зрения фреймворка фикстура это функция, которая принимает тест. Функция
выполняет любые действия, в том числе вызывает тест. Вопрос в какой момент это
сделать остается на усмотрение разработчика. Например, если фикстура готовит
данные в базе, логично сперва очистить таблицы и выполнить несколько запросов:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgres"</span><span class="w"> </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"book"</span><span class="w">
         </span><span class="c1">;; other JDBC fields go here...</span><span class="w">
         </span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-db-data</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="c1">;; purge</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"truncate users cascade;"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="s">"truncate orders cascade;"</span><span class="p">)</span><span class="w">
  </span><span class="c1">;; write</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="n">user-data</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:profile</span><span class="w"> </span><span class="n">profile-data</span><span class="p">)</span><span class="w">
  </span><span class="c1">;; execute</span><span class="w">
  </span><span class="p">(</span><span class="nf">t</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>В этом примере мы сначала готовим окружение, а затем вызываем тест. Но бывает и
наоборот: тест нуждается в финальных штрихах. Предположим, код из теста пишет
промежуточные файлы на диск. Чтобы очистить папку при выходе из теста, напишем
фикстуру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="ss">'java.io.File</span><span class="w">
        </span><span class="ss">'org.apache.commons.io.FileUtils</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-clear-files</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">FileUtils/cleanDirectory</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="s">"/tmp/tests/reports"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Иногда фикстура сообщает тесту и предварительные, и финальные шаги. В этом
случае вызов (t) располагается где-то посередине.</p>

<p>Надеемся, читатель заметил, что имена фикстур начинаются с префикса fix-. В
отношении фикстур действует то же правило, что и для тестов. Это особые
сущности, поэтому их отделяют префиксом от обычных функций.</p>

<h3 id="регистрация">Регистрация</h3>

<p>Если запустить тест прямо сейчас, фикстура не сработает. Мы только объявили
фикстуру, но не указали фреймворку взять ее в работу. Это делают отдельным шагом
– регистрацией фикстуры. На первый взгляд это выглядит странно. Если фреймворк
сам находит тесты, почему бы ему не искать фикстуры и применять их?</p>

<p>Причина в том, что фикстура может быть запущена на разных этапах
теста. Фреймворк Clojure выделяет стадии :each и :once. Зарегистрировать
фикстуру означает связать ее с одним из этих ключей. Значение :each означает,
что фикстура сработает для каждого теста из текущего пространства. С ключом
:once фикстура выполняется только однажды в рамках пространства.</p>

<p>Одна и та же фикстура может быть :each или :once в зависимости от семантики
теста. Вспомним фикстуру fix-clear-files, которая очищает директорию. Если
каждый тест порождает случайные имена файлов, логично очистить их единоразово в
конце. Это значит, что фикстуру регистрируют с ключом :once. В случае, если
имена файлов одинаковы, возрастает риск их коллизии (чтение файла из другого
теста и тд). Тогда фикстуру связывают с ключом :each.</p>

<p>Другой пример — фикстура базы данных. На время теста она добавляет в таблицы
данные и очищает их. Если точно известно, что тесты только читают данные,
фикстуру регистрируют с :once. Это дает выигрыш в производительности: для
тридцати тестов фикстура сработает единожды. Для тестов на запись важно, чтобы
ни один из них не влиял на другой. Поэтому фикстуру регистрируют с :each. Чтобы
не было коллизий, тесты на чтение и запись разносят по разным модулям.</p>

<p>Функция use-fixtures из пакета clojure.test принимает ключ и переменное число
фикстур:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:once</span><span class="w"> </span><span class="n">fix-db-server</span><span class="w"> </span><span class="n">fix-clear-files</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="n">fix-db-data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Эти выражения обычно ставят в верхней части файла до тестов. Технически они
могут располагаться и в конце. Но чем раньше программист узнает о том, какие
тесты участвуют в тестах, тем лучше.</p>

<h3 id="пример">Пример</h3>

<p>Чтобы лучше понять, в какой момент срабатывает фикстура, добавим в нее побочный
эффект. Функция fix-factory принимает тип фикстуры, ее номер и возвращает
функцию-фикстуру. Такая фикстура обрамляет тест выводом в консоль.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-factory</span><span class="w"> </span><span class="p">[</span><span class="n">type</span><span class="w"> </span><span class="n">number</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s %s starts"</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">number</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s %s ends"</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">number</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Добавим по две фикстуры каждого типа:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:once</span><span class="w">
  </span><span class="p">(</span><span class="nf">fix-factory</span><span class="w"> </span><span class="no">:once</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">fix-factory</span><span class="w"> </span><span class="no">:once</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:each</span><span class="w">
  </span><span class="p">(</span><span class="nf">fix-factory</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">fix-factory</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Если запустить тесты, увидим следующий текст. Фикстуры 1 и 2 типа :once
сработали однажды на границах. Обратите внимание, что в момент завершения из
порядок меняется на противоположный: сначала завершается фикстура 2 и только
потом 1. В нашем модуле 4 теста, поэтому фикстуры 3 и 4 встречаются столько же
раз. Чтобы отобразить процесс наглядней, мы добавили отступы в каждое
сообщение. С ними становится ясна иерархия фикстур.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:once 1 starts
 :once 2 starts
  :each 3 starts   +
   :each 4 starts  | test1
   :each 4 ends    |
  :each 3 ends     +
  :each 3 starts   +
   :each 4 starts  | test2
   :each 4 ends    |
  :each 3 ends     +
  :each 3 starts   +
   :each 4 starts  | test3
   :each 4 ends    |
  :each 3 ends     +
  :each 3 starts   +
   :each 4 starts  | test4
   :each 4 ends    |
  :each 3 ends     +
 :once 2 ends
:once 1 ends
</code></pre></div></div>

<h3 id="на-нижнем-уровне">На нижнем уровне</h3>

<p>Пытливому читателю будет интересно узнать, где лежит информация о
фикстурах. Очевидно, вызов use-fixtures меняет глобальное состояние. Это не атом
и не переменная, а нечто другое, с чем мы еще не работали — метаданные текущего
пространства. Проверим его ключи:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="p">(</span><span class="nb">meta</span><span class="w"> </span><span class="n">*ns*</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="no">:clojure.test/each-fixtures</span><span class="w"> </span><span class="no">:clojure.test/once-fixtures</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Под каждым ключом находится список функций, который мы передали в use-fixtures с
:each или :once. Вызов use-fixtures заменяет в метаданных все фикстуры этого
типа. Важно, что это полная замена, а не запись в конец списка. Например, чтобы
отказаться от всех фикстур типа :each без перезагрузки REPL, запустите
выражение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Другой способ – удалите эту строку и выполните весь буфер целиком. Тогда
определение (ns…) сработает еще раз с новыми метаданными.</p>

<p>Другие языки и фреймворки выделяют еще одну стадию :session. Это когда фикстура
запускается в разрезе всего прогона тестов. Можно сказать, что это
фикстура-синглтон: система гарантирует, что даже для нескольких модулей она
сработает один раз. В Clojure нет такой стадии. Если бы она была, это бы
значило, что несколько пространств связаны друг с другом, что идеологически
неверно. Начинающим на Clojure часто не хватает session-фикстур, но мы научимся
обходиться без них.</p>

<h3 id="связанные-переменные">Связанные переменные</h3>

<p>Особенно выразительны фикстуры в связке с динамическими переменными. Мы
рассматривали их в главе про изменяемость. Напомним, динамические переменные это
формы def с тегом ^:dynamic и <em>ушками</em> по краям имени. Макрос binding выполняет
тело в рамках нового значения этой переменной.</p>

<p>Форма deftest порождает функцию без аргументов; мы не можем сообщить тесту его
параметры как обычной функции. А ведь тесту нужны имена файлов, сессия БД и
многое другое. Чтобы пробросить эти данные, применяют binding-фикстуры. Это
фикстура, которая выполняет тест в теле binding. При этом глобальная переменная
связана с актуальным значением. Сослаться на переменную можно только из теста.</p>

<p>Предположим, мы тестируем функцию, которая принимает путь к файлу и пишет в него
PNG-картинку (карту, график). Объявим фикстуру, которая на время теста свяжет
переменную <em>file</em> с временным файлом. С точки зрения теста <em>file</em> будет
экземпляром java.util.File. При выходе из теста он будет удален, а переменная
восстановится в nil.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defonce</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">*file*</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">with-fix-tmp-file</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="o">^</span><span class="n">File</span><span class="w"> </span><span class="n">tmp-file</span><span class="w"> </span><span class="p">(</span><span class="nf">TmpFile/createFile</span><span class="w"> </span><span class="s">"...."</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*file*</span><span class="w"> </span><span class="n">tmp-file</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">t</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">.delete</span><span class="w"> </span><span class="n">tmp-file</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">use-fixture</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="n">with-fix-tmp-file</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Тест мог бы выглядеть следующим образом. Мы вызываем plot-chart с текущим
временным файлом. Остается проверить, что функция действительно записала в него
PNG-изображение. Класс PngImage предлагает простейший парсер PNG. Мы читаем
разрешение файла, его размер и проверяем их.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="ss">'some.path.PngImage</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-plot-chart-png</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">dataset</span><span class="w"> </span><span class="p">[[</span><span class="n">...</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]]</span><span class="w">
        </span><span class="n">filepath</span><span class="w"> </span><span class="p">(</span><span class="nf">.getAbsPath</span><span class="w"> </span><span class="n">*file*</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">plot-chart</span><span class="w"> </span><span class="n">dataset</span><span class="w"> </span><span class="n">filepath</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">png</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">PngImage</span><span class="w"> </span><span class="n">*file*</span><span class="p">)</span><span class="w">
          </span><span class="n">width</span><span class="w"> </span><span class="p">(</span><span class="nf">.getWidth</span><span class="w"> </span><span class="n">png</span><span class="p">)</span><span class="w">
          </span><span class="n">height</span><span class="w"> </span><span class="p">(</span><span class="nf">.getHeight</span><span class="w"> </span><span class="n">png</span><span class="p">)])</span><span class="w">
    </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[</span><span class="mi">640</span><span class="w"> </span><span class="mi">480</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">width</span><span class="w"> </span><span class="n">height</span><span class="p">]))))</span><span class="w">
</span></code></pre></div></div>

<p>Для полноты картины рассмотрим случай с базой данных. Пусть это будет Cassandra,
а не привычный JDBC-драйвер. Фикстура with-fix-db связывает <em>db</em> с текущей
сессией. Поскольку установка соединения это дорогая операция, вынесем ее в
разовую фикстуру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defonce</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="o">^</span><span class="n">Session</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">with-fix-db</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">cluster</span><span class="w"> </span><span class="n">...</span><span class="w">
        </span><span class="n">session</span><span class="w"> </span><span class="n">...</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*db*</span><span class="w"> </span><span class="n">session</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">t</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="n">session</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="n">cluster</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">use-fixture</span><span class="w"> </span><span class="no">:once</span><span class="w"> </span><span class="n">with-fix-db</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Другая фикстура восстанавливает данные для каждого теста. Фикстуры :once
запускаются раньше, чем :each. Поэтому при подготовке данных мы уже будем внутри
<code class="language-plaintext highlighter-rouge">(binding [*db* ...])</code> из тела with-fix-db. Это значит, фикстура
fix-db-prepare-data свободно обращается к <code class="language-plaintext highlighter-rouge">*db*</code> как к сессии:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-db-prepare-data</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">alia/execute!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="s">"truncate project.users;"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">alia/execute!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="s">"truncate project.orders;"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">alia/execute!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="s">"insert into project.users (name, email) values (%s, %s)"</span><span class="w"> </span><span class="n">user-data</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">t</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">use-fixture</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="n">fix-db-prepare-data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h2 id="мульти-фикстуры">Мульти-фикстуры</h2>

<p>Любопытный вопрос: что произойдет, если фикстура вызывает тест несколько раз?
Например, объявим такую фикстуру:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-multi</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">t</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="n">fix-multi</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>и запустим один тест. С точки зрения фреймворка прошло три теста, о чем написано
в отчете:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>book.util-test: Ran 6 assertions, in 3 test functions. 0 failures, 0 errors.
</code></pre></div></div>

<p>На первый взгляд в этом нет никакого смысла. Многократный прогон теста не несет
пользы, а только потребляет ресурсы и время. (Если же число запусков теста на
что-то влияет, это плохой тест.) Но в паре с динамическими переменными такая
фикстура дает полезный эффект. Один и тот же тест можно запустить в разных
окружениях.</p>

<p>Предположим, наша программа работает с базой данных. В системных требованиях
указано, что это может быть PostgreSQL или MySQL. Мы должны убедиться, что
программа действительно поддерживает обе СУБД. Чтобы не дублировать тесты под
каждый тип базы, эту логику выносят в фикстуру.</p>

<p>Объявим JDBC-подключения к базам данных:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-pg</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgresql"</span><span class="w"> </span><span class="no">:host</span><span class="w"> </span><span class="s">"..."</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-mysql</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"mysql"</span><span class="w"> </span><span class="no">:host</span><span class="w"> </span><span class="s">"..."</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Добавим динамическую переменную <code class="language-plaintext highlighter-rouge">*db*</code>. Новая фикстура перебирает список
подключений и связывает их с <code class="language-plaintext highlighter-rouge">*db*</code> на каждом шаге. Когда переменная связана,
запускается тест. Он зависит от текущего подключения и таким образом обращается
либо в PostgreSQL, либо в MySQL.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defonce</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-multi-db-backend</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="n">db-pg</span><span class="w"> </span><span class="n">db-mysql</span><span class="p">]]</span><span class="w">
    </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*db*</span><span class="w"> </span><span class="n">db</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Testing with DB: %s"</span><span class="w"> </span><span class="p">(</span><span class="no">:dbtype</span><span class="w"> </span><span class="n">*db*</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="nf">t</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что вызов (t) дополнительно обернут в форму testing. В ней мы
указываем тип базы. Если произошла ошибка, нам важно знать, с какой базой мы
работали в тот момент. Пример теста на чтение пользователя:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">test-get-user-by-id</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">com.system.orm/get-user</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}))))</span><span class="w">
</span></code></pre></div></div>

<p>Перечислим другие сценарии для мульти-фикстур. Это может быть запуск
интеграционных тестов в нескольких браузерах (Chrome, Firefox). Или мы хотим
убедиться, что логика не зависит от формата передачи данных (JSON, YAML,
XML). Если программа работает с изображениями, тесты прогоняют на разных типах
файлов (PNG, jpeg) и разрешениях.</p>

<h3 id="минутка-неадекватности">Минутка неадекватности</h3>

<p>(Просим не воспринимать этот раздел слишком серьезно.) Перейдем в другую
крайность: что случится, если фикстура не вызовет тест ни разу? Например:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-mute</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="n">fix-mute</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Это приведет к тому, что ни один тест не будет выполнен. Объясним это на
техническом уровне. Такая фикстура не отменяет тесты, и они по-прежнему видны
тестовому фреймворку. В отчете вы увидите их список, но для каждого будет
указано 0 assertions. Формально мы запустили тест, но его тело так и не
сработало из-за фикстуры fix-mute. Она заглушает любой тест в текущем
пространстве.</p>

<p>Если включить fix-mute и запустить тест из Emacs, мы увидим предупреждение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>No assertions (or no tests) were run.Did you forget to use ‘is’ in your tests?
</code></pre></div></div>

<p>Модуль Cider считает подозрительным, что в тесте не было ни одного is. Это
справедливо: без is тест может подать сигнал об ошибке только исключением, что
ведет к ряду проблем. Исключение и неверный результат это разные
сигналы. Например, функция может давать верный результат, а деление на ноль
происходит только в особых случаях. Если заменить деление на умножение, мы
больше никогда не получим ArithmeticException, но результат будет далек от
истины.</p>

<p>Чтобы обмануть Cider, улучшим фикстуру. Вместо запуска теста добавим в нее is,
который всегда истинен. Даже если тест с ошибками, его тело не сработает, но в
отчете будет как минимум 1 assertion. Назовем такую фикстуру fix-this-is-fine:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-this-is-fine</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="n">true</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="n">fix-this-is-fine</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>С ее помощью мы пройдем тест Оруэлла:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-1984</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">5</span><span class="p">)))</span><span class="w">
</span><span class="c1">;; OK, ran 1 assertions</span><span class="w">
</span></code></pre></div></div>

<p>Задание читателю: напишите фикстуру, которая портит любой тест. Добейтесь, чтобы
100% тестов завершились с ошибкой. Если ваша система версий поддерживает
отложенные коммиты, запланируйте такую фикстуру на 1 апреля.</p>

<p>Теперь вернемся к серьезному повествованию.</p>

<h3 id="фикстуры-с-условиями">Фикстуры с условиями</h3>

<p>Из примеров выше ясно, что фикстура не только вызывает тест, но и несет
дополнительную логику. Обращение к тесту может быть обернуто в цикл, условие или
другую форму. Разберемся с условием. В каких случаях тест ставят под if или when
и какой в этом смысл?</p>

<p>К условной фикстуре прибегают, когда мы не знаем заранее, сможем ли выполнить
этот тест. Например, часть программы не работает на платформе Windows или
Mac. Тогда фикстура проверяет тип операционной системы и не вызывает тест, если
он заведомо не работает.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-mac-only</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getProperty</span><span class="w"> </span><span class="s">"os.name"</span><span class="p">)</span><span class="w"> </span><span class="s">"Mac OS X"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">t</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Эта фикстура выполнит тест только на платформе Mac семейства X. Недостаток в
том, что мы сравниваем конкретные значения в лоб. Это наивный подход. В системах
Windows или Linux имена различаются даже в рамках одного семейства. Чтобы
определить платформу правильно, свойство “os.name” проверяют на вхождение строки
или регулярным выражением.</p>

<p>Доработаем фикстуру: во-первых, сделаем ее подробнее. Обернем тест в форму
testing, чтобы видеть в отчете, в рамках какой ОС был выполнен тест. Если мы не
поддерживаем систему, добавим заведомо ложное утверждение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-mac-only</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">os</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getProperty</span><span class="w"> </span><span class="s">"os.name"</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="s">"Mac OS X"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"OS: %s"</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">t</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">testing</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Unsupported OS: %s"</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="n">false</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Каким способом лучше зарегистрировать фикстуру — :once или :each? Это зависит от
характера условия. В нашем примере тип системы не меняется от теста к тесту,
поэтому условие может быть выполнено лишь однажды (:once). Если же фикстура
проверяет файл на диске, это условие выполняют для каждого теста.</p>

<p>Рассмотрим другие сценарии, когда фикстуры несут условия. Например, это версия
базы данных: если она ниже определенного значения, мы не можем выполнить
тест. Некоторые приложения зависят от системных утилит, которые вызывают в
отдельных процессах. Фикстура определяет, установлена ли такая утилита или
нет. Иногда тест работает с большими файлами. Фикстура проверяет, что на диске
достаточно места до того, как скачать файл с сетевого ресурса.</p>

<h2 id="метки-и-селекторы">Метки и селекторы</h2>

<p>Фикстуры с условиями похожи на систему фильтров. С их помощью запускают не все
тесты, а подмножество, которое подходит текущему окружению. Однако, избегайте
ситуаций, когда фикстуры перегружены условиями сверх меры. Clojure предлагает
особые средства для выборочного прогона. Это метки и селекторы тестов.</p>

<p>Метки устроены проще, чем фикстуры с условием. Это метаданные, которые вы
сообщаете тесту при его описании. Например, тесту ниже</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="o">^</span><span class="no">:special</span><span class="w"> </span><span class="n">test-special-case</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="n">true</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>мы сообщили флаг :special со значением true. Напомним, что выражение ^:field это
сокращенная форма ^{:field true}. Сокращенная форма полезна, чтобы задать
несколько флагов за один раз:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="o">^</span><span class="no">:special</span><span class="w"> </span><span class="o">^</span><span class="no">:backend</span><span class="w"> </span><span class="o">^</span><span class="no">:no-db</span><span class="w">
  </span><span class="n">test-special-case</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="n">true</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Когда тегов два и более, имя теста переносят на следующую строку, чтобы
визуально отделить их.</p>

<p>По такому набору тегов легко догадаться, что это тест на серверную логику
(backend); он не зависит от базы данных (no-db); это какой-то особый тест
(special). Семантика тегов зависит от соглашений в команде. Проверим флаги:
прочитаем метаданные переменной ‘test-special-case. Среди прочих полей вы
найдете special и остальные:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">meta</span><span class="w"> </span><span class="o">#</span><span class="ss">'test-special-case</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:special</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="no">:backend</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="no">:no-db</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="n">...</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Логично, что если тестам назначены теги, можно выбрать подмножество
тестов. Например, только особые (special) или на серверную логику
(backend). Такая выборка называется селектором тестов. Селекторы полезны по
нескольким причинам.</p>

<p>Подмножество тестов отработает быстрее, чем полный набор. Если мы работаем над
задачей и точно знаем, какие тесты она затрагивает, то нет смысла запускать все
доступные тесты. Назначим тег и будем запускать только подмножество. Иногда
окружение разработчика не настроено должным образом, и выполнить тесты целиком
невозможно.</p>

<p>Даже если окружение в порядке, отдельные тесты могут занять много
времени. Например, интеграционный тест длится на порядок дольше модульного и
вдобавок требует инфраструктуру: очередь задач, сторонние API. Поэтому
интеграционные тесты выносят в отдельный шаг Continuous Integration-процесса. В
общих чертах он выглядит так:</p>

<ul>
  <li>запускается минимальное окружение (база данных);</li>
  <li>выполняются модульные тесты (селектор :default);</li>
  <li>если не было ошибок, то запускается дополнительное окружение (Kafka, заглушки
API);</li>
  <li>выполняются интеграционные тесты (селектор :integration).</li>
</ul>

<p>Чем сложнее проект, тем больше в нем тестов и дополнительных шагов по их
запуску.</p>

<p>В тестовом фреймворке Clojure нет селекторов. Он запускает либо один тест, либо
пространство, либо все тесты целиком. Селекторы доступны в сторонних библиотеках
и утилитах. Рассмотрим, как задать их в проекте на базе Leiningen.</p>

<p>Откройте файл project.clj. Внутри defproject добавьте ключ :test-selectors. Это
словарь, где ключ это метка селектора, а значение — функция одного
аргумента. Если при запуске тестов сообщить метку, каждый тест проходит проверку
этой функцией. В нее передают метаданные теста. Если функция вернула ложь или
nil, тест не попадает в набор.</p>

<p>Поскольку кейворд в Clojure это функция, селектором может быть сам тег. Пример
ниже можно прочитать как “набор тестов :special, у которых тег :special”:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:test-selectors</span><span class="w"> </span><span class="p">{</span><span class="no">:special</span><span class="w"> </span><span class="no">:special</span><span class="w">
                 </span><span class="no">:backend</span><span class="w"> </span><span class="no">:backend</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы запустить тесты по селектору, передайте его метку в команду test:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein test :special
</code></pre></div></div>

<p>Если метка не задана, фреймворк назначит ей значение :default. Этому селектору
удовлетворяет любой тест (функция всегда вернет true). Ниже пример из реального
проекта. Для :default мы задали селектор, который вернет все не интеграционные
тесты. Этим мы добьемся того, что команда lein test запустит только модульные
тесты. На случай, когда нужно прогнать весь проект, мы завели метку
:all. Функция identity вернет исходный словарь метаданных, который вырождается в
true.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:test-selectors</span><span class="w"> </span><span class="p">{</span><span class="no">:default</span><span class="w"> </span><span class="p">(</span><span class="nb">complement</span><span class="w"> </span><span class="no">:integration</span><span class="p">)</span><span class="w">
                 </span><span class="no">:integration</span><span class="w"> </span><span class="no">:integration</span><span class="w">
                 </span><span class="no">:all</span><span class="w"> </span><span class="nb">identity</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Селектор может быть и полноценной функцией, а не только ключом. Предположим,
программа должна работать с разными версиями БД, чтобы обеспечить
совместимость. Для каждого теста укажем минимальную версию базы. Это поле
:pg/version и числовое значение. Тогда можно задать селектор так, чтобы выбрать
тесты по версиям. В примере ниже тест, который проверяет экспериментальные
разработки на новой версии базы.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="o">^</span><span class="p">{</span><span class="no">:pg/version</span><span class="w"> </span><span class="mi">11</span><span class="p">}</span><span class="w">
  </span><span class="n">test-db-experimental-feature</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="n">true</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>С точки зрения селектора тест экспериментальный, если поле :pg/version больше
или равно 11:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:test-selectors</span><span class="w">
</span><span class="p">{</span><span class="no">:db-experimental</span><span class="w">
 </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">test-meta</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">test-meta</span><span class="w"> </span><span class="no">:pg/version</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="mi">11</span><span class="p">)))}</span><span class="w">
</span></code></pre></div></div>

<p>Запустите их командой <code class="language-plaintext highlighter-rouge">lein test :db-experimental</code>.</p>

<p>Когда в модуле много тестов, расставлять теги утомительно. Вдобавок повышается
риск забыть тег, и тест выпадет из набора. Если все тесты модуля связаны по
смыслу, тег назначают не тесту, а пространству. С точки зрения lein тест
наследует теги пространства, в котором он объявлен:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="o">^</span><span class="no">:integration</span><span class="w">
  </span><span class="n">book.integration-test</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.test</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="no">:all</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-user-login-ok</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>В примере выше нет смысла указывать ^:integration каждому тесту, поскольку это
сделано на уровне модуля. Селектор интеграционных тестов не изменится: его метка
и функция равны ключу :integration. Тесты запускаются как обычно:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein test :integration
</code></pre></div></div>

<h3 id="тесты-в-depsedn">Тесты в deps.edn</h3>

<p>Не все Clojure-проекты используют lein; некоторые перешли на deps.edn. Это
утилита, разработанная в фирме Cognitect. Основная задача утилиты — управлять
зависимостями проекта. С версии 1.9 deps.edn идет в поставке с Clojure.</p>

<p>Если проект работает на deps, мы теряем часть функциональности lein (в отдельных
случаях их удается скрестить, но об этом в другой раз). В том числе это прогон
тестов, команда lein test. В deps замещают возможности lein сторонними
библиотеками. Проект test-runner это библиотека, которая делает то же самое:
находит тесты, запускает их и выводит отчет.</p>

<p>Чтобы включить библиотеку в проект, добавьте в файл deps.edn новую сущность:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:aliases</span><span class="w">
</span><span class="p">{</span><span class="no">:test</span><span class="w">
 </span><span class="p">{</span><span class="no">:extra-paths</span><span class="w"> </span><span class="p">[</span><span class="s">"test"</span><span class="p">]</span><span class="w">
  </span><span class="no">:extra-deps</span><span class="w"> </span><span class="p">{</span><span class="n">com.cognitect/test-runner</span><span class="w">
               </span><span class="p">{</span><span class="no">:git/url</span><span class="w"> </span><span class="s">"https://github.com/cognitect-labs/test-runner.git"</span><span class="w">
                </span><span class="no">:sha</span><span class="w"> </span><span class="s">"209b64504cb3bd3b99ecfec7937b358a879f55c1"</span><span class="p">}}</span><span class="w">
  </span><span class="no">:main-opts</span><span class="w"> </span><span class="p">[</span><span class="s">"-m"</span><span class="w"> </span><span class="s">"cognitect.test-runner"</span><span class="p">]}}</span><span class="w">
</span></code></pre></div></div>

<p>Объясним этот словарь. Ключ :aliases это примерно то же самое, что профили в
lein: дополнительные опции, которые включаются, если указан этот профиль. Ключ
:extra-paths это список дополнительных путей для поиска файлов с кодом. Поле
:extra-deps указывает зависимости, с которыми запустится проект с этим
профилем. Поскольку test-runner нужен только для тестов, нет смысла вносить его
в глобальные зависимости. В примере выше библиотека скачивается прямиком с
GitHub; поле :sha означает номер коммита. Это коренное отличие deps от lein:
последний скачивает зависимости только из репозиториев (maven, clojars). Ключ
:main-opts задает входную точку программы. Это функция -main из пространства
cognitect.test-runner.</p>

<p>Библиотека предлагает несколько ключей для выборки тестов с логикой “только с
этим тегом” (-i, include, включить ) или “без этого тега” (-e, exclude,
исключить). Команда ниже выполнит все тесты кроме интеграционных:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clj -Atest -e :integration
</code></pre></div></div>

<p>В плане селекторов test-runner устроен проще lein. Он учитывает только
логические теги и не работает со сложным функциями, как мы делали это в lein на
примере версий БД. С другой стороны, test-runner умеет искать пространства по
регулярному выражению (ключ -r, namespace-regex). Например, выражение
#”project.api.\w+-test$” найдет тесты из модулей project.api.users-test,
project.api.tasks-test и так далее.</p>

<h2 id="проблема-окружения">Проблема окружения</h2>

<p>До сих пор мы писали примитивные тесты, которые проверяют вычисления. На
практике вы столкнетесь с проблемой: в обычном коде преобладают не вычисления, а
ввод-вывод данных. Это обращение к сторонним ресурсам: базе данных, очереди
задач, HTTP API. Такой код трудно тестировать по двум причинам.</p>

<p>Во-первых, не всегда возможно настроить локальное окружение. У вас может не быть
ключей доступа или сертификатов. Во-вторых, тесты плохо работают с данными,
которые не контролируют. Например, если тест посылает запросы к стороннему
сервису, то в какой-то момент данные изменятся, и мы получим сломанный билд на
ровном месте.</p>

<p>Чтобы тест зависел от окружения, применяют две техники: моки и стабы. В
следующих разделах мы рассмотрим их устройство, преимущества и недостатки.</p>

<h3 id="моки">Моки</h3>

<p>Мок (анг. mock — ложный, фиктивный) — это объект, который временно заменяет
другой объект. Цель такой подмены в том, чтобы при обращении к объекту сработал
не исходный код, а тот, который нужен именно сейчас. Чаще всего моки накладывают
на методы и функции с доступом в сеть. С их помощью проверяют, как поведет себя
функция при различных сценариях: данные получены, пришел код ошибки, соединение
не удалось.</p>

<p>В ООП-языках моки заменяют не только объект, но и отдельные его поля, методы или
даже класс. В Clojure основной строительный элемент это функция, поэтому ниже мы
рассмотрим, как заменять функции на время тестирования.</p>

<p>Представим, что пишем веб-сервер для мобильного приложения. Его тематика —
развлечение и отдых. На главном экране пользователь видит карту, на которую
нанесены кафе, рестораны и ближайшие события: фильмы, выставки,
фестивали. Сервер работает по протоколу HTTP/JSON API. Данные для главного
экрана возвращает функция view-main-page. Она извлекает из запроса координаты
пользователя, собирает сведения о местах общепита и событиях и отсылает
мобильному приложению:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">book.views</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clj-http.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">client</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">view-main-page</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">location</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:params</span><span class="w"> </span><span class="p">(</span><span class="nb">select-keys</span><span class="w"> </span><span class="p">[</span><span class="no">:lat</span><span class="w"> </span><span class="no">:lon</span><span class="p">]))</span><span class="w">
        </span><span class="n">sites</span><span class="w"> </span><span class="p">(</span><span class="nf">get-sites-by-location</span><span class="w"> </span><span class="n">location</span><span class="p">)</span><span class="w">
        </span><span class="n">events</span><span class="w"> </span><span class="p">(</span><span class="nf">get-events-by-location</span><span class="w"> </span><span class="n">location</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:sites</span><span class="w"> </span><span class="n">sites</span><span class="w"> </span><span class="no">:events</span><span class="w"> </span><span class="n">events</span><span class="p">}}))</span><span class="w">
</span></code></pre></div></div>

<p>Проблема в том, что у сервера нет этих данных. Мы извлекаем из сторонних
сервисов, например, условных Яндекс.Карт и Яндекс.Афиши. Функции get-sites… и
get-events… общаются с ними по протоколу HTTP. Вот так может выглядеть функция
get-sites-by-location для поиска кафе и ресторанов в радиусе 300 метров:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-sites-by-location</span><span class="w">
  </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">lat</span><span class="w"> </span><span class="n">lon</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:method</span><span class="w"> </span><span class="no">:get</span><span class="w">
       </span><span class="no">:url</span><span class="w"> </span><span class="s">"https://maps.yandex.ru/search/v1/"</span><span class="w">
       </span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="w">
       </span><span class="no">:query-params</span><span class="w"> </span><span class="p">{</span><span class="no">:apikey</span><span class="w"> </span><span class="s">"....."</span><span class="w">
                      </span><span class="no">:lat</span><span class="w"> </span><span class="n">lat</span><span class="w"> </span><span class="no">:lon</span><span class="w"> </span><span class="n">lon</span><span class="w"> </span><span class="no">:distance</span><span class="w"> </span><span class="mi">300</span><span class="w">
                      </span><span class="no">:type</span><span class="w"> </span><span class="s">"cafe,restaurant"</span><span class="p">}}</span><span class="w">
      </span><span class="n">client/request</span><span class="w">
      </span><span class="no">:body</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Функция get-events-by-location для поиска мероприятий аналогична первой. Разница
лишь в URL-адресе (не maps.yandex.ru, a events.yandex.ru) и query-параметрах.</p>

<p>Очевидно, view-main-page совершает два сетевых вызова, что затрудняет ее
тестирование. Это значит, нам нужно два API-ключа; если запускать тесты часто,
мы исчерпаем квоты на число запросов. Поскольку мы получим настоящие, живые
данные, мы не можем быть уверены в их надежности (завтра в этом месте откроется
новое кафе или закроется старое). Решим эту проблему моками.</p>

<p>В главе про изменяемость мы работали с макросом with-redefs. Он заменяет
переменную по ее пути на что-то другое. Простейший мок — это подмена функции с
сетевым вызовом на анонимную функцию, которая возвращает заведомо известный
результат. Напомним, что получить функцию из результата можно с помощью формы
constantly.</p>

<p>Напишем тест главного экрана с двумя моками. Данные моков удобно вынести в
отдельные переменные в let. Важно, что view-main-page должна быть выполнена
внутри with-redefs, иначе эффект моков теряется.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-main-page</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">sites</span><span class="w"> </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Cafe1"</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Cafe2"</span><span class="p">}]</span><span class="w">
        </span><span class="n">events</span><span class="w"> </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Event1"</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Event2"</span><span class="p">}]]</span><span class="w">
    </span><span class="p">(</span><span class="nf">with-redefs</span><span class="w">
      </span><span class="p">[</span><span class="n">book.views/get-sites-by-location</span><span class="w"> </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="n">sites</span><span class="p">)</span><span class="w">
       </span><span class="n">book.views/get-events-by-location</span><span class="w"> </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="n">events</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">{</span><span class="no">:lat</span><span class="w"> </span><span class="mf">55.751244</span><span class="w">
                              </span><span class="no">:lon</span><span class="w"> </span><span class="mf">37.618423</span><span class="p">}}</span><span class="w">
            </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">view-main-page</span><span class="w"> </span><span class="n">request</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="no">:body</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w">
               </span><span class="p">{</span><span class="no">:sites</span><span class="w"> </span><span class="n">sites</span><span class="w"> </span><span class="no">:events</span><span class="w"> </span><span class="n">events</span><span class="p">}))))))</span><span class="w">
</span></code></pre></div></div>

<p>С этим подходом мы избежали похода в сеть. Тест не зависит от API-ключей, прав
доступа и новых заведений. Можно запустить его в любое время дня и ночи, и
результат будет одинаковым. Теперь рассмотрим, как улучшить этот тест.</p>

<h3 id="вынести-данные-в-файл">Вынести данные в файл</h3>

<p>Переменные sites и events, которые мы якобы получили от сторонних сервисов,
крайне скудны. Будет правильным сообщить им данные, скопированные из реального
источника, например, десять ресторанов и семь мероприятий. Чтобы не засорять код
огромными массивами данных, поместите их в .json-файлы в папку с
ресурсами. Считайте их один раз на уровне модуля в переменную:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data-events</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"data/events.json"</span><span class="w">
      </span><span class="n">clojure.java.io/resource</span><span class="w">
      </span><span class="nb">slurp</span><span class="w">
      </span><span class="p">(</span><span class="nf">cheshire.core/parse-string</span><span class="w"> </span><span class="n">true</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>В промышленном запуске функция get-sites-by-location устроена сложнее, чем в
нашем примере. Скорее всего, данные от сервиса карт придется обработать согласно
бизнес-логике нашего приложения. Например, отбросить заведения с низкой оценкой
и те, что сейчас закрыты. Это логику можно проверить тестом: добавить в
json-файл заведение с низким рейтингом и убедиться, что его нет в ответе.</p>

<h3 id="перенести-мок-в-фикстуру">Перенести мок в фикстуру</h3>

<p>Если требуется больше одного теста на главный экран, оборачивать каждый из них в
with-redefs будет утомительно. Логично вынести мок в фикстуру. Тем самым мы
снизим число повторов в коде, а другие тесты смогут ее переиспользовать:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-mock-main-view</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-redefs</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">t</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="n">fix-mock-main-view</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Недостаток фикстуры в том, что для всех тестов она устанавливает позитивный
сценарий (обе функции сработали без ошибок). Для полноты картины мы должны
проверить, что случится, если сервисы недоступны. Об этом — в следующем пункте.</p>

<h3 id="негативные-сценарии">Негативные сценарии</h3>

<p>Недоступность одного сервиса не должна влиять на работу приложения в целом. Если
возникла накладка с кафе, пользователь все равно должен увидеть мероприятия и
наоборот. Возможно, он даже не заметит проблемы: если ответ не был получен,
приложение покажет старые данные.</p>

<p>Чтобы проверить главный экран на устойчивость, необходимы негативные сценарии:</p>

<ul>
  <li>получили кафе, но не мероприятия;</li>
  <li>наоборот: с кафе все в порядке, ошибка с мероприятиями;</li>
  <li>не работают оба сервиса.</li>
</ul>

<p>Кроме того, под общими словами “не работают” имеют в виду варианты:</p>

<ul>
  <li>проблемы доступа или квот: статусы 403 и 429;</li>
  <li>недоступность сервиса: статусы 500 и 503;</li>
  <li>проблемы связи: исключение по таймауту и поиску хоста.</li>
</ul>

<p>Чтобы сократить код с with-redefs, напишем его краткую версию. Макрос with-mock
принимает путь к функции, результат функции-мока и произвольное тело.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-mock</span><span class="w">
  </span><span class="p">[</span><span class="nb">path</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nf">with-redefs</span><span class="w">
     </span><span class="p">[</span><span class="o">~</span><span class="nb">path</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="ss">'_</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="n">result</span><span class="p">)]</span><span class="w">
     </span><span class="o">~@</span><span class="n">body</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Важный момент: для замены path мы создаем анонимную функцию с помощью fn, а не
constantly. Иначе невозможно смоделировать выброс исключения. Поскольку
constantly это функция, ее аргументы вычисляются до того, как она
сработает. Поэтому выражение</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="s">"error"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>бросит исключение еще на этапе связывания.</p>

<p>С помощью with-mock мы собираем комбинации успехов и неудач. Тест ниже проверяет
сценарий, когда сервис карт сработал без ошибок, а с мероприятиями что-то пошло
не так. Если запустить тест, окажется, что test-main-page не отлавливает
исключения. Это значит, пользователь не увидит ничего.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-sites-ok-events-err</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-mock</span><span class="w"> </span><span class="n">book.views/get-sites-by-location</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">with-mock</span><span class="w"> </span><span class="n">book.views/get-events-by-location</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.net.UnknownHostException</span><span class="w"> </span><span class="s">"DNS error"</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">response</span><span class="w"> </span><span class="p">(</span><span class="nf">view-main-page</span><span class="w"> </span><span class="p">{})]</span><span class="w">
        </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="no">:body</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">})))))</span><span class="w">
</span></code></pre></div></div>

<p>Доработайте view-main-page так, чтобы тест увидел ответ со статусом 200 и полем
:sites. Добавьте тесты с другими комбинациями: ошибка соединения в get-sites,
статусы 403 и 500, недоступность сразу двух сервисов.</p>

<h3 id="сбор-данных">Сбор данных</h3>

<p>Не заглядывая в конец главы, подумайте, как организовать мок промышленного
уровня. Такой мок не только возвращает результат, но и:</p>

<ul>
  <li>считает, сколько раз его вызвали;</li>
  <li>запоминает аргументы каждого вызова;</li>
  <li>принимает список результатов и возвращает их поочередно, например, в первый и
второй раз словари, а на третий раз исключение;</li>
  <li>предлагает удобный доступ к этим данным.</li>
</ul>

<p>Моки с такими возможностями следят за особой логикой программы. Например, поиск
ресторанов вернет только базовые сведения о них. Чтобы получить детальную
информацию о заведении, придется слать отдельный запрос к сервису карт. Чтобы
сетевой трафик не рос линейно, мы извлекаем данные только для трех лучших
ресторанов. Продвинутый мок для условной функции get-site-details проверяет, что
ее вызвали не более трех раз. В конце главы мы рассмотрим продвинутые решения
для мокинга в Clojure.</p>

<h3 id="недостатки">Недостатки</h3>

<p>На первый взгляд кажется, что моки решили проблему окружения. Теперь тесты
автономны и не зависят от сторонних сервисов. Но есть у моков и недостатки;
перечислим основные из них.</p>

<p>Мок нарушает принцип закрытости (черного ящика). При написании теста мы
подглядываем в исходный код, чтобы узнать, какие функции подменить. Это не
критично, но чем меньше тест знает о коде, который тестирует, тем он надежней.</p>

<p>Мок исключает сетевое взаимодействие, что иногда выходит боком. Передача данных
по HTTP это многоступенчатый процесс, где на каждом участке может возникнуть
ошибка. Подмена HTTP-запроса на чистую функцию это грубое приближение. С его
помощью нельзя предугадать все возможные ошибки.</p>

<p>Наконец, мок повышает связанность тестов с логикой. Если переименовать функцию
get-sites-by-location, форма (with-redefs…) перестанет работать. Косметические
исправления в коде повлекут правки в тестах, что неудобно и неверно
идеологически.</p>

<p>Эти проблемы решают стабы, о которых речь в следующем разделе.</p>

<h3 id="стабы">Стабы</h3>

<p>Стаб (анг. stub, заглушка) — это сущность, которая заменяет объект или часть
системы на время тестов. От моков она отличается тем, что тест не может ей
управлять. Если в тестах с моками мы сами указываем что и чем заменить, то стаб
это черный ящик с точки зрения теста.</p>

<p>Удачный пример стаба это локальный HTTP-сервер, имитирующий сторонний сервис,
например, поиск мест на карте. Такой сервер запущен на порту 8808 и по адресу
<code class="language-plaintext highlighter-rouge">/search/v1/</code> возвращает JSON-данные, которые мы взяли из настоящего
источника. Теперь мы не будем мокать функцию get-sites-by-location. Изменим ее
так, чтобы поле :url запроса указывало не на <code class="language-plaintext highlighter-rouge">https://maps.yandex.ru/</code>, а на
<code class="language-plaintext highlighter-rouge">http://127.0.0.1:8808/</code>. Если запустить тест, функция выполнит запрос к
локальному серверу и прочитает его ответ.</p>

<p>Подход со стабами несет колоссальное преимущество. Легко увидеть, что стаб
сводит к нулю зависимость теста от логики. Теперь тест ничего не знает о
функциях приложения; ему и не положено это знать. От нас требуется только
перенацелить запросы на другой адрес. Это вопрос конфигурации, а в логике
программы ничего не меняется.</p>

<p>Другое достоинство в том, что во время теста происходит настоящий обмен данными
по сети. Да, это локальный хост без зашифрованного соединения и проверки
сертификатов. Но основная часть HTTP-взаимодействия протекает так же, как и в
промышленном запуске. Это разбор заголовков, чтение и парсинг JSON-данных,
логика на базе статуса ответа.</p>

<p>Локальные сервера-заглушки еще называют фейки (анг. fake, подделка). С помощью
фейка программист моделирует нештатное поведение сервера. Например, ситуацию,
когда в ответе не JSON-данные, а просто текст. Или когда сервер принимает
соединение, но не отвечает. Или полную недоступность сервера, когда мы выключаем
его перед тестом.</p>

<p>Достичь таких эффектов моком невозможно. С его помощью мы можем только кидать
исключения, которые, согласно документации, бросает настоящий HTTP-клиент. Но
тесты на исключениях хрупки и далеки от реального положения дел.</p>

<p>С технической стороны стаб это фикстура. До запуска теста она включает сервер, а
после выключает его. Сервер это Jetty или другой адаптер для Ring-обработчика
запроса. Мы подробно рассмотрели Ring и Jetty в главе про веб-разработку. Напишем
фикстуру для фейкового сервера карт.</p>

<p>В блок require добавим зависимости:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ring.middleware.json</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-json-response</span><span class="p">]]</span><span class="w">
</span><span class="p">[</span><span class="n">ring.middleware.params</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-params</span><span class="p">]]</span><span class="w">
</span><span class="p">[</span><span class="n">ring.middleware.keyword-params</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-keyword-params</span><span class="p">]]</span><span class="w">
</span><span class="p">[</span><span class="n">ring.adapter.jetty</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">run-jetty</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>Напишем обработчик запроса. Это функция, которая принимает запрос. Для пути
search/v1 она возвращает JSON-данные, для всего остального ответ 404:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">sites-handler*</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">uri</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">uri</span><span class="w">
    </span><span class="s">"/search/v1/"</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Cafe1"</span><span class="w"> </span><span class="no">:address</span><span class="w"> </span><span class="s">"..."</span><span class="p">}</span><span class="w">
            </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Cafe2"</span><span class="w"> </span><span class="no">:address</span><span class="w"> </span><span class="s">"..."</span><span class="p">}]}</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="s">"page not found"</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>Обернем функцию в набор middleware. Во-первых, мы хотим, чтобы тело-коллекция
приводилось к JSON автоматически. Во-вторых, позже нам понадобятся параметры
строки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">sites-handler</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">sites-handler*</span><span class="w">
      </span><span class="n">wrap-keyword-params</span><span class="w">
      </span><span class="n">wrap-params</span><span class="w">
      </span><span class="n">wrap-json-response</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Напишем и подключим фикстуру. Сервер не меняет состояние от теста к тесту (мы
только читаем данные), поэтому фикстура срабатывает один раз (ключ :once):</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-fake-sites-server</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">opt</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8808</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}</span><span class="w">
        </span><span class="n">server</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">sites-handler</span><span class="w"> </span><span class="n">opt</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">use-fixtures</span><span class="w"> </span><span class="no">:once</span><span class="w"> </span><span class="n">fix-fake-sites-server</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Исправим функцию get-sites-by-location так, чтобы клиент обращался к локальному
хосту. Очевидно, базовый URL сервиса приходит из конфигурации. Вы уже знаете,
как устроена конфигурация из предыдущих глав, поэтому весь код приводить мы не
будем. Для краткости представим, что глобальная переменная config это словарь
параметров. Тогда полный URL для сервиса карт формируется так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:url</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="no">:maps-base-url</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="s">"/search/v1/"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Напишем тест главного экрана. На этот раз нам не нужны моки, поэтому тест
сводится к вызову view-main-page. Прямо сейчас тест не пройдет, потому что мы
решили проблему только с поиском заведений. Поиск событий по-прежнему обращается
к чужому серверу. Чтобы убедиться, что стаб работает нормально, на время
закомментируем вызов get-events-by-location, а поле :events сделаем nil. После
этого тест сработает без ошибок: в поле :sites ответа окажутся данные, что
возвращает стаб.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-main-page</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">{</span><span class="no">:lat</span><span class="w"> </span><span class="mf">55.751244</span><span class="w">
                          </span><span class="no">:lon</span><span class="w"> </span><span class="mf">37.618423</span><span class="p">}}</span><span class="w">
        </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">view-main-page</span><span class="w"> </span><span class="n">request</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="no">:body</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="no">:sites</span><span class="w"> </span><span class="p">[</span><span class="n">...</span><span class="p">]</span><span class="w"> </span><span class="no">:events</span><span class="w"> </span><span class="n">nil</span><span class="p">}))))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь верните все как было и напишите похожую заглушку для поиска
событий. Оформите ее в фикстуру и убедитесь, что тест проходит. Это задание для
самостоятельной работы. Далее мы рассмотрим, что еще интересного предлагают
стабы.</p>

<p>Как и в случае с моками, удобно, когда данные лежат в файлах. Чтобы фейковый
сервер читал файл, измените ответ следующим образом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
 </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"data/events.json"</span><span class="w">
           </span><span class="n">clojure.java.io/resource</span><span class="w">
           </span><span class="n">clojure.java.io/file</span><span class="p">)}</span><span class="w">
</span></code></pre></div></div>

<p>В файл resources/data/events.json запишите ответ реального сервера.</p>

<p>На текущий момент стаб всегда возвращает успешный ответ. Расширим его логику:
сделаем так, чтобы при особых условиях мы получали негативные ответы. Проще
всего это сделать в зависимости от входных параметров. Договоримся, что
некоторые координаты, которые передает пользователь, особые. Например, для пары
0,0 сервер вернет пустой результат; при 66,66 получим ошибку доступа. С
координатами 42,42 сервер отвечает с задержкой в 35 секунд, что больше
стандартного ожидания в 30 секунд. Усложним <code class="language-plaintext highlighter-rouge">sites-handler*</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">sites-handler*</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">uri</span><span class="w"> </span><span class="n">params</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">lat</span><span class="w"> </span><span class="n">lon</span><span class="p">]}</span><span class="w"> </span><span class="n">params</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">uri</span><span class="w">
      </span><span class="s">"/search/v1/"</span><span class="w">
      </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="p">[</span><span class="n">lat</span><span class="w"> </span><span class="n">lon</span><span class="p">]</span><span class="w">
        </span><span class="p">[</span><span class="s">"0"</span><span class="w"> </span><span class="s">"0"</span><span class="p">]</span><span class="w">   </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="p">[]}</span><span class="w">
        </span><span class="p">[</span><span class="s">"66"</span><span class="w"> </span><span class="s">"66"</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">403</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:error</span><span class="w"> </span><span class="s">"ACCESS_ERROR"</span><span class="p">}}</span><span class="w">
        </span><span class="p">[</span><span class="s">"42"</span><span class="w"> </span><span class="s">"42"</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="mi">35</span><span class="p">))</span><span class="w">
                        </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="p">[]})</span><span class="w">
        </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
         </span><span class="no">:body</span><span class="w"> </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Cafe1"</span><span class="w"> </span><span class="no">:address</span><span class="w"> </span><span class="s">"..."</span><span class="p">}</span><span class="w">
                </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Cafe2"</span><span class="w"> </span><span class="no">:address</span><span class="w"> </span><span class="s">"..."</span><span class="p">}]})</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="s">"page not found"</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь напишите тесты для этих координат. Особенно интересен случай с долгим
ответом (пара 42). Мы должны убедиться, что если сервис карт не отвечает, мы
ждем какое-то разумное время, а не стандартные 30 секунд. Передайте в параметры
<code class="language-plaintext highlighter-rouge">(client/get)</code> поля <code class="language-plaintext highlighter-rouge">:socket-timeout</code> и <code class="language-plaintext highlighter-rouge">:connection-timeout</code> значения 5000, что
равно пяти секундам. Этого ожидания достаточно для промышленного
запуска. Замерьте время выполнения view-main-page. Добавьте в тест утверждение
is, что ожидание не превышает 5 секунд с небольшой погрешностью.</p>

<p>Можно добавить тест для экстремального случая: что произойдет, если сервер
физически недоступен. Чтобы смоделировать эту ситуацию, фикстура должна
предоставить доступ к переменной server. Проще всего это сделать через
динамическую переменную:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defonce</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">*server*</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fix-fake-sites-server</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">opt</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8808</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}]</span><span class="w">
    </span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">*server*</span><span class="w"> </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">sites-handler</span><span class="w"> </span><span class="n">opt</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">t</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">*server*</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Напишем тест, в котором мы временно отключим сервер. Обратите внимание, что в
конце его нужно включить, иначе мы испортим все следующие тесты.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-the-website-is-down</span><span class="w">
  </span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">*server*</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">{</span><span class="no">:lat</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:lon</span><span class="w"> </span><span class="mi">2</span><span class="p">}}</span><span class="w">
        </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">view-main-page</span><span class="w"> </span><span class="n">request</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="no">:body</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">...</span><span class="p">})))</span><span class="w">
  </span><span class="p">(</span><span class="nf">.start</span><span class="w"> </span><span class="n">*server*</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Сейчас тест не сработает из-за ошибки “Connection refused”. Доработайте логику
так, чтобы пользователю ушел пустой результат.</p>

<h3 id="ресурсы-и-пути">Ресурсы и пути</h3>

<p>Выше мы упомянули, что данные для моков или стабов хранят в файлах. Так мы не
загромождаем код объемными списками и словарями. Файлы в папке resources
называются ресурсами приложения и играют особую роль: при сборке jar-файла они
становятся его частью. Код, запущенный из jar получает доступ к той его части,
где располагаются ресурсы. С точки зрения системы это один файл, а изнутри JVM
нам доступны все те файлы, что были в resources на этапе сборки.</p>

<p>В одном из примеров мы поместили файл events.json в папку resources/data и
читали его как ресурс. Недостаток в том, что эти данные нужны только для
тестов. Если собрать проект, events.json станет частью выходного jar-файла. Это
напрасно увеличит его объем.</p>

<p>Чтобы отбросить лишние ресурсы при сборке, в проекте настраивают
:resource-paths. Это поле-список, в котором перечислены возможные пути поиска
ресурсов. По умолчанию оно равно вектору [“resources”]. При объединении профилей
вектора соединяются в один. Если другой профиль задал ресурсы иначе:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:resource-paths</span><span class="w"> </span><span class="p">[</span><span class="s">"resources_test"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>то в итоге программа будет искать их в папках resources и resources_test. Во
время финальной сборки оставим только resources, чтобы не вбирать в jar ресурсы
для тестов.</p>

<p>Заметим, что путь resources_test выбран неудачно. Существует другой, более
удобный способ связать файловую систему и окружение. Это так называемая
env-директория, о которой мы говорили в главе про изменяемость. На ее первом
уровне находятся папки с именами профилей, а внутри src и resources с кодом и
ресурсами. Эти пути задают профилям в описании проекта.</p>

<p>Создайте нужные пути и переместите данные для теста:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p env/test/resources/data
mv resources/data/events.json env/test/resources/data/
rm -rf resources/data
</code></pre></div></div>

<p>В настройках проекта задайте профили и их пути к ресурсам:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:profiles</span><span class="w"> </span><span class="p">{</span><span class="no">:test</span><span class="w"> </span><span class="p">{</span><span class="no">:resource-paths</span><span class="w"> </span><span class="p">[</span><span class="s">"env/test/resources"</span><span class="p">]}</span><span class="w">
           </span><span class="no">:dev</span><span class="w">  </span><span class="p">{</span><span class="no">:resource-paths</span><span class="w"> </span><span class="p">[</span><span class="s">"env/test/resources"</span><span class="p">]}}</span><span class="w">
</span></code></pre></div></div>

<p>На первый взгляд странно, что для :dev и :test мы указали один и тот же
путь. Это потому, что по умолчанию сеанс REPL запускается с профилем dev, но не
test. В режиме разработки у нас не будет доступа к ресурсам из env/test. Это
влечет неудобства: например, мы исправили код и тут же вызвали тест из REPL, но
он не проходит из-за неверных путей. Проблему решают двумя способами.</p>

<p>Первый — запускают REPL с ключом <code class="language-plaintext highlighter-rouge">with-profile +test</code>, что значить добавить к
профилю по умолчанию test. Знак плюса означает выполнить слияние; без него
стандартный профиль будет отброшен. Второй способ, который мы уже рассмотрели —
продублировать пути из test в dev.</p>

<p>В обоих случаях выражение</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">data-events</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"data/events.json"</span><span class="w">
      </span><span class="n">clojure.java.io/resource</span><span class="w">
      </span><span class="nb">slurp</span><span class="w">
      </span><span class="p">(</span><span class="nf">cheshire.core/parse-string</span><span class="w"> </span><span class="n">true</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>будет работать одинаково. Физически вы переместили файл с данными, но с точки
зрения JVM это один и тот же ресурс.</p>

<p>Особо любознательным предлагаем эксперимент. Скомпилируйте uberjar с разными
ресурсами: в первый раз как обычно, а во второй опцией :resource-paths:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">:profiles</span><span class="w"> </span><span class="p">{</span><span class="no">:uberjar</span><span class="w"> </span><span class="p">{</span><span class="no">:resource-paths</span><span class="w"> </span><span class="p">[</span><span class="s">"env/test/resources"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Перед второй сборкой скопируйте файл target/uberjar/<project>.jar в другую
папку, чтобы не затереть его. Распакуйте оба архива командой jar:</project></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jar xf &lt;project&gt;.jar
</code></pre></div></div>

<p>Среди файлов из второго архива вы найдете data/events.json. Убедитесь, что его
нет в первом случае. Очевидно, если вы распространяете программу в виде
jar-архива, любой желающий может распаковать его. Поэтому в ресурсах не должно
быть приватных данных, например, конфигурации с паролями и ключами. Это касается
и данных для тестирования — включать их в jar будет ошибкой.</p>

<p>Пользуясь случаем, исследуйте другие файлы, которые вы получили из jar, их
структуру и содержимое.</p>

<h3 id="база-данных">База данных</h3>

<p>При написании тестов вы столкнетесь с проблемой. Почти каждое действие требует,
чтобы в базе были определенные данные. Например, для создания пользователя нужна
учетка администратора. Чтобы добавить пользователя в группу, нужна эта
группа. Чтобы оформить заказ, нужны товары, история покупок для расчета скидки и
многое другое. Чем шире логика приложения, тем больше понадобится тестовых
данных.</p>

<p>Если каждый тест создает данные под себя, у вас возникнут проблемы с поддержкой
таких тестов. Очевидно, требуется единая точка входа, такая, чтобы каждый тест
имел доступ к одинаковым данным. В идеале они заданы декларативно в файле. Чтобы
добавить новые записи, мы должны исправить проект только в одном месте. Когда
тесты закончились, все, что мы записали в базу, бесследно исчезает. Недопустимо,
чтобы один тест зависел от изменений, выполненных в другом тесте.</p>

<p>В этом разделе мы рассмотрим, как работать с базой во время тестов. Начнем с
первого шага — подготовки новой базы. Под этим мы понимаем создание всех таблиц,
индексов и других сущностей без вставки данных.</p>

<p>Физически базу создают еще до того, как запустились тесты. Способ зависит от
того, как работает база: локально или в Докере. Если локально, достаточно
вызвать несколько утилит. В примере ниже createuser и createdb входят в поставку
PostgreSQL.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>createuser book_test -S -W
createdb -O book_test book_test
</code></pre></div></div>

<p>Первая команда создает нового пользователя БД с именем book_test. Ключ -S
означает, что это суперпользователь, т.е. обладатель высших
привилегий. Супердоступ необходим, чтобы подключать расширения: триграммный
поиск, прогрев индексов и другие. В промышленном запуске, наоборот, приложению
выделяют минимальные права, но для тестов это неважно. Вторая команда создает
одноименную пустую базу. Ключ -O (owner) задает владельца базы. Владелец имеет
полный доступ ко всем ее сущностям.</p>

<p>Если база работает в Докере, обратитесь к главе про системы. В одноименном
разделе мы рассмотрели, как задать параметры базы в .yaml-файле и переменными
среды.</p>

<p>Пустую базу наполняют таблицами. Если приложение поддерживает миграции,
например, с помощью библиотек migratus или ragtime, их запускают до тестов из
командной строки:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein migratus migrate
lein test
</code></pre></div></div>

<p>Шага с миграциями можно избежать, если скопировать их в папку Докер-образа
/docker-entrypoint-initdb.d. Специальный скрипт выполнит все sql-файлы из этой
папки на старте образа. Убедитесь, что скопировали только up-миграции, иначе их
down-версии сведут пользу на нет.</p>

<p>К этому моменту в базе уже созданы таблицы и индексы, но нет данных. Мы
переходим к основной задаче: перечислим способы их вставки и очистки во время
тестов.</p>

<p><strong>Ручная вставка</strong></p>

<p>В простейшем случае данные для базы хранят в виде коллекции. Специальная функция
пробегает по списку словарей; каждый словарь это запись в базе. Функцию
оборачивают в фикстуру, которая запускает тест после вставки всех записей.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-data</span><span class="w">
  </span><span class="p">[[</span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"ivan@test.com"</span><span class="p">}]</span><span class="w">
   </span><span class="p">[</span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Juan"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"Juan@test.com"</span><span class="p">}]</span><span class="w">
   </span><span class="p">[</span><span class="no">:groups</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Dog fans"</span><span class="w"> </span><span class="no">:topics</span><span class="w"> </span><span class="mi">6</span><span class="p">}]</span><span class="w">
   </span><span class="p">[</span><span class="no">:groups</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Cat fans"</span><span class="w"> </span><span class="no">:topics</span><span class="w"> </span><span class="mi">7</span><span class="p">}]])</span><span class="w">
</span></code></pre></div></div>

<p>Здесь и ниже мы полагаем, что глобальная переменная <code class="language-plaintext highlighter-rouge">*db*</code> указывает на
JDBC-спеку. Мы не будем задаваться вопросом, откуда пришла эта
переменная. Читатель уже знаком с системами и конфигурацией и вправе задать
<code class="language-plaintext highlighter-rouge">*db*</code> так, как это удобно в проекте.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">load-data</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[[</span><span class="n">table</span><span class="w"> </span><span class="n">row</span><span class="p">]</span><span class="w"> </span><span class="n">db-data</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">row</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">with-db-data</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">load-data</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">t</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что для каждой записи нужно знать ее таблицу. Это может быть элемент
пары или поле метаданных. Когда записей одного типа много, имя таблицы
становится избыточным. Логично сгруппировать записи по таблицам и вставлять их
не по одной, а разом, что быстрее.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-data</span><span class="w">
  </span><span class="p">[[</span><span class="no">:users</span><span class="w"> </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"ivan@test.com"</span><span class="p">}</span><span class="w">
            </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Juan"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"Juan@test.com"</span><span class="p">}]]</span><span class="w">
   </span><span class="p">[</span><span class="no">:groups</span><span class="w"> </span><span class="p">[{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Dog fans"</span><span class="w"> </span><span class="no">:topics</span><span class="w"> </span><span class="mi">6</span><span class="p">}</span><span class="w">
             </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Cat fans"</span><span class="w"> </span><span class="no">:topics</span><span class="w"> </span><span class="mi">7</span><span class="p">}]]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">load-data</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[[</span><span class="n">table</span><span class="w"> </span><span class="n">rows</span><span class="p">]</span><span class="w"> </span><span class="n">db-data</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/insert-multi!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">rows</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><strong>Вставка из CSV</strong></p>

<p>Иногда записей бывает так много, что хранить их в виде словарей
затруднительно. В этом случае поможет формат CSV. Это файл с текстом, где каждая
строка означает запись, а поля разделены запятой. В первой строке обычно
размещают заголовок — имена полей с тем же разделителем.</p>

<p>У CSV несколько преимуществ. Записи в нем это массивы, а не словари, поэтому они
не дублируют имена полей. В целом CSV компактней JSON и аналогов. С ним работают
табличные редакторы, например Excel и OpenOffice. Это значит, всегда можно
открыть CSV как лист ячеек, добавить или удалить столбец, пересчитать ячейки по
формуле и сохранить результат.</p>

<p>Наконец, отдельные базы данных читают и пишут CSV напрямую. Чтобы получить
данные из определенной таблицы с прода, выборку из нее пишут в CSV, а из него
восстанавливают в локальную базу. На больших объемах вставка из CSV работает
быстрее, чем обычный INSERT.</p>

<p>Предположим, нам скинули данные о пользователях с прода в CSV-файле. Вот
несколько его первых строк:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name,email
ivan,ivan@test.me
juan,juan@example.com
ioan,ioan@dunno.org
</code></pre></div></div>

<p>Данные для тестов это ресурс, сохраним его по адресу
<code class="language-plaintext highlighter-rouge">env/test/resources/data/users.csv</code>, как делали это раньше. Есть два способа
поместить данные из него в таблицу: запросом и кодом. Рассмотрим оба из них.</p>

<p>Вариант с запросом: составим SQL-выражение с командой COPY. Нужно указать
таблицу, путь к файлу с данными и его свойства. Под свойствами понимают тип
разделителя (это может быть не только запятая, но и точка с запятой или
табуляция), формат файла и признак заголовка. Последний флаг означает, что
первую строку следует пропустить.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">*db*</span><span class="w">
  </span><span class="s">"
  COPY users(name, email)
  FROM '/Users/ivan/work/book/env/test/resources/data/users.csv'
  DELIMITER ',' CSV HEADER
  "</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что запрос ожидает полный путь к файлу, что мешает командной
работе. Вероятность того, что коллеги держат проект в папке
<code class="language-plaintext highlighter-rouge">/Users/ivan/work/book</code> равна нулю. Доработайте запрос так, чтобы вместо
локального пути подставлялась текущая рабочая директория.</p>

<p>Выполним то же самое средствами Clojure. Усложним задачу тем, что в файле
users.csv очень много записей, и потому он сжат архиватором gzip. Это хорошая
практика: все большие файлы в репозитории должны быть сжаты. Чтобы читать такой
файл на лету (т.е. без выгрузки во временную папку), понадобятся импорты:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="no">:import</span><span class="w"> </span><span class="n">java.io.FileInputStream</span><span class="w">
         </span><span class="n">java.util.zip.GZIPInputStream</span><span class="w">
         </span><span class="n">org.postgresql.copy.CopyManager</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Класс CopyManager делает то же, что и команда COPY. Чтобы создать его экземпляр,
требуется соединение с базой (именно TCP-соединение, а не словарь
спеки). Получим его функцией jdbc/get-connection. Метод copyIn принимает
SQL-запрос и стрим с данными CSV. Этот стрим мы получим из ресурса
<code class="language-plaintext highlighter-rouge">data/users.csv.gz</code>, пропустив его через серию функций и классов. Последний
GZIPInputStream занимается тем, что по мере чтения приводит сжатые данные к их
нормальному виду. В конце работы мы закрываем соединение с базой.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">load-data-gz</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">jdbc/get-connection</span><span class="w"> </span><span class="n">*db*</span><span class="p">)</span><span class="w">
        </span><span class="n">copy</span><span class="w"> </span><span class="p">(</span><span class="nf">CopyManager.</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
        </span><span class="n">stream</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"data/users.csv.gz"</span><span class="w">
                   </span><span class="n">clojure.java.io/resource</span><span class="w">
                   </span><span class="n">clojure.java.io/file</span><span class="w">
                   </span><span class="n">FileInputStream.</span><span class="w">
                   </span><span class="n">GZIPInputStream.</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">.copyIn</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="s">"COPY users(name, email)
                   FROM STDIN (FORMAT CSV, HEADER true)"</span><span class="w">
             </span><span class="n">stream</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">.close</span><span class="w"> </span><span class="n">conn</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Нельзя загрузить CSV-файл сразу в несколько таблиц. Соблюдайте правило “один
файл — одна таблица”. Если файлов несколько, перепишите функцию так, чтобы она
принимала путь к файлу и имя таблицы. Помните, что импорт в разные таблицы может
протекать параллельно с помощью футур и pmap.</p>

<p><strong>Проблема ключей</strong></p>

<p>Редко бывает так, что таблицы существуют сами по себе. Чаще всего они логически
связаны: пользователь ссылается на профиль, заказ на пользователя и так далее. В
классических базах для этого служат первичный и внешний ключи. Первичный ключ
(PK, Primary key) это поле, которое однозначно определяет запись в
таблице. Внешний ключ (FK, Foreign key) это другое поле, которое ссылается на
один из PK из другой таблицы. Все вместе это называют отношением таблиц.</p>

<p>Как правило, первичные ключи это целые числа с автоматической нумерацией. Чтобы
добавить запись в таблицу, не нужно подбирать новый PK. Если ключ с
автонумерацией, база данных ведет для него уникальный счетчик. Для очередной
записи мы получим новый PK, увеличив счетчик на единицу. Имя счетчика строится
по шаблону <code class="language-plaintext highlighter-rouge">&lt;table&gt;_&lt;pk&gt;_seq</code>, например, <code class="language-plaintext highlighter-rouge">users_id_seq</code>.</p>

<p>При вставке связанных данных мы должны убедиться, что их PK и FK равны. Проще
всего задать им одинаковые значения, например, 3. Тогда в примере ниже
пользователь действительно ссылается на группу:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="no">:groups</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Clojure fans"</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:group_id</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Проблема в том, что случайно взятый PK может вступить в конфликт со
счетчиком. Предположим, что в момент вставки groups ее счетчик был равен
нулю. Поскольку мы задали id явно, счетчик не увеличился. Но в одном из тестов
мы создали еще несколько групп, чтобы проверить какой-то сценарий (например,
максимальное число групп, в которых можно состоять без платной подписки). С
первыми двумя группами проблем не возникнет: для них база вычислит ключи 1 и 2
из счетчика. Для третьей группы получим ошибку:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR:  duplicate key value violates unique constraint 'groups_pkey'
DETAIL:  Key (id)=(3) already exists
</code></pre></div></div>

<p>Новый ключ 3 вступил в конфликт с записью, которую мы добавили раньше. Избежать
этого можно двумя способами: коррекцией счетчиков и особым загрузчиком
данных. Разница в том, кто контролирует счетчики: вы или база данных.</p>

<p>Под ручной коррекцией имеем в виду следующее. В тестовых данных вы указываете
первичные ключи для всех записей. Для удобства некоторые из них выносят в
переменную. Например, если на пользователя-админа ссылаются несколько сущностей,
логично записать это так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">id-user-admin</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-data</span><span class="w">
  </span><span class="p">[[</span><span class="no">:users</span><span class="w"> </span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="n">id-user-admin</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">}]]</span><span class="w">
   </span><span class="p">[</span><span class="no">:profiles</span><span class="w"> </span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:user_id</span><span class="w"> </span><span class="n">id-user-admin</span><span class="w"> </span><span class="no">:avatar</span><span class="w"> </span><span class="s">"..."</span><span class="p">}]</span><span class="w">
    </span><span class="no">:posts</span><span class="w"> </span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:user_id</span><span class="w"> </span><span class="n">id-user-admin</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"New book"</span><span class="p">}</span><span class="w">
            </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:user_id</span><span class="w"> </span><span class="n">id-user-admin</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Some post"</span><span class="p">}]]])</span><span class="w">
</span></code></pre></div></div>

<p>После вставки данных поправьте счетчики так, чтобы они перескочили значения,
которые мы использовали. Предположим, если в тестовый набор входит семь
пользователей, и мы назначили им ключи от 1 до 7. Тогда установка счетчика в
значение 100 решит проблему. Все дальнейшие записи в таблице users получат ключи
100, 101 и так далее.</p>

<p>Чтобы сбросить счетчик, выполните запрос ниже:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="s">"ALTER SEQUENCE users_id_seq RESTART WITH 100"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Если все первичные ключи называются id (что рекомендуется), достаточно знать
только имя таблицы. Их даже не обязательно перечислять: таблицы указаны в
db-data. Добавьте в конец функции load-data код:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="w"> </span><span class="mi">100</span><span class="w">
      </span><span class="n">tables</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="n">db-data</span><span class="p">))</span><span class="w">
      </span><span class="n">query</span><span class="w"> </span><span class="s">"ALTER SEQUENCE %s_id_seq RESTART WITH %s"</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">table</span><span class="w"> </span><span class="n">tables</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="p">(</span><span class="nb">name</span><span class="w"> </span><span class="n">table</span><span class="p">)</span><span class="w"> </span><span class="n">value</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Он подхватит все таблицы, указанные в db-data и выставит счетчик в точное
значение. На больших данных, например, из CSV, цифру 100 придется увеличить на
порядок или два. Технически мы можем отличить исходные записи от добавленных в
процессе, если это потребуется (id &lt; 100 и наоборот).</p>

<p>Теперь рассмотрим свой загрузчик. В этом случае мы полагаемся на ключи, которые
вернула база данных. Конкретные их значения не важны. Главное, чтобы у связанных
сущностей первичный и внешний ключи были одинаковы. Для этого пойдем на
хитрость.</p>

<p>Для начала удалим первичные ключи из тестовых данных. Ни в одно словаре не
должно быть поля :id с конкретным значением. Сущностям, на которые нужно
ссылаться, присвоим псевдонимы. Проще всего это сделать через метаданные (поле
:entity, :alias и т.д). В связных сущностях в поле-ссылке укажем псевдоним.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; user</span><span class="w">
</span><span class="o">^</span><span class="p">{</span><span class="no">:entity</span><span class="w"> </span><span class="no">:users/admin</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"ivan@test.com"</span><span class="p">}</span><span class="w">
</span><span class="c1">;; profile</span><span class="w">
</span><span class="p">{</span><span class="no">:user_id</span><span class="w"> </span><span class="no">:users/admin</span><span class="w"> </span><span class="no">:avatar</span><span class="w"> </span><span class="s">"/images/ivan.png"</span><span class="p">}</span><span class="w">
</span><span class="c1">;; posts</span><span class="w">
</span><span class="p">{</span><span class="no">:user_id</span><span class="w"> </span><span class="no">:users/admin</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"New book"</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="no">:user_id</span><span class="w"> </span><span class="no">:users/admin</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="s">"Some post"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Загрузчик перебирает записи и делает следующие проверки. Если у записи
псевдоним, мы связываем его с ключом, который вернула база. На старте загрузчик
объявляет атом с пустым словарем и наполняет его в процессе, например,
{:users/admin 42}. Ключ мы получим из ответа функции jdbc/insert!. В зависимости
от типа базы ответ будет разным:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">jdbc/insert!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">})</span><span class="w">
</span><span class="p">({</span><span class="no">:id</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="err">"</span><span class="n">Ivan</span><span class="p">})</span><span class="w"> </span><span class="c1">;; for PostgreSQL</span><span class="w">
</span><span class="p">({</span><span class="no">:generated_key</span><span class="w"> </span><span class="mi">42</span><span class="p">})</span><span class="w">  </span><span class="c1">;; for MariaDB</span><span class="w">
</span></code></pre></div></div>

<p>Перед вставкой загрузчик проверяет поля записи. Если это ключ, например,
{:user_id :users/admin}, мы считаем, что это ссылка. Заменяем ссылку на значение
из атома по ключу. Если в атоме нет такого ключа, кидаем исключение. Предлагаем
читателю написать такой загрузчик самостоятельно.</p>

<p><strong>Удаление данных</strong></p>

<p>Мы достаточно много сказали про вставку данных и переходим к их
удалению. Очистка базы важна не меньше, чем ее наполнение. Она должна вызывать
минимум усилий и не оставлять после себя артефактов.</p>

<p>Наивный способ очистить базу — послать запрос <code class="language-plaintext highlighter-rouge">DELETE FROM &lt;table&gt;</code> для всех
таблиц, с которыми мы работаем. Проблема DELETE в том, что он учитывает
зависимость ключей. Например, если запись из другой таблицы ссылается на users,
удалить пользователей не получится. Придется вызвать DELETE в правильном
порядке: сначала для связной таблицы, затем users. Чем больше у вас таблиц, тем
сложнее будет заполнить порядок.</p>

<p>Такое поведение не относится к недостаткам: наоборот, без контроля за ссылками
база станет неконсистентной. Параметры контроля можно задать в объявлении
внешнего ключа (см. справку по foreign key). Но вообще, нас интересует как
очистить данные независимо от того, как объявлены ссылки.</p>

<p>Команда TRUNCATE (анг. “усечь, подрезать”) нужна для быстрой очистки таблицы. В
отличии от DELETE она не вызывает триггеры удаления и не сканирует всю
таблицу. TRUNCATE принимает несколько несколько таблиц за раз. Еще одно ее
преимущество в каскадном режиме. Если передан флаг CASCADE, все таблицы, которые
так или иначе входят в граф связей, тоже очищаются. На практике выходит, что
каскадная очистка пары таблиц вызывает цепную реакцию по всей базе.</p>

<p>Напишем функцию очистки. Она посылает запрос, в котором через запятую
перечислены все таблицы из данных для тестов. Добавьте ее в фикстуру
with-db-data сразу после вызова (t).</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">delete-data</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">tables</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="n">db-data</span><span class="p">))</span><span class="w">
        </span><span class="n">tables-comma</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/join</span><span class="w"> </span><span class="s">","</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">tables</span><span class="p">))</span><span class="w">
        </span><span class="n">query</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"TRUNCATE %s CASCADE"</span><span class="w"> </span><span class="n">tables-comma</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">jdbc/execute!</span><span class="w"> </span><span class="n">*db*</span><span class="w"> </span><span class="n">query</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><em><a href="/clj-book-tests-2">Продолжение следует</a></em></p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментарии</center>

<div id="comments">
  
    <div id="comment-4687826975" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            anonymous,
            13th Nov 2019,
            <a href="#comment-4687826975">link</a>
            
          </em>
        </small>
      </p>
      <div><p>Генеративные тесты в следующей части?</p>
</div>
    </div>
  
    <div id="comment-4687863096" class="comment-block">
      <p class="comment-lead">
        <small>
          <em>
            Ivan Grishaev,
            13th Nov 2019,
            <a href="#comment-4687863096">link</a>
            , <a href="#comment-4687826975">parent</a>
          </em>
        </small>
      </p>
      <div><p>Гетеративные нет, это уже специфика. Дописываю про интеграционные и всякие мелочи.</p>
</div>
    </div>
  
</div>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-book-tests-1/">
    <input required name="captcha" type="hidden" value="4 &#215; 8">

    <div class="block">
        <span class="comment-form-label"><small>4 &#215; 8 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
