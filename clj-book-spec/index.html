<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Clojure.spec</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-book-spec/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Clojure.spec</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2019-04-16T00:00:00+00:00">
        Apr 16, 2019
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/web/" rel="tag">web</a>, <a href="/tag/programming/" rel="tag">programming</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    
<p><em>Это вторая глава предполагаемой книги по Кложе на русском языке. См. <a href="/clj-book-web-1">первую
главу</a> про веб-разработку.</em></p>

<h2>

    Содержание

</h2>

<ul id="toc-item-clj-book-spec">
  <li><a href="#типы-и-классы" id="toc-item-clj-book-spec-типы-и-классы">Типы и классы</a></li>
  <li><a href="#основы-spec" id="toc-item-clj-book-spec-основы-spec">Основы spec</a></li>
  <li><a href="#спеки-коллекции" id="toc-item-clj-book-spec-спеки-коллекции">Спеки-коллекции</a></li>
  <li><a href="#вывод-значений" id="toc-item-clj-book-spec-вывод-значений">Вывод значений</a></li>
  <li><a href="#спеки-перечисления" id="toc-item-clj-book-spec-спеки-перечисления">Спеки-перечисления</a></li>
  <li><a href="#продвинутые-техники" id="toc-item-clj-book-spec-продвинутые-техники">Продвинутые техники</a>    <ul>
      <li><a href="#множества" id="toc-item-clj-book-spec-множества">Множества</a></li>
      <li><a href="#перечисления" id="toc-item-clj-book-spec-перечисления">Перечисления</a></li>
      <li><a href="#with-conformer" id="toc-item-clj-book-spec-with-conformer">With-conformer</a></li>
    </ul>
  </li>
  <li><a href="#логические-пути" id="toc-item-clj-book-spec-логические-пути">Логические пути</a></li>
  <li><a href="#анализ-ошибок" id="toc-item-clj-book-spec-анализ-ошибок">Анализ ошибок</a></li>
  <li><a href="#понятные-сообщения-об-ошибках" id="toc-item-clj-book-spec-понятные-сообщения-об-ошибках">Понятные сообщения об ошибках</a></li>
  <li><a href="#парсинг" id="toc-item-clj-book-spec-парсинг">Парсинг</a></li>
  <li><a href="#разбор-clojure-кода-теория" id="toc-item-clj-book-spec-разбор-clojure-кода-теория">Разбор Clojure-кода (теория)</a></li>
  <li><a href="#спецификация-функций" id="toc-item-clj-book-spec-спецификация-функций">Спецификация функций</a></li>
  <li><a href="#переиспользование-спек" id="toc-item-clj-book-spec-переиспользование-спек">Переиспользование спек</a></li>
  <li><a href="#дополнения-к-spec-обзор" id="toc-item-clj-book-spec-дополнения-к-spec-обзор">Дополнения к spec (обзор)</a></li>
  <li><a href="#будущее-спеки" id="toc-item-clj-book-spec-будущее-спеки">Будущее спеки</a></li>
  <li><a href="#итог" id="toc-item-clj-book-spec-итог">Итог</a></li>
</ul>

<p>В этой главе мы рассмотрим <code class="language-plaintext highlighter-rouge">clojure.spec</code> – библиотеку для проверки данных в
Clojure. Это особенная библиотека, поэтому уделим пристальное внимание.</p>

<p class="draft-warn">Внимание! Вы читаете черновик к книге <a href="/clojure-in-prod/">“Clojure на производстве”</a>. Для
книги я переписывал его много раз, но в блоге осталась старая версия. Здесь она
для истории, а вам я рекомендую купить книжку.</p>

<p>Spec это сокращение от specification, т.е. спецификация, описание. В общих
словах, это набор функций и макросов, чтобы схематично описывать структуры
данных. Например, из каких ключей состоит словарь и каких типов его
значения. Такое описание называют спецификацией, или сокращенно спекой.</p>

<p>Особые функции принимают спеку, данные и проверяют, подходят ли данные под
спеку. Если нет, то возвращают отчет: в каком узле данных произошла ошибка и
почему.</p>

<p>Spec входит в стандартную поставку Clojure начиная с версии 1.9. Полное имя
модуля <code class="language-plaintext highlighter-rouge">clojure.spec.alpha</code>. Пусть вас не смущает частичка <code class="language-plaintext highlighter-rouge">alpha</code> на конце
имени. Она осталась по историческим причинам.</p>

<p>Появление spec стало важной вехой в развитии Clojure. Ключевое свойство spec в
том, что она фундаментальна. Валидация данных это всего лишь малая часть ее
возможностей. Spec не только проверяет данные, но и преобразует и анализирует
их. Например, на spec легко написать преобразование данных или парсер.</p>

<p>Технически spec основана на абстракциях, которые предлагает Clojure. Формально
это обычная библиотека. Но абстракции spec оказались настолько мощны, что
Clojure переиспользует их в работе. Начиная с 1.10, Clojure анализирует
собственный код с помощью spec. Так проекты дополняют друг друга.</p>

<p>Мы начнем описание spec с валидации данных. Но прежде чем браться за техническую
часть, разберемся с теорией. Как между собой связаны классы, типы и валидация.</p>

<!-- more -->

<h2 id="типы-и-классы">Типы и классы</h2>

<p>Принято считать, что код на языке со статической типизацией безопаснее, чем с
динамической. Действительно, компилятор не позволит сложить число и строку еще
до того, как мы запустим программу. Но сторонники статической типизации
забывают, что тип переменной — это всего лишь одно из многочисленных
ограничений. Редко случается так, что тип переменной полностью определяет
допустимые значения. Чаще всего, в дополнение к типу, учитывают максимальные и
минимальные границы, длину, попадание в интервалы и перечисления. Бывает, по
отдельности значение верно, но не может соседствовать в паре с другим значением.</p>

<p>Рассмотрим абстракцию сетевого порта. Это целое число от 0 до 2^16-1. Поскольку
целочисленные типы, как правило, представлены степенями двойки, наверняка
найдется <code class="language-plaintext highlighter-rouge">unsigned int</code>, который охватывает именно этот диапазон. Но нулевой
порт считается ошибочным, поэтому правильно отсчитывать порт с
единицы. Вероятность, что язык реализует такой целочисленный тип, крайне мала.</p>

<p>Лучше всего проблема видна на диапазоне дат. Единичная дата может быть сколь
угодно разумной, но диапазон накладывает ограничение: дата начала строго меньше
даты конца. Со стороны бизнеса приходят новые требования: разница в датах не
больше недели и в рамках текущего месяца.</p>

<p>В мире ООП знают об этой проблеме и решают ее классами. Типичный
Java-программист пишет классы <code class="language-plaintext highlighter-rouge">UnixPort</code> и <code class="language-plaintext highlighter-rouge">DateRange</code>. Условный
<code class="language-plaintext highlighter-rouge">com.project.net.UnixPort</code> – это класс с одним конструктором. Он принимает целое
число и выполняет проверки на диапазон. Если число отрицательное или выходит за
рамки 1 — 2^16, то конструктор выбрасывает исключение. Программист уверен, что
создал новый тип. Это неверно – классы и типы не тождественны.</p>

<p>Конструктор такого класса это обычный валидатор, проверка во времени
исполнения. Он неявно срабатывает, когда мы пишем new
<code class="language-plaintext highlighter-rouge">UnixPort(8080)</code>. Возникает иллюзия, что это тип, но на самом деле это проверка
в рантайме. Ее удобство обусловлено синтаксисом.</p>

<p>В промышленных языках невозможно объявить класс так, чтобы выражение new
<code class="language-plaintext highlighter-rouge">UnixPort(-42)</code> приводило к ошибке компиляции. Это возможно только сторонними
утилитами или плагинами к IDE.</p>

<p>Проверки в конструкторах трудно переиспользовать. Предположим, два разработчика
написали классы <code class="language-plaintext highlighter-rouge">com.somecompany.util.UnixPort</code> и
<code class="language-plaintext highlighter-rouge">org.community.net.MyPort</code>. Класс <code class="language-plaintext highlighter-rouge">UnixPort</code> проверяет порт на диапазон и
выбрасывает исключение. Нам выгодно пользоваться этим классом, поскольку он
совмещен с валидацией. Однако сторонняя библиотека принимает порт как экземпляр
<code class="language-plaintext highlighter-rouge">MyPort</code>, который только оборачивает целочисленный тип. Невозможно вызвать
конструктор <code class="language-plaintext highlighter-rouge">UnixPort</code> для <code class="language-plaintext highlighter-rouge">MyPort</code>.</p>

<p>В примере выше мы вынуждены создать экземпляр <code class="language-plaintext highlighter-rouge">UnixPort</code>, чтобы проверить
данные. Это стадия валидации. Потом извлечь из класса целое число порта. Это
данные. Затем создать экземпляр <code class="language-plaintext highlighter-rouge">MyPort</code> и передать в библиотеку.</p>

<p>Из сказанного выше определим хорошие практики валидации. Это независимость от
данных и компоновка. Независимость означает, что данные не привязаны намертво к
валидации. Нет ничего плохого в том, что порт – это целое число. Пусть
библиотека принимает <code class="language-plaintext highlighter-rouge">integer</code>, а разработчик сам решит, как проверять такое
число. Так у него появится выбор, насколько строгой должна быть проверка.</p>

<p>Компоновка означает, что хорошо иметь несколько простых проверок, из которых
легко составить сложные. Бывает, по отдельности реализованы проверки “это” и
“то”, и теперь нужны их комбинации “это и то”, “это или то”. В идеале мы не
должны тратить более одной-двух строк на столь тривиальные вещи.</p>

<p>Оба тезиса ложатся на функции. Вспомним, что функция это объект с операцией
вызова. Договоримся, что для верного значения функция-валидатор вернет не ложное
значение (отличное от <code class="language-plaintext highlighter-rouge">false</code> и <code class="language-plaintext highlighter-rouge">nil</code>), а для ошибочного — ложное. Поскольку
функция это объект высшего порядка, другие функции принимают валидаторы как
аргументы и возвращают их комбинированные версии.</p>

<h2 id="основы-spec">Основы spec</h2>

<p>С багажом этих рассуждений мы подошли к тому, как работает clojure.spec.</p>

<p>Импортируем главный модуль spec в текущее пространство:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.spec.alpha</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Синоним <code class="language-plaintext highlighter-rouge">s</code> нужен, чтобы избежать конфликтов имен с модулем
<code class="language-plaintext highlighter-rouge">clojure.core</code>. Модуль spec несет определения <code class="language-plaintext highlighter-rouge">s/and</code>, <code class="language-plaintext highlighter-rouge">s/or</code> и другие, которые
не имеют ничего общего со стандартными <code class="language-plaintext highlighter-rouge">and</code> и <code class="language-plaintext highlighter-rouge">or</code>. Считается плохой практикой,
когда определения одного модуля заменяют другие. Это называется затенением имен,
и мы рассмотрим проблему в отдельной главе. Пока что мы будем обращаться к spec
через синоним s.</p>

<p>Базовая операция в spec – определить новую спецификацию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::string</span><span class="w"> </span><span class="nb">string?</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Макрос <code class="language-plaintext highlighter-rouge">s/def</code> принимает ключ и предикат. Он создал объект спеки из функции
<code class="language-plaintext highlighter-rouge">string?</code>. Затем поместил спеку в глобальное хранилище под ключом <code class="language-plaintext highlighter-rouge">::string</code>.</p>

<p>Важно понимать, что <code class="language-plaintext highlighter-rouge">::string</code> – это не спека, а только ее псевдоним. Все
макросы spec устроены так, что принимают не объект спеки, а ключ, и сами выводят
по нему спеку. Это удобно, потому что ключи глобальны. В любом месте можно
сослаться на <code class="language-plaintext highlighter-rouge">::string</code> без нужды что-то импортировать.</p>

<p>Ключ спеки рассматривают как указатель или псевдоним. Легче передать псевдоним,
чем реальный объект.</p>

<p>Вторым аргументом мы передали предикат <code class="language-plaintext highlighter-rouge">string?</code>. Предикат – это функция,
которая возвращает истину или ложь.</p>

<p>Технически возможно получить объект спеки. Функция <code class="language-plaintext highlighter-rouge">s/get-spec</code> по ключу спеки
возвращает ее Java-объект. Однако, на практике он мало чем полезен.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/get-spec</span><span class="w"> </span><span class="no">::string</span><span class="p">)</span><span class="w">

</span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">clojure.spec.alpha$spec_impl$reify__2059</span><span class="w"> </span><span class="mi">0</span><span class="n">x3e9dde1d</span><span class="w"> </span><span class="n">...</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Спеки хранятся в глобальном регистре под своими ключами. Макрос <code class="language-plaintext highlighter-rouge">s/def</code> не
проверяет, была ли уже зарегистрирована такая спека. Если под этим ключом уже
была спека, она будет потеряна.</p>

<p>Spec не разрешает использовать ключи без пространства, например, просто <code class="language-plaintext highlighter-rouge">:error</code>
или <code class="language-plaintext highlighter-rouge">:message</code>. Это повышает риск конфликта ключей. Чтобы избавиться от
конфликтов, используйте ключи с текущим пространством: <code class="language-plaintext highlighter-rouge">::error</code>, <code class="language-plaintext highlighter-rouge">::message</code>.</p>

<p>Самое простое, что можно сделать с новой спекой – проверить, подходит ли под нее
значение. Функция <code class="language-plaintext highlighter-rouge">s/valid?</code> принимает ключ спеки, значение и возвращает <code class="language-plaintext highlighter-rouge">true</code>
или <code class="language-plaintext highlighter-rouge">false</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::string</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::string</span><span class="w"> </span><span class="s">"test"</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, пустая строка тоже будет валидной, однако чаще всего это не имеет
смысла. Пустая строка в поле “имя пользователя” или “название проекта” означает
ошибку. Объявим спеку, которая в дополнение к строке проверяет, что она не
пустая.</p>

<p>Наивный способ сделать это – передать специальный предикат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::ne-string</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">val</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="nb">val</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="nb">val</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Быстрая проверка:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::ne-string</span><span class="w"> </span><span class="s">"test"</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::ne-string</span><span class="w"> </span><span class="s">""</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">
</span></code></pre></div></div>

<p>Ключ <code class="language-plaintext highlighter-rouge">::ne-string</code> это сокращение от <code class="language-plaintext highlighter-rouge">::non-empty-string</code>. Эта спека встречается
так часто, что логично сэкономить на ее упоминании.</p>

<p>Более изящный способ объявить ту же спеку – объединить предикаты через
<code class="language-plaintext highlighter-rouge">every-pred</code>. Это функция, которая принимает предикаты и возвращает
супер-предикат. Он вернет истину только если истинны все переданные предикаты.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::ne-string</span><span class="w">
  </span><span class="p">(</span><span class="nf">every-pred</span><span class="w"> </span><span class="nb">string?</span><span class="w"> </span><span class="n">not-empty</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::ne-string</span><span class="w"> </span><span class="s">"test"</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::ne-string</span><span class="w"> </span><span class="s">""</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">
</span></code></pre></div></div>

<p>Этот способ хорош, потому что декларативно собирает новую сущность из старых. Но
еще лучше компоновать не предикаты, а спеки. Особый макрос <code class="language-plaintext highlighter-rouge">s/and</code> объединяет
предикаты и объявленные ранее спеки в новую спеку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::ne-string</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w"> </span><span class="no">::string</span><span class="w"> </span><span class="n">not-empty</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>По такому принципу в Clojure строят сложные спеки. Объявляют примитивы и
постепенно строят их усложненные версии.</p>

<p>Во время проверки Spec не перехватывает возможные исключения. Это остается на
усмотрение разработчика. Рассмотрим пример – спеку для проверки строки на
URL. Проще всего это сделать регулярным выражением:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::url</span><span class="w">
  </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">re-matches</span><span class="w"> </span><span class="o">#</span><span class="s">"(?i)^http(s?)://.*"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::url</span><span class="w"> </span><span class="s">"test"</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::url</span><span class="w"> </span><span class="s">"http://test.com"</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">
</span></code></pre></div></div>

<p>Но не строковое значение вызовет ошибку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::url</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="n">Execution</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">(</span><span class="nf">NullPointerException</span><span class="p">)</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">java.util.regex.Matcher...</span><span class="w">
</span></code></pre></div></div>

<p>Это потому, что <code class="language-plaintext highlighter-rouge">nil</code> был передан в функцию <code class="language-plaintext highlighter-rouge">re-matches</code>. Функция трактует
аргумент как строку, что приводит к NPE.</p>

<p>Считается хорошей практикой писать спеки, которые не выбрасывают исключения. В
примере с <code class="language-plaintext highlighter-rouge">::url</code> будет правильно сначала проверить, что значение строка, и
только потом передавать ее в регулярное выражение.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::url</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="no">::ne-string</span><span class="w">
   </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">re-matches</span><span class="w"> </span><span class="o">#</span><span class="s">"(?i)^http(s?)://.*"</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::url</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">
</span></code></pre></div></div>

<p>Теперь проверка <code class="language-plaintext highlighter-rouge">nil</code> не выбрасывает исключение.</p>

<p>По аналогии напишем проверку возраста пользователя. Это комбинация двух
проверок: на число и диапазон.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::age</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w"> </span><span class="n">int?</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">150</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::age</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::age</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::age</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">
</span></code></pre></div></div>

<h2 id="спеки-коллекции">Спеки-коллекции</h2>

<p>Выше мы проверяли примитивные типы или скаляры. Это удобно для демонстрации, но
редко встречается в практике. Гораздо чаще проверяют не скаляры, а
коллекции. Spec предлагает набор макросов, чтобы определить спеки-коллекции из
примитивов.</p>

<p>Макрос <code class="language-plaintext highlighter-rouge">s/coll-of</code> принимает предикат или ключ и возвращает спеку-коллекцию. Она
проверяет, что каждый элемент проходит валидацию. Вот так мы определим список
адресов URL:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::url-list</span><span class="w"> </span><span class="p">(</span><span class="nf">s/coll-of</span><span class="w"> </span><span class="no">::url</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Быстрая проверка:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::url-list</span><span class="w">
          </span><span class="p">[</span><span class="s">"http://test.com"</span><span class="w"> </span><span class="s">"http://ya.ru"</span><span class="p">])</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::url-list</span><span class="w">
          </span><span class="p">[</span><span class="s">"http://test.com"</span><span class="w"> </span><span class="s">"dunno.com"</span><span class="p">])</span><span class="w">
</span><span class="n">false</span><span class="w">
</span></code></pre></div></div>

<p>Макрос <code class="language-plaintext highlighter-rouge">s/map-of</code> проверяет ключи и значения словаря. Вспомним поле запроса
<code class="language-plaintext highlighter-rouge">:params</code> запроса из <a href="/clj-book-web-1">главы про веб-разработку</a>. Его ключи
кейворды, а значения строки.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::params</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/map-of</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="nb">string?</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::params</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="s">"test"</span><span class="p">})</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::params</span><span class="w"> </span><span class="p">{</span><span class="s">"foo"</span><span class="w"> </span><span class="s">"test"</span><span class="p">})</span><span class="w">
</span><span class="n">false</span><span class="w">
</span></code></pre></div></div>

<p>Словари заслуживают отдельного упоминания. Проверка <code class="language-plaintext highlighter-rouge">s/map-of</code> достаточно
слабая, чтобы покрыть все варианты. Факт того, что все значения строки не несет
полезной информации. Гораздо важнее знать, что в словаре именно те ключи, что мы
ожидаем. К тому же редко бывает так, что значения словаря одного типа. Наоборот,
чаще всего словарь объединяет поля разных типов в рамках одной
сущности. Например, имя, возраст и статус пользователя.</p>

<p>Для таких проверок используют макрос <code class="language-plaintext highlighter-rouge">s/keys</code>. Он выглядит как список
спек. Ключи спек совпадают с ключами словаря. Значения таких ключей проверяются
одноименными спеками.</p>

<p>Пусть объект страницы задан словарем с двумя полями. Это будут address, строка
URL и description, текстовое описание. Объявим поля-примитивы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:page/address</span><span class="w"> </span><span class="no">::url</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:page/description</span><span class="w"> </span><span class="no">::ne-string</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>обратите внимание на пространство ключей <code class="language-plaintext highlighter-rouge">:page</code>. Адрес и описание относятся к
сущности страницы, поэтому логично задать им особое пространство. Одноименные
поля могут быть у пользователя или товара. Пространства гарантируют, что спеки
<code class="language-plaintext highlighter-rouge">:page/address</code> и <code class="language-plaintext highlighter-rouge">:user/address</code> не затронут друг друга.</p>

<p>Составим спеку страницы.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::page</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:page/address</span><span class="w">
                   </span><span class="no">:page/description</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Параметр <code class="language-plaintext highlighter-rouge">:req-un</code> содержит вектор спек. Для каждой из них <code class="language-plaintext highlighter-rouge">s/keys</code> ищет ключ с
таким же именем в словаре и проверяет значение. Рассмотрим, что именно означает
<code class="language-plaintext highlighter-rouge">:req-un</code> и какие еще параметры принимает <code class="language-plaintext highlighter-rouge">s/keys</code>.</p>

<p>Ключ <code class="language-plaintext highlighter-rouge">:req-un</code> состоит из двух логических частей: <code class="language-plaintext highlighter-rouge">req</code> и <code class="language-plaintext highlighter-rouge">un</code>. Это признаки
наличия ключа и его типа. <code class="language-plaintext highlighter-rouge">Req</code> означает, что перечисленные ключи обязаны быть в
словаре. Если хотя бы один ключ отсутствует, спека не проходит
проверку. Противоположный по смыслу параметр называется <code class="language-plaintext highlighter-rouge">opt</code>. В нем указаны
ключи, которых может не быть. Валидация таких ключей случается только если они
присутствуют в словаре.</p>

<p>Частичка <code class="language-plaintext highlighter-rouge">un</code> означает unqualified, то есть неполные ключи. При проверке
<code class="language-plaintext highlighter-rouge">un</code>-ключей используются только их имена. Например, если спека <code class="language-plaintext highlighter-rouge">:page/address</code>
указана в списке <code class="language-plaintext highlighter-rouge">-un</code>, то в словаре ищется ключ <code class="language-plaintext highlighter-rouge">:address</code>, а не
<code class="language-plaintext highlighter-rouge">:page/address</code>.</p>

<p>Неполные (краткие) ключи — довольно частое явление в <code class="language-plaintext highlighter-rouge">s/keys</code>. В основном мы
получаем данные из JSON-документов и баз данных. Такие системы не знают о
пространствах имен, поэтому мы игнорируем их. Исключения бывают, когда весь
технологический стек фирмы построен на Clojure.</p>

<p>Различают следующие комбинации <code class="language-plaintext highlighter-rouge">req</code>, <code class="language-plaintext highlighter-rouge">opt</code> и <code class="language-plaintext highlighter-rouge">un</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">:req</code> — необходимые полные ключи,</li>
  <li><code class="language-plaintext highlighter-rouge">:req-un</code> — необходимые краткие ключи,</li>
  <li><code class="language-plaintext highlighter-rouge">:opt</code> — опциональные полные ключи,</li>
  <li><code class="language-plaintext highlighter-rouge">:opt-un</code> — опциональные краткие ключи.</li>
</ul>

<p>В примере со спекой <code class="language-plaintext highlighter-rouge">::page</code> все ключи обязательны и не учитывают пространство.</p>

<p>Приведем пример ошибочных данных. Это может быть невалидный URL, пустое
описание, отсутствующее поле. Если каждый из этих словарей подставить в
выражение <code class="language-plaintext highlighter-rouge">(s/valid? ::params &lt;data&gt;)</code>, результат будет <code class="language-plaintext highlighter-rouge">false</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:address</span><span class="w"> </span><span class="s">"clojure.org"</span><span class="w">
 </span><span class="no">:description</span><span class="w"> </span><span class="s">"Clojure Language"</span><span class="p">}</span><span class="w">

</span><span class="p">{</span><span class="no">:address</span><span class="w"> </span><span class="s">"https://clojure.org/"</span><span class="w">
 </span><span class="no">:description</span><span class="w"> </span><span class="s">""</span><span class="p">}</span><span class="w">

</span><span class="p">{</span><span class="no">:address</span><span class="w"> </span><span class="s">"https://clojure.org/"</span><span class="p">}</span><span class="w">

</span><span class="p">{</span><span class="no">:page/address</span><span class="w"> </span><span class="s">"https://clojure.org/"</span><span class="w">
 </span><span class="no">:page/description</span><span class="w"> </span><span class="s">"Clojure Language"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание на последний случай. Значения полей верны, но ключи содержат
пространства. Это потому, что мы поместили спеки адреса и описания под ключом
<code class="language-plaintext highlighter-rouge">req-un</code>, что значит отбрасывать пространства при поиске в словаре. Чтобы
последний пример сработал, измените <code class="language-plaintext highlighter-rouge">:req-un</code> на <code class="language-plaintext highlighter-rouge">:req</code> в объявлении <code class="language-plaintext highlighter-rouge">::page</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::page-fq</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req</span><span class="w"> </span><span class="p">[</span><span class="no">:page/address</span><span class="w">
                </span><span class="no">:page/description</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::page-fq</span><span class="w">
          </span><span class="p">{</span><span class="no">:page/address</span><span class="w"> </span><span class="s">"https://clojure.org/"</span><span class="w">
           </span><span class="no">:page/description</span><span class="w"> </span><span class="s">"Clojure Language"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Примечание: частичка <code class="language-plaintext highlighter-rouge">-fq</code> означает fully qualified, т.е. полный, разрешенный.</p>

<p>Комбинированный пример. Предположим, у объекта страницы может быть поле
HTTP-статуса, который мы получили при последнем обращении к ней. Если к странице
еще не обращались, в поле нечего записать. Вот как выглядит спека в таком
случае:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:page/status</span><span class="w"> </span><span class="n">int?</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::page-status</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:page/address</span><span class="w">
                   </span><span class="no">:page/description</span><span class="p">]</span><span class="w">
          </span><span class="no">:opt-un</span><span class="w"> </span><span class="p">[</span><span class="no">:page/status</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Словари без статуса и с правильным статусом проходят валидацию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::page-status</span><span class="w">
          </span><span class="p">{</span><span class="no">:address</span><span class="w"> </span><span class="s">"https://clojure.org/"</span><span class="w">
           </span><span class="no">:description</span><span class="w"> </span><span class="s">"Clojure Language"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::page-status</span><span class="w">
          </span><span class="p">{</span><span class="no">:address</span><span class="w"> </span><span class="s">"https://clojure.org/"</span><span class="w">
           </span><span class="no">:description</span><span class="w"> </span><span class="s">"Clojure Language"</span><span class="w">
           </span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что <code class="language-plaintext highlighter-rouge">s/keys</code> различает <code class="language-plaintext highlighter-rouge">nil</code> и наличие ключа в словаре. Если статус
<code class="language-plaintext highlighter-rouge">nil</code>, это значит, что он состоит в словаре. Срабатывает проверка <code class="language-plaintext highlighter-rouge">nil</code> на
<code class="language-plaintext highlighter-rouge">int?</code>, что приводит к ошибке валидации.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::page-status</span><span class="w">
          </span><span class="p">{</span><span class="no">:address</span><span class="w"> </span><span class="s">"https://clojure.org/"</span><span class="w">
           </span><span class="no">:description</span><span class="w"> </span><span class="s">"Clojure Language"</span><span class="w">
           </span><span class="no">:status</span><span class="w"> </span><span class="n">nil</span><span class="p">})</span><span class="w">
</span><span class="n">false</span><span class="w">
</span></code></pre></div></div>

<h2 id="вывод-значений">Вывод значений</h2>

<p>До сих пор мы рассматривали проверку данных с помощью <code class="language-plaintext highlighter-rouge">s/valid?</code>. Эта функция
возвращает истину или ложь, что значит данные верны или нет. Но одной проверки
недостаточно. Часто бывает так, что данные корректны, но требуется привести их к
нужному типу.</p>

<p>Например, мы получили число в виде строки. Валидация показывает, что строка
состоит только из цифр и не превышает допустимой длины. Но и после валидации
значение остается строкой. Это склоняет нас к ручному парсингу, увеличивает код
и вообще неудобно. Хотелось бы, чтобы вывод значений происходил автоматически.</p>

<p>Spec предлагает такие возможности. Это функции <code class="language-plaintext highlighter-rouge">s/conformer</code> и <code class="language-plaintext highlighter-rouge">s/conform</code> (от
анг. conform – подчиняться, приспосабливаться).</p>

<p><code class="language-plaintext highlighter-rouge">S/conformer</code> строит спеку особого типа из функции-конформера. Такая функция
принимает исходное значение и возвращает либо новое значение, либо ключ
<code class="language-plaintext highlighter-rouge">:clojure.spec.alpha/invalid</code>.</p>

<p><code class="language-plaintext highlighter-rouge">S/conform</code> принимает ключ спеки-конформера и данные. Если вывод значений прошел
без ошибок, результатом будет новое значение. Если с ошибками, то вернется все
тот же ключ <code class="language-plaintext highlighter-rouge">invalid</code>.</p>

<p>Рассмотрим пример с выводом числа из строки. Чтобы различать спеку-конформер от
валидатора, к ее имени добавляют стрелку, что означает вывод, приведение.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">try</span><span class="w">
     </span><span class="p">(</span><span class="nf">Integer/parseInt</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
       </span><span class="no">::s/invalid</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Такую спеку передают в <code class="language-plaintext highlighter-rouge">s/conform</code> вместе с данными:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="w"> </span><span class="s">"42"</span><span class="p">)</span><span class="w">
</span><span class="mi">42</span><span class="w">

</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="w"> </span><span class="s">"dunno"</span><span class="p">)</span><span class="w">
</span><span class="no">:clojure.spec.alpha/invalid</span><span class="w">
</span></code></pre></div></div>

<p>Как и <code class="language-plaintext highlighter-rouge">s/valid?</code>, <code class="language-plaintext highlighter-rouge">s/conform</code> не перехватывает исключения в процессе
вывода. Java устроена так, что вывод данных часто выбрасывает
исключения. Хорошей практикой будет перехватывать их на уровне
функции-конформера и возвращать <code class="language-plaintext highlighter-rouge">::s/invalid</code>, как в примере выше.</p>

<p>Оба типа спек — валидатор и конформер – можно объединить через
<code class="language-plaintext highlighter-rouge">s/and</code>. Например, добавить предварительные проверки перед выводом значения. В
нашем случае логично убедиться, что значение – строка, чтобы не передать в
<code class="language-plaintext highlighter-rouge">parseInt</code> значение <code class="language-plaintext highlighter-rouge">nil</code> или что-то еще:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;int+</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w"> </span><span class="no">::ne-string</span><span class="w">
       </span><span class="no">::-&gt;int</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;int+</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="no">:clojure.spec.alpha/invalid</span><span class="w">
</span></code></pre></div></div>

<p>Рассмотрим случай с восстановлением дат из строк. С этой проблемой часто
сталкиваются веб-разработчики, когда получают от браузера JSON-документ. Формат
JSON не поддерживает даты, поэтому их передают строкой или числом секунд.</p>

<p>Нам понадобится функция разбора такой строки и минимальная обвязка, чтобы
подружить ее со спекой. Функция <code class="language-plaintext highlighter-rouge">read-instant-date</code> из модуля <code class="language-plaintext highlighter-rouge">clojure.instant</code>
читает строку в дату. Она очень лояльна к входным данным: например, датой может
быть только год.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.instant</span><span class="w">
         </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">read-instant-date</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">read-instant-date</span><span class="w"> </span><span class="s">"2019"</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019-01-01T00:00:00.000-00:00"</span><span class="w">
</span></code></pre></div></div>

<p>Обернем функцию в спеку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;date</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="no">::ne-string</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nf">read-instant-date</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="no">::s/invalid</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Как и в случае с числом, перед разбором значения мы делаем минимальные
проверки. Убеждаемся, что это непустая строка, чтобы отсечь <code class="language-plaintext highlighter-rouge">nil</code> и другие не
имеющие смысла значения.</p>

<p>Строка даты:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;date</span><span class="w"> </span><span class="s">"2019-12-31"</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019-12-31T00:00:00.000-00:00"</span><span class="w">
</span></code></pre></div></div>

<p>Дата и время:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;date</span><span class="w"> </span><span class="s">"2019-12-31T23:59:59"</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019-12-31T23:59:59.000-00:00"</span><span class="w">
</span></code></pre></div></div>

<h2 id="спеки-перечисления">Спеки-перечисления</h2>

<p>Интересен вариант, когда возможные значения известны заранее. Например, при
вызове определенного API клиент передает архитектуру программы – 32 или 64
бита. Ради двух значений не обязательно парсить число. Достаточно оператора
выбора или подбора по словарю.</p>

<p>Рассмотрим вариант с перебором. Оператор case пробегает по вариантам и
возвращает аналогичные числовые значения. Если ничего не найдено, возвращаем
<code class="language-plaintext highlighter-rouge">::s/invalid</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;bits</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">value</span><span class="w">
     </span><span class="s">"32"</span><span class="w"> </span><span class="mi">32</span><span class="w">
     </span><span class="s">"64"</span><span class="w"> </span><span class="mi">64</span><span class="w">
     </span><span class="no">::s/invalid</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;bits</span><span class="w"> </span><span class="s">"32"</span><span class="p">)</span><span class="w">
</span><span class="mi">32</span><span class="w">

</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;bits</span><span class="w"> </span><span class="s">"42"</span><span class="p">)</span><span class="w">
</span><span class="no">:clojure.spec.alpha/invalid</span><span class="w">
</span></code></pre></div></div>

<p>Вариант со словарем. По заранее определенному словарю ищем результат. Если ключ
не найден, возвращаем тег <code class="language-plaintext highlighter-rouge">invalid</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">bits-map</span><span class="w"> </span><span class="p">{</span><span class="s">"32"</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="s">"64"</span><span class="w"> </span><span class="mi">64</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;bits</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">bits-map</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="no">::s/invalid</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Вариант выше хорош еще тем, что его опорная точка – словарь соответствий –
вынесен в отдельную переменную. При желании его легко дополнить новыми
значениями без изменения логики. Или даже вынести в конфигурацию.</p>

<p>Подобным способом восстанавливают логические значения из строк. Нет единого
соглашения о том, как передавать истину и ложь в тексте. Это может быть
<code class="language-plaintext highlighter-rouge">True</code>, <code class="language-plaintext highlighter-rouge">TRUE</code>, <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">on</code>, <code class="language-plaintext highlighter-rouge">yes</code> для истины и их противоположности:
<code class="language-plaintext highlighter-rouge">FALSE</code>, <code class="language-plaintext highlighter-rouge">no</code>, <code class="language-plaintext highlighter-rouge">off</code>… При разборе таких значений важно приводить их к
одному регистру. В Clojure <code class="language-plaintext highlighter-rouge">FALSE</code> и <code class="language-plaintext highlighter-rouge">false</code> – это разные строки, хотя
отправитель имел в виду одно и то же.</p>

<p>Сценарий вывода выглядит так:</p>

<ul>
  <li>убедиться, что значение это строка;</li>
  <li>привести ее к нижнему регистру;</li>
  <li>проверить значение словарем или перебором.</li>
</ul>

<p>Конформер из реального проекта:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;bool</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
    </span><span class="no">::ne-string</span><span class="w">
    </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">clojure.string/lower-case</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
      </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">value</span><span class="w">
          </span><span class="p">(</span><span class="s">"true"</span><span class="w"> </span><span class="s">"1"</span><span class="w"> </span><span class="s">"on"</span><span class="w"> </span><span class="s">"yes"</span><span class="p">)</span><span class="w"> </span><span class="n">true</span><span class="w">
          </span><span class="p">(</span><span class="s">"false"</span><span class="w"> </span><span class="s">"0"</span><span class="w"> </span><span class="s">"off"</span><span class="w"> </span><span class="s">"no"</span><span class="p">)</span><span class="w"> </span><span class="n">false</span><span class="w">
          </span><span class="no">::s/invalid</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Примеры его работы:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;bool</span><span class="w"> </span><span class="s">"True"</span><span class="p">)</span><span class="w"> </span><span class="c1">;; true</span><span class="w">
</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;bool</span><span class="w"> </span><span class="s">"yes"</span><span class="p">)</span><span class="w">  </span><span class="c1">;; true</span><span class="w">
</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;bool</span><span class="w"> </span><span class="s">"off"</span><span class="p">)</span><span class="w">  </span><span class="c1">;; false</span><span class="w">
</span></code></pre></div></div>

<h2 id="продвинутые-техники">Продвинутые техники</h2>

<p>К этому времени мы написали достаточно кода, чтобы увидеть одинаковые участки –
паттерны. Перечислим несколько техник, которые ускоряют работу со спекой.</p>

<h3 id="множества">Множества</h3>

<p>Когда значения известны заранее, спекой может выступить множество. Вспомним, что
множество ведет себя как функция одного аргумента. Если такой аргумент есть в
множестве, функция просто вернет его. Если нет, результат будет
<code class="language-plaintext highlighter-rouge">nil</code>. Предположим, статус сущности может быть <code class="language-plaintext highlighter-rouge">"todo"</code>, <code class="language-plaintext highlighter-rouge">"in_progress"</code> и
<code class="language-plaintext highlighter-rouge">"done"</code>. Тогда спека будет множеством этих значений:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::status</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="s">"todo"</span><span class="w"> </span><span class="s">"in_progres"</span><span class="w"> </span><span class="s">"done"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::status</span><span class="w"> </span><span class="s">"todo"</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">
</span></code></pre></div></div>

<h3 id="перечисления">Перечисления</h3>

<p>Множество не подходит в случаях, когда мы считаем <code class="language-plaintext highlighter-rouge">false</code> и <code class="language-plaintext highlighter-rouge">nil</code> верными
значениями. <code class="language-plaintext highlighter-rouge">S/valid?</code> трактует их как неудачную проверку. Если <code class="language-plaintext highlighter-rouge">nil</code> или
<code class="language-plaintext highlighter-rouge">false</code> входят в множество значений, проверять проверять следует функцией
<code class="language-plaintext highlighter-rouge">contains?</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы свести повторы кода к минимуму, напишем функцию <code class="language-plaintext highlighter-rouge">enum</code>. Она принимает
значения и возвращает другую функцию-предикат. Этот предикат принимает один
аргумент и проверяет, есть ли такой среди исходных значений.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">enum</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">arg-set</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">arg-set</span><span class="w"> </span><span class="n">value</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Внутренняя функция замкнута на переменной <code class="language-plaintext highlighter-rouge">arg-set</code>. Это множество, полученное
из списка аргументов. Мы создаем его один раз, чтобы не делать это постоянно в
теле функции. Теперь регистрировать спеки-перечисления гораздо удобней:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::status</span><span class="w">
  </span><span class="p">(</span><span class="nf">enum</span><span class="w"> </span><span class="s">"todo"</span><span class="w"> </span><span class="s">"in_progres"</span><span class="w"> </span><span class="s">"done"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h3 id="with-conformer">With-conformer</h3>

<p>Спеки-конформеры требуют особого внимания. В них легко допустить ошибку: не
перехватить исключение, забыть обернуть функцию в <code class="language-plaintext highlighter-rouge">s/conformer</code>. Чтобы свести
код к минимуму, воспользуйтесь макросом <code class="language-plaintext highlighter-rouge">with-conformer</code>. Он принимает символ
для переменной и произвольное тело. Результатом макроса будет спека-конформер.</p>

<p>Ее внутренняя функция принимает параметр, заданный символом. Функция исполняет
тело в блоке <code class="language-plaintext highlighter-rouge">try-catch</code>. Если исключения не было, результатом будет последнее
выражение тела. Если было, то вернется тег <code class="language-plaintext highlighter-rouge">invalid</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">with-conformer</span><span class="w">
  </span><span class="p">[</span><span class="n">bind</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
     </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">~</span><span class="n">bind</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nf">try</span><span class="w">
         </span><span class="o">~@</span><span class="n">body</span><span class="w">
         </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="o">#</span><span class="w">
           </span><span class="no">::s/invalid</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Примеры из реального проекта. Вывод числа:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="no">::ne-string</span><span class="w">
   </span><span class="p">(</span><span class="nf">with-conformer</span><span class="w"> </span><span class="nb">val</span><span class="w">
     </span><span class="p">(</span><span class="nf">Integer/parseInt</span><span class="w"> </span><span class="nb">val</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Вывод логического значения:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;bool</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="n">-&gt;lower</span><span class="w">
   </span><span class="p">(</span><span class="nf">with-conformer</span><span class="w"> </span><span class="nb">val</span><span class="w">
     </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="nb">val</span><span class="w">
       </span><span class="p">(</span><span class="s">"true"</span><span class="w">  </span><span class="s">"1"</span><span class="w"> </span><span class="s">"on"</span><span class="w">  </span><span class="s">"yes"</span><span class="p">)</span><span class="w"> </span><span class="n">true</span><span class="w">
       </span><span class="p">(</span><span class="s">"false"</span><span class="w"> </span><span class="s">"0"</span><span class="w"> </span><span class="s">"off"</span><span class="w"> </span><span class="s">"no"</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">false</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>, где <code class="language-plaintext highlighter-rouge">-&gt;lower</code> это тоже обертка для приведения регистра:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">-&gt;lower</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
    </span><span class="nb">string?</span><span class="w">
    </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">clojure.string/lower-case</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>в примере выше не обязательно указывать <code class="language-plaintext highlighter-rouge">invalid</code> для значения по
умолчанию. Вспомним, что <code class="language-plaintext highlighter-rouge">case</code>, если не нашел соответствия и не задан вариант
по умолчанию, выбрасывает исключение. <code class="language-plaintext highlighter-rouge">With-conformer</code> перехватывает его и
возвращает <code class="language-plaintext highlighter-rouge">invalid</code>.</p>

<h2 id="логические-пути">Логические пути</h2>

<p>Результат <code class="language-plaintext highlighter-rouge">s/conform</code> не всегда то, что мы ожидаем. Некоторые спеки оборачивают
результат в вектор, где первый элемент – часть логического пути. Такой путь
возникает в тех местах, где проверка ветвится.</p>

<p>До сих пор мы объединяли спеки через <code class="language-plaintext highlighter-rouge">s/and</code>. Такая супер-спека последовательно
проходит дочерние и выполняет проверки. Это удобно, но недостаточно. Бывает,
требуется спека-развилка, которая работает по условию. Например, если значение
число, то оставить его как есть, а если строка, то попытаться привести к
числу. Такие спеки называют условными.</p>

<p>Макрос <code class="language-plaintext highlighter-rouge">s/or</code> — одна из условных спек. Он принимает набор других спек и
тегов. Макрос применяет значение к спекам до первого положительного
случая. Результатом становится пара из нового значения и тега той спеки, что
дала положительный результат.</p>

<p>Этот тег становится частью т.н. логического пути, по которому шла
проверка. Логический путь помогает расследовать, в каком именно сценарии
произошла ошибка. Для простых спек типа это не проблема. Но в реальных проектах
бывает так, что условная спека вложена в другую условную, та тоже и т.д. Выявить
ошибку без логического пути в таких случаях трудно.</p>

<p>Если валидация не прошла, то логический путь получают из отладочной
информации. Эту информацию возвращают функции семейства <code class="language-plaintext highlighter-rouge">s/explain*</code>. Мы
рассмотрим эти функции ниже.</p>

<p>Вот как выглядит спека сетевого порта. Она принимает число или строку, которую
пытается преобразовать в число.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::smart-port</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/or</span><span class="w"> </span><span class="no">:string</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="w"> </span><span class="no">:num</span><span class="w"> </span><span class="n">int?</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь <code class="language-plaintext highlighter-rouge">s/conform</code> вернет не просто выведенное значение, а пару тег-значение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::smart-port</span><span class="w"> </span><span class="mi">8080</span><span class="p">)</span><span class="w">
</span><span class="p">[</span><span class="no">:num</span><span class="w"> </span><span class="mi">8080</span><span class="p">]</span><span class="w">

</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::smart-port</span><span class="w"> </span><span class="s">"8080"</span><span class="p">)</span><span class="w">
</span><span class="p">[</span><span class="no">:string</span><span class="w"> </span><span class="mi">8080</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Важно помнить, что если в спеке был условный узел (<code class="language-plaintext highlighter-rouge">s/or</code>, <code class="language-plaintext highlighter-rouge">s/alt</code>), то
структура <code class="language-plaintext highlighter-rouge">s/conform</code> отличается от входных данных. Например, на месте
скалярного значения появится вектор.</p>

<p>Покажем это на более сложном примере. Пусть порт — одно из полей параметров
подключения к базе данных.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:conn/port</span><span class="w"> </span><span class="no">::smart-port</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::conn</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:conn/port</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Топология выходного словаря отличается от входных данных:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::conn</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="s">"9090"</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="p">[</span><span class="no">:string</span><span class="w"> </span><span class="mi">9090</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<h2 id="анализ-ошибок">Анализ ошибок</h2>

<p>Мы уже выяснили, что в случае неудачи <code class="language-plaintext highlighter-rouge">s/valid?</code> и <code class="language-plaintext highlighter-rouge">s/conform</code> возвращают
<code class="language-plaintext highlighter-rouge">false</code> и <code class="language-plaintext highlighter-rouge">invalid</code>. Этих данных недостаточно, чтобы понять причину
ошибки. Представьте, что у вас спека пользователя системы. У пользователя набор
адресов, в каждом адресе несколько строк… и проверка вернула <code class="language-plaintext highlighter-rouge">false</code>. Поиск
ошибки вручную в таком дереве займет день.</p>

<p>Функции семейства <code class="language-plaintext highlighter-rouge">s/explain*</code> принимают спеку и данные. Если ошибок не было,
результат будет пустым. Если были, мы получим информацию о том, что пошло не
так. Разница между функциями в том, как они обрабатывают результат.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">s/explain</code> печатает текст ошибки в стандартный поток (на экран);</li>
  <li><code class="language-plaintext highlighter-rouge">s/explain-str</code> возвращает эту же информацию в виде строки;</li>
  <li><code class="language-plaintext highlighter-rouge">s/explain-data</code> возвращает словарь с данными. Это самый полный отчет об
ошибке.</li>
</ul>

<p>Рассмотрим <code class="language-plaintext highlighter-rouge">s/explain</code> и <code class="language-plaintext highlighter-rouge">s/explain-str</code>. Результат их работы одинаковый,
разница лишь в том, куда приходит текст — в консоль или переменную.</p>

<p>Подготовим простую спеку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:sample/username</span><span class="w"> </span><span class="no">::ne-string</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::sample</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:sample/username</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>На корректных данных <code class="language-plaintext highlighter-rouge">explain</code> никак не проявляет себя, разве что первый вариант
печатает <code class="language-plaintext highlighter-rouge">Success!</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/explain</span><span class="w"> </span><span class="no">::sample</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w"> </span><span class="s">"some user"</span><span class="p">})</span><span class="w">
</span><span class="n">Success!</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="p">(</span><span class="nf">s/explain-data</span><span class="w"> </span><span class="no">::sample</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w"> </span><span class="s">"some user"</span><span class="p">})</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p>Случай с ошибкой, вместо строки передано число:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/explain</span><span class="w"> </span><span class="no">::sample</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w"> </span><span class="mi">42</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>42 - failed: string? in: [:username] at: [:username] spec: ::string
</code></pre></div></div>

<p>Отчет следует читать так: значение <code class="language-plaintext highlighter-rouge">42</code> не прошло проверку на предикате
<code class="language-plaintext highlighter-rouge">string?</code>. Путь к значению внутри структуры <code class="language-plaintext highlighter-rouge">[:username]</code>. Ключ спеки, на
которой произошла ошибка – <code class="language-plaintext highlighter-rouge">::string</code>.</p>

<p>Отчет показывает самые вложенные спеки и предикаты. Вспомним, что <code class="language-plaintext highlighter-rouge">::ne-string</code>
это комбинация <code class="language-plaintext highlighter-rouge">::string</code> и <code class="language-plaintext highlighter-rouge">not-empty</code>. Ошибка случилась на этапе <code class="language-plaintext highlighter-rouge">::string</code>,
что отчет и показывает.</p>

<p>Для пустой строки вывод будет другим. На этот раз проверка оборвется на этапе
<code class="language-plaintext highlighter-rouge">not-empty</code>. Проверим это:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/explain</span><span class="w"> </span><span class="no">::sample</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w"> </span><span class="s">""</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"" - failed: not-empty in: [:username] at: [:username] spec: ::ne-string
</code></pre></div></div>

<p>Сообщения такого рода допустимы для разработчиков, например, при проверке
конфигурации на старте приложения. Но чем сложнее структура данных, тем менее
понятен отчет explain. И уж точно такое сообщение нельзя показывать
пользователям, если они ошиблись в данных. В следующем разделе мы рассмотрим эти
проблемы.</p>

<h2 id="понятные-сообщения-об-ошибках">Понятные сообщения об ошибках</h2>

<p>Когда мы проверяем данные, важно не только зафиксировать факт ошибки. Еще важнее
доступно объяснить клиенту, что именно неверно в его данных. Под клиентом не
обязательно подразумевают человека. Даже если клиент это другая программа, будет
правильно снабдить ответ понятным описанием. Скорее всего, клиент запишет
результат в лог, и его прочитает человек.</p>

<p>Многие из нас сталкивались с сообщениями вроде “Ошибка 0x00ffff” без каких-либо
деталей. Или красной надписью “проверьте данные” над формой в два экрана. Этих
глупостей можно было избежать, умей программисты переводить системные сообщения
в человеческие.</p>

<p>Очевидно, фраза <code class="language-plaintext highlighter-rouge">"" - failed: not-empty in: [:username]</code> не только ничего не
скажет пользователю, но и отпугнет его машинной природой. Возникнет ощущение,
что в интерфейсе образовалась брешь, и пользователь видит то, чего не
должен. Это резко снижает доверие к системе в целом.</p>

<p>Чтобы сформировать понятное сообщение об ошибке, воспользуемся
<code class="language-plaintext highlighter-rouge">s/explain-data</code>. Эта функция возвращает словарь со всей необходимой
информацией. Вот как он выглядит:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/explain-data</span><span class="w"> </span><span class="no">::sample</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w"> </span><span class="s">""</span><span class="p">})</span><span class="w">

</span><span class="o">#</span><span class="no">:clojure.spec.alpha</span><span class="w">
</span><span class="p">{</span><span class="no">:problems</span><span class="w">
 </span><span class="p">({</span><span class="no">:path</span><span class="w"> </span><span class="p">[</span><span class="no">:username</span><span class="p">]</span><span class="w">
   </span><span class="no">:pred</span><span class="w"> </span><span class="n">clojure.core/not-empty</span><span class="w">
   </span><span class="no">:val</span><span class="w"> </span><span class="s">""</span><span class="w">
   </span><span class="no">:via</span><span class="w"> </span><span class="p">[</span><span class="no">::sample</span><span class="w"> </span><span class="no">::ne-string</span><span class="p">]</span><span class="w">
   </span><span class="no">:in</span><span class="w"> </span><span class="p">[</span><span class="no">:username</span><span class="p">]})</span><span class="w">
 </span><span class="no">:spec</span><span class="w"> </span><span class="no">::sample</span><span class="w">
 </span><span class="no">:value</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w"> </span><span class="s">""</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>На первый взгляд непонятно, что делать с этой структурой. К сожалению, многие
разработчики пасуют перед проблемой и говорят, что spec не подходит для
ошибок. На самом деле, это отличная структура данных, нужно только правильно ее
обработать.</p>

<p>Вопрос, который задают новички – почему бы не сделать понятные сообщения сразу
на уровне библиотеки? Например, назначить спеке дополнительное поле с текстом
“введите правильный адрес”? Почему не взять пример с многочисленных фреймворков
для Python или JavaScript?</p>

<p>Ответ на этот вопрос не устраивает новичков. Вспомним тезис из начала
главы. Spec – это фундаментальная библиотека. Она не предназначена для обработки
ввода пользователя. Это набор абстракций и примитивов. То, что мы проверяем
спекой поля HTML-формы – всего лишь частный случай. Ниже мы убедимся, что у
спеки самые разные области применения. Поэтому структура ошибки тоже
фундаментальна.</p>

<p>Во-вторых, трудно создать систему ошибок, которая устроит всех. В каждом проекте
свои правила о том, как показывать ошибки. Рассмотрим поле возраста. Где-то
пишут “укажите правильный возраст”. Это фиксированное сообщение, которое не
меняется. Но в другом проекте ошибку выводят с текущим значением: “999 не
подходит под критерии возраста”. Такое сообщение уже не фиксированный текст, а
шаблон. Это значит, на одном из этапов срабатывает код, который извлекает
ошибочное значение, шаблон, форматирует текст… А теперь добавим локализацию. В
зависимости от локали браузера будем формировать сообщения на английском,
русском, французском. Это очень, очень сложные сценарии.</p>

<p>Если бы разработчики Spec занялись выводом ошибок по принципу других
фреймворков, их фокус был бы смещен с главной цели. И тогда вместо spec мы бы
получили валидаторы по типу тех, что пишут десятками для JavaScript. Они скучны,
не гибки и без концепции.</p>

<p>Словарь <code class="language-plaintext highlighter-rouge">explain-data</code> содержит ключи <code class="language-plaintext highlighter-rouge">:spec</code>, <code class="language-plaintext highlighter-rouge">:value</code> и <code class="language-plaintext highlighter-rouge">:problems</code> (с
пространством <code class="language-plaintext highlighter-rouge">clojure.spec.alpha</code>). Первые два это спека и значение, которые
принимали участие в проверке. Нас интересует поле problems. Это список
словарей. Каждый словарь описывает конкретную ошибку валидации. Перечислим его
поля и семантику.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:path</code> – Логический путь валидации. Вектор ключей, где спеки чередуются с
тегами-развилками. Условные спеки типа s/or записывают в этот вектор метки
дочерних спек.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:pred</code> – полный символ предиката, например <code class="language-plaintext highlighter-rouge">clojure.core/string?</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:val</code> – конкретное значение, которое не прошло проверку на
предикат. Например, один из элементов исходного словаря.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:via</code> – цепочка спек, по которым успело пройти значение от верхнего уровня к
нижнему.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:in</code> – физический путь к значению. Вектор ключей и индексов, который передают
в функцию <code class="language-plaintext highlighter-rouge">get-in</code>. Если выполнить <code class="language-plaintext highlighter-rouge">(get-in &lt;исходные-данные&gt; &lt;путь&gt;)</code>, то
получим значение, которое вызвало ошибку.</p>
  </li>
</ul>

<p>Видим, что отчет содержит все данные, чтобы собрать понятное сообщение. Из
<code class="language-plaintext highlighter-rouge">:val</code> возьмем конкретное неверное значение. Спека, на которой прервалась
валидация это последний элемента вектора <code class="language-plaintext highlighter-rouge">:via</code>.</p>

<p>Составим словарь сообщений, где ключ — спека, а значение — понятный текст или
шаблон. Зная спеку, в которой произошла ошибка, получим из словаря текст. Так,
последним элементом вектора <code class="language-plaintext highlighter-rouge">:via</code> была спека <code class="language-plaintext highlighter-rouge">::ne-string</code>. Логичное
сопоставить ей сообщение “Строка не должна быть пустой” или что-то похожее.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">spec-errors</span><span class="w">
  </span><span class="p">{</span><span class="no">::ne-string</span><span class="w"> </span><span class="s">"Строка не должна быть пустой"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Напишем наивную функцию, которая принимает словарь ошибки (один из элементов
<code class="language-plaintext highlighter-rouge">::s/problems</code>) и возвращает понятное сообщение:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-message</span><span class="w">
  </span><span class="p">[</span><span class="n">problem</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">via</span><span class="p">]}</span><span class="w"> </span><span class="n">problem</span><span class="w">
        </span><span class="n">spec</span><span class="w"> </span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="n">via</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">spec-errors</span><span class="w"> </span><span class="n">spec</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">get-message</span><span class="w"> </span><span class="p">{</span><span class="no">:via</span><span class="w"> </span><span class="p">[</span><span class="no">::sample</span><span class="w"> </span><span class="no">::ne-string</span><span class="p">]})</span><span class="w">
</span><span class="s">"Строка не должна быть пустой"</span><span class="w">
</span></code></pre></div></div>

<p>Рассмотрим, как это работает на других полях. Добавим спеку электронной почты и
новое поле в <code class="language-plaintext highlighter-rouge">::sample</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::email</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="no">::ne-string</span><span class="w">
   </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">re-matches</span><span class="w"> </span><span class="o">#</span><span class="s">"(.+?)@(.+?)\.(.+?)"</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:sample/email</span><span class="w"> </span><span class="no">::email</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::sample</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:sample/username</span><span class="w">
                   </span><span class="no">:sample/email</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Спека <code class="language-plaintext highlighter-rouge">::email</code> проверяет строку по наивному шаблону электронного
адреса. Регулярное выражение из примера выше читают как
<code class="language-plaintext highlighter-rouge">&lt;что-угодно&gt;@&lt;что-угодно&gt;.&lt;что-угодно&gt;</code>.</p>

<p>Если передать в email пустую строку, последним элементом via будет
<code class="language-plaintext highlighter-rouge">::ne-string</code>. Для экономии места слегка сократим вывод <code class="language-plaintext highlighter-rouge">explain-data</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/explain-data</span><span class="w"> </span><span class="no">::sample</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w"> </span><span class="s">"test"</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">""</span><span class="p">})</span><span class="w">

</span><span class="p">{</span><span class="no">:path</span><span class="w"> </span><span class="p">[</span><span class="no">:email</span><span class="p">]</span><span class="w">
 </span><span class="no">:pred</span><span class="w"> </span><span class="n">clojure.core/not-empty</span><span class="w">
 </span><span class="no">:val</span><span class="w"> </span><span class="s">""</span><span class="w">
 </span><span class="no">:via</span><span class="w"> </span><span class="p">[</span><span class="no">::sample</span><span class="w"> </span><span class="no">::email</span><span class="w"> </span><span class="no">::ne-string</span><span class="p">]</span><span class="w">
 </span><span class="no">:in</span><span class="w"> </span><span class="p">[</span><span class="no">:email</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Если передать эту ошибку в <code class="language-plaintext highlighter-rouge">get-message</code>, она вернет прежнее сообщение о пустой
строке. Но если email был непустой строкой, которая не попала под шаблон
регулярного выражения, то последним элементом <code class="language-plaintext highlighter-rouge">:via</code> будет
<code class="language-plaintext highlighter-rouge">:sample/email</code>. Полный словарь ошибки выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:path</span><span class="w"> </span><span class="p">[</span><span class="no">:email</span><span class="p">]</span><span class="w">
 </span><span class="no">:pred</span><span class="w">
 </span><span class="p">(</span><span class="nf">clojure.core/partial</span><span class="w">
  </span><span class="n">clojure.core/re-matches</span><span class="w">
  </span><span class="o">#</span><span class="s">"(.+?)@(.+?)\.(.+?)"</span><span class="p">)</span><span class="w">
 </span><span class="no">:val</span><span class="w"> </span><span class="s">"test"</span><span class="w">
 </span><span class="no">:via</span><span class="w"> </span><span class="p">[</span><span class="no">::sample</span><span class="w"> </span><span class="no">::email</span><span class="p">]</span><span class="w">
 </span><span class="no">:in</span><span class="w"> </span><span class="p">[</span><span class="no">:email</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы <code class="language-plaintext highlighter-rouge">get-message</code> вернул другое сообщение, добавим в словарь ошибок ключ
<code class="language-plaintext highlighter-rouge">::email</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">spec-errors</span><span class="w">
  </span><span class="p">{</span><span class="no">::ne-string</span><span class="w"> </span><span class="s">"Строка не должна быть пустой"</span><span class="w">
   </span><span class="no">::email</span><span class="w"> </span><span class="s">"Введите правильный почтовый адрес"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Остается наращивать словарь все новыми спеками и сообщениями, пока не закроем
все возможные ошибки. Но это линейный подход. Существует несколько способов
улучшить поиск сообщений.</p>

<p>Например, что случится, если нужного перевода не окажется в словаре? В этом
случае вернем нейтральное “исправьте ошибки в поле”. Заодно зафиксируем факт
того, что перевод не был найден. Проще всего это сделать записью в лог.</p>

<p>Нормально, что команды разработки и локализации иногда не согласованы. Команда
локализаторов время от времени просматривает этот лог и добавляет переводы.</p>

<p>Рассмотрим, как упростить поиск поля в словаре. Поле <code class="language-plaintext highlighter-rouge">email</code> может встречаться в
разных спеках: <code class="language-plaintext highlighter-rouge">:account/email</code>, <code class="language-plaintext highlighter-rouge">:patient/email</code>, <code class="language-plaintext highlighter-rouge">:client/email</code>. Линейный
подход из примера выше требует, чтобы для каждого такого ключа было сообщение об
ошибке. Это склоняет нас к повторам в коде.</p>

<p>Чтобы не засорять словарь переводов, пойдем на хитрость. Пусть функция поиска
пытается найти сообщение по полному ключу, а в случае неудачи — по его
имени. Тогда достаточно ключа <code class="language-plaintext highlighter-rouge">:email</code>, и все емейлы будут сходиться на этот
перевод. Если для одного конкретного емейла нужен особый перевод, добавим его
полную версию в словарь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">spec-errors</span><span class="w">
  </span><span class="p">{</span><span class="no">::ne-string</span><span class="w"> </span><span class="s">"Строка не должна быть пустой"</span><span class="w">
   </span><span class="no">:email</span><span class="w"> </span><span class="s">"Введите правильный почтовый адрес"</span><span class="w">
   </span><span class="no">:account/email</span><span class="w"> </span><span class="s">"Особое сообщение для адреса отправителя"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Объединим вышесказанное в одну функцию. Вот как выглядит поиск в словаре с
учетом неполного ключа и ошибки по умолчанию.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">default-message</span><span class="w">
  </span><span class="s">"Исправьте ошибки в поле"</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-better-message</span><span class="w">
  </span><span class="p">[</span><span class="n">problem</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">via</span><span class="p">]}</span><span class="w"> </span><span class="n">problem</span><span class="w">
        </span><span class="n">spec</span><span class="w"> </span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="n">via</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">or</span><span class="w">
     </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">spec-errors</span><span class="w"> </span><span class="n">spec</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">spec-errors</span><span class="w">
          </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">spec</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="nb">keyword</span><span class="p">))</span><span class="w">
     </span><span class="n">default-message</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Система, которую мы построили, достаточно проста. Ее легко тестировать и
изменять под нужды конкретного проекта. Автор использовал доработанные версии
такой системы в реальных проектах. В одном из случаев формы полностью
проверялись на стороне клиента до их отправки на сервер. Это возможно, поскольку
код на Clojure компилируется в JavaScript. Мощь clojure.spec в полной мере
доступна на клиенте.</p>

<p>До сих пор мы использовали фиксированные сообщения. Но легко сделать их
шаблонами, куда подставляют текущее значение или имя поля. В этом случае
исправления в коде минимальны.</p>

<p>Получим имя поля как последний отличный от цифры элемент вектора <code class="language-plaintext highlighter-rouge">:in</code>. Ключ
<code class="language-plaintext highlighter-rouge">:val</code> хранит текущее ошибочное значение. В тексте сообщения расставим <code class="language-plaintext highlighter-rouge">%s</code> для
имени поля и значения. Функция <code class="language-plaintext highlighter-rouge">(format &lt;шаблон&gt; &lt;поле&gt; &lt;значение&gt;)</code> вернет
что-то вроде “Поле email содержит неверное значение test.com”.</p>

<p>За рамками главы остались несколько вопросов. Первый — что делать, если
требуется локализация сообщения, то есть вывод на русском или английском в
зависимости от состояния? Очевидно, наша структура станет словарем словарей, где
на первом уровне будет код локали (ru, en), а на втором — переводы для спек.</p>

<p>Теперь на первом шаге мы получаем по локали словарь переводов, затем переводим
как описано выше. С кодом локали тоже можно схитрить, чтобы облегчить
поиск. Например, иногда требуется различные написания для локалей <code class="language-plaintext highlighter-rouge">en_US</code> и
<code class="language-plaintext highlighter-rouge">en_GB</code>. Реализуем функцию поиска так, что сперва она ищет по младшей локали
(<code class="language-plaintext highlighter-rouge">en_US</code>), а затем по старшей (<code class="language-plaintext highlighter-rouge">en</code>).</p>

<p>Вопрос откуда приходит локаль остается на усмотрение разработчика. Ее можно
хранить в сессии, параметрах адресной строки, базе данных, глобальной
переменной, словом — как это удобно в текущем проекте.</p>

<p>Второй вопрос — как связать вывод ошибок с интерфейсом пользователя. Это тоже
зависит от конкретного проекта. Хорошей практикой считается отделение модели от
ее представления. Это верно и для форм. Удобно, когда форма — это структура
данных с набором функций. Тогда все операции над ней будут чистыми функциями,
которые легко поддерживать.</p>

<p>Представим форму как дерево, в листьях которого структура виджета. Виджет знает
тип поля, текущее значение и ошибку. Специальный react-компонент подписан на
этот лист дерева. На каждое его изменения компонент рисует HTML-элемент,
например, поле ввода с текущим текстом. Если поле ошибки не <code class="language-plaintext highlighter-rouge">nil</code>, то оно
выводится над полем.</p>

<p>Функция валидации принимает дерево формы. Она строит дерево значений. Это
структура с той же топологией, но вместо листьев-виджетов на их местах
значения. С помощью спеки мы проверяем значения (<code class="language-plaintext highlighter-rouge">s/valid?</code>) или выводим
правильные типы из текста. В случае ошибки мы получаем отчет
(<code class="language-plaintext highlighter-rouge">s/explain-data</code>). Для каждого элемента из поле problems находим путь, спеку и
сообщение об ошибке. Это сообщение добавляем в соответствующий виджет в поле
<code class="language-plaintext highlighter-rouge">:error</code>. Компонент, который отрисовывает этот виджет, уведомит пользователя об
ошибке.</p>

<h2 id="парсинг">Парсинг</h2>

<p>До сих пор мы обсуждали проверку данных и вывод значений. Теперь рассмотрим
операцию более высокого уровня — парсинг. Под парсингом понимают разбор данных
на части, выделение структуры там, где прежде ее не было.</p>

<p>Читателю наверняка приходилось парсить текст регулярными выражениями. Это особые
шаблоны, которые описывают структуру фрагмента. Специальные функции принимают
исходный текст и регулярное выражение. Структура результата известна
заранее. Например, это список фрагментов, которые совпали с шаблоном.</p>

<p>Простейший пример регулярного выражения — IP-адрес. Это четыре группы,
разделенные точками. Каждая группа состоит из числа от 0 до 255.</p>

<pre><code class="language-regex">\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
</code></pre>

<p>В примере выше мы ставим косую черту перед точкой. В регулярных выражениях точка
это служебный символ. Мы экранируем его, чтобы описать именно символ точки.</p>

<p>В регулярных выражениях применяют операторы <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">*</code> и другие. Они
указывают, сколько раз встречается данный шаблон. Например, один и более раз, ни
одного или один, произвольное число или ни одного. В зависимости от
модификатора, шаблон захватывает разные части текста.</p>

<p>Можно представить, что регулярные выражения откусывают текст частями. Та часть,
что легла на шаблон, наполняет структурированный результат. Оставшийся текст
передается следующим шаблонам, и так далее.</p>

<p>Регулярные выражения подводят нас к regex-спекам. Это особый тип спек для
разбора данных по шаблону. Разница в том, что и шаблон, и исходные данные это
структуры, а не текст.</p>

<p>Предположим, мы читаем из текстового файла список пользователей. Каждый
пользователь это кортеж вида &lt;номер, емейл, статус&gt;. Все значения в виде
текста. Для каждого пользователя требуется:</p>

<ul>
  <li>убедиться, что в кортеже именно три элемента;</li>
  <li>привести номер к числу;</li>
  <li>проверить емейл на минимальные критерии;</li>
  <li>привести статус к системному перечислению (одной из констант).</li>
</ul>

<p>В идеале получить словарь с верными значениями.</p>

<p>Мы уже знакомы с <code class="language-plaintext highlighter-rouge">s/conformer</code>. Мы могли бы написать функцию, которая принимает
кортеж пользователя и выполняет описанные выше преобразования. Технически это
несложно. Но такая функция будет монолитной со слишком большим скоупом. Это
плохая практика при работе с clojure.spec.</p>

<p>Для разбиения коллекций подходит <code class="language-plaintext highlighter-rouge">s/cat</code>. Эта спека принимает последовательность
тегов и спек. На вход s/cat подают коллекцию значений, например список или
вектор. Спека накладывает элементы коллекции на спеки. Если они совпали,
результатом будет словарь. Ключи этого словаря — теги спек, значения — результат
применения спеки к соответствующему значению.</p>

<p>Составим спеку для разбора кортежа. У нас уже есть парсинг чисел и проверка
мейла. Опишем вывод статуса и соберем композицию спек:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:user/status</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="n">-&gt;lower</span><span class="w">
   </span><span class="p">(</span><span class="nf">with-conformer</span><span class="w"> </span><span class="nb">val</span><span class="w">
     </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="nb">val</span><span class="w">
       </span><span class="s">"active"</span><span class="w"> </span><span class="no">:USER_ACTIVE</span><span class="w">
       </span><span class="s">"pending"</span><span class="w"> </span><span class="no">:USER_PENDING</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::user</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/cat</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="w">
         </span><span class="no">:email</span><span class="w"> </span><span class="no">::email</span><span class="w">
         </span><span class="no">:status</span><span class="w"> </span><span class="no">:user/status</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Проверим положительный случай:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::user</span><span class="w"> </span><span class="p">[</span><span class="s">"1"</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="s">"active"</span><span class="p">])</span><span class="w">
</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w">
 </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w">
 </span><span class="no">:status</span><span class="w"> </span><span class="no">:USER_ACTIVE</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Варианты с плохим номером, почтой или не тем статусом не проходят
преобразование. Примеры ниже вернут <code class="language-plaintext highlighter-rouge">::s/invalid</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::user</span><span class="w"> </span><span class="p">[</span><span class="s">""</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="s">"active"</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::user</span><span class="w"> </span><span class="p">[</span><span class="s">"1"</span><span class="w"> </span><span class="s">"@test.com"</span><span class="w"> </span><span class="s">"active"</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::user</span><span class="w"> </span><span class="p">[</span><span class="s">"1"</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="s">"unknown"</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>В примере с пользователем число полей в кортеже фиксировано. На практике так
бывает не всегда. Мы все еще сталкиваемся с устаревшими форматами данных. В
таких форматах бывают условия вроде “если перед номером строка <code class="language-plaintext highlighter-rouge">BLOCKED</code>, то
пользователь заблокирован.” Это осложняет задачу, ведь теперь в кортеж состоит
или из трех, или четырех элементов. Кроме того, сдвигается семантика
полей. Первый элемент теперь не только номер, но и флаг блокировки. Встречаются
и более сложные условия.</p>

<p>В императивных языка типа Python и Java такие требования порождают каскад
<code class="language-plaintext highlighter-rouge">if/else</code> с перезаписью переменных. В Clojure эту проблему решают
декларативно. Объявим спеку для флага блокировки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::blocked</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="n">-&gt;lower</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w">
    </span><span class="o">#</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="s">"blocked"</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Добавим ее в итоговую <code class="language-plaintext highlighter-rouge">s/cat</code>, но укажем, что она встречается ноль или один раз:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::user</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/cat</span><span class="w"> </span><span class="no">:blocked</span><span class="w"> </span><span class="p">(</span><span class="nf">s/?</span><span class="w"> </span><span class="no">::blocked</span><span class="p">)</span><span class="w">
         </span><span class="no">:id</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="w">
         </span><span class="no">:email</span><span class="w"> </span><span class="no">::email</span><span class="w">
         </span><span class="no">:status</span><span class="w"> </span><span class="no">:user/status</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь оба типа кортежа попадают под действие спеки. Если пользователь
заблокирован, в итоговом словаре будет поле <code class="language-plaintext highlighter-rouge">:blocked</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::user</span><span class="w"> </span><span class="p">[</span><span class="s">"1"</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="s">"active"</span><span class="p">])</span><span class="w">
</span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="no">:status</span><span class="w"> </span><span class="no">:USER_ACTIVE</span><span class="p">}</span><span class="w">

</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::user</span><span class="w"> </span><span class="p">[</span><span class="s">"Blocked"</span><span class="w"> </span><span class="s">"1"</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="s">"active"</span><span class="p">])</span><span class="w">
</span><span class="p">{</span><span class="no">:blocked</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="no">:status</span><span class="w"> </span><span class="no">:USER_ACTIVE</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Представим теперь, что на входе коллекция кортежей. Чтобы не утруждать себя
ручной итерацией, объявим спеку-коллекцию:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::users</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/coll-of</span><span class="w"> </span><span class="no">::user</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user-data</span><span class="w">
  </span><span class="p">[[</span><span class="s">"1"</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="s">"active"</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="s">"Blocked"</span><span class="w"> </span><span class="s">"2"</span><span class="w"> </span><span class="s">"joe@doe.com"</span><span class="w"> </span><span class="s">"pending"</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::users</span><span class="w"> </span><span class="n">user-data</span><span class="p">)</span><span class="w">

</span><span class="p">[{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"test@test.com"</span><span class="w"> </span><span class="no">:status</span><span class="w"> </span><span class="no">:USER_ACTIVE</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:blocked</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:email</span><span class="w"> </span><span class="s">"joe@doe.com"</span><span class="w"> </span><span class="no">:status</span><span class="w"> </span><span class="no">:USER_PENDING</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>Отсеять заблокированных пользователей можно функцией <code class="language-plaintext highlighter-rouge">filter</code> с предикатом
<code class="language-plaintext highlighter-rouge">(complement :blocked)</code>.</p>

<p>С помощью regex-спек можно парсить не только данные, но и текст. Рассмотрим, как
распарсить INI-файл в словарь данных. Напомним, INI — это старый текстовый
формат для конфигурации приложений. Он состоит из секций в квадратных скобках и
пар <code class="language-plaintext highlighter-rouge">поле=значение</code>.</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># config.ini
</span>
<span class="nn">[database]</span>
<span class="py">host</span><span class="p">=</span><span class="s">localhost</span>
<span class="py">port</span><span class="p">=</span><span class="s">5432</span>
<span class="py">user</span><span class="p">=</span><span class="s">test</span>

<span class="nn">[server]</span>
<span class="py">host</span><span class="p">=</span><span class="s">127.0.0.1</span>
<span class="py">port</span><span class="p">=</span><span class="s">8080</span>
</code></pre></div></div>

<p>Хотелось бы получить из файла вложенный словарь вида:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:database</span><span class="w"> </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="s">"localhost"</span><span class="w">
            </span><span class="no">:port</span><span class="w"> </span><span class="mi">5432</span><span class="p">}</span><span class="w">
 </span><span class="no">:server</span><span class="w"> </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Если отбросить пустые и закомментированные строки, то структура файла сводится к
грамматике <code class="language-plaintext highlighter-rouge">(&lt;section&gt;, &lt;key=value&gt;*)*</code>, где звездочка означает сколько угодно
раз, в т.ч. ничего.</p>

<p>Сперва прочитаем строки из файла обычной функцией. Эта функция не должна быть
частью спеки. Спеки не должны иметь побочных эффектов, они только
преобразовывают данные.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.java.io</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">io</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-ini-lines</span><span class="w">
  </span><span class="p">[</span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">with-open</span><span class="w"> </span><span class="p">[</span><span class="n">src</span><span class="w"> </span><span class="p">(</span><span class="nf">io/reader</span><span class="w"> </span><span class="nb">path</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">doall</span><span class="w"> </span><span class="p">(</span><span class="nb">line-seq</span><span class="w"> </span><span class="n">src</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь составим спеку-парсер. Решим, что такая спека принимает список строк из
ini-файла. Требуется выполнить следующие шаги:</p>

<ul>
  <li>удалить пустые строки и комментарии;</li>
  <li>оставшиеся строки сгруппировать по заголовкам, распарсить пары поле=значение;</li>
  <li>реструктурировать данные во вложенный словарь;</li>
  <li>вывести типы и все проверить.</li>
</ul>

<p>Выразим это в коде:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;ini-config</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">clear-ini-lines</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/*</span><span class="w"> </span><span class="p">(</span><span class="nf">s/cat</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="no">:ini/title</span><span class="w"> </span><span class="no">:fields</span><span class="w"> </span><span class="p">(</span><span class="nf">s/*</span><span class="w"> </span><span class="no">:ini/field</span><span class="p">)))</span><span class="w"> </span><span class="c1">;; 4</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">remap-ini-data</span><span class="p">)</span><span class="w">
   </span><span class="no">::ini-config</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Убедитесь, что поняли смысл четвертой строки. Мы считаем, что INI-файл это ноль
и более блоков. Каждый блок состоит из заголовка и ноль и более пар
ключ-значение.</p>

<p>Реализуем недостающие элементы. Функция <code class="language-plaintext highlighter-rouge">clear-ini-lines</code> выбрасывает незначащие
строки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">comment?</span><span class="w">
  </span><span class="p">[</span><span class="n">line</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">str/starts-with?</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="s">"#"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">clear-ini-lines</span><span class="w">
  </span><span class="p">[</span><span class="n">lines</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">lines</span><span class="w">
       </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="nb">complement</span><span class="w"> </span><span class="n">str/blank?</span><span class="p">))</span><span class="w">
       </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="nb">complement</span><span class="w"> </span><span class="n">comment?</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Объявим спеку <code class="language-plaintext highlighter-rouge">:ini/title</code>. Она проверяет, заголовок ли текущая строка или
нет. Заголовок определяют квадратные скобки на границах строки. Если условие
выполняется, вернем текст заголовка без скобок:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:ini/title</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="o">#</span><span class="p">(</span><span class="nf">str/starts-with?</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="s">"["</span><span class="p">)</span><span class="w">
   </span><span class="o">#</span><span class="p">(</span><span class="nf">str/ends-with?</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="s">"]"</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">with-conformer</span><span class="w"> </span><span class="nb">val</span><span class="w">
     </span><span class="p">(</span><span class="nb">subs</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="nb">val</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Спека <code class="language-plaintext highlighter-rouge">:ini/field</code> парсит поле и значение. Просто разбиваем строку по знаку
равенства. Цифра 2 означает, что в итоговом списке должно быть не более двух
элементов: ключ и значение. Это полезно, когда значение содержит знак равенства
(например, base64 строка).</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:ini/field</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-conformer</span><span class="w"> </span><span class="nb">val</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="nb">key</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">pair</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="nb">val</span><span class="w"> </span><span class="o">#</span><span class="s">"="</span><span class="w"> </span><span class="mi">2</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="nb">val</span><span class="p">)</span><span class="w">
        </span><span class="n">pair</span><span class="w">
        </span><span class="no">::s/invalid</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>В примере выше мы убеждаемся, что действительно получили ключ и значение. Так мы
исключим строки, в которых нет знака равенства.</p>

<p>На текущий момент запустим черновую, урезанную версию спеки:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;ini-config</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">clear-ini-lines</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/*</span><span class="w"> </span><span class="p">(</span><span class="nf">s/cat</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="no">:ini/title</span><span class="w"> </span><span class="no">:fields</span><span class="w"> </span><span class="p">(</span><span class="nf">s/*</span><span class="w"> </span><span class="no">:ini/field</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">parse</span><span class="w">
  </span><span class="p">[</span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">lines</span><span class="w"> </span><span class="p">(</span><span class="nf">get-ini-lines</span><span class="w"> </span><span class="nb">path</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">s/conform</span><span class="w"> </span><span class="no">::-&gt;ini-config</span><span class="w"> </span><span class="n">lines</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nb">parse</span><span class="w"> </span><span class="s">"config.ini"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="no">:title</span><span class="w"> </span><span class="s">"database"</span><span class="w">
  </span><span class="no">:fields</span><span class="w"> </span><span class="p">[[</span><span class="s">"host"</span><span class="w"> </span><span class="s">"localhost"</span><span class="p">]</span><span class="w">
           </span><span class="p">[</span><span class="s">"port"</span><span class="w"> </span><span class="s">"5432"</span><span class="p">]</span><span class="w">
           </span><span class="p">[</span><span class="s">"user"</span><span class="w"> </span><span class="s">"test"</span><span class="p">]]}</span><span class="w">
 </span><span class="p">{</span><span class="no">:title</span><span class="w"> </span><span class="s">"server"</span><span class="w">
  </span><span class="no">:fields</span><span class="w"> </span><span class="p">[[</span><span class="s">"host"</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="p">]</span><span class="w">
           </span><span class="p">[</span><span class="s">"port"</span><span class="w"> </span><span class="s">"8080"</span><span class="p">]]}]</span><span class="w">
</span></code></pre></div></div>

<p>Разбор файла прошел удачно. Читатель заметит, что структура словаря отличается
от той, что мы предложили вначале. Это неважно. Главное, нам удалось привести
набор строк к определенному формату. Не составит труда обработать словарь
функцией <code class="language-plaintext highlighter-rouge">remap-ini-data</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remap-ini-data</span><span class="w">
  </span><span class="p">[</span><span class="n">data-old</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">data-new</span><span class="w"> </span><span class="n">entry</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">title</span><span class="w"> </span><span class="n">fields</span><span class="p">]}</span><span class="w"> </span><span class="n">entry</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">data-new</span><span class="w"> </span><span class="n">title</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">fields</span><span class="p">))))</span><span class="w">
   </span><span class="p">{}</span><span class="w">
   </span><span class="n">data-old</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Если передать в эту функцию вектор из предыдущего шага, результат будет тем, что
мы ожидали:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="s">"database"</span><span class="w"> </span><span class="p">{</span><span class="s">"host"</span><span class="w"> </span><span class="s">"localhost"</span><span class="w"> </span><span class="s">"port"</span><span class="w"> </span><span class="s">"5432"</span><span class="w"> </span><span class="s">"user"</span><span class="w"> </span><span class="s">"test"</span><span class="p">}</span><span class="w">
 </span><span class="s">"server"</span><span class="w"> </span><span class="p">{</span><span class="s">"host"</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w"> </span><span class="s">"port"</span><span class="w"> </span><span class="s">"8080"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Напишем спеку, чтобы проверить конфигурацию и вывести типы. Например, чтобы
номера портов были числами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:db/host</span><span class="w"> </span><span class="no">::ne-string</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:db/port</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:db/user</span><span class="w"> </span><span class="no">::ne-string</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::database</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:db/host</span><span class="w">
                   </span><span class="no">:db/port</span><span class="w">
                   </span><span class="no">:db/user</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:server/host</span><span class="w"> </span><span class="no">::ne-string</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:server/port</span><span class="w"> </span><span class="no">::-&gt;int</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::server</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">:server/host</span><span class="w">
                   </span><span class="no">:server/port</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::ini-config</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">::database</span><span class="w">
                   </span><span class="no">::server</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Перед тем, как применять словарь к этой спеке, следует перевести его ключи из
строк в кейворды. Вот как выглядит итоговая спека:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.walk</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">walk</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::-&gt;ini-config</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">clear-ini-lines</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/*</span><span class="w"> </span><span class="p">(</span><span class="nf">s/cat</span><span class="w"> </span><span class="no">:title</span><span class="w"> </span><span class="no">:ini/title</span><span class="w"> </span><span class="no">:fields</span><span class="w"> </span><span class="p">(</span><span class="nf">s/*</span><span class="w"> </span><span class="no">:ini/field</span><span class="p">)))</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">remap-ini-data</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/conformer</span><span class="w"> </span><span class="n">walk/keywordize-keys</span><span class="p">)</span><span class="w">
   </span><span class="no">::ini-config</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>И результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">parse</span><span class="w"> </span><span class="s">"config.ini"</span><span class="p">)</span><span class="w">

</span><span class="p">{</span><span class="no">:database</span><span class="w"> </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="s">"localhost"</span><span class="w">
            </span><span class="no">:port</span><span class="w"> </span><span class="mi">5432</span><span class="w">
            </span><span class="no">:user</span><span class="w"> </span><span class="s">"test"</span><span class="p">}</span><span class="w">
 </span><span class="no">:server</span><span class="w"> </span><span class="p">{</span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
          </span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Упражнение: устраните мелкие недоработки в коде выше. Пусть пара <code class="language-plaintext highlighter-rouge">"foo="</code>
становится <code class="language-plaintext highlighter-rouge">{:foo nil}</code>, а не <code class="language-plaintext highlighter-rouge">{:foo ""}</code>.  Удалите пустые символы, которые
могли остаться по краям ключа и значения. Опробуйте парсинг на больших
ini-файлах.</p>

<h2 id="разбор-clojure-кода-теория">Разбор Clojure-кода (теория)</h2>

<p>В завершении темы немного поговорим о том, как парсить код. Мы уже видели, что
clojure.spec подходит для разбора структур данных — в основном
последовательностей. Вспомним, что код на Clojure состоит из списков. Это
приводит к неожиданному решению: оказывается, исходный код на Clojure можно
проверить спекой и вернуть ошибку еще до того, как он запущен.</p>

<p>В начале главы мы упоминали, что Clojure и Spec неразрывно связаны. Объясним эту
связь на примере макросов. Большинство форм в Clojure представлены
макросами. Это особые функции, которые срабатывают на этапе компиляции
кода. Макрос принимает код как список символов. Задача макроса, как правило, в
том, чтобы перестроить этот список в другой и вернуть его. Компилятор заменяет
макрос на список-результат и выполняет его.</p>

<p>Макросы это отдельная веха в изучении Clojure. Мы поговорим о них в другой
главе. Пока что заострим внимание на том, как проверить тело макроса.</p>

<p>Каждый макрос это по сути мини-язык с соглашением о том, что и в каком порядке
передавать. Иногда один и тот же макрос допускает разные формы записи. По
аналогии с языком, требуется разобрать грамматику кода. В случае ошибки доступно
объяснить программисту, где он ошибся.</p>

<p>Хорошим примером служит <code class="language-plaintext highlighter-rouge">defn</code>, макрос определения функции. Кроме обязательных
параметров он принимает несколько второстепенных: строку документации, пре- и
пост-проверки. Справедлива форма записи с несколькими телами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-inc</span><span class="w">
  </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-inc</span><span class="w">
  </span><span class="s">"Increase a number"</span><span class="w">
  </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:pre</span><span class="w"> </span><span class="p">[(</span><span class="nf">int?</span><span class="w"> </span><span class="n">x</span><span class="p">)]</span><span class="w">
   </span><span class="no">:post</span><span class="w"> </span><span class="p">[(</span><span class="nf">int?</span><span class="w"> </span><span class="n">%</span><span class="p">)]}</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-inc</span><span class="w">
  </span><span class="p">([</span><span class="n">x</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">my-inc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="n">delta</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">delta</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Все это одна и та же функция, записанная по-разному. Очевидно, ручной разбор
всех вариантов трудоемок. До версии Clojure 1.10 каждый макрос разбирал код по
собственным правилам. Это было неорганизованно и неконсистентно. Начиная с 1.10
большинство макросов используют спеку для проверки и вывода ошибок. Так
образовался общий подход к проблеме, который легко контролировать.</p>

<p>Разберем устно, как бы мы построили спеку для разбора <code class="language-plaintext highlighter-rouge">defn</code>. Очевидно, это
список, поэтому на верхнем уровне спеки поместим s/cat. Первый его элемент —
символ <code class="language-plaintext highlighter-rouge">defn</code>. Второй — символ с именем. После имени следует опциональный параметр
строки документации. Затем тело или список тел.</p>

<p>Тело начинается с вектор параметров. После него идет опциональный словарь пре- и
пост- проверок. Затем произвольное количество форм, которые составляют тело
функции.</p>

<p>Грубая версия:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::defn</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/cat</span><span class="w"> </span><span class="no">:tag</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="ss">'defn</span><span class="p">)</span><span class="w">
         </span><span class="no">:name</span><span class="w"> </span><span class="nb">symbol?</span><span class="w">
         </span><span class="no">:docstring</span><span class="w"> </span><span class="nb">string?</span><span class="w">
         </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">s/+</span><span class="w"> </span><span class="no">:defn/body</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>, где тело функции это</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">:defn/body</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/cat</span><span class="w"> </span><span class="no">:args</span><span class="w"> </span><span class="no">:defn/args</span><span class="w">
         </span><span class="no">:prepost</span><span class="w"> </span><span class="p">(</span><span class="nf">s/?</span><span class="w"> </span><span class="nb">map?</span><span class="p">)</span><span class="w">
         </span><span class="no">:code</span><span class="w"> </span><span class="no">:defn/code</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>В свободное время напишите такую спеку. Передайте в нее замороженную версию
<code class="language-plaintext highlighter-rouge">defn</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/conform</span><span class="w">
 </span><span class="no">::defn</span><span class="w">
 </span><span class="o">'</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-inc</span><span class="w">
    </span><span class="s">"Increase a number"</span><span class="w">
    </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
    </span><span class="p">{</span><span class="no">:pre</span><span class="w"> </span><span class="p">[(</span><span class="nf">int?</span><span class="w"> </span><span class="n">x</span><span class="p">)]</span><span class="w">
     </span><span class="no">:post</span><span class="w"> </span><span class="p">[(</span><span class="nf">int?</span><span class="w"> </span><span class="n">%</span><span class="p">)]}</span><span class="w">
    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Результатом будет что-то отдаленно напоминающее:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="n">my-inc</span><span class="w">
  </span><span class="no">:docstring</span><span class="w"> </span><span class="s">"Increase a number"</span><span class="w">
  </span><span class="no">:bodies</span><span class="w">
  </span><span class="p">[{</span><span class="no">:params</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
    </span><span class="no">:declaration</span><span class="w"> </span><span class="p">[(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w">
    </span><span class="c1">;; other fields}]}</span><span class="w">
</span></code></pre></div></div>

<p>Каждый следующий уровень можно расширить вглубь. Выше мы упомянули вектор
параметров. Будет здорово разобрать их на обязательные и
необязательные. Например, чтобы параметры <code class="language-plaintext highlighter-rouge">[x y &amp; other]</code> предстали в виде
словаря:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:required</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="no">:rest</span><span class="w"> </span><span class="n">other</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Усложните спеку так, чтобы она различала параметры функции. По аналогии
выполните разбор словаря пре- и пост- проверок.</p>

<h2 id="спецификация-функций">Спецификация функций</h2>

<p>В последнем разделе мы поговорим о том, как clojure.spec связана с функциями. Мы
уже упоминали проблему с проверкой входных данных. Даже если параметры нужного
типа, это не гарантирует, что значения верны. Вспомним функцию, которая
принимает диапазон дат. Случай, когда ее вызвали с параметрами
<code class="language-plaintext highlighter-rouge">start=2010.01.01</code> и <code class="language-plaintext highlighter-rouge">end=2009.01.01</code>, не имеет смысла.</p>

<p>Логично описать параметры этой функции спекой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::date-range-args</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/and</span><span class="w">
   </span><span class="p">(</span><span class="nf">s/cat</span><span class="w"> </span><span class="no">:start</span><span class="w"> </span><span class="n">inst?</span><span class="w"> </span><span class="no">:end</span><span class="w"> </span><span class="n">inst?</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">start</span><span class="w"> </span><span class="n">end</span><span class="p">]}]</span><span class="w">
     </span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="nf">compare</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Вторая функция из <code class="language-plaintext highlighter-rouge">s/and</code> принимает результат первого <code class="language-plaintext highlighter-rouge">s/cat</code>, то есть словарь с
ключами <code class="language-plaintext highlighter-rouge">:start</code> и <code class="language-plaintext highlighter-rouge">:end</code>. Для сравнения дат используют специальную функцию
compare, которая возвращает -1, 0 и 1 для случаев меньше, равно и
больше. Быстрая проверка:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::date-range-args</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019"</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2020"</span><span class="p">])</span><span class="w"> </span><span class="c1">;; true</span><span class="w">
</span><span class="p">(</span><span class="nf">s/valid?</span><span class="w"> </span><span class="no">::date-range-args</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2020"</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019"</span><span class="p">])</span><span class="w"> </span><span class="c1">;; false</span><span class="w">
</span></code></pre></div></div>

<p>Возникает идея написать декоратор, который принимает целевую функцию и спеку ее
параметров. Перед тем, как запускать функцию, он проверит параметры и в случае
ошибки выкинет исключение. То же самое можно проделать для результата функции.</p>

<p>Нам не придется писать декоратор, потому что его включили в поставку
clojure.spec. Речь идет о функции <code class="language-plaintext highlighter-rouge">clojure.spec.test.alpha/instrument</code>. Глагол
instrument дословно означает оснастить, оборудовать.</p>

<p>Функция принимает символ другой функции, которую мы хотим оснастить
проверкой. Вместе с тем она ищет особую функциональную спеку, зарегистрированную
под этим же символом. Когда обе сущности найдены, instrument подменяет функцию
на такую же, но с проверками. Это своего рода monkey patch, когда один модуль
изменяет поведение другого.</p>

<p>Функциональную спеку объявляют макросом <code class="language-plaintext highlighter-rouge">s/fdef</code>. Сначала передают символ
функции, которую хотели бы оснастить. Затем отдельные спеки для проверки
входящих параметров, результата и их композиции.</p>

<p>В качестве примера напишем функцию и спеку к ней. Пусть это будет функция,
которая возвращает разницу между двумя датами в секундах. В отличие от примера
выше, мы допускаем случай, когда первая дата болье второй. В этом случае разница
в секундах будет отрицательной.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="ss">'java.util.Date</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">date-range-sec</span><span class="w">
  </span><span class="s">"Return a difference between two dates in seconds."</span><span class="w">
  </span><span class="p">[</span><span class="o">^</span><span class="n">Date</span><span class="w"> </span><span class="n">date1</span><span class="w"> </span><span class="o">^</span><span class="n">Date</span><span class="w"> </span><span class="n">date2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">quot</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nf">.getTime</span><span class="w"> </span><span class="n">date2</span><span class="p">)</span><span class="w">
           </span><span class="p">(</span><span class="nf">.getTime</span><span class="w"> </span><span class="n">date1</span><span class="p">))</span><span class="w">
        </span><span class="mi">1000</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Теги <code class="language-plaintext highlighter-rouge">^Date</code> нужны, чтобы компилятор знал тип объектов date1 и date2. В
противном случае компилятор выполнит рефлексию, чтобы узнать тип. Это съедает
машинное время. Мы поговорим о типах в отдельной главе.</p>

<p>Посчитаем разницу в сутках:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">date-range-sec</span><span class="w">
 </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019-01-01"</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019-01-02"</span><span class="p">)</span><span class="w">
</span><span class="mi">86400</span><span class="w">
</span></code></pre></div></div>

<p>Если поменять даты местами, результат будет отрицательным.</p>

<p>Опишем функциональную спеку. Ее символ будет <code class="language-plaintext highlighter-rouge">date-range-sec</code>.  Под ключом
<code class="language-plaintext highlighter-rouge">:args</code> указывают спеку входящих параметров. Поскольку параметры это список, на
верхнем уровне почти всегда <code class="language-plaintext highlighter-rouge">s/cat</code>. Его задача разбить список на словарь, чтобы
спекам ниже было удобно работать с отдельными значениями.</p>

<p>Под <code class="language-plaintext highlighter-rouge">:ret</code> указана спека выходного значения. Чаще всего это проверка на число
или строку. Например, <code class="language-plaintext highlighter-rouge">int?</code>, <code class="language-plaintext highlighter-rouge">string?</code> или их nilable-версии: <code class="language-plaintext highlighter-rouge">(s/nilable int)</code>
и так далее.</p>

<p>Ключ <code class="language-plaintext highlighter-rouge">:fn</code> особый. Это спека, которая будет вызвана в контексте входных
параметров и результата. Бывает, что результат зависит от входных параметров по
определенным правилам. Например, если функция возвращает число из диапазона, то
проверка результата на <code class="language-plaintext highlighter-rouge">int?</code> недостаточна. Следует убедиться, что результат
действительно не выходит за границы аргументов.</p>

<p>Спеке <code class="language-plaintext highlighter-rouge">:fn</code> передают словарь с ключами <code class="language-plaintext highlighter-rouge">:args</code> и <code class="language-plaintext highlighter-rouge">:ret</code>. Значение <code class="language-plaintext highlighter-rouge">:args</code>
содержит не исходный список параметров, а результат <code class="language-plaintext highlighter-rouge">s/conform</code> от
<code class="language-plaintext highlighter-rouge">:args</code>. Задача спеки — проверить, удовлетворяет ли результат входным
аргументам. Если нет, вернуть <code class="language-plaintext highlighter-rouge">false</code> для предиката или <code class="language-plaintext highlighter-rouge">::s/invalid</code> для
<code class="language-plaintext highlighter-rouge">s/conformer</code>.</p>

<p>Напомним, что в ключи <code class="language-plaintext highlighter-rouge">:args</code>, <code class="language-plaintext highlighter-rouge">:ret</code>, <code class="language-plaintext highlighter-rouge">:fn</code> можно передавать объявленные ранее
спеки. Это хорошая практика по переиспользованию кода. Например, у вас может
быть семейство функций для работы с диапазонами чисел. Будет правильно объявить
спеку параметров отдельно и затем ссылаться на нее в каждой из <code class="language-plaintext highlighter-rouge">s/fdef</code>.</p>

<p>Опишем спеку для функции <code class="language-plaintext highlighter-rouge">date-range-sec</code>. Ограничимся проверкой входных
параметров и результата:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">s/fdef</span><span class="w"> </span><span class="n">date-range-sec</span><span class="w">
  </span><span class="no">:args</span><span class="w"> </span><span class="p">(</span><span class="nf">s/cat</span><span class="w"> </span><span class="no">:start</span><span class="w"> </span><span class="n">inst?</span><span class="w"> </span><span class="no">:end</span><span class="w"> </span><span class="n">inst?</span><span class="p">)</span><span class="w">
  </span><span class="no">:ret</span><span class="w"> </span><span class="n">int?</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Объявление функциональной спеки еще не меняет целевую функцию. Это правильно,
потому что спека только декларирует проверки, но не запускает их. Чтобы
подменить целевую функцию на ее оснащенную версию, используют <code class="language-plaintext highlighter-rouge">instrument</code> из
модуля <code class="language-plaintext highlighter-rouge">clojure.spec.test.alpha</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.spec.test.alpha</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">instrument</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">instrument</span><span class="w"> </span><span class="o">`</span><span class="n">date-range-sec</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Важно, что символ функции должен быть полным, то есть с пространством. Чтобы
подставить в символ текущее пространство, перед ним ставят обратную кавычку ```.</p>

<p>Теперь <code class="language-plaintext highlighter-rouge">date-range-sec</code> проверяет аргументы и результат. Попробуем передать
<code class="language-plaintext highlighter-rouge">nil</code> вместо одной из дат. Получим исключение класса
<code class="language-plaintext highlighter-rouge">clojure.lang.ExceptionInfo</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">date-range-sec</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Его текстовое сообщение и тело уже вам знакомы. Поле message содержит текст,
аналогичный <code class="language-plaintext highlighter-rouge">s/explain-str</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Execution error - invalid arguments to date-range-sec
nil - failed: inst? at: [:start]
</code></pre></div></div>

<p>В поле data структура, аналогичная результату <code class="language-plaintext highlighter-rouge">s/explain-data</code>. Чтобы получить
эти данные из пойманного сообщения, используют функцию <code class="language-plaintext highlighter-rouge">(ex-data exception)</code>.</p>

<p>Обратите внимание, что <code class="language-plaintext highlighter-rouge">instrument</code> расположен в отдельном модуле с доменом
“test”. Это потому, что instrument предназначен для тестирования функций, но не
продакшена. Разработчики пишут спеки для наиболее важных функций в отдельном
модуле. Во время тестов проект стартует с особыми параметрами, где указаны
дополнительные модули, которые нужно загрузить. Один из таких тестовых модулей
оснащает функции их спеками. Если при прогоне тестов функция вернула неверный
результат, это сразу станет заметно.</p>

<p>Instrument не подходит для боевого режима, потому что значительно снижает
быстродействие функции. Замерим десять тысяч прогонов оснащенной функции:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">time</span><span class="w">
 </span><span class="p">(</span><span class="nb">dotimes</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="mi">10000</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">date-range-sec</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019"</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2020"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"Elapsed time: 116.984496 msecs"
</code></pre></div></div>

<p>Получили десятую долю секунды на 10К вызовов. Пока что трудно сказать, быстро
это или нет. Посчитаем время для исходной функции. Поскольку <code class="language-plaintext highlighter-rouge">date-range-sec</code>
уже оснащена, объявим функцию с таким же телом, но другим именем, например
<code class="language-plaintext highlighter-rouge">date-range-sec-orig</code>. Посчитаем стоимость ее вызова:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">time</span><span class="w">
 </span><span class="p">(</span><span class="nb">dotimes</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="mi">10000</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">date-range-sec-orig</span><span class="w">
     </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2019"</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2020"</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"Elapsed time: 1.783962 msecs"
</code></pre></div></div>

<p>Разница в сто раз, или два порядка! Очевидно, что проверка в рантайме
существенно замедляет приложение. По этой причине <code class="language-plaintext highlighter-rouge">instrument</code> не претендует на
то, чтобы его использовали в продакшене. Замедление кода в десятки раз — слишком
дорогая цена за детальный вывод ошибок.</p>

<p>Наоборот, во время тестов быстродействие нас не интересует. Мы стремимся покрыть
код как можно большим числом проверок, чтобы отловить необычные сценарии.</p>

<p>В примере выше мы проигнорировали ключ <code class="language-plaintext highlighter-rouge">:fn</code>. Напомним, это комплексная
проверка, в которой одновременно доступны аргументы и результат. Для функции
<code class="language-plaintext highlighter-rouge">date-range-sec</code> справедливо правило: если первая дата больше второй, то
результат отрицательный. Напишите спеку <code class="language-plaintext highlighter-rouge">:fn</code>, которая проверяет это
условие. Тем самым вы предотвратите случай, когда кто-то решит, что результат
должен быть по модулю.</p>

<p>Наличие спеки для функции улучшает документацию у ней. Специальная функция <code class="language-plaintext highlighter-rouge">doc</code>
из модуля <code class="language-plaintext highlighter-rouge">clojure.repl</code> выводит на экран справку о запрошенной функции. С
появлением clojure.spec ее поведение изменилось. Теперь, кроме строки
документации, она выводит спеку функции.</p>

<p>Вот как выглядит справка для <code class="language-plaintext highlighter-rouge">date-range-sec</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.repl</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="nb">doc</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-------------------------
date-range-sec
([date1 date2])
  Return a difference between two dates in seconds.
Spec
  args: (cat :start inst? :end inst?)
  ret: int?
</code></pre></div></div>

<p>Функцию <code class="language-plaintext highlighter-rouge">doc</code> активно используют различные IDE и редакторы, чтобы показывать
сигнатуру по мере написания кода. Даже если вы не пользуетесь <code class="language-plaintext highlighter-rouge">instrument</code> для
тестирования, спека помогает поддерживать проект.</p>

<h2 id="переиспользование-спек">Переиспользование спек</h2>

<p>Писать спеки порой долго и утомительно. В Clojure-сообществе принято снабжать
библиотеки спеками, чтобы облегчить труд другим разработчикам. Если библиотека
использует какую-то структуру данных, будет правильно описать ее спекой.</p>

<p>Хорошим примером служит <code class="language-plaintext highlighter-rouge">clojure.jdbc</code>. Это легковесная Clojure-обертка над
реляционными базами данных. Почти каждое веб-приложение использует БД для
хранения данных. JDBC-подключение описано словарем с ключами <code class="language-plaintext highlighter-rouge">:host</code>, <code class="language-plaintext highlighter-rouge">:port</code>,
<code class="language-plaintext highlighter-rouge">:user</code> и так далее.</p>

<p>Считается правильным проверить конфигурацию базы перед тем, как подключаться к
ней. В противном случае вы рискуете получить странное поведение, например
<code class="language-plaintext highlighter-rouge">NullPointerException</code> при попытке соединения.</p>

<p>Сlojure.jdbc несет на борту семейство спек для всех своих подсистем. Достаточно
импортировать модуль <code class="language-plaintext highlighter-rouge">clojure.java.jdbc.spec</code>, чтобы описанные в нем спеки
попали в глобальный реестр.</p>

<p>Предположим, ключ <code class="language-plaintext highlighter-rouge">:db</code> в конфигурации описывает подключение. Пусть это будет
edn-файл:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"mysql"</span><span class="w">
      </span><span class="no">:host</span><span class="w"> </span><span class="s">"127.0.0.1"</span><span class="w">
      </span><span class="no">:port</span><span class="w"> </span><span class="mi">3306</span><span class="w">
      </span><span class="no">:dbname</span><span class="w"> </span><span class="s">"project"</span><span class="w">
      </span><span class="no">:user</span><span class="w"> </span><span class="s">"user"</span><span class="w">
      </span><span class="no">:password</span><span class="w"> </span><span class="s">"********"</span><span class="w">
      </span><span class="no">:useSSL</span><span class="w"> </span><span class="n">true</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Прочитаем файл комбинацией <code class="language-plaintext highlighter-rouge">read-string</code> и <code class="language-plaintext highlighter-rouge">slurp</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="s">"config.edn"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Спека для этого файла выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.java.jdbc.spec</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jdbc</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::db</span><span class="w"> </span><span class="no">::jdbc/db-spec</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">s/def</span><span class="w"> </span><span class="no">::config</span><span class="w">
  </span><span class="p">(</span><span class="nf">s/keys</span><span class="w"> </span><span class="no">:req-un</span><span class="w"> </span><span class="p">[</span><span class="no">::db</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Нормально, если спеку поставляют в отдельной библиотеке как дополнение. Так
поступили разработчики alia — Clojure-клиента для Кассандры. Базовый пакет
<code class="language-plaintext highlighter-rouge">qbits.alia</code> несет базовую функциональность, а сторонний <code class="language-plaintext highlighter-rouge">cc.qbits/alia-spec</code>
содержит спеку кластера и основных функций.</p>

<h2 id="дополнения-к-spec-обзор">Дополнения к spec (обзор)</h2>

<p>Spec входит в поставку Clojure и потому не меняется так радикально, как
предлагают некоторые разработчики. Дополнения к spec выпускают отдельными
библиотеками. Среди прочих заслуживают внимания два проекта: <code class="language-plaintext highlighter-rouge">expound</code> и
<code class="language-plaintext highlighter-rouge">spec.tools</code>. В этом разделе мы коротко опишем возможности каждого.</p>

<p>Библиотека <a href="https://github.com/bhb/expound">expound</a> улучшает сообщения об ошибках, делает их понятней
для человека. Сигнатура функции expound аналогична <code class="language-plaintext highlighter-rouge">s/explain</code>. Она тоже принимает
спеку и данные. Сообщение об ошибке выглядит примерно так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">expound/expound</span><span class="w"> </span><span class="nb">string?</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Spec failed --------------------
  1
should satisfy
  string?
-------------------------
Detected 1 error
</code></pre></div></div>

<p>Такой отчет все еще выглядит машинным, и мы не можем показать его
пользователю. Все же он лучше, чем сырой <code class="language-plaintext highlighter-rouge">s/explain</code>. Например, его могут
прочитать коллеги из команды Ops, которые не знакомы с Clojure. Особенно хорошо
expound подходит для проверки конфигурации на старте приложения. Иногда код
приложения не меняется месяцами, но конфигурацию обновляют часто, поэтому отчет
о проблемах на старте важен.</p>

<p>Разработчики Metosin собрали ряд улучшений к clojure.spec в проекте
<a href="https://github.com/metosin/spec-tools">spec.tools</a>. В сердце этой библиотеки особый объект Spec. Он
оборачивает стандартную спеку и дополняет ее различными методами. С помощью
spec.tools удобно формировать JSON-схему или описывать REST-проект по стандарту
Swagger. Библиотеку используют в основном как промежуточный слой между
REST-фреймворком и спекой.</p>

<p>Мы не будем останавливаться подробно на этих проектах. Они просты в техническом
плане и требуют больше кода, чем объяснения. Читателю не составит труда
разобраться с ними, когда на то возникнет потребность.</p>

<h2 id="будущее-спеки">Будущее спеки</h2>

<p>На сегодняшний день пакет clojure.spec все еще не избавился от частички “alpha”
в названии. Авторы все еще экспериментируют со спекой, пытаются найти лучший
способ валидировать данные. Это смущает некоторых разработчиков. Опасаясь, что
по окончании эксперимента от spec избавятся, они предпочитают альтернативные
библиотеки: <a href="https://github.com/plumatic/schema">schema</a>, <a href="https://github.com/leonardoborges/bouncer">bouncer</a>.</p>

<p>Отдельные группы пишут обертки над спекой, чтобы расширить ее
возможности. Например, подружить ее с JSON-схемами и популярными инструментами
вроде Swagger.</p>

<p>В недавнем докладе Maybe Not Рич Хикки анонсировал вторую версию
спеки. Ожидается, что разработчики упростят проверку сложных типов
данных. Например, когда значением может быть и строка, и число. Разработка
ведется в открытом режиме, но еще рано говорить о конкретных
результатах. Обсуждение новой спеки выходит за рамки этой главы.</p>

<h2 id="итог">Итог</h2>

<p>Как мы выяснили, clojure.spec — это набор функций и макросов. Ими описывают
правила, которым должны удовлетворять данные. Правила это предикаты,
т.е. Функции, которые возвращают истину или ложь.</p>

<p>Предикаты гибче и мощнее типов. Если о значении известно, что оно верного типа,
это еще не гарантирует его корректность. Значение <code class="language-plaintext highlighter-rouge">-1</code> не может быть
Unix-портом. Пользовательские классы вроде <code class="language-plaintext highlighter-rouge">UnixPort</code> в конструкторе это не
типы, а валидация в рантайме. Она привязана к вызову класса синтаксическим
сахаром.</p>

<p>В отличие от классов, предикаты компонуются друг с другом. Легко написать
супер-предикат с логикой “все из”, “любой из” и так далее.</p>

<p>Мы рассмотрели основные возможности из пакета clojure.spec. Это далеко не все, о
чем еще можно рассказать. В обсуждение не попали различные спеки-комбинаторы
вроде <code class="language-plaintext highlighter-rouge">s/alt</code>, полезные для тонких проверок. Другая обширная тема по spec —
генераторы из модуля <code class="language-plaintext highlighter-rouge">clojure.spec.gen.alpha</code>. Мы коснемся их в отдельной главе
про тесты.</p>

<p>Код этой главы доступен <a href="https://github.com/igrishaev/book-sessions/blob/master/src/book/spec.clj">в одном модуле</a> на Гитхабе.</p>

  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-book-spec/">
    <input required name="captcha" type="hidden" value="5 &#215; 9">

    <div class="block">
        <span class="comment-form-label"><small>5 &#215; 9 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
